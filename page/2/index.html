<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">246</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">交换排序-冒泡排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-20 20:40:04 / Modified: 20:40:46" itemprop="dateCreated datePublished" datetime="2021-11-20T20:40:04+08:00">2021-11-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/Users/qifei/Documents/blog/source/_posts/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="冒泡排序动图"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">insert-sorting</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-20 16:14:02 / Modified: 21:01:08" itemprop="dateCreated datePublished" datetime="2021-11-20T16:14:02+08:00">2021-11-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-quick-sorting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-quick-sorting/" class="post-title-link" itemprop="url">quick sorting</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-20 16:13:39 / Modified: 20:38:38" itemprop="dateCreated datePublished" datetime="2021-11-20T16:13:39+08:00">2021-11-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter05-servlet%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter05-servlet%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">chapter05-servlet容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-07 20:14:36" itemprop="dateCreated datePublished" datetime="2021-10-07T20:14:36+08:00">2021-10-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-14 08:59:41" itemprop="dateModified" datetime="2021-10-14T08:59:41+08:00">2021-10-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lovejavaydj/category_9267782.html">https://blog.csdn.net/lovejavaydj/category_9267782.html</a></p>
<!--socket转化为request和response这项工作已经被httpConnector和httpProcessor解决了，那么如何处理请求交给servlet容器，比如日志、添加请求头、业务..-->

<p>servelet容器是用来处理请求servlet资源，为web client端填充response对象的模块。servlet容器是org.apache.catalina.Container接口的实现。</p>
<!--org.apache.catalina包是接口, -org.apache.catalina.core包是具体实现-->



<h2 id="5-1-Container接口"><a href="#5-1-Container接口" class="headerlink" title="5.1 Container接口"></a>5.1 Container接口</h2><p>一个容器必须实现 org.apache.catalina.Container 接口。如第4章中看到，传递一个 Container 实例给 Connector 对象的 setContainer()方法，然后Connector 就可以调用 container 的 invoke() 方法，重新看第4章中Bootstrap 类的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpConnector connector = <span class="keyword">new</span> HttpConnector();</span><br><span class="line">SimpleContainer container = <span class="keyword">new</span> SimpleContainer();</span><br><span class="line">connector.setContainer(container);</span><br></pre></td></tr></table></figure>

<p>首先需要注意的是，对于 Catalina 容器，在不同的概念上，它一共有4种不同类型的容器：</p>
<p>1》Engine：表示整个 Catalina 的 servlet 引擎<br>2》Host：表示一拥有数个上下文(context)的虚拟主机<br>3》Context：表示一 Web 应用，一个 context 包含一个或多个wrapper<br>4》Wrapper：表示一个独立的 servlet</p>
<p>上面的每个概念级别都由org.apache.catalin包中的接口表示。Engine、Host、Context和 Wrapper 接口都实现了 Container 接口。它们的标准实现是 StandardEngine,StandardHost, StandardContext, StandardWrapper，它们都是org.apache.catalina.core 包的一部分。</p>
<p>图 5.1 表示了 Container 接口和它的子接口的结构图。注意接口都是org.apache.catalina 包的，而所有的类都是 org.apache.catalina.core 包的。<br><img src="https://img-blog.csdn.net/20170115205718774?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>图 5.1: Container相关类图</p>
<blockquote>
<p>注意:</p>
<p>所有的类都扩展自抽象类 ContainerBase。</p>
<p>Catalina 功能部署不一定需要所有的四种类型容器。例如本章第一个应用程序就仅包括一个 wrapper，而第二个应用程序包含 Context 和wrapper 容器模块。在本章附带的应用程序中不需要host和engine。</p>
</blockquote>
<p>一个容器可以有一个或多个低层次上的子容器。例如，一个 Context 有一个或多个 wrapper；一个host有零个或多个context。 然而 wrapper 作为最底层容器，则不能包含子容器。把个容器添加到另一容器中可以使用 Container 接口中定义的 addChild()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加子容器；Host容器下只能添加Context容器。。。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Container child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除子容器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Container child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名称查找子容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Container <span class="title">findChild</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找子容器集合</span></span><br><span class="line">    <span class="keyword">public</span> Container[] findChildren();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它组件的get/set方法，包括：载入器（Loader）、记录器（Logger）、Session管理器（Manager）、领域（Realm）、资源（Resource）</span></span><br><span class="line"></span><br><span class="line">    容器是Tomcat的核心，所以才将所有组件都与容器连接起来，而且通过Lifecyle接口，使我们可以只启动容器组件就可以了（他帮我们启动其它组件）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：这是组合模式的一种使用</p>
</blockquote>
<p>一个容器还包含一系列的部分如 Lodder、Loggee、Manager、Realm 和Resources。我们将会在后边章节中讨论这些组成部分。</p>
<p>更有意思的是Container接口被设计成Tomcat管理员可以通过server.xml文件配置来决定其工作方式的模式。它通过一个 pipeline和容器中一系列的valves来实现，这些内容将会在下一节 “管道流水线任务”中讨论。</p>
<h2 id="5-2-管道任务"><a href="#5-2-管道任务" class="headerlink" title="5.2 管道任务"></a>5.2 管道任务</h2><p>本章节介绍当connector 调用容器(container)的 invoke() 方法会发生什么。后续子章节中讨论org.apache.catalina 中4个相关接口：Pipeline, Valve, ValveContext和Contained。</p>
<p>这里是 Container 接口中 invoke() 方法在org.apache.catalina.core.ContainerBase 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    pipeline.invoke(request, response); <span class="comment">//这里pipeline是容器中 Pipeline 接口的一个实例。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个管道(pipeline)中包含了该容器要调用的所有任务。每一个阀门(valve)表示着一特定任务。一个容器的管道中有一个<font color="red">基本的阀门</font>，但是我们可以添加任意想要添加的阀门。阀门的数目定义为添加的阀门的个数（不包括基本阀门）。有趣的是，阀门可以通过编辑 Tomcat 的配置文件 server.xml 来动态地添加。</p>
<p>一个管道线就像一个过滤链，每一个阀门像一个过滤器。跟过滤器一样，一个阀门可以操作处理传递给它的 request 和 response 对象。一个阀门完成处理后，它则进一步调用管道中的下一个阀门，基本阀门总是在最后才被调用。</p>
<p>一个容器可以有一个管道。当容器的 invoke() 方法被调用时，容器将通过管道处理，且管理调用在其中的第一个阀门，一个接一个阀门的调用处理，直到所有阀门都被处理完毕。可以想象管道的 invoke() 方法的伪代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invoke each valve added to the pipeline</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;valves.length; n++) &#123;</span><br><span class="line">    valve[n].invoke( ... );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then, invoke the basic valve</span></span><br><span class="line">basicValve.invoke( ... );</span><br></pre></td></tr></table></figure>

<p>但是，Tomcat 设计者通过引入org.apache.catalina.ValveContext接口选择了一种不同处理方式。这里将介绍它是如何工作的。</p>
<p><a href="">容器不会硬编码它的invoke()方法被调用时应该做什么。反而，容器调用的是管道的 invoke()方法</a>。管道接口的 invoke() 方法跟容器接口的invoke() 方法签名相同，方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br></pre></td></tr></table></figure>

<p>一个Pipeline的 invoke() 方法可以如下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">   <span class="comment">// Invoke the first Valve in this pipeline for this request</span></span><br><span class="line">   (<span class="keyword">new</span> SimplePipelineValveContext()).invokeNext(request, response);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><a href="">现在，管道必须保证添加给它的阀门必须如基本阀门一样被调用一次。</a><strong>管道通过创建一</strong><br><strong>个 ValveContext 接口的实例来实现</strong>。ValveContext 是管道的内部类，这样 ValveContext 就可以访问管道中所有成员。ValveContext 中最重要的方法是 invokeNext() 方法：</p>
<p>在创建一个 ValveContext 实例之后，管道调用 ValveContext 的 invokeNext()方法。ValveContext 会先唤起管道中的第一个阀门，然后第一个阀门会在完成它的任务之前继续唤起下一个阀门。ValveContext 将它自己传递给每一个阀门，那么该阀门就可以调用 ValveContext 的 invokeNext() 方法。</p>
<p>Valve 接口的 invoke()签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">invoke</span><span class="params">(Request request, Response response,</span></span></span><br><span class="line"><span class="function"><span class="params">    ValveContext ValveContext)</span> <span class="keyword">throws</span> IOException, ServletException</span></span><br></pre></td></tr></table></figure>

<p>一个Valve的 invoke() 方法可以如下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response,</span></span></span><br><span class="line"><span class="function"><span class="params">    ValveContext valveContext)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// Pass the request and response on to the next valve in our pipeline</span></span><br><span class="line">    valveContext.invokeNext(request, response);</span><br><span class="line">    <span class="comment">// now perform what this valve is supposed to do，</span></span><br><span class="line">    ...比如下文的HeaderLoggerValve的逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.apache.catalina.core.StandardPipeline 类是所有容器中Pipeline的实现。在Tomcat4 中，这个类中有一个<a href="">内部类 StandardPipelineValveContext</a> 实现了ValveContext 接口，</p>
<blockquote>
<p>仔细推敲会发现，每个Valve都是先调用ValveContext的invokeNext，然后才做自己的工作，所以“第一个”被 pipeline调用的Valve，实际却是最后一个完成自己工作的，有点类似“压栈”操作，第一个Valve最先被压进去，却是最后一个从堆栈中弹出来 的。如果不信，可以做个试验，眼见为实。</p>
</blockquote>
<p>Listing 5.1: Tomcat 4中的StandardPipelineValveContext 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pipeline的内部类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardPipelineValveContext</span> <span class="keyword">implements</span> <span class="title">ValveContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> stage = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeNext</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> subscript = stage;</span><br><span class="line">        stage = stage + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Invoke the requested Valve for the current request thread</span></span><br><span class="line">        <span class="keyword">if</span> (subscript &lt; valves.length) &#123;</span><br><span class="line">            valves[subscript].invoke(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((subscript == valves.length) &amp;&amp; (basic != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            basic.invoke(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException (sm.getString(<span class="string">&quot;standardPipeline.noValve&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>invokeNext()方法中使用subscript和stage记住哪个阀门被唤醒。当第一次唤醒时，subscript的值是 0，stage的值是 1。所以，第一个阀门(数组下标是0)被唤醒，管道的阀门获得 ValveContext 实例接收到ValveContext实例并调用它的 invokeNext() 方法。这时subscript的值是 1， 所以第二个阀门被唤醒，然后一步步地这样继续进行。<!--疑惑，stage作为类变量，是线程安全的吗--></p>
<p>当invokeNext()在最后一个阀门中调用时，subscript值等于总阀门的个数。因此这时，基本阀门被唤醒调用。</p>
<h3 id="5-2-1-Pipeline接口"><a href="#5-2-1-Pipeline接口" class="headerlink" title="5.2.1 Pipeline接口"></a><strong>5.2.1 Pipeline接口</strong></h3><p>我们提到的Pipeline接口的第一种方法是invoke()方法，容器调用它来开始调用管道中的阀门和基本阀门。Pipeline接口允许我们通过addValve()方法添加一个新的阀门或者通过removeValve()方法删除一个阀门。最后，可以使用 setBasic()方法来分配一个基本阀门给管道，使用getBasic()方法会得到基本阀门。最后调用的基本阀门负责处理请求和相应的响应。</p>
<p>Listing 5.3: Pipeline接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">public interface Pipeline &#123;</span><br><span class="line">    public Valve getBasic();</span><br><span class="line">    public void setBasic(Valve valve);</span><br><span class="line">    public void addValve(Valve valve);</span><br><span class="line">    public Valve[] getValves();</span><br><span class="line">    public void invoke(Request request, Response response)</span><br><span class="line">        throws IOException, ServletException;</span><br><span class="line">    public void removeValve(Valve valve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-Valve接口"><a href="#5-2-2-Valve接口" class="headerlink" title="5.2.2 Valve接口"></a><strong>5.2.2 Valve接口</strong></h3><p>Value接口表示一个阀门，该组件负责处理请求。该接口有两个方法，invoke() 和getInfo()方法。invoke()方法如上面已讨论过，getInfo()方法返回阀门的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">public interface Valve &#123;</span><br><span class="line">    public String getInfo();</span><br><span class="line">    public void invoke(Request request, Response response,</span><br><span class="line">        ValveContext context) throws IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-ValveContext接口"><a href="#5-2-3-ValveContext接口" class="headerlink" title="5.2.3 ValveContext接口"></a><strong>5.2.3 ValveContext接口</strong></h3><p>ValveContext接口有两个方法，invokeNext()方法如上已讨论，getInfo()方法会返回valveContext的实现信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">public interface ValveContext &#123;</span><br><span class="line">    public String getInfo();</span><br><span class="line">    public void invokeNext(Request request, Response response)</span><br><span class="line">        throws IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-Contained接口"><a href="#5-2-4-Contained接口" class="headerlink" title="5.2.4 Contained接口"></a><strong>5.2.4 Contained接口</strong></h3><p>阀门类可以选择性实现org.apache.catalina.Contained接口。此接口指定实现类最多与一个相关联容器实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line"></span><br><span class="line">public interface Contained &#123;</span><br><span class="line">    public Container getContainer();</span><br><span class="line">    public void setContainer(Container container);</span><br><span class="line">&#125;123456</span><br></pre></td></tr></table></figure>



<h2 id="5-3-Wrapper接口"><a href="#5-3-Wrapper接口" class="headerlink" title="5.3 Wrapper接口"></a>5.3 Wrapper接口</h2><p>org.apache.catalina.Wrapper 接口表示一个包装器。包装器是表示单个servlet定义的容器。包装器继承了Container接口，并且添加了几个方法。包装器的实现类负责管理其servlet 的生命中期，包括 servlet 的init()、service()、和 destroy()方法。由于包装器是最底层的容器，所以不可以将子容器添加给它。<a href="">如果 addChild()方法被调用，则会产生IllegalArgumantException 异常。</a></p>
<p>包装器接口中重要方法有 allocate() 和 load() 方法。allocate() 方法负责定位该包装器表示的 servlet 的实例。allocate()方法必须考虑一个 servlet 是否实现了javax.servlet.SingleThreadModel 接口，该部分内容将会在 11 章中进行讨论。load() 方法负责加载和初始化 servlet 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 载入并加载servlet，在它的子类StandardWrapper中直接调用的loadServlet方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法会返回已加载的servlet类，还要考虑它是否实现了SingleThreadModel</span></span><br><span class="line"><span class="function">Servlet <span class="title">allocate</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-Context接口"><a href="#5-4-Context接口" class="headerlink" title="5.4 Context接口"></a><strong>5.4 Context接口</strong></h2><p>一个 context 容器表示一个 web 应用。一个 context 通常含有一个或多个包装器作为其子容器。重要的方法包括 addWrapper(), createWrapper() 等方法。该接口将会在第 12 章中详细介绍。</p>
<h2 id="5-5-Wrapper应用Demo"><a href="#5-5-Wrapper应用Demo" class="headerlink" title="5.5 Wrapper应用Demo"></a><strong>5.5 Wrapper应用Demo</strong></h2><p>这个应用Demo展示了如何写一个简单的容器模型。该应用程序的核心类是ex05.pyrmont.core.SimpleWrapper，它实现了 Wrapper 接口。SimpleWrapper类包括一个 Pipeline（由 ex05.pyrmont.core.SimplePipeline 实现）和一个Loader 类（ex05.pyrmont.core.SimpeLoader）来加载一个 servlet。管道包括一个基本阀门（ex05.pyrmont.core.SimpleWrapperValve）和两个另外的阀门<br>(ex05.pyrmont.core.ClientIPLoggerValve 和ex05.pyrmont.core.HeaderLoggerValve)。该应用的类结构图如图 5.3 所示：</p>
<p><img src="https://img-blog.csdn.net/20170115210024548?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>注意：该容器使用的是Tomcat 4的默认连接器</p>
<p>包装器包装的是前面章节已经使用过的 ModernServlet类。这个应用程序表示一个 servlet 容器可以只有一单一的包装器构成。这些类都没有完整的实现，只是实现了必要方法。接下来看程序的具体实现。</p>
<h4 id="core-SimpleLoader"><a href="#core-SimpleLoader" class="headerlink" title="core.SimpleLoader"></a><strong>core.SimpleLoader</strong></h4><p>容器中加载 servlet 的任务分配给了 Loader 实现。在该程序中 SimpleLoader就是一个 Loader 实现。它知道如何定位一个 servlet，并且通过 getClassLoader()获得一个 java.lang.ClassLoader 实例用来查找 servlet 类位置。</p>
<ul>
<li>SimpleLoader定义了 3 个变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个是 WEB_ROOT 用来指明在哪里查找 servlet 类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEB_ROOT =</span><br><span class="line">        System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + File.separator + <span class="string">&quot;webroot&quot;</span>;</span><br><span class="line"><span class="comment">//另外两个变量是 ClassLoader 和 Container：</span></span><br><span class="line">ClassLoader classLoader = <span class="keyword">null</span>;</span><br><span class="line">Container container = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>SimpleLoader 类的构造器初始化类加载器，以便于准备返回一个 SimpleWrapper实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL[] urls = <span class="keyword">new</span> URL[l];</span><br><span class="line">        URLStreamHandler streamHandler = <span class="keyword">null</span>;</span><br><span class="line">        File classPath = <span class="keyword">new</span> File(WEB_ROOT);</span><br><span class="line">        String repository = (<span class="keyword">new</span> URL(<span class="string">&quot;file&quot;</span>, <span class="keyword">null</span>,</span><br><span class="line">            classPath.getCanonicalPath() + File.separator)).toString() ;</span><br><span class="line">        urls[<span class="number">0</span>] = <span class="keyword">new</span> URL(<span class="keyword">null</span>, repository, streamHandler);</span><br><span class="line">        classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的构造器用于初始化一个类加载器如前面章节所用的一样。container变量表示容器跟该加载器是相关联。</p>
<p>注意：加载器将在第8章详细讨论。</p>
<h4 id="core-SimplePipeline"><a href="#core-SimplePipeline" class="headerlink" title="core.SimplePipeline"></a><strong>core.SimplePipeline</strong></h4><p>SimplePipeline 实现了 org.apache.catalina.Pipeline 接口。该类中最重要的方法是 invoke() 方法，其中包括了一个内部类 SimplePipelineValveContext。SimplePipelineValveContext 实现了 org.apache.catalina.ValveContext 接口如上面章节所介绍。</p>
<h4 id="core-SimpleWrapper"><a href="#core-SimpleWrapper" class="headerlink" title="core. SimpleWrapper"></a><strong>core. SimpleWrapper</strong></h4><p>该类实现了 org.apache.catalina.Wrapper 接口并且实现了 allocate() 方法和load() 方法，并声明了如下变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private Loader loader;</span><br><span class="line">protected Container parent &#x3D; null;</span><br></pre></td></tr></table></figure>

<p>loader 变量用于加载一个 servlet 类。parent 变量表示该包装器的父容器。这意味着，该容器可以是其它容器的子容器，例如 Context。</p>
<p>需要特别注意 getLoader()方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Loader <span class="title">getLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (loader);</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (parent.getLoader());</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getLoader()方法用于返回一个 Loader 对象用于加载一个 servlet 类。如果一个包装器跟一个加载器相关联，会返回该加载器。否则返回其父容器的加载器，如果没有父容器，则返回 null。</p>
<p>SimpleWrapper 类有一个管道和该管道的基本阀门。这些工作在SimpleWrapper 的构造函数中完成。</p>
<p>Listing 5.8:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中，pipeline是 SimplePipeline 类的一个实例：</span></span><br><span class="line"><span class="keyword">private</span> SimplePipeline pipeline = <span class="keyword">new</span> SimplePipeline(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipeline.setBasic(<span class="keyword">new</span> SimpleWrapperValve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="core-SimpleWrapperValve"><a href="#core-SimpleWrapperValve" class="headerlink" title="core. SimpleWrapperValve"></a><strong>core. SimpleWrapperValve</strong></h4><p>SimpleWrapperValve 类是一个给 SimpleWrapper 类专门处理请求的<a href="">基本阀门</a>。它实现了 org.apache.catalina.Valve 接口和org.apache.catalina.Contained接口。最重要的方法是 invoke() 方法，如 Listing5.9 所示：</p>
<p>Listing 5.9: SimpleWrapperValve类的invoke()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    SimpleWrapper wrapper = (SimpleWrapper) getContainer();</span><br><span class="line">    ServletRequest sreq = request.getRequest();</span><br><span class="line">    ServletResponse sres = response.getResponse();</span><br><span class="line">    Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line">    HttpServletRequest hreq = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (sreq <span class="keyword">instanceof</span> HttpServletRequest)</span><br><span class="line">      hreq = (HttpServletRequest) sreq;</span><br><span class="line">    HttpServletResponse hres = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (sres <span class="keyword">instanceof</span> HttpServletResponse)</span><br><span class="line">      hres = (HttpServletResponse) sres;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a servlet instance to process this request</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      servlet = wrapper.allocate();</span><br><span class="line">      <span class="keyword">if</span> (hres!=<span class="keyword">null</span> &amp;&amp; hreq!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        servlet.service(hreq, hres);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        servlet.service(sreq, sres);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">由于 SimpleWrapperValve 被当做一基本阀门来使用，所以它的 invoke() 方法不需要invokeNext()方法。</font></p>
<p>invoke()方法调用SimpleWrapper的allocate()方法获得servlet的实例。然后调用 servlet 的 service() 方法。注意包装器管道的基本阀门唤醒的是 servlet 的 service ()方法，而不是 wrapper自己。</p>
<h4 id="ex05-pyrmont-valves-ClientIPLoggerValve"><a href="#ex05-pyrmont-valves-ClientIPLoggerValve" class="headerlink" title="ex05.pyrmont. valves. ClientIPLoggerValve"></a><strong>ex05.pyrmont. valves. ClientIPLoggerValve</strong></h4><p>ClientIPLoggerValve 是一个阀门，它打印客户端的 IP 地址到控制台。该类如 Listing5.10:</p>
<p>Listing 5.10: ClientIPLoggerValve类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex05.pyrmont.valves;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Valve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.ValveContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Contained;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Container;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientIPLoggerValve</span> <span class="keyword">implements</span> <span class="title">Valve</span>, <span class="title">Contained</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Container container;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass this request on to the next valve in our pipeline</span></span><br><span class="line">    valveContext.invokeNext(request, response);</span><br><span class="line">    System.out.println(<span class="string">&quot;Client IP Logger Valve&quot;</span>);</span><br><span class="line">    ServletRequest sreq = request.getRequest();</span><br><span class="line">    System.out.println(sreq.getRemoteAddr());</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.container = container;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p> invoke() 方法，它的第一件事情是调用阀门上下文 invokeNext ()方法来唤醒下一个阀门，然后它会打印出请求对象的 getRemoteAddr() 方法的输出。</p>
</blockquote>
<h4 id="ex05-pyrmont-valves-HeaderLoggerValve"><a href="#ex05-pyrmont-valves-HeaderLoggerValve" class="headerlink" title="ex05.pyrmont. valves. HeaderLoggerValve"></a><strong>ex05.pyrmont. valves. HeaderLoggerValve</strong></h4><p>该类跟 ClientIPLoggerValve 类非常相似。HeaderLoggerValve 是一个阀门打印请求头部信息到控制台上。该类如 Listing5.11：</p>
<p>Listing 5.11: HeaderLoggerValve 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex05.pyrmont.valves;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Valve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.ValveContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Contained;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Container;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderLoggerValve</span> <span class="keyword">implements</span> <span class="title">Valve</span>, <span class="title">Contained</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Container container;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass this request on to the next valve in our pipeline</span></span><br><span class="line">    valveContext.invokeNext(request, response);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Header Logger Valve&quot;</span>);</span><br><span class="line">    ServletRequest sreq = request.getRequest();</span><br><span class="line">    <span class="keyword">if</span> (sreq <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">      HttpServletRequest hreq = (HttpServletRequest) sreq;</span><br><span class="line">      Enumeration headerNames = hreq.getHeaderNames();</span><br><span class="line">      <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">        String headerName = headerNames.nextElement().toString();</span><br><span class="line">        String headerValue = hreq.getHeader(headerName);</span><br><span class="line">        System.out.println(headerName + <span class="string">&quot;:&quot;</span> + headerValue);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      System.out.println(<span class="string">&quot;Not an HTTP Request&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.container = container;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>其 invoke() 方法，该方法首先调用阀门的 invokeNext()方法唤醒下一个阀门。然后打印出头部的值。</p>
</blockquote>
<h4 id="pyrmont-startup-Bootstrap1"><a href="#pyrmont-startup-Bootstrap1" class="headerlink" title="pyrmont.startup.Bootstrap1"></a><strong>pyrmont.startup.Bootstrap1</strong></h4><p>Bootstrap1 用于启动这个应用程序。</p>
<p>Listing 5.12: Bootstrap1 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex05.pyrmont.startup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.core.SimpleLoader;</span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.core.SimpleWrapper;</span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.valves.ClientIPLoggerValve;</span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.valves.HeaderLoggerValve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Loader;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Pipeline;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Valve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Wrapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.http.HttpConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* call by using http://localhost:8080/ModernServlet,</span></span><br><span class="line"><span class="comment">   but could be invoked by any name */</span></span><br><span class="line"></span><br><span class="line">    HttpConnector connector = <span class="keyword">new</span> HttpConnector();</span><br><span class="line">    Wrapper wrapper = <span class="keyword">new</span> SimpleWrapper();</span><br><span class="line">    <span class="comment">//创建 HttpConnector 和 SimpleWrapper 类的实例后，分配ModernServlet 给 SimpleWrapper 的 setServletClass() 方法，告诉包装器要加载的类的名字以便于加载。</span></span><br><span class="line">    wrapper.setServletClass(<span class="string">&quot;ModernServlet&quot;</span>);</span><br><span class="line">    <span class="comment">//然后创建了加载器和两个阀门，然后将其加载器赋给包装器：</span></span><br><span class="line">    Loader loader = <span class="keyword">new</span> SimpleLoader();</span><br><span class="line">    Valve valve1 = <span class="keyword">new</span> HeaderLoggerValve();</span><br><span class="line">    Valve valve2 = <span class="keyword">new</span> ClientIPLoggerValve();</span><br><span class="line">    wrapper.setLoader(loader);</span><br><span class="line">     <span class="comment">//然后把两个阀门添加到包装器管道中：</span></span><br><span class="line">    ((Pipeline) wrapper).addValve(valve1);</span><br><span class="line">    ((Pipeline) wrapper).addValve(valve2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后，把包装器当做容器添加到连接器中，然后初始化并启动连接器：</span></span><br><span class="line">    connector.setContainer(wrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      connector.initialize();</span><br><span class="line">      connector.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// make the application wait until we press a key.</span></span><br><span class="line">      System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-8-运行Demo"><a href="#5-5-8-运行Demo" class="headerlink" title="5.5.8 运行Demo"></a><strong>5.5.8 运行Demo</strong></h4><p>在 Linux 下，使用冒号分开两个库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .&#x2F;lib&#x2F;servlet.jar:.&#x2F; ex05.pyrmont.startup.Bootstrap11</span><br></pre></td></tr></table></figure>

<p>可以使用下面的 URL 来请求servlet：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:80801</span><br></pre></td></tr></table></figure>

<p>浏览器将会显示从 ModernServlet 得到的响应回复。跟下面相似的内容会显示在控制台上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ModernServlet -- init</span><br><span class="line">Client IP Logger Valve</span><br><span class="line">127.0.0.1</span><br><span class="line">------------------------------------</span><br><span class="line">Header Logger Valve</span><br><span class="line">host:localhost:8080</span><br><span class="line">user-agent:Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko&#x2F;20100101 Firefox&#x2F;50.0</span><br><span class="line">accept:text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">accept-language:zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3</span><br><span class="line">accept-encoding:gzip, deflate</span><br><span class="line">connection:keep-alive</span><br><span class="line">upgrade-insecure-requests:1</span><br><span class="line">------------------------------------</span><br></pre></td></tr></table></figure>

<!--果然最先添加的valve，是最后执行的，递归操作，类似stack-->



<h2 id="5-6-Context应用Demo"><a href="#5-6-Context应用Demo" class="headerlink" title="5.6 Context应用Demo"></a><strong>5.6 Context应用Demo</strong></h2><p>在本章第一个Demo中，介绍了如何部署一个仅仅包括一个包装器(Wrapper)的简单web应用。该程序仅包括一个 servlet。也许会有一些应用仅仅需要一个 servlet，可是大多数的网络应用需要多个 servlet。在这些应用中，我们需要一个跟包装器（wrapper）不同的容器：上下文（context）。</p>
<p>第二个Demo将会示范如何使用一个包含两个包装器的上下文来包装两个servlet 类。当有多于一个包装器时，需要一个 map 来处理这些子容器——本Demo中使用Context容器，对于特殊的请求可以使用特殊的子容器来处理。</p>
<blockquote>
<p>注意 使用 map 方法是在 Tomcat4 中，Tomcat 5 使用了另一种机制来查找子容器。</p>
</blockquote>
<p>在这个程序中，mapper 是 ex05.pyrmont.core.SimpleContextMapper 类的一个实例，它继承Tomcat 4 中org.apache.catalina.Mapper 接口。一个容器也可以有多个 mapper 来支持多协议。例如容器可以用一个 mapper 来支持 HTTP 协议，而使用另一个 mapper 来支持 HTTPS 协议。Listing5.13 提供了 Tomcat4 中的 Mapper 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line"></span><br><span class="line">public interface Mapper &#123;</span><br><span class="line">    public Container getContainer();</span><br><span class="line">    public void setContainer(Container container);</span><br><span class="line">    public String getProtocol();</span><br><span class="line">    ublic void setProtocol(String protocol);</span><br><span class="line">    ublic Container map(Request request, boolean update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getContainer()获取该容器的 mapper，setContainer() 方法用于关联一个容器到mapper。getProtocol() 返回该 mapper 负责处理的协议，setProtocol()用于分配该容器要处理的协议。map()方法返回处理一个特殊请求的子容器。<br><img src="https://img-blog.csdn.net/20170115210322558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>图 5.4 是该Demo结构图。</p>
<p>SimpleContext表示一个上下文，它使用SimpleContextMapper作为它的mapper，SimpleContextValve 作为它的基本阀门。该上下文包括两个阀门ClientIPLoggerValve 和 HeaderLoggerValve。用 SimpleWrapper 表示的两个包装器作为该上下文的子容器被添加到其中。包装器 SimpleWrapperValve 作为它的基阀门，但是没有其它的阀门了。</p>
<p>该Context应用程序使用同一个加载器、两个阀门。<a href="">但是加载器和阀门是跟该Context关联的，而不是跟包装器关联</a>。这样，两个包装器就可以都使用该加载器。该Conetext被当做连接器的容器。因此，连接器每次收到一个 HTTP 请求可以使用上下文的 invoke() 方法。根据前面介绍的内容，其余的不难理解。</p>
<p>1》一个容器有一个管道，容器的 invoke() 方法会调用管道的invoke()方法<br>2》管道的 invoke()方法会调用添加到容器中的阀门的 invoke()方法，然后调用基本阀门的 invoke()方法<br>3》在一包装器中，基本阀门负责加载相关的 servlet 类并对请求作出相应<br>4》在一个有子容器的上下文中，基阀门使用 mapper 来查找负责处理请求的子容器。如果一个子容器被找到，子容器的 invoke() 方法会被调用，然后返回步骤 1</p>
<p>现在让我们看看实现中的处理流程。</p>
<p>SimpleContext 的 invoke() 方法调用管道的 invoke() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line">        pipeline.invoke(request, response);</span><br><span class="line">&#125;1234</span><br></pre></td></tr></table></figure>

<p>pipeline是SimplePipeline 类实例，用来表示管道，它的 invoke()方法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line">    &#x2F;&#x2F; Invoke the first Valve in this pipeline for this request</span><br><span class="line">    (new SimplePipelineValveContext()).invokeNext(request, response);</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure>

<p>如“管道任务”一节中介绍的，该段代码唤醒所有阀门，然后调用基阀门的invoke()方法。在SimpleContext中SimpleContextValve代表着基阀门。在它的invoke()方法中SimpleContextValve使用上下文的mapper是查找一个包装器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Select the Wrapper to be used for this Request</span><br><span class="line">Wrapper wrapper &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    wrapper &#x3D; (Wrapper) context.map(request, true);</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure>

<p>如果一个包装器被找到，它的invoke()方法会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrapper.invoke(request, response);1</span><br></pre></td></tr></table></figure>

<p>本Demo着通过SimpleWrapper表示一个包装器。如下是其invoke()方法，和SimpleContext类的invoke()方法完全一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line">    pipeline.invoke(request, response);</span><br><span class="line">&#125;1234</span><br></pre></td></tr></table></figure>

<p>管道是SimplePipeline的一个实例，其调用方法已在上面列出。本Demo中包装器是SimpleWrapperValve的实例，它除了有基阀门外没其它阀门。包装器的管道调用SimpleWrapperValve类的invoke()方法，它分配一个servlet并调用其service()方法，如上文“Wrapper应用Demo”一节中所述。</p>
<p>注意，包装器不与加载器相关联，而是上下文与其关联。 因此，SimpleWrapper类的getLoader()方法返回父级（Context）的加载器。</p>
<p>有4个类：SimpleContext, SimpleContextValve, SimpleContextMapper和Bootstrap2在前面小节没被提到，在下面将讨论。</p>
<h4 id="5-6-1-core-SimpleContextValve"><a href="#5-6-1-core-SimpleContextValve" class="headerlink" title="5.6.1 core.SimpleContextValve"></a><strong>5.6.1 core.SimpleContextValve</strong></h4><p>此类作为SimpleContext的基阀门。它的最重要的方法invoke()代码如Listing 5.14：</p>
<p>Listing 5.14: SimpleContextValve类的invoke()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// Validate the request and response object types</span></span><br><span class="line">    <span class="keyword">if</span> (!(request.getRequest() <span class="keyword">instanceof</span> HttpServletRequest) ||</span><br><span class="line">      !(response.getResponse() <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;     <span class="comment">// NOTE - Not much else we can do generically</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disallow any direct access to resources under WEB-INF or META-INF</span></span><br><span class="line">    HttpServletRequest hreq = (HttpServletRequest) request.getRequest();</span><br><span class="line">    String contextPath = hreq.getContextPath();</span><br><span class="line">    String requestURI = ((HttpRequest) request).getDecodedRequestURI();</span><br><span class="line">    String relativeURI =</span><br><span class="line">      requestURI.substring(contextPath.length()).toUpperCase();</span><br><span class="line"></span><br><span class="line">    Context context = (Context) getContainer();</span><br><span class="line">    <span class="comment">// Select the Wrapper to be used for this Request</span></span><br><span class="line">    Wrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      wrapper = (Wrapper) context.map(request, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      badRequest(requestURI, (HttpServletResponse) response.getResponse());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">      notFound(requestURI, (HttpServletResponse) response.getResponse());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ask this Wrapper to process this Request</span></span><br><span class="line">    response.setContext(context);</span><br><span class="line">    wrapper.invoke(request, response);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-2-core-SimpleContextMapper"><a href="#5-6-2-core-SimpleContextMapper" class="headerlink" title="5.6.2 core.SimpleContextMapper"></a><strong>5.6.2 core.SimpleContextMapper</strong></h4><p>SimpleContextMapper类实现Tomcat4中的org.apache.catalina.Mapper接口，并被设计成和SimpleContext实例相关联。</p>
<p>Listing 5.15: The SimpleContext 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleContextMapper</span> <span class="keyword">implements</span> <span class="title">Mapper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SimpleContext context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(container <span class="keyword">instanceof</span> SimpleContext))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span><br><span class="line">        (<span class="string">&quot;Illegal type of container&quot;</span>);</span><br><span class="line">    context = (SimpleContext) container;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProtocol</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the child Container that should be used to process this Request,</span></span><br><span class="line"><span class="comment">   * based upon its characteristics.  If no such child Container can be</span></span><br><span class="line"><span class="comment">   * identified, return &lt;code&gt;null&lt;/code&gt; instead.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">map</span><span class="params">(Request request, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Identify the context-relative URI to be mapped</span></span><br><span class="line">    String contextPath =</span><br><span class="line">      ((HttpServletRequest) request.getRequest()).getContextPath();</span><br><span class="line">    String requestURI = ((HttpRequest) request).getDecodedRequestURI();</span><br><span class="line">    String relativeURI = requestURI.substring(contextPath.length());</span><br><span class="line">    <span class="comment">// Apply the standard request URI mapping rules from the specification</span></span><br><span class="line">    Wrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">    String servletPath = relativeURI;</span><br><span class="line">    String pathInfo = <span class="keyword">null</span>;</span><br><span class="line">    String name = context.findServletMapping(relativeURI);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span>)</span><br><span class="line">      wrapper = (Wrapper) context.findChild(name);</span><br><span class="line">    <span class="keyword">return</span> (wrapper);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们传递一个不是SimpleContext实例的容器给setContainer()方法时，它将抛出IllegalArgumentException异常。map()方法返回一个子容器（wrapper），它负责处理请求。map()方法接收二个参数，一个是请求对象，一个是布尔值。这里的方法实现忽略了第二个参数。该方法执行的操作是检索从请求对象中得到上下文路径，并使用context的findServletMapping()方法获取与其路径关联的名称。 如果找到名称，它使用context的findChild()方法来获取Wrapper的实例。</p>
<p><strong>5.6.3 ex05.pyrmont.core.SimpleContext</strong></p>
<p>SimpleContext类是本Demo中Context一个实现。它是分配给连接器的主容器。然而，每个单独的servlet的处理由包装器执行。本应用Demo有2个servlet：PrimitiveServlet和ModernServlet，如此一来就有2个包装器。每个包装器都有名字。名称为Primitive是PrimitiveServlet的包装器，Modern是ModernServlet的包装器。对于每个请求，SimpleContext要决定调用哪个包装器，这个必须使用包装器的名称映射匹配请求URL。在此应用程序中，我们有两个可用于调用2个包装器的URL模式。第一个模式是/ Primitive，它映射到Primitive包装器。 第二个模式是/ Modern，它被映射到Modern包装器。 当然，对于给定的servlet，我们可以使用多个模式。 我们只需要添加这些模式即可。</p>
<p>从Container和Context接口有很多方法，SimpleContext必须实现。 大多数方法是留白，但是这些与映射相关的方法给予了实现代码。 这些方法如下：</p>
<p>1》addServletMapping()方法——添加URL/包装器名称映射对。 添加的每一个，可用于调用具有给定名称的包装器<br>2》findServletMapping()方法——获取和URL对应的包装器名称。这个方法用于为一个指定的URL查找哪个包装器应该被调用。如果给定的模式之前未通过addServletMapping()方法添加过，那么此方法将返回null<br>3》addMapper()方法——添加一个mapper给context。SimpleContext申明mapper和mappers变量。mapper为默认的mapper，mappers包含SimpleContext实例中所有mapper。第一个添加到SimpleContext中的mapper将作为默认mapper<br>4》findMapper()方法——查找当前mapper。在SimpleContext中，返回默认mapper。<br>5》map()方法——返回负责处理此请求的包装器</p>
<p>此外SimpleContext也提供了addChild(),findChild(), 和findChildren()方法实现。addChild()用于添加一个wrapper给context；findChild()用于获取指定名称的wrapper；findChildren()返回SimpleContext实例当中的所有包装器。</p>
<p><strong>5.6.4 ex05.pyrmont.startup.Bootstrap2</strong></p>
<p>Listing 5.16: The Bootstrap2 类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package ex05.pyrmont.startup;</span><br><span class="line"></span><br><span class="line">import ex05.pyrmont.core.SimpleContext;</span><br><span class="line">import ex05.pyrmont.core.SimpleContextMapper;</span><br><span class="line">import ex05.pyrmont.core.SimpleLoader;</span><br><span class="line">import ex05.pyrmont.core.SimpleWrapper;</span><br><span class="line">import ex05.pyrmont.valves.ClientIPLoggerValve;</span><br><span class="line">import ex05.pyrmont.valves.HeaderLoggerValve;</span><br><span class="line">import org.apache.catalina.Context;</span><br><span class="line">import org.apache.catalina.Loader;</span><br><span class="line">import org.apache.catalina.Mapper;</span><br><span class="line">import org.apache.catalina.Pipeline;</span><br><span class="line">import org.apache.catalina.Valve;</span><br><span class="line">import org.apache.catalina.Wrapper;</span><br><span class="line">import org.apache.catalina.connector.http.HttpConnector;</span><br><span class="line"></span><br><span class="line">public final class Bootstrap2 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HttpConnector connector &#x3D; new HttpConnector();</span><br><span class="line">    Wrapper wrapper1 &#x3D; new SimpleWrapper();</span><br><span class="line">    wrapper1.setName(&quot;Primitive&quot;);</span><br><span class="line">    wrapper1.setServletClass(&quot;PrimitiveServlet&quot;);</span><br><span class="line">    Wrapper wrapper2 &#x3D; new SimpleWrapper();</span><br><span class="line">    wrapper2.setName(&quot;Modern&quot;);</span><br><span class="line">    wrapper2.setServletClass(&quot;ModernServlet&quot;);</span><br><span class="line"></span><br><span class="line">    Context context &#x3D; new SimpleContext();</span><br><span class="line">    context.addChild(wrapper1);</span><br><span class="line">    context.addChild(wrapper2);</span><br><span class="line"></span><br><span class="line">    Valve valve1 &#x3D; new HeaderLoggerValve();</span><br><span class="line">    Valve valve2 &#x3D; new ClientIPLoggerValve();</span><br><span class="line"></span><br><span class="line">    ((Pipeline) context).addValve(valve1);</span><br><span class="line">    ((Pipeline) context).addValve(valve2);</span><br><span class="line"></span><br><span class="line">    Mapper mapper &#x3D; new SimpleContextMapper();</span><br><span class="line">    mapper.setProtocol(&quot;http&quot;);</span><br><span class="line">    context.addMapper(mapper);</span><br><span class="line">    Loader loader &#x3D; new SimpleLoader();</span><br><span class="line">    context.setLoader(loader);</span><br><span class="line">    &#x2F;&#x2F; context.addServletMapping(pattern, name);</span><br><span class="line">    context.addServletMapping(&quot;&#x2F;Primitive&quot;, &quot;Primitive&quot;);</span><br><span class="line">    context.addServletMapping(&quot;&#x2F;Modern&quot;, &quot;Modern&quot;);</span><br><span class="line">    connector.setContainer(context);</span><br><span class="line">    try &#123;</span><br><span class="line">      connector.initialize();</span><br><span class="line">      connector.start();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; make the application wait until we press a key.</span><br><span class="line">      System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657</span><br></pre></td></tr></table></figure>

<p>main()方法由实例化Tomcat默认连接器和两个wrappers，wrapper1和wrapper2开始。 这些包装器被命名为Primitive和Modern。 Primitive和Modern的servlet类是PrimitiveServlet和ModernServlet。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpConnector connector &#x3D; new HttpConnector();</span><br><span class="line">Wrapper wrapper1 &#x3D; new SimpleWrapper();</span><br><span class="line">wrapper1.setName(&quot;Primitive&quot;);</span><br><span class="line">wrapper1.setServletClass(&quot;PrimitiveServlet&quot;);</span><br><span class="line">Wrapper wrapper2 &#x3D; new SimpleWrapper();</span><br><span class="line">wrapper2.setName(&quot;Modern&quot;);</span><br><span class="line">wrapper2.setServletClass(&quot;ModernServlet&quot;);1234567</span><br></pre></td></tr></table></figure>

<p>然后，main()方法创建一个SimpleContext实例，并将wrapper1和wrapper2添加为SimpleContext的子容器。它还实例化两个阀门ClientIPLoggerValve和HeaderLoggerValve，并将它们添加到SimpleContext。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Context context &#x3D; new SimpleContext();</span><br><span class="line">context.addChild(wrapper1);</span><br><span class="line">context.addChild(wrapper2);</span><br><span class="line">Valve valve1 &#x3D; new HeaderLoggerValve();</span><br><span class="line">Valve valve2 &#x3D; new ClientIPLoggerValve();</span><br><span class="line">((Pipeline) context).addValve(valve1);</span><br><span class="line">((Pipeline) context).addValve(valve2);1234567</span><br></pre></td></tr></table></figure>

<p>接下来，它从SimpleMapper类构造一个映射器对象并将其添加到SimpleContext。 此映射器负责在上下文中查找子容器来处理HTTP请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mapper mapper &#x3D; new SimpleContextMapper();</span><br><span class="line">mapper.setProtocol(&quot;http&quot;);</span><br><span class="line">context.addMapper(mapper);123</span><br></pre></td></tr></table></figure>

<p>要加载servlet类，则需要一个加载器。 在这里我们使用SimpleLoader类，正如在第一个应用Demo一样。 但是，不是将它添加到两个包装器，而是loader被添加到context中。 包装器将使用它的getLoader()找到加载器，因为context是其父级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loader loader &#x3D; new SimpleLoader();</span><br><span class="line">context.setLoader(loader);12</span><br></pre></td></tr></table></figure>

<p>现在，是时候添加servlet映射了。 我们为2个包装器添加了2个匹配模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; context.addServletMapping(pattern, name);</span><br><span class="line">context.addServletMapping(&quot;&#x2F;Primitive&quot;, &quot;Primitive&quot;);</span><br><span class="line">context.addServletMapping(&quot;&#x2F;Modern&quot;, &quot;Modern&quot;);123</span><br></pre></td></tr></table></figure>

<p>最后，将上下文指定为连接器的容器，并初始化和启动连接器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connector.setContainer(context);</span><br><span class="line">try &#123;</span><br><span class="line">    connector.initialize();</span><br><span class="line">    connector.start();1234</span><br></pre></td></tr></table></figure>

<p><strong>5.6.5 运行Demo</strong></p>
<p>在 Linux 下，使用冒号分开两个库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .&#x2F;lib&#x2F;servlet.jar:.&#x2F; ex05.pyrmont.startup.Bootstrap21</span><br></pre></td></tr></table></figure>

<p>调用PrimitiveServlet，可以使用下面的 URL 来请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;Primitive</span><br></pre></td></tr></table></figure>

<p>调用ModernServlet，可以使用下面的 URL 来请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;Modern</span><br></pre></td></tr></table></figure>

<h2 id="5-7小结"><a href="#5-7小结" class="headerlink" title="5.7小结"></a><strong>5.7小结</strong></h2><p>容器是连接器之后的第二个主模块。 容器使用许多其它模块，如Loader，Logger，Manager等。有4种类型容器：Engine，Host，Context和Wrapper。 Catalina部署没有必需所有4个容器都存在。 本章中的两个应用Demo展现了：部署可以具有单个Wrapper或含有几个wrapper的Context。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%208%20%E5%AE%9E%E6%88%98/Chapter-4%20%E5%BC%95%E5%85%A5%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%208%20%E5%AE%9E%E6%88%98/Chapter-4%20%E5%BC%95%E5%85%A5%E6%B5%81/" class="post-title-link" itemprop="url">chapter4-引入流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-04 18:24:28" itemprop="dateCreated datePublished" datetime="2021-10-04T18:24:28+08:00">2021-10-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-10 10:28:27" itemprop="dateModified" datetime="2023-02-10T10:28:27+08:00">2023-02-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h2><ul>
<li><p>以声明的方式（通过查询语句表达，而不是临时写实现）处理数据集合</p>
</li>
<li><p>遍历数据的高级迭代器</p>
</li>
</ul>
<h2 id="集合与流"><a href="#集合与流" class="headerlink" title="集合与流"></a>集合与流</h2><h3 id="集合和流比较"><a href="#集合和流比较" class="headerlink" title="集合和流比较"></a>集合和流比较</h3><ul>
<li>无法并行处理了元素</li>
</ul>
<p>java使用集合处理数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; lowCaloricDishes &#x3D; new ArrayList();</span><br><span class="line">for(Dish : dishes)&#123;</span><br><span class="line">	if(dishes.getCalories() &lt; 400)</span><br><span class="line">		lowCaloricDishes.add(dish)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collections.sort(lowCaloricDishes, (d1, d2) -&gt; return d1.getCalories() - d2.getCaloriest());</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; lowCaloricDishNames &#x3D; new ArrayList();</span><br><span class="line">for(Dish d : lowCaloricDishes)&#123;</span><br><span class="line">  lowCaloricDishNames.add(d.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java使用流处理同样的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lowCaloricDishNames &#x3D;  dishes</span><br><span class="line">.parallelStream()</span><br><span class="line">.filter(d-&gt;d.getCalories() &lt; 400)</span><br><span class="line">.sorted(comparing(Dishes::getCalories))</span><br><span class="line">.map(e-&gt;e.getName())</span><br><span class="line">.collect(toList())</span><br></pre></td></tr></table></figure>

<p>总结stream api的优势：</p>
<ul>
<li>声明性：更简单、更透明</li>
<li>可复合：更灵活</li>
<li>可并行：性能更好</li>
</ul>
<h3 id="流简介"><a href="#流简介" class="headerlink" title="流简介"></a>流简介</h3><p>简短定义：从支持数据处理操作的源生成的元素序列</p>
<ul>
<li>元素序列：就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。但<strong>流的目的在于表达计算</strong>，比如filter、 sorted和map。集合讲的是数据，流讲的是计算。</li>
<li>源：流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li>
<li>数据处理操作：流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、 map、 reduce、 find、 match、 sort等。流操作可以顺序执行，也可并行执行。</li>
<li>流水线：很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线，流水线的操作可以看作对数据源进行数据库式查询。</li>
<li>内部迭代：与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li>
</ul>
<h3 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h3><p>Java现有的集合概念和新的流概念都提供了接口，来配合代表元素型有序值的数据接口。所谓有序，就是说我们一般是按顺序取用值，而不是随机取用的。</p>
<p>粗略地说，集合与流之间的差异就在于什么时候进行计算。</p>
<ul>
<li>集合是一个内存中的数据结构，它包含数据结构中目前所有的值，集合中的每个元素都得先算出来才能添加到集合中。（你可以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素都得先算出来才能成为集合的一部分。）</li>
<li>相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。 这对编程有很大的好处。这个思想就是用户仅仅从流中提取需要的值，而这些值在用户看不见的地方，只会按需生成。这是一种生产者，消费者的关系。从另一个角度来说，流就像是一个延迟创建的集合，只有在消费者要求的时候才会计算值（用管理学的话说这就是需求驱动，甚至是实时制造)。</li>
</ul>
<h4 id="只能遍历一次"><a href="#只能遍历一次" class="headerlink" title="只能遍历一次"></a>只能遍历一次</h4><p>请注意，和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集合之类的可重复的源，如果是I/O通道就没戏了）。</p>
<h4 id="外部迭代与内部迭代"><a href="#外部迭代与内部迭代" class="headerlink" title="外部迭代与内部迭代"></a>外部迭代与内部迭代</h4><p>使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。 相反，Streams库使用内部迭代，它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。</p>
<h3 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h3><h4 id="常用中间操作"><a href="#常用中间操作" class="headerlink" title="常用中间操作"></a>常用中间操作</h4><p>操作    类型    返回类型    操作参数    函数描述符<br>filter    中间    Stream<T>    Predicate<T>    T -&gt; boolean<br>map    中间    Stream<R>    Function&lt;T, R&gt;    T -&gt; R<br>limit    中间    Stream<T><br>sorted    中间    Stream<T>    Comparator<T>    (T, T) -&gt; int<br>distinct    中间    Stream<T>        </p>
<h4 id="常用终端操作"><a href="#常用终端操作" class="headerlink" title="常用终端操作"></a>常用终端操作</h4><p>操作    类型    目的<br>forEach    终端    消费流中的每个元素并对其应用 Lambda。这一操作返回 void<br>count    终端    返回流中元素的个数。这一操作返回 long<br>collect    终端    把流归约成一个集合，比如 List、 Map 甚至是 Integer。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%208%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/Chapter-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%208%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/Chapter-1/" class="post-title-link" itemprop="url">CHAPTER 1: SCALE FROM ZERO TO MILLIONS OF USERS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-04 18:24:28" itemprop="dateCreated datePublished" datetime="2021-10-04T18:24:28+08:00">2021-10-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-10 09:42:25" itemprop="dateModified" datetime="2023-02-10T09:42:25+08:00">2023-02-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell%E5%B7%A5%E5%85%B7-01-%E5%A4%A7%E7%A5%9E%E7%9A%84%E5%BC%80%E6%BA%90%E7%81%AB%E7%84%B0%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell%E5%B7%A5%E5%85%B7-01-%E5%A4%A7%E7%A5%9E%E7%9A%84%E5%BC%80%E6%BA%90%E7%81%AB%E7%84%B0%E5%9B%BE/" class="post-title-link" itemprop="url">shell工具-01-大神的开源火焰图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-08 18:39:39 / Modified: 18:40:36" itemprop="dateCreated datePublished" datetime="2021-09-08T18:39:39+08:00">2021-09-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p> <em>来源：<a target="_blank" rel="noopener" href="https://zhenbianshu.github.io/">https://zhenbianshu.github.io</a></em></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>火焰图</code>，之前组内大神分享过它的使用办法，但我之后很久都没有用过，以至于对它没有什么深刻印象，最近排查我们 Java 应用负载问题时试用了一下，这才对它的用途有了点心得。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>在排查性能问题时，我们通常会把线程栈 dump 出来，然后使用 <code>grep --no-group-separator -A 1 java.lang.Thread.State jstack.log | awk &#39;NR%2==0&#39; | sort | uniq -c | sort -nr</code> 类似的 shell 语句，查看大多数线程栈都在干什么。而由线程栈的出现频率，来推断 JVM 内耗时最多的调用。</p>
<p>至于其原理，设想广场上有一个大屏幕在不停地播放各种广告。如果我们随机对大屏幕拍照，次数多了，统计照片中各个广告出现的频率，基本可以得出每个广告的播放时长占比了。</p>
<p>而我们应用的资源就像大屏幕，每次调用就像是播放一次广告，统计 dump 出的线程栈出现比例，也就基本能看出线程栈的耗时占比，虽然有误差，但是多次统计下应该差不了多少。这也就是为什么有些家长每次进孩子房间都发现孩子在看系统桌面后以为孩子平时喜欢对着桌面发呆的原因。:)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2444  at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1200)</span><br><span class="line">1587  at sun.misc.Unsafe.park(Native Method)</span><br><span class="line"> 795  at java.security.Provider.getService(Provider.java:1035)</span><br><span class="line"> 293  at java.lang.Object.wait(Native Method)</span><br><span class="line"> 292  at java.lang.Thread.sleep(Native Method)</span><br><span class="line">  73  at org.apache.logging.log4j.core.layout.TextEncoderHelper.copyDataToDestination(TextEncoderHelper.java:61)</span><br><span class="line">  71  at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">  70  at java.lang.Class.forName0(Native Method)</span><br><span class="line">  54  at org.apache.logging.log4j.core.appender.rolling.RollingFileManager.checkRollover(RollingFileManager.java:217)</span><br></pre></td></tr></table></figure>

<p>但是这样有些问题，首先写 shell 挺费事的，另外如果我想查看自栈顶第二个栈的最多调用，即使修改了 shell 命令，结果也不直观。</p>
<p>产生这个问题的主要原因是，我们的线程栈是有调用关系的，即我们需要考虑线程栈的 <code>调用链</code> 和 <code>出现频率</code> 两个维度，而单一的文本表现这两种维度比较困难，所以，著名性能分析大师 brendan gregg 就提出了火焰图。</p>
<h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>火焰图，因其形似火焰而得名，其开源代码地址：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a></p>
</blockquote>
<p>它是一种 svg 可交互式图形，我们通过点击和鼠标指向可以展示出更多的信息。下图就是一个典型的火焰图，从结构上，它是由多个大小和颜色各异的方块构成，每个方块上都有字符，它们底部连接在一块，组成火焰的基底，顶部分出许多”小火苗”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvauyA1tcQgR1fHrxzrSgcAWjq0icLIXIcCIF7hibbGlaXGxFsjibxANw4evL9xNL6nan7iaaeFIJtABg3w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>当我们点击方块时，图片会从我们点击的方块为基底向上展开，而我们鼠标指向方块时，会展示出方块的详细说明。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>介绍火焰图的分析前，我们要首先说明它的特性：</p>
<ul>
<li>由底部到顶部可以追溯一个唯一的调用链，下面的方块是上面方块的父调用。</li>
<li>同一父调用的方块从左到右以字母序排列。</li>
<li>方块上的字符表示一个调用名称，括号内是火焰图指向的调用在火焰图中出现的次数和这个方块占最底层方块的宽度百分比。</li>
<li>方块的颜色没有实际意义，相邻方块的颜色差只为了便于查看。</li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>那么，给我们一张火焰图，我们怎么能看出系统哪里有问题呢？</p>
<p>由上文中的火焰图特性特性，查看火焰图时，我们最主要的关注点要放在方块的宽度上，因为宽度代表了调用栈在全局出现的次数，次数代表着出现频率，而频率也就可以说明耗时。</p>
<p>但是观察火焰图底部或中部方块的宽度占比意义不大，如上面的火焰图，中部的 <code>do_redirections</code> 函数宽度是 24.87%，也就是说它耗用了整个应用近四分之一的时间，但是真正消耗时间的并不是 do_redirections 函数，而是 do_redirections 内部又调用的其他函数，而它的子调用分为了很多个，每个调用的耗时并没有异常。</p>
<p>我们更应该关注的是火焰图顶部的一些 “平顶山”，顶部说明它没有子调用，方块宽说明它耗时长，长时间 hang 住，或者被非常频率地调用，这种方块指向的调用才是性能问题的罪魁祸首。</p>
<p>找到了异常调用，直接优化它，或者再根据火焰图的调用链层层向下，找到我们的业务代码进行优化，也就大功告成。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>每种工具都有其适合的应用场景，火焰图则适合用在：</p>
<ul>
<li>代码循环分析：如果代码中有很大的循环或死循环代码，那么从火焰图的顶部或接近项部的地方会有很明显的”平顶”，表示代码频繁地在某个线程栈上下切换。但需要注意的是，如果循环的总耗时不长，在火焰图上不会很明显。</li>
<li>IO 瓶颈/锁分析：在我们的应用代码中，我们的调用普遍都是同步的，也就是说在进行网络调用、文件 I/O 操作或未成功获得锁时，线程会停留在某个调用上等待 I/O 响应或锁，如果这个等待非常耗时，会导致线程在某个调用上一直 hang 住，这在火焰图上表现得会非常清晰。与此相对的是，我们应用线程构成的火焰图无法准确地表达 CPU 的消耗，因为应用线程内没有系统的调用栈，在应用线程栈 hang 住时，CPU 可能去做其他事了，导致我们看到耗时很长，而 CPU 却很闲。</li>
<li>火焰图倒置分析全局代码：火焰图倒置有时也会很实用，如果我们的代码 N 个不同的分支都调用某一方法，倒置后，所有栈顶相同的调用被合并在一块，我们就能看出这个方法的总耗时，也就很容易评估出优化这个方法的收益。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>既然火焰图这么强大，那么我们该怎么实现呢？</p>
<h4 id="生成工具"><a href="#生成工具" class="headerlink" title="生成工具"></a>生成工具</h4><p>brendan gregg 大神已经把生成火焰图的方法用 perl 实现了，开源代码就在上文的 Github 仓库中，根目录下的 <code>flamegraph.pl</code> 文件就是可执行的 perl 文件了。</p>
<p>这个命令还可以传入各种参数，支持我们修改火焰图的颜色、大小等 。</p>
<p>但 flamegraph.pl 只能处理特定格式的文件，像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a;b;c 12</span><br><span class="line">a;d 3</span><br><span class="line">b;c 3</span><br><span class="line">z;d 5</span><br><span class="line">a;c;e 3</span><br></pre></td></tr></table></figure>

<p>前面是调用链，每个调用之间用 <code>;</code> 隔开，每行后面的数字是调用栈出现的次数。</p>
<p>如上面的数据，用 flamegraph.pl 生成的火焰图如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8Jeic82Or04l8qwqLuAsZNZVtNKRsloJlTsDdd4ialwYzZTGiaAFAhl35iawbMibbwRdCClX2n6zW62gvXgA5uRKYlA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>至于我们的 jstack 信息如何被处理成上面的格式，大神则为常见的 dump 格式都提供了工具，像 <code>stackcollapse-perf.pl</code>可以处理 <code>perf</code> 命令的输出，<code>stackcollapse-jstack.pl</code> 处理 <code>jstack</code> 输出，<code>stackcollapse-gdb.pl</code> 处理 gdb 输出的栈等。</p>
<p>也可以用 shell 简单地实现一下 jstack 的处理方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v -P &#39;.+prio&#x3D;d+ os_prio&#x3D;d+&#39; | grep -v -E &#39;locked &lt;&#39; | awk &#39;&#123;if ($0&#x3D;&#x3D;&quot;&quot;)&#123;print $0&#125;else&#123;printf&quot;%s;&quot;,$0&#125;&#125;&#39; | sort | uniq -c | awk &#39;&#123;a&#x3D;$1;$1&#x3D;&quot;&quot;;print $0,a&#125;&#39;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell-01-%E7%BB%9F%E8%AE%A1stack%E4%BF%A1%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell-01-%E7%BB%9F%E8%AE%A1stack%E4%BF%A1%E6%81%AF/" class="post-title-link" itemprop="url">shell-01-统计stack信息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-08 18:39:15" itemprop="dateCreated datePublished" datetime="2021-09-08T18:39:15+08:00">2021-09-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-24 08:50:05" itemprop="dateModified" datetime="2021-11-24T08:50:05+08:00">2021-11-24</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell-03-grep%E5%88%86%E6%9E%90%E7%BB%9F%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell-03-grep%E5%88%86%E6%9E%90%E7%BB%9F%E8%AE%A1/" class="post-title-link" itemprop="url">shell-01-统计stack信息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-08 18:39:15" itemprop="dateCreated datePublished" datetime="2021-09-08T18:39:15+08:00">2021-09-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-08 17:37:37" itemprop="dateModified" datetime="2021-11-08T17:37:37+08:00">2021-11-08</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka-06-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%9B%E5%BC%83zk%E8%80%8C%E7%94%A8raft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka-06-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%9B%E5%BC%83zk%E8%80%8C%E7%94%A8raft/" class="post-title-link" itemprop="url">Kafka-06-高可用抛弃zk而用raft</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-07 18:39:48" itemprop="dateCreated datePublished" datetime="2021-09-07T18:39:48+08:00">2021-09-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-08 18:29:30" itemprop="dateModified" datetime="2021-09-08T18:29:30+08:00">2021-09-08</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Zookeeper使用场景"><a href="#Zookeeper使用场景" class="headerlink" title="Zookeeper使用场景"></a>Zookeeper使用场景</h2><p>使用Zookeeper提供的临时顺序节点与事件监听机制，能非常轻松的实现Leader选举。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFv5bvEeVf3VA9XJvdAvDTmibpuJPBnuUW0mcdicEkwfJPKr6o7hRicC86YvLFlBceVdZ6AULJS0iaEh4g/640" alt="Image"></p>
<p>正如上图所示，</p>
<ul>
<li><p><strong>客户端集群</strong>的多个成员t1和t2，能提供相同的服务，但为了实现冷备效果(即同一时间只有一个成员对外提供服务，我们称之为Leader，当Leader宕机或停止服务后，该组织中的其他成名重新竞争Leader，然后继续对外提供服务)。</p>
</li>
<li><p><strong>Zookeeper是注册中心，以集群部署的，能有效避免单点故障，并且集群内部提供了对数据的强一致性</strong>。</p>
</li>
</ul>
<p><a href="">成为leader的步骤</a></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 当客户端集群的成员需要竞争Leader时，借助Zookeeper的实现套路是向zookeeper中的一个数据节点(示例中为/app/order-service/leader)节点创建两个子节点，并且是**顺序的临时节点**。</span><br><span class="line"></span><br><span class="line">- 判断客户端集群的成员判断创建的节点的序号是否为/app/order-service/leader中序号最小的节点，</span><br><span class="line">  - 如果是则成为Leader，对外提供服务；</span><br><span class="line">  - 如果序号不是最小的，则向自己前置的**注册节点**删除事件**，一旦Leader代表的进程宕机，它与Zookeeper的会话失效后，与之关联的临时节点会被删除，一旦Leader创建的节点被删除，其后继节点会得到通知，从而再次触发选主，选举出新的Leader，继续对外提供服务，保质服务的高可用性。</span><br></pre></td></tr></table></figure>

<p>zk的选举机制特点</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 临时节点</span><br><span class="line">  临时节点是与会话关联的，一点创建该临时节点的会话结束，与之会被自动删除，无需应用方人工删除。</span><br><span class="line">- 顺序节点</span><br><span class="line">- 事件机制</span><br><span class="line">  借助与事件机制，Zookeeper能及时通知存活的其他应用节点，重新触发选举，使得实现自动主从切换变的非常简单。</span><br></pre></td></tr></table></figure>



<h2 id="Kafka对Zookeeper的使用"><a href="#Kafka对Zookeeper的使用" class="headerlink" title="Kafka对Zookeeper的使用"></a>Kafka对Zookeeper的使用</h2><p>Kafka中存在众多的Leader选举，一个topic可以拥有多个patition，每一个partition可以配置多个replica，<strong>如何保证一个patition的数据在此patition的多个replica之间的一致性？</strong>。</p>
<p>Kafka的实现就是一个partition有多个冗余(多个副本)，从中选举出一个Leader用来承担客户端的读写请求，从节点从主节点处拷贝内容，Leader节点根据数据在副本中成功写入情况，进行抉择来确定是否写入成功。<!--主备，不是主从--></p>
<p><strong>故此处需要进行Leader选举</strong>,而基于Zookeeper能轻松实现。</p>
<p><a target="_blank" rel="noopener" href="https://colobu.com/2017/11/02/kafka-replication/kafka_replication_diagram.png"><img src="https://colobu.com/2017/11/02/kafka-replication/kafka_replication_diagram.png" alt="img"></a></p>
<p>kafka的复制是针对分区的。比如上图中有4个broker, 1个topic, 2个分区，复制因子是3。当producer发送一个消息的时候，它会选择一个分区，比如<code>topic1-part1</code>分区，将消息发送给这个分区的leader， broker2、broker3会拉取这个消息，一旦消息被拉取过来，slave会发送ack给master，这时候master才commit这个log。</p>
<h2 id="Zookeeper的致命弱点"><a href="#Zookeeper的致命弱点" class="headerlink" title="Zookeeper的致命弱点"></a>Zookeeper的致命弱点</h2><p>Zookeeper是集群部署，只要集群中超过半数节点存活，即可提供服务</p>
<p>但Zookeeper的设计是CP模型。Zookeeper集群中也存在所谓的Leader节点和从节点，Leader节点负责写，Leader与从节点可用接受读请求，但在Zookeeper内部节点在选举时整个Zookeeper无法对外提供服务。当然正常情况下选举会非常快，但在异常情况下就不好说了，例如Zookeeper节点发生full Gc，此时造成的影响将是毁灭性的。</p>
<p>Zookeeper节点如果频繁发生Full Gc，此时与客户端的会话将超时，由于此时无法响应客户端的心跳请求(Stop World)，从而与会话相关联的临时节点将被删除，注意，此时是所有的临时节点会被删除，Zookeeper依赖的事件通知机制将失效，整个集群的选举服务将失效。</p>
<p>站在高可用性的角度，Kafka集群的可用性不仅取决于自身，还受到了外部组件的制约，从长久来看，<strong>显然都不是一个优雅的方案</strong>。</p>
<p><strong>随着分布式领域相关技术的不断完善，去中心化的思想逐步兴起，去Zookeeper的呼声也越来越高，在这个进程中涌现了一个非常优秀的算法：Raft协议。</strong></p>
<p>Raft协议的两个重要组成部分：Leader选举、日志复制，而日志复制为多个副本提供数据强一致性提供了强一致性，<strong>并且一个显著的特点是Raft节点是去中心化的架构，不依赖外部的组件，而是作为一个协议簇嵌入到应用中的，即与应用本身是融合为一体的</strong>。</p>
<p>再以Kafka Topic的分布图举例，引用Raft协议的示例图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFv5bvEeVf3VA9XJvdAvDTmibaH526cQCXlKkCHf9zf6wVOBIjic6vFjYYVZ7lEpHVPxv8kic2tbbRicMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>选主提供了另外一种可行方案，而且还无需依赖第三方组件，故最终Kafka在2.8版本中正式废弃了Zookeeper，拥抱Raft。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
