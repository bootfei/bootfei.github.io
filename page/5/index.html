<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">209</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/Netty-01-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/Netty-01-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Netty-01-心跳机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-14 20:44:36 / Modified: 20:50:17" itemprop="dateCreated datePublished" datetime="2021-06-14T20:44:36+08:00">2021-06-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="如何实现心跳"><a href="#如何实现心跳" class="headerlink" title="如何实现心跳"></a>如何实现心跳</h2><p>我们可以通过两种方式实现心跳机制:</p>
<ul>
<li>使用 TCP 协议层面的 keepalive 机制.</li>
<li>在应用层上实现自定义的心跳机制.</li>
</ul>
<p>虽然在 TCP 协议层面上, 提供了 keepalive 保活机制, 但是使用它有几个缺点:</p>
<ol>
<li>它不是 TCP 的标准协议, 并且是默认关闭的.</li>
<li>TCP keepalive 机制依赖于操作系统的实现, 默认的 keepalive 心跳时间是 两个小时, 并且对 keepalive 的修改需要系统调用(或者修改系统配置), 灵活性不够.</li>
<li>TCP keepalive 与 TCP 协议绑定, 因此如果需要更换为 UDP 协议时, keepalive 机制就失效了.</li>
</ol>
<p>虽然使用 TCP 层面的 keepalive 机制比自定义的应用层心跳机制节省流量, 但是基于上面的几点缺点, 一般的实践中, 人们大多数都是选择在应用层上实现自定义的心跳.</p>
<p>既然如此, 那么我们就来大致看看在在 Netty 中是怎么实现心跳的吧. 在 Netty 中, 实现心跳机制的关键是 IdleStateHandler, 它可以对一个 Channel 的 读/写设置定时器, 当 Channel 在一定事件间隔内没有数据交互时(即处于 idle 状态), 就会触发指定的事件.</p>
<h2 id="使用-Netty-实现心跳"><a href="#使用-Netty-实现心跳" class="headerlink" title="使用 Netty 实现心跳"></a><strong>使用 Netty 实现心跳</strong></h2><p>上面我们提到了, 在 Netty 中, 实现心跳机制的关键是 IdleStateHandler, 那么这个 Handler 如何使用呢? 我们来看看它的构造器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public IdleStateHandler(int readerIdleTimeSeconds, int writerIdleTimeSeconds, int allIdleTimeSeconds) &#123;</span><br><span class="line">    this((long)readerIdleTimeSeconds, (long)writerIdleTimeSeconds, (long)allIdleTimeSeconds, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化一个 IdleStateHandler 需要提供三个参数:</p>
<ul>
<li>readerIdleTimeSeconds, 读超时. 即当在指定的时间间隔内没有从 Channel 读取到数据时, 会触发一个 READER_IDLE 的 IdleStateEvent 事件.</li>
<li>writerIdleTimeSeconds, 写超时. 即当在指定的时间间隔内没有数据写入到 Channel 时, 会触发一个 WRITER_IDLE 的 IdleStateEvent 事件.</li>
<li>allIdleTimeSeconds, 读/写超时. 即当在指定的时间间隔内没有读或写操作时, 会触发一个 ALL_IDLE 的 IdleStateEvent 事件.</li>
</ul>
<p>为了展示具体的 IdleStateHandler 实现的心跳机制, 下面我们来构造一个具体的EchoServer 的例子, 这个例子的行为如下:</p>
<ol>
<li>在这个例子中, 客户端和服务器通过 TCP 长连接进行通信.</li>
<li>TCP 通信的报文格式是:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--------+-----+---------------+ </span><br><span class="line">| Length |Type |   Content     |</span><br><span class="line">|   17   |  1  |&quot;HELLO, WORLD&quot; |</span><br><span class="line">+--------+-----+---------------+</span><br></pre></td></tr></table></figure>

<ol>
<li>客户端每隔一个随机的时间后, 向服务器发送消息, 服务器收到消息后, 立即将收到的消息原封不动地回复给客户端.</li>
<li>若客户端在指定的时间间隔内没有读/写操作, 则客户端会自动向服务器发送一个 PING 心跳, 服务器收到 PING 心跳消息时, 需要回复一个 PONG 消息.</li>
</ol>
<h3 id="通用部分"><a href="#通用部分" class="headerlink" title="通用部分"></a>通用部分</h3><p>根据上面定义的行为, 我们接下来实现心跳的通用部分 CustomHeartbeatHandler:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CustomHeartbeatHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123;</span><br><span class="line">    public static final byte PING_MSG &#x3D; 1;</span><br><span class="line">    public static final byte PONG_MSG &#x3D; 2;</span><br><span class="line">    public static final byte CUSTOM_MSG &#x3D; 3;</span><br><span class="line">    protected String name;</span><br><span class="line">    private int heartbeatCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public CustomHeartbeatHandler(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext context, ByteBuf byteBuf) throws Exception &#123;</span><br><span class="line">        if (byteBuf.getByte(4) &#x3D;&#x3D; PING_MSG) &#123;</span><br><span class="line">            sendPongMsg(context);</span><br><span class="line">        &#125; else if (byteBuf.getByte(4) &#x3D;&#x3D; PONG_MSG)&#123;</span><br><span class="line">            System.out.println(name + &quot; get pong msg from &quot; + context.channel().remoteAddress());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handleData(context, byteBuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void sendPingMsg(ChannelHandlerContext context) &#123;</span><br><span class="line">        ByteBuf buf &#x3D; context.alloc().buffer(5);</span><br><span class="line">        buf.writeInt(5);</span><br><span class="line">        buf.writeByte(PING_MSG);</span><br><span class="line">        context.writeAndFlush(buf);</span><br><span class="line">        heartbeatCount++;</span><br><span class="line">        System.out.println(name + &quot; sent ping msg to &quot; + context.channel().remoteAddress() + &quot;, count: &quot; + heartbeatCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void sendPongMsg(ChannelHandlerContext context) &#123;</span><br><span class="line">        ByteBuf buf &#x3D; context.alloc().buffer(5);</span><br><span class="line">        buf.writeInt(5);</span><br><span class="line">        buf.writeByte(PONG_MSG);</span><br><span class="line">        context.channel().writeAndFlush(buf);</span><br><span class="line">        heartbeatCount++;</span><br><span class="line">        System.out.println(name + &quot; sent pong msg to &quot; + context.channel().remoteAddress() + &quot;, count: &quot; + heartbeatCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void handleData(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; IdleStateHandler 所产生的 IdleStateEvent 的处理逻辑.</span><br><span class="line">        if (evt instanceof IdleStateEvent) &#123;</span><br><span class="line">            IdleStateEvent e &#x3D; (IdleStateEvent) evt;</span><br><span class="line">            switch (e.state()) &#123;</span><br><span class="line">                case READER_IDLE:</span><br><span class="line">                    handleReaderIdle(ctx);</span><br><span class="line">                    break;</span><br><span class="line">                case WRITER_IDLE:</span><br><span class="line">                    handleWriterIdle(ctx);</span><br><span class="line">                    break;</span><br><span class="line">                case ALL_IDLE:</span><br><span class="line">                    handleAllIdle(ctx);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.err.println(&quot;---&quot; + ctx.channel().remoteAddress() + &quot; is active---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.err.println(&quot;---&quot; + ctx.channel().remoteAddress() + &quot; is inactive---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void handleReaderIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        System.err.println(&quot;---READER_IDLE---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void handleWriterIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        System.err.println(&quot;---WRITER_IDLE---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void handleAllIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        System.err.println(&quot;---ALL_IDLE---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 CustomHeartbeatHandler 负责心跳的发送和接收, 我们接下来详细地分析一下它的作用. 我们在前面提到, IdleStateHandler 是实现心跳的关键, 它会根据不同的 IO idle 类型来产生不同的 IdleStateEvent 事件, 而这个事件的捕获, 其实就是在 userEventTriggered 方法中实现的.</p>
<p>我们来看看 CustomHeartbeatHandler.userEventTriggered 的具体实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">    if (evt instanceof IdleStateEvent) &#123;</span><br><span class="line">        IdleStateEvent e &#x3D; (IdleStateEvent) evt;</span><br><span class="line">        switch (e.state()) &#123;</span><br><span class="line">            case READER_IDLE:</span><br><span class="line">                handleReaderIdle(ctx);</span><br><span class="line">                break;</span><br><span class="line">            case WRITER_IDLE:</span><br><span class="line">                handleWriterIdle(ctx);</span><br><span class="line">                break;</span><br><span class="line">            case ALL_IDLE:</span><br><span class="line">                handleAllIdle(ctx);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 userEventTriggered 中, 根据 IdleStateEvent 的 state() 的不同, 而进行不同的处理. 例如如果是读取数据 idle, 则 <code>e.state() == READER_IDLE</code>, 因此就调用 handleReaderIdle 来处理它.</p>
<p>CustomHeartbeatHandler 提供了三个 idle 处理方法: handleReaderIdle, handleWriterIdle, handleAllIdle, 这三个方法目前只有默认的实现, 它需要在子类中进行重写, 现在我们暂时略过它们, 在具体的客户端和服务器的实现部分时再来看它们.</p>
<p>知道了这一点后, 我们接下来看看数据处理部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void channelRead0(ChannelHandlerContext context, ByteBuf byteBuf) throws Exception &#123;</span><br><span class="line">    if (byteBuf.getByte(4) &#x3D;&#x3D; PING_MSG) &#123;</span><br><span class="line">        sendPongMsg(context);</span><br><span class="line">    &#125; else if (byteBuf.getByte(4) &#x3D;&#x3D; PONG_MSG)&#123;</span><br><span class="line">        System.out.println(name + &quot; get pong msg from &quot; + context.channel().remoteAddress());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        handleData(context, byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>CustomHeartbeatHandler.channelRead0</code> 中, 我们首先根据报文协议:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--------+-----+---------------+ </span><br><span class="line">| Length |Type |   Content     |</span><br><span class="line">|   17   |  1  |&quot;HELLO, WORLD&quot; |</span><br><span class="line">+--------+-----+---------------+</span><br></pre></td></tr></table></figure>

<p>来判断当前的报文类型, 如果是 PING_MSG 则表示是服务器收到客户端的 PING 消息, 此时服务器需要回复一个 PONG 消息, 其消息类型是 PONG_MSG.</p>
<p>扔报文类型是 PONG_MSG, 则表示是客户端收到服务器发送的 PONG 消息, 此时<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247491704&idx=1&sn=60738828c02e3cc2e4ada24a8a8bc07a&chksm=ebd5df54dca25642b6e71daa96c7780ac3a6208ecc1d002d8d558ef28a8c3b2d91688de9d66d&scene=21#wechat_redirect">打印一个 log</a> 即可.</p>
<h3 id="客户端部分"><a href="#客户端部分" class="headerlink" title="客户端部分"></a>客户端部分</h3><h4 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioEventLoopGroup workGroup &#x3D; new NioEventLoopGroup(4);</span><br><span class="line">        Random random &#x3D; new Random(System.currentTimeMillis());</span><br><span class="line">        try &#123;</span><br><span class="line">            Bootstrap bootstrap &#x3D; new Bootstrap();</span><br><span class="line">            bootstrap</span><br><span class="line">                    .group(workGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            ChannelPipeline p &#x3D; socketChannel.pipeline();</span><br><span class="line">                            p.addLast(new IdleStateHandler(0, 0, 5));</span><br><span class="line">                            p.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, -4, 0));</span><br><span class="line">                            p.addLast(new ClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            Channel ch &#x3D; bootstrap.remoteAddress(&quot;127.0.0.1&quot;, 12345).connect().sync().channel();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                String content &#x3D; &quot;client msg &quot; + i;</span><br><span class="line">                ByteBuf buf &#x3D; ch.alloc().buffer();</span><br><span class="line">                buf.writeInt(5 + content.getBytes().length);</span><br><span class="line">                buf.writeByte(CustomHeartbeatHandler.CUSTOM_MSG);</span><br><span class="line">                buf.writeBytes(content.getBytes());</span><br><span class="line">                ch.writeAndFlush(buf);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(random.nextInt(20000));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是 Netty 的客户端端的初始化代码, 使用过 Netty 的朋友对这个代码应该不会陌生. 别的部分我们就不再赘述, 我们来看看 <code>ChannelInitializer.initChannel</code> 部分即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">        ChannelPipeline p &#x3D; socketChannel.pipeline();</span><br><span class="line">        p.addLast(new IdleStateHandler(0, 0, 5));</span><br><span class="line">        p.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, -4, 0));</span><br><span class="line">        p.addLast(new ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们给 pipeline 添加了三个 Handler, IdleStateHandler 这个 handler 是心跳机制的核心, 我们为客户端端设置了读写 idle 超时, 时间间隔是5s, 即如果客户端在间隔 5s 后都没有收到服务器的消息或向服务器发送消息, 则产生 ALL_IDLE 事件.</p>
<p>接下来我们添加了 LengthFieldBasedFrameDecoder, 它是负责解析我们的 TCP 报文, 因为和本文的目的无关, 因此这里不详细展开.</p>
<p>最后一个 Handler 是 ClientHandler, 它继承于 CustomHeartbeatHandler, 是我们处理业务逻辑部分.</p>
<h4 id="客户端-Handler"><a href="#客户端-Handler" class="headerlink" title="客户端 Handler"></a>客户端 Handler</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ClientHandler extends CustomHeartbeatHandler &#123;</span><br><span class="line">    public ClientHandler() &#123;</span><br><span class="line">        super(&quot;client&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleData(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) &#123;</span><br><span class="line">        byte[] data &#x3D; new byte[byteBuf.readableBytes() - 5];</span><br><span class="line">        byteBuf.skipBytes(5);</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line">        String content &#x3D; new String(data);</span><br><span class="line">        System.out.println(name + &quot; get content: &quot; + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleAllIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        super.handleAllIdle(ctx);</span><br><span class="line">        sendPingMsg(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClientHandler 继承于 CustomHeartbeatHandler, 它重写了两个方法, 一个是 handleData, 在这里面实现 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247491704&idx=1&sn=60738828c02e3cc2e4ada24a8a8bc07a&chksm=ebd5df54dca25642b6e71daa96c7780ac3a6208ecc1d002d8d558ef28a8c3b2d91688de9d66d&scene=21#wechat_redirect">仅仅打印</a>收到的消息.</p>
<p>第二个重写的方法是 handleAllIdle. 我们在前面提到, 客户端负责发送心跳的 PING 消息, 当客户端产生一个 ALL_IDLE 事件后, 会导致父类的 CustomHeartbeatHandler.userEventTriggered 调用, 而 userEventTriggered 中会根据 e.state() 来调用不同的方法, 因此最后调用的是 ClientHandler.handleAllIdle, 在这个方法中, 客户端调用 sendPingMsg 向服务器发送一个 PING 消息.</p>
<h3 id="服务器部分"><a href="#服务器部分" class="headerlink" title="服务器部分"></a>服务器部分</h3><h4 id="服务器初始化"><a href="#服务器初始化" class="headerlink" title="服务器初始化"></a>服务器初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioEventLoopGroup bossGroup &#x3D; new NioEventLoopGroup(1);</span><br><span class="line">        NioEventLoopGroup workGroup &#x3D; new NioEventLoopGroup(4);</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerBootstrap bootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">            bootstrap</span><br><span class="line">                    .group(bossGroup, workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            ChannelPipeline p &#x3D; socketChannel.pipeline();</span><br><span class="line">                            p.addLast(new IdleStateHandler(10, 0, 0));</span><br><span class="line">                            p.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, -4, 0));</span><br><span class="line">                            p.addLast(new ServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            Channel ch &#x3D; bootstrap.bind(12345).sync().channel();</span><br><span class="line">            ch.closeFuture().sync();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器的初始化部分也没有什么好说的, 它也和客户端的初始化一样, 为 pipeline 添加了三个 Handler.</p>
<h4 id="服务器-Handler"><a href="#服务器-Handler" class="headerlink" title="服务器 Handler"></a>服务器 Handler</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ServerHandler extends CustomHeartbeatHandler &#123;</span><br><span class="line">    public ServerHandler() &#123;</span><br><span class="line">        super(&quot;server&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleData(ChannelHandlerContext channelHandlerContext, ByteBuf buf) &#123;</span><br><span class="line">        byte[] data &#x3D; new byte[buf.readableBytes() - 5];</span><br><span class="line">        ByteBuf responseBuf &#x3D; Unpooled.copiedBuffer(buf);</span><br><span class="line">        buf.skipBytes(5);</span><br><span class="line">        buf.readBytes(data);</span><br><span class="line">        String content &#x3D; new String(data);</span><br><span class="line">        System.out.println(name + &quot; get content: &quot; + content);</span><br><span class="line">        channelHandlerContext.write(responseBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleReaderIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        super.handleReaderIdle(ctx);</span><br><span class="line">        System.err.println(&quot;---client &quot; + ctx.channel().remoteAddress().toString() + &quot; reader timeout, close it---&quot;);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServerHandler 继承于 CustomHeartbeatHandler, 它重写了两个方法, 一个是 handleData, 在这里面实现 EchoServer 的功能: 即收到客户端的消息后, 立即原封不动地将消息回复给客户端.</p>
<p>第二个重写的方法是 handleReaderIdle, 因为服务器仅仅对客户端的读 idle 感兴趣, 因此只重新了这个方法. 若服务器在指定时间后没有收到客户端的消息, 则会触发 READER_IDLE 消息, 进而会调用 handleReaderIdle 这个方法.</p>
<p>我们在前面提到, 客户端负责发送心跳的 PING 消息, 并且服务器的 READER_IDLE 的超时时间是客户端发送 PING 消息的间隔的两倍, 因此当服务器 READER_IDLE 触发时, 就可以确定是客户端已经掉线了, 因此服务器直接关闭客户端连接即可.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>使用 Netty 实现心跳机制的关键就是利用 IdleStateHandler 来产生对应的 idle 事件.</li>
<li>一般是客户端负责发送心跳的 PING 消息, 因此客户端注意关注 ALL_IDLE 事件, 在这个事件触发后, 客户端需要向服务器发送 PING 消息, 告诉服务器”我还存活着”.</li>
<li>服务器是接收客户端的 PING 消息的, 因此服务器关注的是 READER_IDLE 事件, 并且服务器的 READER_IDLE 间隔需要比客户端的 ALL_IDLE 事件间隔大(例如客户端ALL_IDLE 是5s 没有读写时触发, 因此服务器的 READER_IDLE 可以设置为10s)</li>
<li>当服务器收到客户端的 PING 消息时, 会发送一个 PONG 消息作为回复. 一个 PING-PONG 消息对就是一个心跳交互.</li>
</ol>
<h2 id="实现客户端的断线重连"><a href="#实现客户端的断线重连" class="headerlink" title="实现客户端的断线重连"></a><strong>实现客户端的断线重连</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    private NioEventLoopGroup workGroup &#x3D; new NioEventLoopGroup(4);</span><br><span class="line">    private Channel channel;</span><br><span class="line">    private Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Client client &#x3D; new Client();</span><br><span class="line">        client.start();</span><br><span class="line">        client.sendData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendData() throws Exception &#123;</span><br><span class="line">        Random random &#x3D; new Random(System.currentTimeMillis());</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            if (channel !&#x3D; null &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                String content &#x3D; &quot;client msg &quot; + i;</span><br><span class="line">                ByteBuf buf &#x3D; channel.alloc().buffer(5 + content.getBytes().length);</span><br><span class="line">                buf.writeInt(5 + content.getBytes().length);</span><br><span class="line">                buf.writeByte(CustomHeartbeatHandler.CUSTOM_MSG);</span><br><span class="line">                buf.writeBytes(content.getBytes());</span><br><span class="line">                channel.writeAndFlush(buf);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(random.nextInt(20000));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            bootstrap &#x3D; new Bootstrap();</span><br><span class="line">            bootstrap</span><br><span class="line">                    .group(workGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            ChannelPipeline p &#x3D; socketChannel.pipeline();</span><br><span class="line">                            p.addLast(new IdleStateHandler(0, 0, 5));</span><br><span class="line">                            p.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, -4, 0));</span><br><span class="line">                            p.addLast(new ClientHandler(Client.this));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            doConnect();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doConnect() &#123;</span><br><span class="line">        if (channel !&#x3D; null &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelFuture future &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 12345);</span><br><span class="line"></span><br><span class="line">        future.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            public void operationComplete(ChannelFuture futureListener) throws Exception &#123;</span><br><span class="line">                if (futureListener.isSuccess()) &#123;</span><br><span class="line">                    channel &#x3D; futureListener.channel();</span><br><span class="line">                    System.out.println(&quot;Connect to server successfully!&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;Failed to connect to server, try connect after 10s&quot;);</span><br><span class="line"></span><br><span class="line">                    futureListener.channel().eventLoop().schedule(new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            doConnect();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, 10, TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中, 我们抽象出 doConnect 方法, 它负责客户端和服务器的 TCP 连接的建立, 并且当 TCP 连接失败时, doConnect 会 通过 <code>channel().eventLoop().schedule</code> 来延时10s 后尝试重新连接.</p>
<h3 id="客户端-Handler-1"><a href="#客户端-Handler-1" class="headerlink" title="客户端 Handler"></a>客户端 Handler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ClientHandler extends CustomHeartbeatHandler &#123;</span><br><span class="line">    private Client client;</span><br><span class="line">    public ClientHandler(Client client) &#123;</span><br><span class="line">        super(&quot;client&quot;);</span><br><span class="line">        this.client &#x3D; client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleData(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) &#123;</span><br><span class="line">        byte[] data &#x3D; new byte[byteBuf.readableBytes() - 5];</span><br><span class="line">        byteBuf.skipBytes(5);</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line">        String content &#x3D; new String(data);</span><br><span class="line">        System.out.println(name + &quot; get content: &quot; + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleAllIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        super.handleAllIdle(ctx);</span><br><span class="line">        sendPingMsg(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        super.channelInactive(ctx);</span><br><span class="line">        client.doConnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断线重连的关键一点是检测连接是否已经断开. 因此我们改写了 ClientHandler, 重写了 channelInactive 方法. 当 TCP 连接断开时, 会回调 channelInactive 方法, 因此我们在这个方法中调用 client.doConnect() 来进行重连</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/Netty-00-%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/Netty-00-%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Netty-00-入门简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-14 20:44:36" itemprop="dateCreated datePublished" datetime="2021-06-14T20:44:36+08:00">2021-06-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-05-13 12:23:35" itemprop="dateModified" datetime="2024-05-13T12:23:35+08:00">2024-05-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="BIO-vs-NIO-vs-AIO"><a href="#BIO-vs-NIO-vs-AIO" class="headerlink" title="BIO vs  NIO vs AIO"></a>BIO vs  NIO vs AIO</h3><p><strong>BIO: 同步阻塞式IO</strong>  打个比喻您打了专车，在您没有到之前司机就在出发地等您上车。您上车之后司机专门送您到目的地。在这个例子中您扮演着IO中的网络事件，司机扮演着处理网络事件的线程。整个过程中您如果没有任何事件发生司机一直都在等待这就是同步阻塞﻿。</p>
<p><strong>NIO:同步非阻塞IO</strong>  银行柜员在等待人办理银行业务，人们去银行后首先要到取号机上取号然后等待对应的柜台叫号。在这个例子中银行柜员扮演着selector，办理银行业务的人扮演者网络事件，而取号机扮演者register的作用，银行柜台就是channel。整个过程中当没有人来办业务时，柜员是可以去做其他事情这就是非阻塞。</p>
<p><strong>AIO:异步非阻塞IO</strong>  您点外卖后就去忙其他的事情了，等骑手把外卖送达后打电话告诉您外卖放外卖柜子里了；您闲下来的时候去取外卖。在这个例子里您扮演着处理网络事件线的程，外卖是网络事件；在这个过程中您可以在外卖还没有送来的时候做些其他的事情，等外卖送达后只是向您发送了一个外卖送达的事件。这就是异步和非阻塞。﻿</p>
<p>通过网络服务端代码的编写来让我们直观感受一下他们的区别：</p>
<p>BIOServer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;  &#x2F;&#x2F;定义一个循环接收客户端的Socket连接请求。初始化一个线程池对象  private static ExecutorService poolHandler &#x3D; new ThreadPoolExecutor(5, 5,                120, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10));    public static void main(String[] args) &#123;        try &#123;            &#x2F;&#x2F; 注册端口            ServerSocket ss &#x3D; new ServerSocket(9999);            while (true) &#123;                Socket socket &#x3D; ss.accept();                &#x2F;&#x2F; 把Socket封装成一个任务对象交给线程池处理                Runnable target &#x3D; new ServerRunnable(socket);                poolHandler.execute(target);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;</span><br><span class="line">    public static class ServerRunnable implements Runnable &#123;      private Socket socket;      public ServerRunnable(Socket socket) &#123;          this.socket &#x3D; socket;      &#125;      @Override      public void run() &#123;          &#x2F;&#x2F; 处理接收的客户端Socket通信需求          try &#123;              InputStream is &#x3D; socket.getInputStream();              BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(is));              String msg;              while ((msg &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;处理数据的粘包拆包                &#x2F;&#x2F;对完整的数据包进行解码操作                &#x2F;&#x2F;得到客户端消息                &#x2F;&#x2F;触发各种统计类事件如心跳检测 信息统计                 &#x2F;&#x2F;处理客户端的消息                &#x2F;&#x2F;得到响应消息                &#x2F;&#x2F;对响应消息进行编码              &#125;          &#125; catch (IOException e) &#123;              e.printStackTrace();            &#x2F;&#x2F;处理网络断开事件            &#x2F;&#x2F;处理其他异常事件          &#125;      &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>NIOServer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;    public static void main(String[] args) throws IOException &#123;        &#x2F;&#x2F;获取ServerSocketChannel        ServerSocketChannel ssChannel &#x3D; ServerSocketChannel.open();        &#x2F;&#x2F;设置非阻塞模式        ssChannel.configureBlocking(false);        &#x2F;&#x2F;绑定端口        ssChannel.bind(new InetSocketAddress(9999));        &#x2F;&#x2F;获取选择器        Selector selector &#x3D; Selector.open();        &#x2F;&#x2F;将ServerSocketChannel注册到选择器上，并且监听建立连接事件        ssChannel.register(selector, SelectionKey.OP_ACCEPT);        &#x2F;&#x2F; 使用Selector选择器轮询已经就绪好的事件        while (selector.select() &gt; 0) &#123;            &#x2F;&#x2F; 获取选择器就绪事件            Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();            &#x2F;&#x2F;遍历事件            while (it.hasNext()) &#123;                SelectionKey sk &#x3D; it.next();                &#x2F;&#x2F;判断事件类型                if (sk.isAcceptable()) &#123;                    &#x2F;&#x2F; 获取客户端channel                    SocketChannel channel &#x3D; ssChannel.accept();                    &#x2F;&#x2F;切换非阻塞模式                    channel.configureBlocking(false);                    &#x2F;&#x2F;将该channel注册到选择器上                    channel.register(selector, SelectionKey.OP_READ);                &#125; else if (sk.isReadable()) &#123;                    &#x2F;&#x2F;获取channel                    SocketChannel sChannel &#x3D; (SocketChannel) sk.channel();                    &#x2F;&#x2F;读取网络数据                    ByteBuffer buf &#x3D; ByteBuffer.allocate(1024);                    int len &#x3D; 0;                    while ((len &#x3D; sChannel.read(buf)) &gt; 0) &#123;                        &#x2F;&#x2F;处理数据的粘包拆包                        &#x2F;&#x2F;对完整的数据包进行解码操作                        &#x2F;&#x2F;得到客户端消息                        &#x2F;&#x2F;触发各种统计类事件如心跳检测 信息统计                     &#125;                &#125;else if(sk.isWritable())&#123;                        &#x2F;&#x2F;得到响应消息                        &#x2F;&#x2F;对响应消息进行编码                &#125;                &#x2F;&#x2F; 15.取消选择键SelectionKey                it.remove();            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>用Netty进行网络编程时代码是这样的：</p>
<p>NettyServer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class NettyServer &#123;    public static void main(String[] args) throws Exception&#123;        &#x2F;&#x2F;设置接受网络连接线程池        NioEventLoopGroup bossGroup &#x3D; new NioEventLoopGroup(1);        &#x2F;&#x2F;设置处理网络除连接外所有事件线程的线程池        NioEventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();        ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">        serverBootstrap.group(bossGroup,workerGroup)                .channel(NioServerSocketChannel.class)&#x2F;&#x2F;设置Channel类型                .option(ChannelOption.SO_BACKLOG,1024)                .handler(new ChannelInitializer&lt;ServerSocketChannel&gt;() &#123;                    @Override                    protected void initChannel(ServerSocketChannel ch) throws Exception &#123;                      &#x2F;&#x2F;设置处理网络连接的Handler                        ch.pipeline().addLast(&quot;serverBindHandler&quot;,                         new NettyBindHandler(NettyTcpServer.this,serverStreamLifecycleListeners));                    &#125;                &#125;)                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;                    @Override                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;                        ch.pipeline()                                .addLast(&quot;protocolHandler&quot;, new NettyProtocolHandler())&#x2F;&#x2F;设置编解码器                                .addLast(&quot;serverIdleHandler&quot;,                                        new IdleStateHandler(0, 0, serverIdleTimeInSeconds))&#x2F;&#x2F;设置心跳检测                                .addLast(&quot;serverHandler&quot;,new NettyServerStreamHandler(NettyTcpServer.this, false,                                        serverStreamLifecycleListeners,                                          serverStreamMessageListeners));&#x2F;&#x2F;设置业务处理逻辑                    &#125;                &#125;);</span><br><span class="line">        ChannelFuture channelFuture &#x3D; serverBootstrap.bind(9000).sync();        channelFuture.channel().closeFuture().sync();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>BIO和NIO编程在网络事件发生后都需要进行处理数据的粘包拆包、对完整的数据包进行解码、触发各种统计类事件、对响应消息进行编码、监听各种网络异常、需要对底层网络和通信协议有一定的了解。﻿</p>
<p>用Netty编程时只需要设置Handler就能快速的进行业务开发而不用关心数据的读取及网络事件的分发处理.让开发者从底层网络通信中解放出来。</p>
<p>从这些对比中我们可以看出Netty开发网络程序要求低，使用者无需太多关心和业务无关的信息。</p>
<p><strong>定制能力强</strong></p>
<p><strong>通过ChannelHandler灵活扩展</strong></p>
<p>多数情况下我们自定义的Handler会有多个，那么他们是怎么进行协调合作的呢？接下一起探索handler之间的协调合作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dSPBDsriaSyCRnSzWNxvdXt7mnxoSZvspbP5mBLq87byzGa2F5vN9IZyQ/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">﻿﻿</p>
<p>通过上图我们可以知道我们定义的handler在Netty里是通过双向链表进行关联的。﻿</p>
<p>介绍一下读网络事件发生后Handler事件流：</p>
<ul>
<li>假如每个handler都会把读事件向下一个InboundHandler类型的节点进行传递，此时的调用链路为head-&gt;A-&gt;B-&gt;C-&gt;tail；</li>
<li>假如B业务handler处理数据后不把读事件继续向下传递,此时B可以在自己内部选择不向下一个节点传递读事件.此时调用链路变为head-&gt;A-&gt;B；</li>
</ul>
<p>当服务端有数据需要写入时又会发生什么呢？</p>
<ul>
<li>假如每个handler都会把读事件向下一个OutboundHandler类型的节点进行传递,当C业务handler发送响应数据时此时调用链路为C-&gt;B-&gt;head；</li>
<li>假如业务B是参数校验的的headler,当校验失败就响应客户端.此时调用的链路为B-&gt;head﻿；</li>
</ul>
<p>我们可以看出Netty通过控制InboundHandler节点的调用来决定读事件响应链路；通过控制OutboundHandler节点的调用来决定写事件调用链路。</p>
<p><strong>Handler强大</strong></p>
<p>Netty通过内置多种Handler让你在不了解底层网络、通信协议、编解码的背景下也可进行网络应用程序。它都内置有哪些Handler呢？</p>
<h3 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h3><p>当你通过Netty发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码，从字节转换为另一种格式（比如java对象）。如果是出站消息，它会被编码成字节。</p>
<h4 id="TCP粘包拆包"><a href="#TCP粘包拆包" class="headerlink" title="TCP粘包拆包"></a><strong>TCP粘包拆包</strong></h4><p>大多数基于Netty通信底层都会使用TCP进行的通信。TCP在发送数据流的时一定会把整条数据流单独发送吗？答案是否定的。TCP在发送数据包的时会存在拆包和粘包问题。什么是TCP的粘包和拆包呢？</p>
<p><strong>TCP拆包:</strong> 产生的原因就是消息体太大了,一个数据包里只能发送消息体的一部分；</p>
<p><strong>TCP粘包:</strong> 产生的原因就是有多条消息体需要发送,一个数据包可以存放多个消息体；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS4WVoHfAiaHuiaKicXmq9lhADmwAek4OXvYd4H5X5eqZvRXicCZgiadKUic9Q/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>由于篇幅有限关于TCP拆包和粘包只是大致说明了一些。</p>
<h4 id="编解码Handler"><a href="#编解码Handler" class="headerlink" title="编解码Handler"></a><strong>编解码Handler</strong></h4><p>Netty提供了三种解码器来解决TCP的拆包和粘包,他们分别是：</p>
<ul>
<li>LineBasedFrameDecoder(回车换行分包);</li>
<li>DelimiterBasedFrameDecoder(特殊分隔符分包);</li>
<li>FixedLengthFrameDecoder(固定长度报文来分包)</li>
</ul>
<p>此外Netty还提供了N：</p>
<ul>
<li>编解码字符串的StringEncoder和StringDecoder;</li>
<li>用于处理HTTP协议编解码HttpObjectDecoder和HttpObjectEncoder;</li>
<li>用于处理protobuf编解码ProtobufVarint32FrameDecoder和ProtobufDecoder；</li>
</ul>
<p>除了以上介绍的编解码Netty内部还有很多内置编解码器,当您使用Netty开发时如果有用到编解码的时候可以首先查询一下Netty内部是否有实现。</p>
<h3 id="支持多种主流协议"><a href="#支持多种主流协议" class="headerlink" title="支持多种主流协议"></a>支持多种主流协议</h3><p>从Netty源码包上可以看出Netty基本上覆盖了主流协议的编解码实现，如HTTP、Protobuf、WebSocket、二进制等主流协议。</p>
<h4 id=""><a href="#" class="headerlink" title="﻿﻿"></a>﻿﻿<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS0AOkj10sEic1TOgOU3Nz3OibVExRDnHl1Gc5PqH7Qic7s4qukyA1y1ibFg/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></h4><h3 id="idle-心跳检测"><a href="#idle-心跳检测" class="headerlink" title="idle(心跳检测)"></a>idle(心跳检测)</h3><p>当需要监听网络连接是否长时间没有数据交换（如发送心跳包、关闭连接等）就可以使用内置的IdleStateHandler。</p>
<p>IdleStateHandler接收三个参数：</p>
<ul>
<li>readerIdleTimeSeconds: 读取空闲时间，即从上次读取数据到现在的秒数。</li>
<li>writerIdleTimeSeconds: 写入空闲时间，即从上次写入数据到现在的秒数。</li>
<li>allIdleTimeSeconds: 读写都空闲的时间，即从上次读写数据到现在的秒数。</li>
</ul>
<p>当达到设定的空闲时间阈值时，IdleStateHandler会触发对应的IdleState事件，这些事件包括READ_IDLE、WRITE_IDLE和ALL_IDLE。你可以通过实现ChannelInboundHandler的channelIdle方法来监听这些事件，并在事件发生时执行相应的操作。</p>
<p><strong>高性能</strong></p>
<h3 id="一次网络通信都发生了什么"><a href="#一次网络通信都发生了什么" class="headerlink" title="一次网络通信都发生了什么"></a>一次网络通信都发生了什么</h3><p>1.客户端确定需要发送的数据；</p>
<p>2.数据从程序到系统然后通过网卡发送；</p>
<p>3.服务端收到读事件后把数据从系统读取到应用中；</p>
<p>4.应用处理客户端信息；</p>
<h3 id="Netty怎么提高通信性能"><a href="#Netty怎么提高通信性能" class="headerlink" title="Netty怎么提高通信性能"></a>Netty怎么提高通信性能</h3><ul>
<li>数据在系统中的存储Netty使用<strong>ByteBuf</strong>内存池来减少申请内存耗时；</li>
<li>数据在用户态到内核态的传输Netty采用了<strong>内存零拷贝</strong>（减少用户态到内核态的两次拷贝）来<strong>减少传输耗时；</strong></li>
</ul>
<p><strong><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dSQbtEAPTNMt5GICMyCvgGicuicHXZB4Htm75JHFaKs5xNgWE6JolgIGrQ/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></strong></p>
<ul>
<li>﻿﻿数据在网络中的传输  数据传输时间取决于数据传输速度、数据包数量。对于传输速度无法优化，Netty内置了许多<strong>编码器</strong>，可以选择对数据压缩比较好的解码器来减少数据包的数量，以此来减少耗时；</li>
<li>服务端对网络事件的处理Netty采用主次<strong>Reactor多线程模型来加快对网络事件的处理</strong>，传统的BIO不能支持太多网络连接以及对系统资源使用率比较低。传统的NIO当网络连接数超多时网络事件得不到快速响应,造成大量客户端进行重试。</li>
</ul>
<p>﻿﻿<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dSzWEibh5E65kPBoibdTKprwakA6RRX2DVyVZHqkMK1vFLC7pQHPeNzN1g/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><strong>reactor单线程模型：</strong> 有一个线程负责处理所有的网络事件。</p>
<p>﻿<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS1cl44RlPrA4W4061kHgS4FYgfJ3dHnnIjJOt1lHthlnUic4Wjz8rlow/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><strong>Reactor多线程模型：</strong>有一个线程单独处理建立网络事件，另外一个线程负责处理其他的网络事件。</p>
<p>﻿﻿<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dSZFCLWyVgA4OVRlBGy6BuyQM6ON49RQNWdH8bQ1FEr7icFnseLYOqiabg/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>主次<strong>Reactor多线程模型：</strong>有一个线程单独处理建立网络事件,把建立网络连接放到线程池中的某一个线程中，这个线程负责大量网络连接的其他请求.</p>
<p>从reactor线程模型上我们可以看出主次Reactor多线程模型可以快速对大量的网络事件进行响应,因此也会缩短网络事件处理时间.</p>
<ul>
<li>客户端消息处理上，Netty采用了无锁串行化设计思想结合volatile的大量使用;通过读写锁提升并发性能来大大缩短了消息处理时间。</li>
</ul>
<p>我们可以看到Netty针对网络传输的各个节点都做到了尽可能的缩短时间，这也是Netty高性能的原因所在。</p>
<p>Netty运行原理</p>
<p>通过以上对Netty是什么，优势有哪些已经有了初步了解。那么它内部是怎么工作的呢？接下来让我们一起看一下它内部的原理。</p>
<p><strong>整体结构</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS2zydhafxsdJySlGIC2LncGBcxCz9ibliaso4lIrr8KRmwzZJBjAuiaic4w/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>上面这张图就是在官网首页的架构图，我们从上到下分析一下。</p>
<ul>
<li><strong>Core</strong>核心层：核心层里Netty最精华的部分，它提供了底层网络通信的通用抽象和实现，包括事件模型、通用API、支持零拷贝的ByteBuf 等；</li>
<li><strong>Protocol Support 协议支持层</strong>：协议支持层基本上覆盖了主流协议的编解码实现，Netty 丰富的协议支持降低了用户的开发成本；</li>
<li><strong>Transport Service 传输服务层：</strong>传输服务层提供了网络传输能力的定义和实现方法。它支持 Socket、HTTP 隧道等传输方式。Netty 对 TCP、UDP 等数据传输做了抽象和封装，让开发者可以更聚焦在业务逻辑实现上，而不必关系底层数据传输的细节；</li>
</ul>
<p>以上可看出Netty的功能、协议、传输方式都比较全，比较强大。</p>
<p><strong>逻辑架构</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS72UajWyyFsVEePGL9BWFY9otrysdlXUNbhaRUJFF3mb3CCVfVgHgWA/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>从图中可以Netty通过网络通信层、事件调度层、服务编排层协调合作来运行程序</p>
<h3 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h3><p>网络通信层的职责是执行网络 I/O 的操作。当网络数据读取到内核缓冲区后，会触发各种网络事件。这些网络事件会分发给事件调度层进行处理。接下来分别看一下Netty服务端和客户端在网络通信层是怎么运行的：</p>
<ul>
<li>Netty服务端：程序启动时会生成一个ServerBootstrap对象，该对象会生成一个NioServerSocketChannel来监听某一个端口的建立网络连接的事件，当网络连接建立后会监听网络连接的各种事件并通知到事件调度层。</li>
<li>﻿Netty客户端：程序启动的时会生成一个Bootstrap对象，该对象会生成一个NioSocketChannel来与服务端建立网络连接的事件，当网络连接建立后会监听网络连接的各种事件并通知到事件调度层。</li>
</ul>
<h3 id="事件调度层"><a href="#事件调度层" class="headerlink" title="事件调度层"></a>事件调度层</h3><p>事件调度层的职责是通过 Reactor 线程模型对各类事件进行聚合处理，通过 Selector 主循环线程集成多种事件(I/O 事件,信号事件,定时事件等)，实际的业务处理逻辑是交由服务编排层中相关的 Handler 完成。事件调度层主要由EventLoopGroup和EventLoop构成。﻿</p>
<ul>
<li>EventLoop 负责处理 I/O 事件和调度任务。每一个NioEventLoop内部都有唯一一个Selector，通过这个Selector可以对注册的channel进行网络事件的读取；NioEventLoop 还有一个内部的任务队列，可以用来提交 Runnable 任务。这些任务会在 NioEventLoop 的线程上下文中执行，确保了任务的顺序执行。</li>
<li>EventLoopGroup  本质是一个线程池，负责管理EventLoop。其主要作用有从线程池挑选一个EventLoop进行channe的注册或者提交一个任务、关闭不再使用的 Channel、释放 Selector 和其他相关资源确保应用程序的干净退出。</li>
</ul>
<h3 id="服务编排层"><a href="#服务编排层" class="headerlink" title="服务编排层"></a>服务编排层</h3><p>服务编排层的职责是通过组装各类handler来实现网络数据流的处理。它是 Netty 的核心处理链，用以实现网络事件的动态编排和有序传播。</p>
<p>服务编排层的核心组件包括 <strong>ChannelHandler、ChannelHandlerContext、ChannelPipeline</strong>。他们之间的关系如下图所示：</p>
<p>﻿﻿<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS3EkyiaKtmgjichNyttyDSG1OtHFibic2DKmKI1ibfP1FgJtGiba9cXzxibdgg/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li><p>﻿<strong>ChannelHandler</strong>主要分为两类，InboundHandler和OutboundHandler</p>
</li>
<li><p>InboundHandler用于处理从网络流入(inbound)的数据和事件。帮助我们处理接收的数据、连接建立、断开等事件。核心方法有channelActive(网络连接建立成功时会调用)、channelInactive(网络连接断连时调用)、channelRead(接受到数据时调用)、exceptionCaught(如果在处理事件或数据时发生异常，该方法会被调用。可以在这里捕获并处理异常，防止应用程序崩溃。)</p>
</li>
<li><p>OutboundHandler用于处理从应用程序流向网络的出站(outbound)操作,如写入数据,发起连接,关闭连接等核心方法有。</p>
<p>write(写入数据到channel时调用),flush(将缓冲区所有未写入数据立即发送出去),connect(尝试建立网络连接时调用)。</p>
</li>
<li><p>﻿<strong>ChannelHandlerContext</strong>是handler与Netty内部机制交互的主要方式，它使得 handler 可以在不直接访问其他handler的情况下，协同处理I/O事件和数据。同时也是每个ChannelHandler在处理事件时的上下文环境，可以获取到Pipeline、Channel、Allocator等对象。</p>
</li>
<li><p>﻿<strong>ChannelPipeline  Netty</strong>中的关键组件，是一个处理网络I/O事件和数据的有序链表。ChannelPipeline负责将入站（inbound）和出站（outbound）事件分发给链中的各个ChannelHandler，实现了事件驱动的网络编程模型。每个ChannelHandler都有一个唯一的ChannelHandlerContext，用于与ChannelPipeline交互。</p>
</li>
</ul>
<p><strong>运行流程</strong></p>
<p>我们已经从宏观上了解了Netty，接下来我们从服务端的视角简要的看一下Netty整个的运行流程。</p>
<p>1.服务端启动的时把ServerSocketChannel注册到boss EventLoopGroup中某一个EventLoop上，暂时把这个EventLoop叫做server EventLoop；</p>
<p>2.当 serverEventLoop中监听到有建立网络连接的事件后会把底层的SocketChannel和serverSocketChannel封装成为NioSocketChannel；</p>
<p>3.开始把自定义的ChannelHandler加载到NioSocketChannel 里的pipeline中，然后把该NioSocketChannel注册到worker EventLoopGroup中某一个EventLoop上，暂时把这个EventLoop叫做worker  EventLoop；</p>
<p>4.worker  EventLoop开始监听NioSocketChannel上所有网络事件；</p>
<p>5.当有读事件后就会调用pipeline中第一个InboundHandler的channelRead方法进行处理；</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li>Nettry入门：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/52iS3RxIO_to29IG_JoOpw">https://mp.weixin.qq.com/s/52iS3RxIO_to29IG_JoOpw</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-05-tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-05-tomcat/" class="post-title-link" itemprop="url">springboot-starter-05-tomcat</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-13 23:28:38 / Modified: 23:37:09" itemprop="dateCreated datePublished" datetime="2021-06-13T23:28:38+08:00">2021-06-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Spring-Boot是如何创建Tomcat的"><a href="#Spring-Boot是如何创建Tomcat的" class="headerlink" title="Spring Boot是如何创建Tomcat的"></a>Spring Boot是如何创建Tomcat的</h3><p>SpringBoot启动只有一个main方法的入口，只需要运行main方法就能把web项目部署到tomcat容器中，在main方法中，tomcat到底是如何启动的（本文基于SpringBoot 2.2.2.RELEASE） 我们从SpringBoot的main方法一路进去，就会进入到以下的run方法<img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-01.png" alt="img"></p>
<p>当Spring的环境和参数初始化设置好以后，创建ConfigurableApplicationContext成功后会调用refreshContext()方法来刷新上下文  <!--又是ApplicationContext的refresh()方法，果然是重中之重啊--><img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-02.png" alt="img"></p>
<p>发现里面还是继续调用了 onRefresh() 方法，我们进一步找到它的实现类 ServletWebServerApplicationContext，</p>
<p><img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-03.png" alt="img"></p>
<p>发现这里有一行代码：createWebServer();</p>
<p>很明显是创建Web服务器的意思，点进去查看<img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-04.png" alt="img"></p>
<p>我们来分析一下这一小段代码，如果webServer 和 serverletContext不存在，则从工厂中创建webServer</p>
<p>下面看一下webServer的创建过程，发现该方法有几个实现类，有TomcatServerlet、JettyServerlet、UndertowServlet，这里我们看一下Tomcat的实现<img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-05.png" alt="img"></p>
<p>Tomcat其实就是通过new出来的一个对象而已，然后给Tomcat进行一些参数的设置，启动Tomcat容器设置监听等待连接</p>
<h3 id="内嵌Tomcat的启动"><a href="#内嵌Tomcat的启动" class="headerlink" title="内嵌Tomcat的启动"></a>内嵌Tomcat的启动</h3><p>我们回到之前的onRefresh入口，容器刷新后，有一个完成刷新的finishRefresh()操作，这里就是容器启动的入口，如下图<img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-06.png" alt="img"></p>
<p>我们发现Tomcat里面也有这个完成刷新的finishRefresh()方法<img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-06.png" alt="img"></p>
<h3 id="手写main方法创建并启动Tomcat容器"><a href="#手写main方法创建并启动Tomcat容器" class="headerlink" title="手写main方法创建并启动Tomcat容器"></a>手写main方法创建并启动Tomcat容器</h3><p>SpringBoot也是通过new来创建Tomcat容器的，那么就意味着，我们可以不使用SpringBoot的run方法来启动web项目，我们自己也可以手写一个main方法来启动web项目，下面我们就来实现一下这个过程。</p>
<p>首先我们想一下，我们如果需要部署一个web项目，我们需要哪些操作：</p>
<ol>
<li>初始化Spring容器</li>
<li>扫描实例化Bean</li>
<li>配置DispatchServerlet，其实容器默认只有一个serverlet，就是DispatchServerlet，默认是 / ，自己写得Controller都是由DispatchServerlet进行分发的</li>
<li>使用main方法启动</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/07/database/Mybatis/mybatis-%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/07/database/Mybatis/mybatis-%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">mybatis-方法不能重载的原因</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-07 18:28:59 / Modified: 18:43:04" itemprop="dateCreated datePublished" datetime="2021-06-07T18:28:59+08:00">2021-06-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么不能重载？"><a href="#为什么不能重载？" class="headerlink" title="为什么不能重载？"></a>为什么不能重载？</h2><ul>
<li>Springboot与Mybatis会有一个启动器的自动配置类<code>MybatisAutoConfiguration</code>，其中有一段代码就是创建<code>sqlSessionFactory</code>，如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzIucG5n.jpg" alt="img"></li>
<li>既然是创建失败，那么肯定是这里出现异常了，这里的<strong>「大致思路」</strong>就是：</li>
</ul>
<blockquote>
<p>❝</p>
<p>解析<code>XML</code>文件和<code>Mapper</code>接口，将Mapper中的方法与XML文件中<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>等标签一一对应，那么Mapper中的方法如何与XML中<code>&lt;select&gt;</code>这些标签对应了，当然是唯一的<code>id</code>对应了，具体如何这个<code>id</code>的值是什么，如何对应？下面一一讲解。</p>
<p>❞</p>
</blockquote>
<ul>
<li>如上图的<code>SqlSessionFactory</code>的创建过程中，前面的部分代码都是设置一些配置，并没有涉及到解析XML的内容，因此答案肯定是在最后一行<code>return factory.getObject();</code>，于是此处打上断点，一点点看。于是一直到了<code>org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory</code>这个方法中，其中一段代码如下：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzMucG5n.jpg" alt="img"></li>
<li>略过不重要的代码，在<code>org.apache.ibatis.builder.xml.XMLMapperBuilder#configurationElement</code>这个方法中有一行重要的代码，如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzQucG5n.jpg" alt="img"></li>
<li>到<code>org.apache.ibatis.builder.MapperBuilderAssistant#addMappedStatement</code>这个方法返回值就是<code>MappedStatement</code>，不用多说，肯定是这个方法了，仔细一看，很清楚的看到了构建<code>id</code>的代码，如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzUucG5n.jpg" alt="img"></li>
<li>从上图可以知道，创建<code>id</code>的代码就是<code>id = applyCurrentNamespace(id, false);</code>，具体实现如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzYucG5n.jpg" alt="img"></li>
</ul>
<blockquote>
<p>❝</p>
<p>上图的代码已经很清楚了，<code>MappedStatement</code>中的<code>id=Mapper的全类名+&#39;.&#39;+方法名</code>。如果重载话，肯定会存在<code>id</code>相同的<code>MappedStatement</code>。</p>
<p>❞</p>
</blockquote>
<ul>
<li>到了这其实并不能说明方法不能重载啊，重复就重复呗，并没有冲突啊。这里需要看一个结构，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final Map&lt;String, MappedStatement&gt; mappedStatements &#x3D; new StrictMap&lt;MappedStatement&gt;(&quot;Mapped Statements collection&quot;)</span><br><span class="line">      .conflictMessageProducer((savedValue, targetValue) -&gt;</span><br><span class="line">          &quot;. please check &quot; + savedValue.getResource() + &quot; and &quot; + targetValue.getResource());</span><br></pre></td></tr></table></figure>

<ul>
<li>构建好的<code>MappedStatement</code>都会存入<code>mappedStatements</code>中，如下代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void addMappedStatement(MappedStatement ms) &#123;</span><br><span class="line">    &#x2F;&#x2F;key 是id</span><br><span class="line">    mappedStatements.put(ms.getId(), ms);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>StrictMap</code>的<code>put(k,v)</code>方法如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzcucG5n.jpg" alt="img"></li>
</ul>
<h2 id="如何找到XML中对应的SQL？"><a href="#如何找到XML中对应的SQL？" class="headerlink" title="如何找到XML中对应的SQL？"></a>如何找到XML中对应的SQL？</h2><ul>
<li>在使用Mybatis的时候只是简单的调用Mapper中的方法就可以执行SQL，如下代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserInfo&gt; userInfos &#x3D; userMapper.selectList(Arrays.asList(&quot;192&quot;,&quot;198&quot;));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一行简单的调用到底如何找到对应的SQL呢？其实就是根据<code>id</code>从<code>Map&lt;String, MappedStatement&gt; mappedStatements</code>中查找对应的<code>MappedStatement</code>。</p>
</blockquote>
<ul>
<li>在<code>org.apache.ibatis.session.defaults.DefaultSqlSession#selectList</code>方法有这一行代码如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzgucG5n.jpg" alt="img"></li>
<li><code>MappedStatement ms = configuration.getMappedStatement(statement);</code>这行代码就是根据<code>id</code>从<code>mappedStatements</code>获取对应的<code>MappedStatement</code>，源码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public MappedStatement getMappedStatement(String id) &#123;</span><br><span class="line">    return this.getMappedStatement(id, true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%B9%82%E7%AD%89%E6%80%A7-02-%E7%8A%B6%E6%80%81%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%B9%82%E7%AD%89%E6%80%A7-02-%E7%8A%B6%E6%80%81%E6%9C%BA/" class="post-title-link" itemprop="url">幂等性-02-状态机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-02 14:51:01" itemprop="dateCreated datePublished" datetime="2021-06-02T14:51:01+08:00">2021-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>状态机幂等</strong></p>
<p>在支付场景中，创建了一个支付订单，发起了一个支付请求，这个订单不论多少次重复请求，都应该保证最多只扣款一次。即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相同支付订单ID（幂等条件） —&gt; 最多一次扣款（期望结果）</span><br></pre></td></tr></table></figure>

<p>为了实现这个目标，可以考虑使用有限状态机。</p>
<p>有限状态机(Finite-state machine FSM)，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。用于处理复杂的状态转换。</p>
<p>在这个支付的例子中，为了化简，不考虑退款、取消订单等复杂的状态，只考虑未支付和已支付两种状态之间的转换。</p>
<p><img src="https://img.toutiao.io/c/f217e1df139ab9e614398a401c624131" alt="img"></p>
<p>由上面的状态转换图可以看到，相同支付订单ID从未支付状态，要不就是支付不成功停留在未支付状态，要不就是支付成功，状态转移为已支付。此状态转移过程不可逆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public enum OrderStateEnum &#123;</span><br><span class="line">    UNPAID &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public OrderStateEnum changeState() &#123;</span><br><span class="line">            if (doPay()) &#123;</span><br><span class="line">                return PAID;</span><br><span class="line">            &#125;</span><br><span class="line">            return UNPAID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    PAID &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public OrderStateEnum changeState() &#123;</span><br><span class="line">            return PAID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    public abstract OrderStateEnum changeState();</span><br><span class="line">    public boolean doPay() &#123;</span><br><span class="line">        &#x2F;&#x2F;这里是逻辑伪代码,可以是发起下游调用请求支付通道等</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个java版本的简单状态机实现。状态机里定义了一个未支付状态和其行为changeState。changeState又定义了一个未支付状态和其行为changeState。</p>
<p>利用状态机来实现这个幂等支付请求的设计流程图如下：</p>
<p><img src="https://img.toutiao.io/c/34edb771f6045f3df4f30baeda3bbd33" alt="img"></p>
<p>参考状态机实现和上图可知，相同支付ID的请求，支付状态只能进行一次从未支付到已支付的转换。从而保证了其幂等性。</p>
<p><strong>按目标幂等</strong></p>
<p>先来回答一个小学生的问题：</p>
<p>定了一个会议，参加人数为10人。发现会议室的椅子只有5把。3个提前来到会议室的同学热心的去其他地方搬椅子进来。问：每人要搬几把椅子？</p>
<p>有人要说这不是把简单的问题复杂了吗？大家看到椅子不够就去搬，看够10把椅子了就不搬就可以了。对了，这其实是一个很好的解题思路，完全可以用在设计当中，就是按目标幂等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相同会议ID（幂等条件） —&gt; 总数10把椅子（期望结果）</span><br></pre></td></tr></table></figure>

<p>利用按目标幂等来实现这个总数10把椅子请求的设计流程图如下：</p>
<p><img src="https://img.toutiao.io/c/0f4b81ab2ae6e759c2403c476ff07a17" alt="img"></p>
<p>采用按目标的设计，相同会议ID，不管多少次请求，请求椅子的总数就是10把。多次请求不改变行为，从而实现了幂等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%8B%93%E5%B1%95%E7%82%B9-BeanPostProcessor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%8B%93%E5%B1%95%E7%82%B9-BeanPostProcessor/" class="post-title-link" itemprop="url">spring-07-BeanPostProcessor</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-02 11:31:13" itemprop="dateCreated datePublished" datetime="2021-06-02T11:31:13+08:00">2021-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-02 14:01:38" itemprop="dateModified" datetime="2023-02-02T14:01:38+08:00">2023-02-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>Spring</strong>的<code>BeanPostProcessor</code>后置处理器承担了很多工作</p>
<ul>
<li>AOP、代理</li>
<li>构造方法注入的构造方法推断，构造方法上使用<code>@Autowired</code>等注解时</li>
<li>循环依赖，提前暴露未完成的Bean</li>
<li>依赖注入，<code>@Resource</code>、<code>@Autowired</code>、<code>@Value</code>等，不同注解依赖不同的后置处理器</li>
<li>动态注入</li>
<li>执行<code>Aware</code>回调</li>
<li><code>@Import</code>注解，通过<code>ImportAwareBeanPostProcessor</code>将<code>@Import</code>修饰的注解注入到<code>@Import</code>指定的类中</li>
<li>初始化和销毁方法，<code>@PostConsturct</code>、<code>@PreDestroy</code>后置处理完成</li>
<li><code>ApplicationListener</code>的监听等</li>
</ul>
<h2 id="相关BeanPostProcessor"><a href="#相关BeanPostProcessor" class="headerlink" title="相关BeanPostProcessor"></a>相关BeanPostProcessor</h2><p><img src="https://images.effiu.cn/blog/spring/BeanPostProcessor.png" alt=" "></p>
<p>在<strong>Spring Boot</strong>中<strong>Spring framework</strong>相关<strong>BeanPostProcesso</strong>如下:</p>
<ol>
<li>ApplicationContextAwareProcessor</li>
<li>ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor</li>
<li>PostProcessorRegistrationDelegate.BeanPostProcessorChecker</li>
<li>CommonAnnotationBeanPostProcessor</li>
<li>AutowiredAnnotationBeanPostProcessor</li>
<li>ApplicationListenerDetector</li>
</ol>
<blockquote>
<p>忽略Spring MVC、Spring Boot、Spring Cloud相关BeanPostProcessor，例如:Spring Boot的<code>ConfigurationPropertiesBindingPostProcessor</code>,Spring Cloud的<code>ConfigurationPropertiesBeans</code>等等。</p>
</blockquote>
<p>上述6个后置处理器相关接口以及发挥作用的方法(标红的):</p>
<p><img src="https://images.effiu.cn/blog/spring/BeanPostProcessor_class.jpg" alt="BeanPostProcessor类图"></p>
<blockquote>
<p>上述标红的为真正执行的类,类中的成员仅仅是一些重要的<strong>field</strong>和方法，即在获取Bean过程中执行后置处理器相关的方法。</p>
</blockquote>
<h2 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h2><blockquote>
<p><strong>BeanPostProcessor</strong>在<code>org.springframework.context.support.AbstractApplicationContext#refresh</code>中的<code>obtainFreshBeanFactory()</code>和<code>registerBeanPostProcessors()</code>方法中注册的</p>
</blockquote>
<p><code>org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory</code>加载了<code>ApplicationContextAwareProcessor</code>和<code>ApplicationListenerDetector</code>两个后置处理器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">    &#x2F;&#x2F; Tell the internal bean factory to use the context&#39;s class loader etc.</span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 第一个BeanPostProcessor:ApplicationContextAwareProcessor</span><br><span class="line">    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line">    &#x2F;&#x2F; 配置自动注入忽略的接口，需要以其他的方式完成相关Bean的引用,例如实现ApplicationContextAware接口完成引用</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 自动装配时指定实现类(一个接口有多个实现类的情况),作用类似于@Primary注解</span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Register early post-processor for detecting inner beans as ApplicationListeners.</span><br><span class="line">    &#x2F;&#x2F; 第二个BeanPostProcessor</span><br><span class="line">	&#x2F;&#x2F; ApplicationListenerDetector用于将ApplicationListener子类Bean放入到&#123;@link applicationListeners&#125; 集合中</span><br><span class="line">    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...省略</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Register default environment beans. 三个Bean，environment、systemProperties、systemEnvironment, 可以直接通过@Autowried等注解使用</span><br><span class="line">    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors</code>通过调用<code>ConfigurationClassPostProcessor#postProcessBeanFactory()</code>方法注册了<code>ImportAwareBeanPostProcessor</code>后置处理器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ConfigurationClassPostProcessor部分源码</span><br><span class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">    int factoryId &#x3D; System.identityHashCode(beanFactory);</span><br><span class="line">    if (this.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">        throw new IllegalStateException(</span><br><span class="line">        &quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    this.factoriesPostProcessed.add(factoryId);</span><br><span class="line">    if (!this.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">        &#x2F;&#x2F; BeanDefinitionRegistryPostProcessor hook apparently not supported...</span><br><span class="line">        &#x2F;&#x2F; Simply call processConfigurationClasses lazily at this point then.</span><br><span class="line">        processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enhanceConfigurationClasses(beanFactory);</span><br><span class="line">    beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#registerBeanPostProcessors&#96;注册了&#96;BeanPostProcessorChecker&#96;、&#96;AutowiredAnnotationBeanPostProcessor&#96;、&#96;CommonAnnotationBeanPostProcessor&#96;、以及重新注册了&#96;ApplicationListenerDetector</span><br><span class="line">public static void registerBeanPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line">    &#x2F;&#x2F; 遍历beanDefinitionNames获取BeanPostProcessorNames</span><br><span class="line">    String[] postProcessorNames &#x3D; beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line">    int beanProcessorTargetCount &#x3D; beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">    &#x2F;&#x2F; BeanPostProcessorChecker用于当在BeanPostProcessor实例化期间创建Bean时，当某个Bean不适合所有BeanPostProcessor时，记录信息. BeanPostProcessorChecker内部会比较beanProcessorTargetCount与beanFactory.getBeanPostProcessorCount()</span><br><span class="line">    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">    &#x2F;&#x2F; Separate between BeanPostProcessors that implement PriorityOrdered,</span><br><span class="line">    &#x2F;&#x2F; Ordered, and the rest.</span><br><span class="line">    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;BeanPostProcessor&gt; internalPostProcessors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (String ppName : postProcessorNames) &#123;</span><br><span class="line">        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            BeanPostProcessor pp &#x3D; beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            &#x2F;&#x2F; CommonAnnotationBeanPostProcessor、AutowiredAnnotationBeanPostProcessor两个BeanPostProcessor</span><br><span class="line">            priorityOrderedPostProcessors.add(pp);</span><br><span class="line">            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; First, register the BeanPostProcessors that implement PriorityOrdered.</span><br><span class="line">    &#x2F;&#x2F; 注册实现PriorityOrdered的BeanPostProcessors</span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Next, register the BeanPostProcessors that implement Ordered.</span><br><span class="line">    &#x2F;&#x2F; 注册实现Ordered的BeanPostProcessors</span><br><span class="line">    List&lt;BeanPostProcessor&gt; orderedPostProcessors &#x3D; new ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    for (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp &#x3D; beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        orderedPostProcessors.add(pp);</span><br><span class="line">        if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Now, register all regular BeanPostProcessors.</span><br><span class="line">    &#x2F;&#x2F; 注册所有常规的BeanPostProcessors</span><br><span class="line">    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors &#x3D; new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    for (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp &#x3D; beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        nonOrderedPostProcessors.add(pp);</span><br><span class="line">        if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Finally, re-register all internal BeanPostProcessors.</span><br><span class="line">    &#x2F;&#x2F; 最后重新注册所有内部BeanPostProcessor</span><br><span class="line">    sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Re-register post-processor for detecting inner beans as ApplicationListeners,</span><br><span class="line">    &#x2F;&#x2F; moving it to the end of the processor chain (for picking up proxies etc).</span><br><span class="line">    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanPostProcessor作用"><a href="#BeanPostProcessor作用" class="headerlink" title="BeanPostProcessor作用"></a>BeanPostProcessor作用</h2><p>排序后的BeanPostProcessor顺序为:</p>
<ol>
<li>ApplicationContextAwareProcessor</li>
<li>ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor</li>
<li>PostProcessorRegistrationDelegate.BeanPostProcessorChecker</li>
<li>CommonAnnotationBeanPostProcessor</li>
<li>AutowiredAnnotationBeanPostProcessor</li>
<li>ApplicationListenerDetector</li>
</ol>
<h3 id="ApplicationContextAwareProcessor"><a href="#ApplicationContextAwareProcessor" class="headerlink" title="ApplicationContextAwareProcessor"></a>ApplicationContextAwareProcessor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||</span><br><span class="line">          bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||</span><br><span class="line">          bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware))&#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AccessControlContext acc &#x3D; null;</span><br><span class="line"></span><br><span class="line">    if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">        acc &#x3D; this.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (acc !&#x3D; null) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareInterfaces(bean);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;, acc);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        invokeAwareInterfaces(bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">    if (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">        ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof EmbeddedValueResolverAware) &#123;</span><br><span class="line">        ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof ResourceLoaderAware) &#123;</span><br><span class="line">        ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">        ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof MessageSourceAware) &#123;</span><br><span class="line">        ((MessageSourceAware) bean).setMessageSource(this.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">        ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationContextAwareProcessor</code>加载的是<code>EnvironmentAware</code>、<code>EmbeddedValueResolverAware</code>、<code>ResourceLoaderAware</code>、<code>ApplicationEventPublisherAware</code>、<code>MessageSourceAware</code>、<code>ApplicationContextAware</code>6个用于回调的Aware。</p>
<h3 id="ImportAwareBeanPostProcessor"><a href="#ImportAwareBeanPostProcessor" class="headerlink" title="ImportAwareBeanPostProcessor"></a>ImportAwareBeanPostProcessor</h3><blockquote>
<p>是<code>ConfigurationClassPostProcessor</code>的子类，在Spring容器启动过程中，由其父类完成注册</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static class ImportAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private final BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    public ImportAwareBeanPostProcessor(BeanFactory beanFactory) &#123;</span><br><span class="line">        this.beanFactory &#x3D; beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PropertyValues postProcessProperties(@Nullable PropertyValues pvs, Object bean, String beanName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在AutowiredAnnotationBeanPostProcessor的postProcessProperties方法注入Bean之前,注入BeanFactory,</span><br><span class="line">        if (bean instanceof EnhancedConfiguration) &#123;</span><br><span class="line">            ((EnhancedConfiguration) bean).setBeanFactory(this.beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        return pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 若该bean是ImportAware, 则将@Import注解的类</span><br><span class="line">        &#x2F;&#x2F; (支持@Configuration、@Component,实现ImportSelector、ImportBeanDefinitionRegistrar接口的实现类)</span><br><span class="line">        &#x2F;&#x2F; 通过ImportAware的setImportMetadata将该注解注入到@Import指定类中</span><br><span class="line">        if (bean instanceof ImportAware) &#123;</span><br><span class="line">            ImportRegistry ir &#x3D; this.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);</span><br><span class="line">            AnnotationMetadata importingClass &#x3D; ir.getImportingClassFor(ClassUtils.getUserClass(bean).getName());</span><br><span class="line">            if (importingClass !&#x3D; null) &#123;</span><br><span class="line">                ((ImportAware) bean).setImportMetadata(importingClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanPostProcessorChecker"><a href="#BeanPostProcessorChecker" class="headerlink" title="BeanPostProcessorChecker"></a>BeanPostProcessorChecker</h3><blockquote>
<p>没有实际逻辑，只是用于在BeanPostProcessor实例化期间创建Bean时记录日志。</p>
</blockquote>
<h3 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p><code>CommonAnnotationBeanPostProcessor</code>支持的注解,<code>@Resource</code>、<code>@EJB</code>、<code>@WebServiceRef</code>，其继承了<code>InitDestroyAnnotationBeanPostProcessor</code>，<code>InitDestroyAnnotationBeanPostProcessor</code>支持<code>@PostConstruct</code>和<code>@PreDestroy</code>注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">private static final Class&lt;? extends Annotation&gt; webServiceRefClass;</span><br><span class="line">@Nullable</span><br><span class="line">private static final Class&lt;? extends Annotation&gt; ejbClass;</span><br><span class="line">private static final Set&lt;Class&lt;? extends Annotation&gt;&gt; resourceAnnotationTypes &#x3D; new LinkedHashSet&lt;&gt;(4);</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    webServiceRefClass &#x3D; loadAnnotationType(&quot;javax.xml.ws.WebServiceRef&quot;);</span><br><span class="line">    ejbClass &#x3D; loadAnnotationType(&quot;javax.ejb.EJB&quot;);</span><br><span class="line">    &#x2F;&#x2F; 配置支持的注解</span><br><span class="line">    resourceAnnotationTypes.add(Resource.class);</span><br><span class="line">    if (webServiceRefClass !&#x3D; null) &#123;</span><br><span class="line">        resourceAnnotationTypes.add(webServiceRefClass);</span><br><span class="line">    &#125;</span><br><span class="line">    if (ejbClass !&#x3D; null) &#123;</span><br><span class="line">        resourceAnnotationTypes.add(ejbClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 将支持的注解解析为InjectionMetadata,放入到injectionMetadataCache</span><br><span class="line">@Override</span><br><span class="line">public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123;</span><br><span class="line">    super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);</span><br><span class="line">    InjectionMetadata metadata &#x3D; findResourceMetadata(beanName, beanType, null);</span><br><span class="line">    metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从injectionMetadataCache中取得InjectionMetadata，然后完成注入</span><br><span class="line">@Override</span><br><span class="line">public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) &#123;</span><br><span class="line">    InjectionMetadata metadata &#x3D; findResourceMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 属性注入</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(beanName, &quot;Injection of resource dependencies failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InjectionMetadata"><a href="#InjectionMetadata" class="headerlink" title="InjectionMetadata"></a>InjectionMetadata</h3><p><code>InjectionMetadata</code>要注入的数据元，<code>InjectElement</code>是其内部类。<code>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition</code>方法会将BeanPostProcessor支持的注解解析为<code>InjectionMetadata</code>，然后由<code>InstantiationAwareBeanPostProcessorAdapter.postProcessProperties</code>方法完成注入。</p>
<p><code>InjectionMetadata</code>部分源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 待注入的元素,field或者method</span><br><span class="line">private final Collection&lt;InjectedElement&gt; injectedElements;</span><br><span class="line"></span><br><span class="line">public abstract static class InjectedElement &#123;</span><br><span class="line">	protected final Member member;</span><br><span class="line">	protected final boolean isField;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; postProcessProperties中会调用该方法</span><br><span class="line">protected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)</span><br><span class="line">				throws Throwable &#123;</span><br><span class="line">    if (this.isField) &#123;</span><br><span class="line">        Field field &#x3D; (Field) this.member;</span><br><span class="line">        ReflectionUtils.makeAccessible(field);</span><br><span class="line">        field.set(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (checkPropertySkipping(pvs)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method &#x3D; (Method) this.member;</span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            method.invoke(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InvocationTargetException ex) &#123;</span><br><span class="line">            throw ex.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p><code>AutowiredAnnotationBeanPostProcessor</code>支持<code>@Autowired</code>、<code>@Value</code>、<code>@Inject</code>、<code>@Lookup</code>等注解</p>
<blockquote>
<p><code>AutowiredAnnotationBeanPostProcessor</code>会将支持的注解的field或者method解析为<code>InjectMetadata</code>，但是<code>AutowiredAnnotationBeanPostProcessor</code>内部自己实现了<code>InjectedElement</code>的子类<code>AutowiredFieldElement</code>和<code>AutowiredMethodElement</code>，分别用于属性注入和方法注入。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">public AutowiredAnnotationBeanPostProcessor() &#123;</span><br><span class="line">    &#x2F;&#x2F; 配置支持@Autowired、@Value以及JSR-330相关注解</span><br><span class="line">    this.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">    this.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">    try &#123;</span><br><span class="line">        this.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">                                          ClassUtils.forName(&quot;javax.inject.Inject&quot;, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException ex) &#123;</span><br><span class="line">        &#x2F;&#x2F; JSR-330 API not available - simply skip.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ··· 省略</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将支持的注解解析为InjectionMetadata(AutowiredFieldElement、AutowiredMethodElement)</span><br><span class="line">@Override</span><br><span class="line">public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123;</span><br><span class="line">    InjectionMetadata metadata &#x3D; findAutowiringMetadata(beanName, beanType, null);</span><br><span class="line">    metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, final String beanName)</span><br><span class="line">    throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Let&#39;s check for lookup methods here...</span><br><span class="line">    if (!this.lookupMethodsChecked.contains(beanName)) &#123;</span><br><span class="line">        if (AnnotationUtils.isCandidateClass(beanClass, Lookup.class)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class&lt;?&gt; targetClass &#x3D; beanClass;</span><br><span class="line">                do &#123;</span><br><span class="line">                    ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">                        Lookup lookup &#x3D; method.getAnnotation(Lookup.class);</span><br><span class="line">                        if (lookup !&#x3D; null) &#123;</span><br><span class="line">                            Assert.state(this.beanFactory !&#x3D; null, &quot;No BeanFactory available&quot;);</span><br><span class="line">                            LookupOverride override &#x3D; new LookupOverride(method, lookup.value());</span><br><span class="line">                            try &#123;</span><br><span class="line">                                RootBeanDefinition mbd &#x3D; (RootBeanDefinition)</span><br><span class="line">                                    this.beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">                                mbd.getMethodOverrides().addOverride(override);</span><br><span class="line">                            &#125;</span><br><span class="line">                            catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                                throw new BeanCreationException(beanName,</span><br><span class="line">                                                                &quot;Cannot apply @Lookup to beans without corresponding bean definition&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    targetClass &#x3D; targetClass.getSuperclass();</span><br><span class="line">                &#125;</span><br><span class="line">                while (targetClass !&#x3D; null &amp;&amp; targetClass !&#x3D; Object.class);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch (IllegalStateException ex) &#123;</span><br><span class="line">                throw new BeanCreationException(beanName, &quot;Lookup method resolution failed&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.lookupMethodsChecked.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Quick check on the concurrent map first, with minimal locking.</span><br><span class="line">    Constructor&lt;?&gt;[] candidateConstructors &#x3D; this.candidateConstructorsCache.get(beanClass);</span><br><span class="line">    if (candidateConstructors &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; Fully synchronized resolution now...</span><br><span class="line">        synchronized (this.candidateConstructorsCache) &#123;</span><br><span class="line">            candidateConstructors &#x3D; this.candidateConstructorsCache.get(beanClass);</span><br><span class="line">            if (candidateConstructors &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Constructor&lt;?&gt;[] rawCandidates;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取所有的构造方法</span><br><span class="line">                    rawCandidates &#x3D; beanClass.getDeclaredConstructors();</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Throwable ex) &#123;</span><br><span class="line">                    throw new BeanCreationException(beanName,</span><br><span class="line">                                                    &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +</span><br><span class="line">                                                    &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;Constructor&lt;?&gt;&gt; candidates &#x3D; new ArrayList&lt;&gt;(rawCandidates.length);</span><br><span class="line">                Constructor&lt;?&gt; requiredConstructor &#x3D; null;</span><br><span class="line">                Constructor&lt;?&gt; defaultConstructor &#x3D; null;</span><br><span class="line">                Constructor&lt;?&gt; primaryConstructor &#x3D; BeanUtils.findPrimaryConstructor(beanClass);</span><br><span class="line">                int nonSyntheticConstructors &#x3D; 0;</span><br><span class="line">                for (Constructor&lt;?&gt; candidate : rawCandidates) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 是否由编译器自己生成的构造方法</span><br><span class="line">                    if (!candidate.isSynthetic()) &#123;</span><br><span class="line">                        nonSyntheticConstructors++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (primaryConstructor !&#x3D; null) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 检查是否存在使用支持注解修饰的类构造方法</span><br><span class="line">                    MergedAnnotation&lt;?&gt; ann &#x3D; findAutowiredAnnotation(candidate);</span><br><span class="line">                    if (ann &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 检查父类构造方法是否存在支持的注解</span><br><span class="line">                        Class&lt;?&gt; userClass &#x3D; ClassUtils.getUserClass(beanClass);</span><br><span class="line">                        if (userClass !&#x3D; beanClass) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                Constructor&lt;?&gt; superCtor &#x3D;</span><br><span class="line">                                    userClass.getDeclaredConstructor(candidate.getParameterTypes());</span><br><span class="line">                                ann &#x3D; findAutowiredAnnotation(superCtor);</span><br><span class="line">                            &#125;</span><br><span class="line">                            catch (NoSuchMethodException ex) &#123;</span><br><span class="line">                                &#x2F;&#x2F; Simply proceed, no equivalent superclass constructor found...</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (ann !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 只能存在一个需要注入的构造方法，否则会抛出异常</span><br><span class="line">                        if (requiredConstructor !&#x3D; null) &#123;</span><br><span class="line">                            throw new BeanCreationException(beanName,</span><br><span class="line">                                                            &quot;Invalid autowire-marked constructor: &quot; + candidate +</span><br><span class="line">                                                            &quot;. Found constructor with &#39;required&#39; Autowired annotation already: &quot; +</span><br><span class="line">                                                            requiredConstructor);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 判断是否需要注入，若需要那么当不存在要注入的bean时会抛出异常</span><br><span class="line">                        boolean required &#x3D; determineRequiredStatus(ann);</span><br><span class="line">                        if (required) &#123;</span><br><span class="line">                            if (!candidates.isEmpty()) &#123;</span><br><span class="line">                                throw new BeanCreationException(beanName,</span><br><span class="line">                                                                &quot;Invalid autowire-marked constructors: &quot; + candidates +</span><br><span class="line">                                                                &quot;. Found constructor with &#39;required&#39; Autowired annotation: &quot; +</span><br><span class="line">                                                                candidate);</span><br><span class="line">                            &#125;</span><br><span class="line">                            requiredConstructor &#x3D; candidate;</span><br><span class="line">                        &#125;</span><br><span class="line">                        candidates.add(candidate);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (candidate.getParameterCount() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        defaultConstructor &#x3D; candidate;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!candidates.isEmpty()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Add default constructor to list of optional constructors, as fallback.</span><br><span class="line">                    if (requiredConstructor &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        if (defaultConstructor !&#x3D; null) &#123;</span><br><span class="line">                            candidates.add(defaultConstructor);</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (candidates.size() &#x3D;&#x3D; 1 &amp;&amp; logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(&quot;Inconsistent constructor declaration on bean with name &#39;&quot; + beanName +</span><br><span class="line">                                        &quot;&#39;: single autowire-marked constructor flagged as optional - &quot; +</span><br><span class="line">                                        &quot;this constructor is effectively required since there is no &quot; +</span><br><span class="line">                                        &quot;default constructor to fall back to: &quot; + candidates.get(0));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    candidateConstructors &#x3D; candidates.toArray(new Constructor&lt;?&gt;[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (rawCandidates.length &#x3D;&#x3D; 1 &amp;&amp; rawCandidates[0].getParameterCount() &gt; 0) &#123;</span><br><span class="line">                    candidateConstructors &#x3D; new Constructor&lt;?&gt;[] &#123;rawCandidates[0]&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (nonSyntheticConstructors &#x3D;&#x3D; 2 &amp;&amp; primaryConstructor !&#x3D; null &amp;&amp;</span><br><span class="line">                         defaultConstructor !&#x3D; null &amp;&amp; !primaryConstructor.equals(defaultConstructor)) &#123;</span><br><span class="line">                    candidateConstructors &#x3D; new Constructor&lt;?&gt;[] &#123;primaryConstructor, defaultConstructor&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (nonSyntheticConstructors &#x3D;&#x3D; 1 &amp;&amp; primaryConstructor !&#x3D; null) &#123;</span><br><span class="line">                    candidateConstructors &#x3D; new Constructor&lt;?&gt;[] &#123;primaryConstructor&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    candidateConstructors &#x3D; new Constructor&lt;?&gt;[0];</span><br><span class="line">                &#125;</span><br><span class="line">                this.candidateConstructorsCache.put(beanClass, candidateConstructors);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (candidateConstructors.length &gt; 0 ? candidateConstructors : null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从injectionMetadataCache中取出需要出入的原始数据完成注入</span><br><span class="line">@Override</span><br><span class="line">public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) &#123;</span><br><span class="line">    InjectionMetadata metadata &#x3D; findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    try &#123;</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (BeanCreationException ex) &#123;</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ApplicationListenerDetector"><a href="#ApplicationListenerDetector" class="headerlink" title="ApplicationListenerDetector"></a>ApplicationListenerDetector</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType,</span><br><span class="line">                                            String beanName) &#123;</span><br><span class="line">    &#x2F;&#x2F; 若Bean是ApplicationListener则将其放入到singletonNames内</span><br><span class="line">    &#x2F;&#x2F; 在postProcessAfterInitialization方法中，将ApplicationListener子类放入到ApplicationListeners集合中</span><br><span class="line">    if (ApplicationListener.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">        this.singletonNames.put(beanName, beanDefinition.isSingleton());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) &#123;</span><br><span class="line">    if (bean instanceof ApplicationListener) &#123;</span><br><span class="line">        &#x2F;&#x2F; potentially not detected as a listener by getBeanNamesForType retrieval</span><br><span class="line">        &#x2F;&#x2F; getBeanNamesForType可能不会将其判断为监听器,所以此处判断是否是ApplicationListener若是则将其加入到ApplicationListeners中</span><br><span class="line">        Boolean flag &#x3D; this.singletonNames.get(beanName);</span><br><span class="line">        if (Boolean.TRUE.equals(flag)) &#123;</span><br><span class="line">            &#x2F;&#x2F; singleton bean (top-level or inner): register on the fly</span><br><span class="line">            this.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">         &#125; else if (Boolean.FALSE.equals(flag)) &#123;</span><br><span class="line">                this.singletonNames.remove(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanPostProcessor的执行顺序"><a href="#BeanPostProcessor的执行顺序" class="headerlink" title="BeanPostProcessor的执行顺序"></a>BeanPostProcessor的执行顺序</h2><blockquote>
<p><code>BeanPostProcessor</code>在<strong>Bean</strong>的实例化过程中每个方法执行的顺序。上文已经指出在<strong>Bean</strong>的实例化过程中8次调用后置处理器的地方。</p>
</blockquote>
<h3 id="postProcessBeforeInstantiation"><a href="#postProcessBeforeInstantiation" class="headerlink" title="postProcessBeforeInstantiation"></a>postProcessBeforeInstantiation</h3><p>第一次调用后置处理器是<code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>，其会在目标对象被实例化之前调用，因为此时目标对象未被实例化，所以可以返回自定义对象，比如代理对象。</p>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code>是<code>InstantiationAwareBeanPostProcessor</code>的一个子类，所有使用<code>@AspectJ</code>注解修饰的类，都会被其自动识别，其实现了<code>BeanFactoryAware</code>接口，所有持有beanFactory对象，会在创建代理类后将<strong>targetClass</strong>赋给代理类。</p>
<blockquote>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code>与AOP相关，待后续研究</p>
</blockquote>
<h3 id="determineCandidateConstructors"><a href="#determineCandidateConstructors" class="headerlink" title="determineCandidateConstructors"></a>determineCandidateConstructors</h3><p>第二次调用后置处理器是<code>SmartInstantiationAwareBeanPostProcessor.determineCandidateConstructors</code>方法，主要是推断创建Bean的构造方法。具体见<a target="_blank" rel="noopener" href="https://www.effiu.cn/blog/2020/10/27/spring/3_beanPostProcessor/#AutowiredAnnotationbeanPostProcessor">AutowiredAnnotationBeanPostProcessor</a>。</p>
<h3 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h3><p>第三次调用后置处理器是<code>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition</code>其主要作用的解析类中要注入的对象然后放入到<code>BeanDefinition</code>中，然后会在``InstantiationAwareBeanPostProcessor.postProcessProperties`中完成属性注入</p>
<h3 id="getEarlyBeanReference"><a href="#getEarlyBeanReference" class="headerlink" title="getEarlyBeanReference"></a>getEarlyBeanReference</h3><p>第四次调用后置处理器是<code>SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference</code>，用于循环依赖中提前暴露Bean</p>
<h3 id="postProcessAfterInstantiation"><a href="#postProcessAfterInstantiation" class="headerlink" title="postProcessAfterInstantiation"></a>postProcessAfterInstantiation</h3><p>第五次调用后置处理器是<code>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</code>主要是在Bean完成实例化后判断是否需要属性注入，返回false则不需要完成属性注入</p>
<h3 id="postProcessProperties"><a href="#postProcessProperties" class="headerlink" title="postProcessProperties"></a>postProcessProperties</h3><p>第六次调用后置处理器是<code>InstantiationAwareBeanPostProcessor.postProcessProperties</code>，主要是完成属性注入。</p>
<ul>
<li>在``ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor.postProcessProperties<code>中指定</code>BeanFactory`</li>
<li>在<code>CommonAnnotationBeanPostProcessor.postProcessProperties</code>中注入<code>@Resurce</code>、<code>@WebServiceRef</code>、<code>@EJB</code>、<code>@PostConstruct</code>、<code>@PreDestory</code>注解相关</li>
<li>在<code>AutowiredAnnotationBeanPostProcessor.postProcessProperties</code>中进行属性注入<code>@Autowired</code>、<code>@Value</code>、<code>@Inject</code>注解相关属性</li>
</ul>
<h3 id="postProcessBeforeInitialization"><a href="#postProcessBeforeInitialization" class="headerlink" title="postProcessBeforeInitialization"></a>postProcessBeforeInitialization</h3><p>第七次调用后置处理器是<code>BeanPostProcessor.postProcessBeforeInitialization</code>，<code>BeanPostProcessor</code>是最顶层接口，所以所有后置处理器都有该方法。存在逻辑的如下:</p>
<ul>
<li><code>ApplicationContextAwareProcessor</code>: 执行<code>EnvironmentAware</code>、<code>EmbeddedValueResolverAware</code>、<code>ResourceLoaderAware</code>、<code>ApplicationEventPublisherAware</code>、<code>MessageSourceAware</code>、<code>ApplicationContextAware</code>相关回调</li>
<li><code>ImportAwareBeanPostProcessor</code>: 实现<code>ImportAware</code>接口的Bean</li>
<li><code>CommonAnnotationBeanPostProcessor</code>其继承了<code>InitDestroyAnnotationBeanPostProcessor</code>类，其会执行<code>@PostConstruct</code>方法</li>
</ul>
<h3 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h3><p>第八次调用后置处理器是<code>BeanPostProcessor.postProcessAfterInitialization</code>，<code>BeanPostProcessor</code>是最顶层接口，所以所有后置处理器都有该方法。</p>
<ul>
<li><code>ApplicationListenerDetector</code>，将符合条件的<strong>Bean</strong>放入到<code>ApplicationContext.applicationListeners</code>中，用于监听<strong>Application</strong>事件</li>
<li><code>AnnotationAwareAspectJAutoProxyCreator</code>，待研究</li>
</ul>
<h3 id="requiresDestruction和postProcessBeforeDestruction"><a href="#requiresDestruction和postProcessBeforeDestruction" class="headerlink" title="requiresDestruction和postProcessBeforeDestruction"></a>requiresDestruction和postProcessBeforeDestruction</h3><p>第9次调用后置处理器，<code>DestructionAwareBeanPostProcessor#requiresDestruction</code>和<code>DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</code>，判断Bean实例是否需要该后置处理器销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public DisposableBeanAdapter(Object bean, String beanName, RootBeanDefinition beanDefinition,</span><br><span class="line">			List&lt;BeanPostProcessor&gt; postProcessors, @Nullable AccessControlContext acc) &#123;</span><br><span class="line">    &#x2F;&#x2F; 构造方法中返回该bean在销毁时需要执行的后置处理器,filterPostProcessors</span><br><span class="line">    this.beanPostProcessors &#x3D; filterPostProcessors(postProcessors, bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; DestructionAwareBeanPostProcessor#requiresDestruction方法</span><br><span class="line">private List&lt;DestructionAwareBeanPostProcessor&gt; filterPostProcessors(List&lt;BeanPostProcessor&gt; processors, Object bean) &#123;</span><br><span class="line">    List&lt;DestructionAwareBeanPostProcessor&gt; filteredPostProcessors &#x3D; null;</span><br><span class="line">    if (!CollectionUtils.isEmpty(processors)) &#123;</span><br><span class="line">        filteredPostProcessors &#x3D; new ArrayList&lt;&gt;(processors.size());</span><br><span class="line">        for (BeanPostProcessor processor : processors) &#123;</span><br><span class="line">            if (processor instanceof DestructionAwareBeanPostProcessor) &#123;</span><br><span class="line">                DestructionAwareBeanPostProcessor dabpp &#x3D; (DestructionAwareBeanPostProcessor) processor;</span><br><span class="line">                if (dabpp.requiresDestruction(bean)) &#123;</span><br><span class="line">                    filteredPostProcessors.add(dabpp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return filteredPostProcessors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 销毁调用方法</span><br><span class="line">public void destroy() &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理@PreDestroy注解</span><br><span class="line">    if (!CollectionUtils.isEmpty(this.beanPostProcessors)) &#123;</span><br><span class="line">        for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) &#123;</span><br><span class="line">            processor.postProcessBeforeDestruction(this.bean, this.beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F; DisposableBean接口</span><br><span class="line">    if (this.invokeDisposableBean) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; ··· 省略</span><br><span class="line">            ((DisposableBean) this.bean).destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            &#x2F;&#x2F; throw ex</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F; 推断的destroyMethod，例如close、shutdown方法,xml中的destroy-method、default-destroy-method属性</span><br><span class="line">    if (this.destroyMethod !&#x3D; null) &#123;</span><br><span class="line">        invokeCustomDestroyMethod(this.destroyMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (this.destroyMethodName !&#x3D; null) &#123;</span><br><span class="line">        Method methodToInvoke &#x3D; determineDestroyMethod(this.destroyMethodName);</span><br><span class="line">        if (methodToInvoke !&#x3D; null) &#123;</span><br><span class="line">            invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当销毁Bean时:</p>
<ol>
<li><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#destroySingletons</code></li>
<li><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#destroySingleton</code></li>
<li><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#destroyBean</code></li>
</ol>
<blockquote>
<p>destroyBean的源码如下:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">protected void destroyBean(String beanName, @Nullable DisposableBean bean) &#123;</span><br><span class="line">    &#x2F;&#x2F; Trigger destruction of dependent beans first...</span><br><span class="line">    Set&lt;String&gt; dependencies;</span><br><span class="line">    synchronized (this.dependentBeanMap) &#123;</span><br><span class="line">        &#x2F;&#x2F; Within full synchronization in order to guarantee a disconnected Set</span><br><span class="line">        dependencies &#x3D; this.dependentBeanMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 销毁依赖的bean</span><br><span class="line">    if (dependencies !&#x3D; null) &#123;</span><br><span class="line">        for (String dependentBeanName : dependencies) &#123;</span><br><span class="line">            destroySingleton(dependentBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Actually destroy the bean now...</span><br><span class="line">    if (bean !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 此处调用的是DisposableBeanAdapter.destroy()方法。</span><br><span class="line">            bean.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(&quot;Destruction of bean with name &#39;&quot; + beanName + &quot;&#39; threw an exception&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Trigger destruction of contained beans...</span><br><span class="line">    Set&lt;String&gt; containedBeans;</span><br><span class="line">    synchronized (this.containedBeanMap) &#123;</span><br><span class="line">        &#x2F;&#x2F; Within full synchronization in order to guarantee a disconnected Set</span><br><span class="line">        containedBeans &#x3D; this.containedBeanMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    if (containedBeans !&#x3D; null) &#123;</span><br><span class="line">        for (String containedBeanName : containedBeans) &#123;</span><br><span class="line">            destroySingleton(containedBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Remove destroyed bean from other beans&#39; dependencies.</span><br><span class="line">    synchronized (this.dependentBeanMap) &#123;</span><br><span class="line">        for (Iterator&lt;Map.Entry&lt;String, Set&lt;String&gt;&gt;&gt; it &#x3D; this.dependentBeanMap.entrySet().iterator(); it.hasNext();) &#123;</span><br><span class="line">            Map.Entry&lt;String, Set&lt;String&gt;&gt; entry &#x3D; it.next();</span><br><span class="line">            Set&lt;String&gt; dependenciesToClean &#x3D; entry.getValue();</span><br><span class="line">            dependenciesToClean.remove(beanName);</span><br><span class="line">            if (dependenciesToClean.isEmpty()) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Remove destroyed bean&#39;s prepared dependency information.</span><br><span class="line">    this.dependenciesForBeanMap.remove(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-01-%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-01-%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">分布式事务-01-一致性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-01 17:52:09" itemprop="dateCreated datePublished" datetime="2021-06-01T17:52:09+08:00">2021-06-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在微服务架构盛行的情况下，在分布式的多个服务中保证业务的一致性，即分布式事务就显得尤为重要。本文将讲述分布式事务及其解决方案，有XA协议、TCC和Saga事务模型、本地消息表、事务消息和阿里开源的Seata。</p>
<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">概要</a></h1><p>在微服务架构盛行的情况下，在分布式的多个服务中保证业务的一致性，即分布式事务就显得尤为重要。本文将讲述分布式事务及其解决方案，有XA协议、TCC和Saga事务模型、本地消息表、事务消息和阿里开源的Seata。</p>
<h1 id="分布式事务特性"><a href="#分布式事务特性" class="headerlink" title="分布式事务特性"></a>分布式事务特性</h1><p>单机事务是相对分布式事务来说的，即数据库事务。</p>
<ul>
<li>A（Atomicity）：指单个事务中的操作要不都执行，要不都不执行</li>
<li>C（Consistency）：指事务前后数据的完整性必须保持一致</li>
<li>I（Isolation）：指多个事务对数据可见性的规则</li>
<li>D（Durability）：指事务提交后，就会被永久存储下来</li>
</ul>
<p>既然数据库事务有这四个特性的，那么分布式事务也不例外，应该具备这四个特性。</p>
<p>在微服务架构下，服务之间通过RPC远程调用，相对单机事务来说，多了“网络通信”这一不确定因素，使得本来服务的调用只有“成功”和“失败”这两种返回结果，变为“成功”、“失败”和“未知”三种返回结果。系统之间的通信可靠性从单一系统中的可靠变成了微服务架构之间的不可靠，分布式事务其实就是在不可靠的通信下实现事务的特性。一般因为网络导致的异常可能有机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的TCP、存储数据丢失、其他异常等等。</p>
<h1 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h1><h2 id="2PC-3PC"><a href="#2PC-3PC" class="headerlink" title="2PC/3PC"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">2PC/3PC</a></h2><p>2PC即二阶段提交 :</p>
<blockquote>
<p>二阶段提交（Two-phase Commit）是指在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法。通常，二阶段提交也被称为是一种协议（Protocol）。</p>
</blockquote>
<p>2PC是一种协议，它的作用保证在分布式系统中每个节点要不都提交事务，要么都取消事务。这个跟ACID中的A原子性的定义很像。</p>
<p>2PC引入一个第三方的节点协调者，即Coordinator，其他参与事务的节点为参与者，即Participants。协调者统筹整个事务行为，负责通知参与者进行Commit还是Rollback操作。</p>
<p>2PC的过程比较简单，分为两个阶段：</p>
<ol>
<li><p>准备阶段</p>
<p>协调者分别给每个参与者发送Prepare消息，每个参与者收到消息后，进行“预提交”操作（不是实际的提交操作），把操作的结果（成功或失败）返回给协调者。</p>
</li>
<li><p>提交阶段</p>
<p>协调者根据准备阶段收到的参与者的返回结果进行判断，如果所有的参与者都返回成功，那么分别给每个参与者发送Commit消息，否则发送Rollback消息。</p>
</li>
</ol>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">upload successful</p>
<p>2PC是一个强一致性协议，同时它在实际应用中还存在几个问题</p>
<ul>
<li>同步阻塞，2PC的两个阶段中，协调者和参与者的通信都是同步的，这会导致整个事务的长时间阻塞</li>
<li>Coordinator的单点问题</li>
<li>数据不一致，在Commit阶段，可能存在只有部分参与者收到Commit消息（或处理成功）的情况</li>
</ul>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">3PC</a></h3><p>3PC即三阶段提交，它比2PC多了一个阶段，即把原来2PC的准备阶段拆分成CanCommit和PreCommit两个阶段，同时</p>
<p>引入超时机制来解决2PC的同步阻塞问题。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">upload successful</p>
<p>但是在我看来3PC并没有解决2PC的根本问题，它只是在2PC的基础上做了一些优化，它增加了一个阶段（也增加了1个RTT）来提高对方可用性的概率，这本质跟TCP的三次握手一样，同样也改为四次握手，五次握手等等。</p>
<h3 id="XA"><a href="#XA" class="headerlink" title="XA"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">XA</a></h3><p>XA是一种基于2PC协议实现的规范。在2PC中没有明确资源是什么，以及资源是怎么提交的等等，而XA就是数据库实现2PC的规范，已知常用的支持XA的关系型数据库有Mysql、Oracle等。</p>
<h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">本地消息表</a></h2><p>本地消息表方案应该是业界内使用最为广泛的，因为它使用简单，成本比较低。</p>
<p>本地消息表的方案最初是由 eBay 提出（完整方案），核心思路是将分布式事务拆分成本地事务进行处理。</p>
<p>它的处理流程如下：</p>
<ul>
<li>事务发起方把<a href="">要处理的业务事务</a>和<a href="">写消息表</a>这两个操作放在同一个本地事务里</li>
<li>事务发起方有一个定时任务轮询消息表，把<a href="">未成功的消息</a>发送到消息中间件，做补偿</li>
<li>事务被动方从消息中间件获取消息后，返回成功</li>
<li>事务发起方更新消息状态为已成功</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcqFjwkXDAcOWzt5b707kH6CuLmfstpk8fmrHq7licApVRSKhkxKcGVMfsaLK0IGqOQ9uAiaTqN6J6g/640" alt="图片"></p>
<p>从处理流程来看，本地消息表方案是一个基于消息中间件的可靠性来达到事务的最终一致性的方案。</p>
<p>一些分析：</p>
<ul>
<li><p>把业务处理和写消息表放在同一个事务是为了失败/异常后可以同时回滚</p>
</li>
<li><p>为什么不直接发消息，而是先写消息表？</p>
<p>试想，如果发送消息超时了，即不确定消息中间件收到消息没，那么你是重试还是抛异常回滚事务呢？回滚是不行的，因为可能消息中间件已经收到消息，接收方收到消息后做处理，导致双方数据不一致了；重试也是不行的，因为有可能会一直重试失败，导致事务阻塞。</p>
</li>
<li><p>基于上述分析，消息的接收方是需要做幂等操作的</p>
</li>
</ul>
<p>本地消息表方案整体来说还是比较简单、可用的，但是也有以下缺点：</p>
<ul>
<li>消息数据和业务数据耦合，消息表需要根据具体的业务场景制定，不能公用。就算可以公用消息表，对于分库的业务来说每个库都是需要消息表的。</li>
<li>只适用于最终一致的业务场景。例如在 A -&gt; B场景下，在不考虑网络异常、宕机等非业务异常的情况下，A成功的话，B肯定也会成功的。</li>
</ul>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">事务消息</a></h2><p>事务消息是通过消息中间件来解耦本地消息表和业务数据表，适用于所有对数据最终一致性需求的场景。现在支持事务消息的消息中间件只有RocketMQ，这个概念最早也是RocketMQ提出的。</p>
<p>通过事务消息实现分布式事务的流程如下：</p>
<ol>
<li>发起方发送半事务消息会给RocketMQ ，此时消息的状态prepare，接受方还不能拉取到此消息</li>
<li>发起方进行本地事务操作</li>
<li>发起方给RocketMQ确认提交消息，此时接受方可以消费到此消息了</li>
</ol>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">upload successful</p>
<p>步骤1和3失败/异常该如何处理：</p>
<p>RocketMQ会定期扫描还没确认的消息，回调给发送方，询问此次事务的状态，根据发送方的返回结果把这条消息进行取消还是提交确认。</p>
<p>可以看出事务消息的本质的借鉴了二阶段提交的思想，它跟本地消息表的做法也很像，事务消息做的事情其实就是把消息表的存储和扫描消息表这两个事情放到消息中间件来做，使得消息表和业务表解耦。</p>
<h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">TCC</a></h2><p>TCC （Try-Confirm-Cancel）事务模型采用的是补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿操作。</p>
<p>相当于XA来说，TCC可以不依赖于资源管理器，即数据库，它是通过业务逻辑来控制确认和补偿操作的，所以它用了’Cancel’而非’Rollback’的字眼。它是一个应用层面的2PC。</p>
<p>TCC分为三个阶段：</p>
<ul>
<li>Try阶段，对业务资源进行检测和预留</li>
<li>Confirm阶段，对Try阶段预留的资源进行确认提交，Try阶段执行成功是Confirm阶段执行成功的前提</li>
<li>Cancel阶段，对Try阶段预留的资源进行撤销或释放</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">upload successful</p>
<p>看上去TCC跟2PC/3PC可能有点像，但是TCC强调的是补偿，而且对于对资源的“预留”，“确认”，“释放”，TCC并没有明确说要如何做，这个具体是要业务来定义的。</p>
<p>例如在转账的场景，“预留”操作可能就是对账号里的部分资金进行冻结，这样这个资金只能是当前事务才能用，别的事务用不了。</p>
<p>另外，对于异常的场景，TCC也没有说要怎么做，因为Try、Confirm、Cancel都是业务定义的，这三个阶段中发生了异常，那么就由业务来做相应的处理。一般都有以下几种处理：</p>
<ul>
<li>如果Try成功了，那么Confirm阶段异常了就一直重试，直到成功</li>
<li>Try、Confirm、Cancel三个阶段都有相应的资源及事务日志，应用根据日志（异步）来做重试或补偿</li>
<li>TCC的实现依赖底层数据库，异常后直接利用数据库的事务机制回滚</li>
</ul>
<p>其中现在使用比较多的TCC框架ByteTCC、tcc-transaction的原理都是基于第三点</p>
<p>同时，在实现TCC时要注意以下三个问题</p>
<ul>
<li><p>允许空回滚</p>
<p>在Try没有真正执行的情况下，触发了Cancel操作，这时要允许Cancel成功</p>
</li>
<li><p>防悬挂控制</p>
<p>Cancel操作比Try操作先执行（网络延迟原因），后面的Try操作不能执行成功</p>
</li>
<li><p>幂等控制</p>
</li>
</ul>
<p>TCC其实是把控制事务的逻辑放在业务应用层面，而非资源管理器，这样实现起来就会相对灵活很多，但相对对数据一致性的保证可能没那么强（具体看怎么实现Try），整体来说TCC还有以下缺点：</p>
<ul>
<li>对于Confirm和Cancel阶段失败后要完全靠业务应用自己去处理</li>
<li>每个业务都需要实现Try、Confirm、Cancel三个接口，代码量比较多</li>
<li>如果是基于现有的业务想使用TCC会比较困难。一是对于原来的接口要拆分为三个接口，入侵性比较大；二是因为要做“预留”资源的操作，有可能需要对原来的业务模型进行改造。</li>
</ul>
<h2 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">Saga</a></h2><p>Saga事务模型又叫做长时间运行的事务（Long-running-transaction）, 它是由普林斯顿大学的H.Garcia-Molina等人提出，它描述的是另外一种在没有两阶段提交的的情况下解决分布式系统中复杂的业务事务问题。Saga的论文。</p>
<p>该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Saga工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Saga工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。</p>
<p>Saga也是一种补偿协议，在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcqFjwkXDAcOWzt5b707kH6QE2MdM6ZVZzMnNFHqUZeMwnUWMmvKPJxb3zeP6boKGvk1gmbTribfSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">overwrote existing file</p>
<p>你可以看到Saga跟TCC很像，但是Saga更加宽松，一致性更弱，在Saga看来，在一阶段直接做提交/确认操作就好了，有问题再做补偿。这样的话，Saga可以拥有比XA和TCC更好的性能（XA、TCC需要锁定资源或预留资源），而且Saga强调通过事件驱动异步处理，实现高吞吐。</p>
<p>可以看出Saga是对TCC的一种“妥协”，从TCC的三个接口变为两个接口，一阶段直接提交缺少对资源的隔离（如果一阶段提交后，后面发现需要做补偿，但是补偿操作执行前有另外的事务更改了数据，这时数据已经变“脏”了，那么这时该如何处理是一个问题。在TCC没有这个问题，因为资源已经被hold住了），因此对使用者也是比较宽松的，对于现有业务的改造也会比较简单。</p>
<p>Saga实现分两种，一种是Saga状态机实现，一种是Saga AOP Proxy实现。Saga状态机实现，在关于参与者服务编排实现又有集中式和协同式两种分支。这点就不展开了。</p>
<h3 id="TCC-vs-Saga"><a href="#TCC-vs-Saga" class="headerlink" title="TCC vs Saga"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">TCC vs Saga</a></h3><p>TCC和Saga都属于补偿型事务模型，Saga没有Try，直接Commit，所有会产生实际的事务痕迹，而补偿做的是反向操作。TCC是二阶段的广义实现，利用了数据的中间态，Cancel是中间状态的数据进行撤销，从而不存在数据污染问题。</p>
<p>使用场景对比：</p>
<ul>
<li>TCC 适用于执行时间确定且较短、对一致性要求比较高、数据隔离强的业务</li>
<li>Saga 适用于业务流程长、业务流程多的业务，在银行业金融机构使用广泛</li>
<li>TCC 对现有业务改造较大，Saga则相对少点</li>
</ul>
<h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">Seata</a></h2><p>Seata是一个由阿里做背书的分布式事务框架，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">AT模式</a></h3><p>AT模式是Seata通过拦截、解释用户的SQL，对业务数据进行加锁、回滚等操作的基于二阶段协议的一个实现。</p>
<p>它的特点是对业务无入侵，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。</p>
<p>在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</p>
<p>二阶段如果是提交的话，因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">upload successful</p>
<h3 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">TCC模式</a></h3><p>Seata的TCC模式跟上面讲的TCC事务模型差不多</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">overwrote existing file</p>
<h3 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">Saga模式</a></h3><p>Saga模式也是上面讲的Saga事务模型差不多。在Seata中对服务的编排引入了状态机引擎， 使得对业务流程的定义更加标准化，提高可读性，不过相对来说配置会比较复杂繁琐。同时支持注解的方式，这个在开发上会简单一点，但功能可能少一点。</p>
<h1 id="分布式事务一致性与Paxos一致性的思考"><a href="#分布式事务一致性与Paxos一致性的思考" class="headerlink" title="分布式事务一致性与Paxos一致性的思考"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">分布式事务一致性与Paxos一致性的思考</a></h1><p>首先要明确一点的就是对于上述提到的分布式事务解决方案，如TCC、Saga、本地消息表等，其本质都是2PC。</p>
<p>Paxos算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。</p>
<p>咋看起来2PC和Paxos都是解决关于“一致性”的问题，其实细想它们解决的问题不在一个层面。</p>
<p>2PC要求分布式系统中的每个节点要不全部成功，要不全部失败，强调的是原子性。</p>
<p>Paxos要求多个副本之间的数据一致性，其实这里用“一致性”并不准确，应该用“共识（Consensus）”才对。</p>
<p>例如2PC中的协调者单点的问题可以用Paxos算法通过选举出新的协调者来解决。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">总结</a></h1><p>总得看来，分布式事务的解决方案都很难做到有高一致性的同时，也有高性能，同时在实现上也有一定的难度。在业务允许的情况下，我们通常处理分布式事务的一般原则应是：业务规避 &gt; 最终一致 &gt; 强一致。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/31/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ-04-%E5%BC%80%E6%BA%90%E8%B4%A1%E7%8C%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/31/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ-04-%E5%BC%80%E6%BA%90%E8%B4%A1%E7%8C%AE/" class="post-title-link" itemprop="url">RocketMQ-04-开源贡献</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-31 09:10:13" itemprop="dateCreated datePublished" datetime="2021-05-31T09:10:13+08:00">2021-05-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/o917lCT1kHPYpAD63bvv7w">https://mp.weixin.qq.com/s/o917lCT1kHPYpAD63bvv7w</a></p>
<p><strong>我们希望能够有一个运维命令，能够获取当前集群中所有的客户端连接信息。</strong></p>
<p>那我们能否定制化一个运维命令实现获取所有生产者的连接信息，既然官方提供了producerConnection命令获取单个生产者组信息，服务端应该是会存储所有生产者组的连接信息，只是官方没有提供相关的命令而已，为了验证，我们可以去看一下producerConnection命令在服务端的处理逻辑。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFsujHP5KXGTMibVaYCfRrxjY0rLzcpmfQFqLt3qrcG8ib8TLYuuURDAss2YIdKsiaryAcgxMSgxooBaA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>从服务端代码可知，在服务端会使用一个Map存储所有的生产者客户端连接，其键为生产者组名称，其值为Map键值对(通道对象(Channel),客户端信息(ClientChannelInfo))，其中客户端信息就包含了客户端ID，客户端使用的语言以及版本等信息。</p>
<p>经过上面分析，实现一个获取全部生产者连接信息将变得非常简单。</p>
<p>本文由于篇幅问题，不展示全部代码，主要总结一下开发一个RocketMQ的几个核心步骤，代码已提交到github仓库：</p>
<p>链接：<a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/pull/2940">https://github.com/apache/rocketmq/pull/2940</a></p>
<p>首先我们看一下该命令在IDEA中的测试效果，运行命令如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFsujHP5KXGTMibVaYCfRrxjYD6ILnKgAVhW3zTdiaeUCp34fMLRtCIvZhh3GReZIpbgzCxngMouCJ8w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>命令运行输出为：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFsujHP5KXGTMibVaYCfRrxjYzDaIoJLJtCibP3D6agiaNNRfm51IMRGXGTqXjMtk9liadibdbp3iaxNyK0g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>打包部署后命令的使用说明如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFsujHP5KXGTMibVaYCfRrxjY3GvNu1nSZjccZ8tekt01O0cOhD6GxEmwt5jmbADJw9lQGUYqagkTlA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>其中-b broker地址与-c cluster集群名称两个参数二选一，主用用于路由。</p>
<p>编写一个RocketMQ运维命令通常具备如下几个要点：</p>
<ul>
<li>创建自己的命令处理类，并在MQAdminStartup中调用initCommand初始化命令。</li>
<li>定义命令请求CODE,RocketMQ为每一个请求定义了对应的RequestCode。</li>
<li>在Broker端的AdminBrokerProcessor中添加对该请求Code的处理逻辑</li>
</ul>
<p>为了更加形象完整的展示开发一个运维命令，我将本次提交记录截图展示给大家：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFsujHP5KXGTMibVaYCfRrxjYeQkUFTqXWDs5kJNyqib9xWAaibibpBcxHdV3VbW8o08WO0A9EFFics8JQQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springMVC/springMVC-03-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springMVC/springMVC-03-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">springMVC-03-拦截器和过滤器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-31 08:55:22 / Modified: 09:01:26" itemprop="dateCreated datePublished" datetime="2021-05-31T08:55:22+08:00">2021-05-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="HandlerInterceptor实现登录拦截的原理"><a href="#HandlerInterceptor实现登录拦截的原理" class="headerlink" title="HandlerInterceptor实现登录拦截的原理"></a>HandlerInterceptor实现登录拦截的原理</h3><p>SpringBoot通过实现HandlerInterceptor接口实现拦截器，通过实现WebMvcConfigurer接口实现一个配置类，在配置类中注入拦截器，最后再通过@Configuration注解注入配置.</p>
<h4 id="实现HandlerInterceptor接口"><a href="#实现HandlerInterceptor接口" class="headerlink" title="实现HandlerInterceptor接口"></a>实现HandlerInterceptor接口</h4><p>实现HandlerInterceptor接口需要实现3个方法：<code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code>.</p>
<p>3个方法各自的功能如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> blog.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 在请求处理之前进行调用(Controller方法调用之前)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了拦截器的preHandle方法&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpSession session = request.getSession();</span><br><span class="line">            <span class="comment">//统一拦截（查询当前session是否存在user）(这里user会在每次登录成功后，写入session)</span></span><br><span class="line">            User user = (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            response.sendRedirect(request.getContextPath() + <span class="string">&quot;login&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果设置为false时，被请求时，拦截器执行到此处将不会继续操作</span></span><br><span class="line">        <span class="comment">//如果设置为true时，拦截器将会继续执行后面的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了拦截器的postHandle方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 整个请求结束之后被调用，也就是在DispatchServlet渲染了对应的视图之后执行（主要用于进行资源清理工作）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了拦截器的afterCompletion方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>preHandle在Controller之前执行，因此拦截器的功能主要就是在这个部分实现：</p>
<ul>
<li>检查session中是否有user对象存在；</li>
<li>如果存在，就返回true，那么Controller就会继续后面的操作；</li>
<li>如果不存在，就会重定向到登录界面。就是通过这个拦截器，使得Controller在执行之前，都执行一遍preHandle.</li>
</ul>
<h4 id="实现WebMvcConfigurer接口，注册拦截器"><a href="#实现WebMvcConfigurer接口，注册拦截器" class="headerlink" title="实现WebMvcConfigurer接口，注册拦截器"></a>实现WebMvcConfigurer接口，注册拦截器</h4><p>实现WebMvcConfigurer接口来实现一个配置类，将上面实现的拦截器的一个对象注册到这个配置类中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> blog.interceptor.UserLoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注册TestInterceptor拦截器</span></span><br><span class="line">        InterceptorRegistration registration = registry.addInterceptor(<span class="keyword">new</span> UserLoginInterceptor());</span><br><span class="line">        registration.addPathPatterns(<span class="string">&quot;/**&quot;</span>); <span class="comment">//所有路径都被拦截</span></span><br><span class="line">        registration.excludePathPatterns(    <span class="comment">//添加不拦截路径</span></span><br><span class="line">                <span class="string">&quot;/login&quot;</span>,                    <span class="comment">//登录路径</span></span><br><span class="line">                <span class="string">&quot;/**/*.html&quot;</span>,                <span class="comment">//html静态资源</span></span><br><span class="line">                <span class="string">&quot;/**/*.js&quot;</span>,                  <span class="comment">//js静态资源</span></span><br><span class="line">                <span class="string">&quot;/**/*.css&quot;</span>                  <span class="comment">//css静态资源</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将拦截器注册到了拦截器列表中，并且指明了拦截哪些访问路径，不拦截哪些访问路径，不拦截哪些资源文件；最后再以@Configuration注解将配置注入。</p>
<h4 id="保持登录状态"><a href="#保持登录状态" class="headerlink" title="保持登录状态"></a>保持登录状态</h4><p>只需一次登录，如果登录过，下一次再访问的时候就无需再次进行登录拦截，可以直接访问网站里面的内容了。</p>
<p>在正确登录之后，就将user保存到session中，再次访问页面的时候，登录拦截器就可以找到这个user对象，就不需要再次拦截到登录界面了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &#123;&quot;/login&quot;&#125;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">loginIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;users/login&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &#123;&quot;/login&quot;&#125;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestParam(name = &quot;username&quot;)</span>String username, <span class="meta">@RequestParam(name = &quot;password&quot;)</span>String password, Model model, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    User user = userService.getPwdByUsername(username);</span><br><span class="line">    String pwd = user.getPassword();</span><br><span class="line">    <span class="keyword">if</span> (pwd.equals(password2)) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        request.getSession().setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;users/failed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring-03-DI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring-03-DI/" class="post-title-link" itemprop="url">spring-03-DI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-29 21:40:10" itemprop="dateCreated datePublished" datetime="2021-05-29T21:40:10+08:00">2021-05-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-02 11:20:40" itemprop="dateModified" datetime="2021-06-02T11:20:40+08:00">2021-06-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="beanFactory-createBean和doCreateBean"><a href="#beanFactory-createBean和doCreateBean" class="headerlink" title="beanFactory.createBean和doCreateBean"></a>beanFactory.createBean和doCreateBean</h3><p>创建Bean的过程如下(省略部分代码，只保留主要逻辑)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">	RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">    <span class="comment">// 从BeanDefinition Map中得到要创建的bean的类型</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">    	mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次调用后置处理器，判断是否加代理，Spring Boot中没有任何处理</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Bean的真正过程</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    	<span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第二次调用后置处理器</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建实例对象</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 第三次调用后置处理器，通过后置处理器合并BeanDefinition,拿到所有需要注入的属性</span></span><br><span class="line">                <span class="comment">// ApplicationListenerDetector: 将属于ApplicationListener的Bean放入到ApplicationContext上下文的applicationListener集合中</span></span><br><span class="line">                <span class="comment">// CommonAnnotationBeanPostProcessor: 将@Resource、@webServiceRef、@EJB修饰的属性放入到RootBeanDefinition中</span></span><br><span class="line">                <span class="comment">// AutowiredAnnotationBeanPostProcessor: 将@Autowired、@Value、JSR-330相关注解放入到RootBeanDefinition中</span></span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环依赖相关</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">      <span class="comment">// 当支持循环依赖时，就会提前暴露自己(为了其他对象可以注入自己)，第四次调用后置处理器,实际在Spring Boot中没有处理任何事情</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要属性注入,若需要则注入则完成注入,第五、六次调用后置处理器</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化Spring，进行第七、八次后置处理器的调用</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">//异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第9次调用后置处理器</span></span><br><span class="line">      <span class="comment">// DestructionAwareBeanPostProcessor的requiresDestruction方法和postProcessBeforeDestruction方法，具体destroy过程见:</span></span><br><span class="line">      <span class="comment">// org.springframework.beans.factory.support.DisposableBeanAdapter.destroy()方法</span></span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="beanFactory-populateBean"><a href="#beanFactory-populateBean" class="headerlink" title="beanFactory.populateBean"></a>beanFactory.populateBean</h3><p><code>populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</code>方法完成属性注入(省略部分代码，只保留主要逻辑):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任何实现postProcessAfterInstantiation的BeanPostProcessor都可以修改postProcessAfterInstantiation的返回值,例如:动态注入</span></span><br><span class="line">    <span class="comment">// 第五次调用后置处理器，判断是否需要属性注入,CommonAnnotationBeanPostProcessor、AutowiredAnnotationBeanPostProcessor、ImportAwareBeanPostProcessor都默认为true</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                <span class="comment">// 调用后置处理器 判断是否需要属性注入，实现InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation就不会进行属性注入</span></span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始属性注入</span></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 自动注入的方式。。。省略</span></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第六次调用后置处理器</span></span><br><span class="line">        <span class="comment">// 1.在ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor.postProcessProperties中指定BeanFactory</span></span><br><span class="line">        <span class="comment">// 2.在CommonAnnotationBeanPostProcessor.postProcessProperties中注入@Resurce、@WebServiceRef、@EJB相关</span></span><br><span class="line">        <span class="comment">// 3.其会在AutowiredAnnotationBeanPostProcessor.postProcessProperties中进行属性注入@Autowired、@Value、@Inject注解</span></span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="comment">// 完成属性注入</span></span><br><span class="line">                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">                pvs = pvsToUse;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="beanFactory-initializeBean"><a href="#beanFactory-initializeBean" class="headerlink" title="beanFactory.initializeBean"></a>beanFactory.initializeBean</h3><p><code>initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd)</code>方法会执行工厂相关回调方法、init方法等BeanPostProcessor后置处理器，具体如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行或者回调Aware相关接口:BeanNameAware、BeanClassLoaderAware、BeanFactoryAware，只有这三个</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 第七次调用后置处理器</span></span><br><span class="line">		<span class="comment">// 1.ApplicationContextAwareProcessor: 执行EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware相关回调</span></span><br><span class="line">		<span class="comment">// 2.ImportAwareBeanPostProcessor: 实现ImportAware接口的Bean</span></span><br><span class="line">		<span class="comment">// 3.BeanPostProcessorChecker:没有做任何事情</span></span><br><span class="line">		<span class="comment">// 4.CommonAnnotationBeanPostProcessor继承自CommonAnnotationBeanPostProcessor, 执行带@PostConstract注解的方法</span></span><br><span class="line">		<span class="comment">// 5.AutowiredAnnotationBeanPostProcessor:没有做任何事情</span></span><br><span class="line">		<span class="comment">// 6.ApplicationListenerDetector:将ApplicationListener添加到applicationContext中</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先处理实现InitializingBean,然后处理xml的init-method方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 第8次调用后置处理器</span></span><br><span class="line">		<span class="comment">// 1.ApplicationContextAwareProcessor、ImportAwareBeanPostProcessor、: 没有做任何事情</span></span><br><span class="line">		<span class="comment">// 2.BeanPostProcessorChecker: 一些日志</span></span><br><span class="line">		<span class="comment">// 3.CommonAnnotationBeanPostProcessor、AutowiredAnnotationBeanPostProcessor:没有做任何事情</span></span><br><span class="line">		<span class="comment">// 4.ApplicationListenerDetector: 将符合条件的Bean放入到ApplicationContext.applicationListeners中</span></span><br><span class="line">		<span class="comment">// AOP代理 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述过程不仅仅是Bean的创建过程，还包括了创建Bean过程中相关的后置处理器逻辑，<strong>Spring framework</strong>相关的共6个后置处理器，具体见下文。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
