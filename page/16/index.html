<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/16/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/16/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">246</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/rpc-dubbo/dubbo-01-%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/rpc-dubbo/dubbo-01-%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">dubbo-01-入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-04 09:53:30" itemprop="dateCreated datePublished" datetime="2021-03-04T09:53:30+08:00">2021-03-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Dubbo概述"><a href="#Dubbo概述" class="headerlink" title="Dubbo概述"></a>Dubbo概述</h1><h2 id="什么是-PRC"><a href="#什么是-PRC" class="headerlink" title="什么是 PRC?"></a>什么是 <strong>PRC</strong>?</h2><p>RPC(Remote Procedure Call Protocol)——远程过程调用协议，它是一种通过网络从远 程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 协议假定某些传输协议 的存在，如 TCP 或 UDP，为通信程序之间携带信息数据。在 OSI 网络通信模型(OSI 七层网 络模型，OSI，Open System Interconnection，开放系统互联)中，RPC 跨越了传输层和应用 层。RPC 使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<p>RPC 采用客户机/服务器模式(即 C/S 模式)。请求程序就是一个客户机，而服务提供程 序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然 后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息 到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后， 客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p>
<h2 id="Dubbo-四大组件"><a href="#Dubbo-四大组件" class="headerlink" title="Dubbo 四大组件"></a><strong>Dubbo</strong> 四大组件</h2><p>Dubbo 中存在四大组件:</p>
<ul>
<li><p><strong>Provider</strong>:服务提供者。</p>
</li>
<li><p><strong>Consumer</strong>:服务消费者。<font color="red">会从Registry下载Provider注册列表，负载均衡、限流等操作，都是Consumer自己根据这个注册列表中的Provider进行操作。</font></p>
</li>
<li><p><strong>Registry</strong>:服务注册与发现的中心，提供目录服务，亦称为服务注册中心</p>
</li>
<li><p><strong>Monitor</strong>:统计服务的调用次数、调用时间等信息的日志服务，并可以对服务设置权限、降级处理等，称为服务管控中心</p>
</li>
</ul>
<h1 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h1><p>注意：业务接口已经打成jar包，消费者和生产者直接导入jar包即可。</p>
<h2 id="直连方式"><a href="#直连方式" class="headerlink" title="直连方式"></a>直连方式</h2><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><ul>
<li><p>pom依赖</p>
<ul>
<li><p>业务接口依赖</p>
</li>
<li><p>Dubbo 依赖(2.7.0 版本) </p>
</li>
<li><p>Spring 依赖(4.3.16 版本)</p>
</li>
<li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.abc&lt;/groupId&gt;
    &lt;artifactId&gt;01-consumer&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
        &lt;!-- 自定义版本号 --&gt;
        &lt;spring-version&gt;4.3.16.RELEASE&lt;/spring-version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!--业务接口工程依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.abc&lt;/groupId&gt;
            &lt;artifactId&gt;00-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- dubbo依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
            &lt;version&gt;2.7.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- Spring依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- commons-logging依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-logging&lt;/groupId&gt;
            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 配置文件： src&#x2F;main&#x2F;resources 下定义 spring-consumer.xml 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">           xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&quot;</span><br><span class="line">           xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定当前工程在管控平台中的名称--&gt;</span><br><span class="line">        &lt;dubbo:application name&#x3D;&quot;01-consumer&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定注册中心：不使用注册中心--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;N&#x2F;A&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--直连式连接提供者--&gt;</span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;someService&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                         url&#x3D;&quot;dubbo:&#x2F;&#x2F;localhost:20880&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>main：作为测试类</p>
<ul>
<li><pre><code class="java">public class ConsumerRun &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
        SomeService service = (SomeService) ac.getBean(&quot;someService&quot;);
        String hello = service.hello(&quot;China&quot;);
        System.out.println(hello);
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### 生产者</span><br><span class="line"></span><br><span class="line">- pom依赖</span><br><span class="line"></span><br><span class="line">  -  业务接口依赖</span><br><span class="line">  - Dubbo 依赖(2.7.0 版本) </span><br><span class="line">  - Spring 依赖(4.3.16 版本)</span><br><span class="line"></span><br><span class="line">- 定义接口实现类（略）</span><br><span class="line"></span><br><span class="line">- 配置文件： src&#x2F;main&#x2F;resources 下定义 spring-provider.xml 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">           xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&quot;</span><br><span class="line">           xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定当前工程在管控平台中的名称--&gt;</span><br><span class="line">        &lt;dubbo:application name&#x3D;&quot;01-provider&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定注册中心：不使用注册中心--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;N&#x2F;A&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--注册业务接口实现类，它是真正的服务提供者--&gt;</span><br><span class="line">        &lt;bean id&#x3D;&quot;someService&quot; class&#x3D;&quot;com.abc.provider.SomeServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--服务暴露--&gt;</span><br><span class="line">        &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                       ref&#x3D;&quot;someService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>main: 启动类</p>
<ul>
<li><pre><code class="java">    public static void main(String[] args) throws IOException &#123;
        // 创建Spring容器
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-provider.xml&quot;);
        // 启动Spring容器
        ((ClassPathXmlApplicationContext) ac).start();
        // 使主线程阻塞
        System.in.read();
    &#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **Zookeeper** **注册中心**</span><br><span class="line"></span><br><span class="line">### 消费者</span><br><span class="line"></span><br><span class="line">- 导入依赖</span><br><span class="line">  </span><br><span class="line">- 复制前面的提供者工程 01-provider，并更名为 02-provider-zk。修改 pom 文件，并在其中导入 Zookeeper 客户端依赖 curator。</span><br><span class="line">  </span><br><span class="line">- 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:application name&#x3D;&quot;02-consumer-zk&quot;&gt;</span><br><span class="line">            &lt;dubbo:parameter key&#x3D;&quot;qos.port&quot; value&#x3D;&quot;33333&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;dubbo:application&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定服务注册中心：zk单机--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定服务注册中心：zk集群--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS1:2181?backup&#x3D;zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS1:2181,zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;someService&quot; check&#x3D;&quot;false&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ul>
<li><p>导入依赖</p>
<ul>
<li><p>复制前面的提供者工程 01-provider，并更名为 02-provider-zk。修改 pom 文件，并在其中导入 Zookeeper 客户端依赖 curator。</p>
</li>
<li><pre><code class="java"> &lt;!-- zk客户端依赖：curator --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
            &lt;version&gt;2.13.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
            &lt;version&gt;2.13.0&lt;/version&gt;
        &lt;/dependency&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">      &lt;dubbo:application name&#x3D;&quot;02-provider-zk&quot;&#x2F;&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;!--声明注册中心：单机版zk--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;!--声明注册中心：zk群集--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS1:2181?backup&#x3D;zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS1:2181,zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;bean id&#x3D;&quot;someService&quot; class&#x3D;&quot;com.abc.provider.SomeServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                ref&#x3D;&quot;someService&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>zk集群 + 不同协议</p>
<ul>
<li><pre><code class="xml">    &lt;dubbo:application name=&quot;02-provider-zk&quot; /&gt;

    &lt;!--声明注册中心：单机版zk--&gt;
    &lt;dubbo:registry address=&quot;zookeeper://zkOS:2181&quot;/&gt;
    &lt;!--&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;zkOS:2181&quot;/&gt;--&gt;

    &lt;!--声明注册中心：zk群集--&gt;
    &lt;!--&lt;dubbo:registry address=&quot;zookeeper://zkOS1:2181?backup=zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;/&gt;--&gt;
    &lt;!--&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;zkOS1:2181,zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;/&gt;--&gt;

    &lt;bean id=&quot;someService&quot; class=&quot;com.abc.provider.SomeServiceImpl&quot;/&gt;

    &lt;dubbo:protocol id=&quot;dp&quot; name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;
    &lt;dubbo:protocol id=&quot;dp2&quot; name=&quot;dubbo&quot; port=&quot;20881&quot;/&gt;
    &lt;dubbo:protocol id=&quot;rp&quot; name=&quot;rmi&quot; port=&quot;9411&quot;/&gt;

    &lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; protocol=&quot;dp,dp2&quot;/&gt;

    &lt;dubbo:provider id=&quot;xxx&quot; timeout=&quot;2000&quot; protocol=&quot;dp&quot; default=&quot;true&quot;/&gt;
    &lt;dubbo:provider id=&quot;ooo&quot; delay=&quot;2000&quot; protocol=&quot;dp2&quot; default=&quot;true&quot;/&gt;
    &lt;dubbo:provider id=&quot;jjj&quot;  /&gt;
    &lt;dubbo:provider id=&quot;kkk&quot;  /&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">- 添加日志</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;properties</span><br><span class="line">    log4j.appender.console&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">    log4j.appender.console.Target&#x3D;System.out</span><br><span class="line">    log4j.appender.console.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">    log4j.appender.console.layout.ConversionPattern&#x3D;[%-5p] %m%n</span><br><span class="line">    log4j.rootLogger&#x3D;info,console</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="将-Dubbo-应用到-web-工程"><a href="#将-Dubbo-应用到-web-工程" class="headerlink" title="将 Dubbo 应用到 web 工程"></a><strong>将</strong> <strong>Dubbo</strong> <strong>应用到</strong> <strong>web</strong> <strong>工程</strong></h2><p>前面所有提供者与消费者均是 Java 工程，而在生产环境中，它们都应是 web 工程，Dubbo如何应用于 Web 工程中呢？</p>
<h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><ul>
<li><p>pom依赖</p>
<ul>
<li><p> dubbo2.7.0 版本依赖</p>
<p> zk 客户端 curator 依赖</p>
<p> servlet 与 jsp 依赖</p>
<p> spring 相关依赖</p>
<p> spring 需要的 commons-logging 依赖</p>
<p> 自定义 00-api 依赖</p>
</li>
<li><pre><code class="xml">&lt;!-- Servlet 依赖 --&gt; 
&lt;dependency&gt; 
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; 
    &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- JSP 依赖 --&gt; 
&lt;dependency&gt; 
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; 
    &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; 
    &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **定义** **web.xml**</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">             xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">             xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_1.xsd&quot;</span><br><span class="line">             version&#x3D;&quot;3.1&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--注册Spring配置文件--&gt;</span><br><span class="line">        &lt;context-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:spring-*.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;context-param&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--注册ServletContext监听器--&gt;</span><br><span class="line">        &lt;listener&gt;</span><br><span class="line">            &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">        &lt;&#x2F;listener&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>修改</strong> <strong>spring-provider.xml</strong>：略</p>
</li>
</ul>
<h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><ul>
<li><p>pom依赖</p>
<ul>
<li><p> dubbo2.7.0 版本依赖</p>
<p> zk 客户端 curator 依赖</p>
<p> servlet 与 jsp 依赖</p>
<p> spring 相关依赖</p>
<p> spring 需要的 commons-logging 依赖</p>
<p> 自定义 00-api 依赖</p>
</li>
</ul>
</li>
<li><p><strong>定义</strong> <strong>web.xml</strong></p>
<ul>
<li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

    &lt;!--对于2.6.4版本，其Spring配置文件必须指定从&lt;context-param&gt;中加载--&gt;
    &lt;!--&lt;context-param&gt;--&gt;
        &lt;!--&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;--&gt;
        &lt;!--&lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;--&gt;
    &lt;!--&lt;/context-param&gt;--&gt;

    &lt;!--字符编码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!--注册中央调度器--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--不能写/*，不建议写/，建议扩展名方式--&gt;
        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **修改** **spring-consumer.xml**：略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># **Dubbo** **管理控制台**</span><br><span class="line"></span><br><span class="line">2019 年初，官方发布了 Dubbo 管理控制台 0.1 版本。结构上采取了前后端分离的方式，前端使用 Vue 和 Vuetify 分别作为 Javascript 框架和 UI 框架，后端采用 Spring Boot 框架。</span><br><span class="line"></span><br><span class="line"> **下载**</span><br><span class="line"></span><br><span class="line">Dubbo 管理控制台的下载地址为：https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;incubator-dubbo-ops</span><br><span class="line"></span><br><span class="line">**配置**</span><br><span class="line"></span><br><span class="line">在下载的 zip 文件的解压目录的 dubbo-admin-server\src\main\resources 下，修改配置文件 application.properties。主要就是修改注册中心、配置中心，与元数据中心的 zk 地址。这是一个 springboot 工程，默认端口号为 8080，若要修改端口号，则在配置文件中增加形如 server.port&#x3D;8888 的配置。</span><br><span class="line"></span><br><span class="line">**打包**</span><br><span class="line"></span><br><span class="line">在命令行窗口中进入到解压目录根目录，执行打包命令。mvn clean package。</span><br><span class="line"></span><br><span class="line">打包结束后，进入到解压目录下的 dubbo-admin-distribution 目录下的 target 目录。目录下有个 dubbo-admin-0.1.jar 文件。该 Jar 包文件即为 Dubbo 管理控制台的运行文件，可以将其放到任意目录下运行。</span><br><span class="line"></span><br><span class="line">**启动zk**</span><br><span class="line"></span><br><span class="line">**启动管控台**</span><br><span class="line"></span><br><span class="line">将 dubbo-admin-0.1.jar 文件存放到任意目录下，例如 D 盘根目录下，直接运行。</span><br><span class="line"></span><br><span class="line">**访问**</span><br><span class="line"></span><br><span class="line">在浏览器地址栏中输入 http:&#x2F;&#x2F;localhost:8080 ，即可看到 Dubbo 管理控制台界面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># **Dubbo** **高级配置**</span><br><span class="line"></span><br><span class="line">&gt; 注意：consumer是从Registry获取provider注册表，所以consumer端也可以设置负载均衡等配置，从而覆盖从Registry获取的注册表</span><br><span class="line">&gt;</span><br><span class="line">&gt; | interface + version + group | provider host | 负载均衡设置 | 请求次数 |</span><br><span class="line">&gt; | --------------------------- | ------------- | ------------ | -------- |</span><br><span class="line">&gt; | someService, 1.00, beijing  | h1, h2,h3     | random       | 3        |</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 关闭服务检查</span><br><span class="line"></span><br><span class="line">默认情况下，若服务消费者先于服务提供者启动，则消费者端会报错。因为默认情况下消费者会在启动时查检其要消费的服务的提供者是否已经注册，若未注册则抛出异常。可以在消费者端的 spring 配置文件中添加 check&#x3D;”false”属性，则可关闭服务检查功能。</span><br><span class="line"></span><br><span class="line">## **多版本控制**</span><br><span class="line"></span><br><span class="line">消费者和生产者都要同步改</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&lt;dubbo:application name=&quot;04-consumer-version&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>&lt;dubbo:registry address=”zookeeper://zkOS:2181” /&gt;</p>
<!--指定消费0.0.1版本，即oldService提供者-->
<!--<dubbo:reference id="someService"  version="0.0.1"-->
<pre><code>             &lt;!--interface=&quot;com.abc.service.SomeService&quot;/&gt;--&gt;</code></pre>
<!--指定消费0.0.2版本，即newService提供者-->
<p>&lt;dubbo:reference id=”someService”  version=”0.0.2”<br>                 interface=”com.abc.service.SomeService”/&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## **服务分组**</span><br><span class="line"></span><br><span class="line">服务分组与多版本控制的使用方式几乎是相同的，只要将 version 替换为 group 即可。</span><br><span class="line"></span><br><span class="line">但使用目的不同。使用版本控制的目的是为了升级，将原有老版本替换掉，将来不再提供老版本的服务，所以不同版本间不能出现相互调用。而分组的目的则不同，其也是针对相同接口，给出了多种实现类。但不同的是，这些不同实现并没有谁替换掉谁的意思，是针对不同需求，或针对不同功能模块所给出的不同实现。这些实现所提供的服务是并存的，所以它们间可以出现相互调用关系。例如，对于支付服务的实现，可以有微信支付实现与支付宝支付实现等。</span><br><span class="line"></span><br><span class="line">## **同一服务支持多种协议**</span><br><span class="line"></span><br><span class="line">这里需要理解这个服务暴露协议的意义。其是指出，消费者若要连接当前的服务，就需要通过这里指定的协议及端口号进行访问。这里的端口号可以是任意的，不一定非要使用默认的端口号（Dubbo 默认为 20880，rmi 默认为 1099）。这里指定的协议名称及端口号，在当前服务注册到注册中心时会一并写入到服务映射表中。当消费者根据服务名称查找到相应主机时，其同时会查询出消费此服务的协议、端口号等信息。其底层就是一个 Socket 编程，通过主机名与端口号进行连接。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:application name&#x3D;&quot;05-provider-group&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dubbo:protocal name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20880&quot;&#x2F;&gt;</span><br><span class="line">	&lt;dubbo:protocal name&#x3D;&quot;rmi&quot; port&#x3D;&quot;1099&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册Service实现类--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;weixinService&quot; class&#x3D;&quot;com.abc.provider.WeixinServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;zhifubaoService&quot; class&#x3D;&quot;com.abc.provider.ZhifubaoServiceImpl&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--暴露服务--&gt;</span><br><span class="line">    &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                   ref&#x3D;&quot;weixinService&quot; group&#x3D;&quot;pay.weixin&quot; protocal&#x3D;&quot;dubbo,rmi&quot;&#x2F;&gt;</span><br><span class="line">    &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                   ref&#x3D;&quot;zhifubaoService&quot; group&#x3D;&quot;pay.zhifubao&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="不同服务使用不同协议"><a href="#不同服务使用不同协议" class="headerlink" title="不同服务使用不同协议"></a><strong>不同服务使用不同协议</strong></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;05-provider-group&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://zkOS:2181&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocal</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocal</span> <span class="attr">name</span>=<span class="string">&quot;rmi&quot;</span> <span class="attr">port</span>=<span class="string">&quot;1099&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--注册Service实现类--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.abc.provider.WeixinServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;zhifubaoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.abc.provider.ZhifubaoServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--暴露服务--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">ref</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.weixin&quot;</span> <span class="attr">protocal</span>=<span class="string">&quot;rmi&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">ref</span>=<span class="string">&quot;zhifubaoService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.zhifubao&quot;</span> <span class="attr">protocal</span>=<span class="string">&quot;dubbo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h2><p>Dubbo 内置了四种负载均衡算法。</p>
<ul>
<li>random</li>
</ul>
<p>随机算法，是 Dubbo 默认的负载均衡算法。存在服务堆积问题。</p>
<ul>
<li><strong>roundrobin</strong></li>
</ul>
<p>轮询算法。按照设定好的权重依次进行调度。</p>
<ul>
<li><strong>leastactive</strong> </li>
</ul>
<p>最少活跃度调度算法。即被调度的次数越少，其优选级就越高，被调度到的机率就越高。</p>
<ul>
<li>consistent hash</li>
</ul>
<p>一致性 hash 算法。对于相同参数的请求，其会被路由到相同的提供者。</p>
<h3 id="消费者端指定"><a href="#消费者端指定" class="headerlink" title="消费者端指定"></a><strong>消费者端指定</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--暴露服务--&gt;</span><br><span class="line">&lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">               ref&#x3D;&quot;weixinService&quot; group&#x3D;&quot;pay.weixin&quot; protocal&#x3D;&quot;rmi&quot; loadBalance&#x3D;&quot;random&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="服务端指定"><a href="#服务端指定" class="headerlink" title="服务端指定"></a>服务端指定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--暴露服务--&gt;</span><br><span class="line">&lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">               ref&#x3D;&quot;weixinService&quot; group&#x3D;&quot;pay.weixin&quot; protocal&#x3D;&quot;rmi&quot; loadBalance&#x3D;&quot;random&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="集群容错策略与重试次数"><a href="#集群容错策略与重试次数" class="headerlink" title="集群容错策略与重试次数"></a><strong>集群容错策略与重试次数</strong></h2><p>集群容错指的是，当消费者调用提供者集群时发生异常的处理方案。</p>
<p>Dubbo 内置了 6 种集群容错策略。</p>
<p> <strong>Failover</strong> </p>
<p>故障转移策略。当消费者调用提供者集群中的某个服务器失败时，其会自动尝试着调用</p>
<p>其它服务器。该策略通常用于读操作，例如，消费者要通过提供者从 DB 中读取某数据。但</p>
<p>重试会带来服务延迟。</p>
<p> <strong>Failfast</strong> </p>
<p>快速失败策略。消费者端只发起一次调用，若失败则立即报错。通常用于非幂等性的写</p>
<p>操作，比如新增记录。</p>
<p>幂等：在请求参数相同的前提下，请求一次与请求 n 次，对系统产生的影响是相同的。</p>
<p> GET：幂等</p>
<p> POST：非幂等</p>
<p> PUT：幂等</p>
<p> DELETE：幂等</p>
<p><strong>Failsafe</strong> </p>
<p>失败安全策略。当消费者调用提供者出现异常时，直接忽略本次消费操作。该策略通常用于执行相对不太重要的服务，例如，写入审计日志等操作。</p>
<p> <strong>Failback</strong> </p>
<p>失败自动恢复策略。消费者调用提供者失败后，Dubbo 会记录下该失败请求，然后定时</p>
<p>自动重新发送该请求。该策略通常用于实时性要求不太高的服务，例如消息通知操作。</p>
<p><strong>Forking</strong> </p>
<p>并行策略。消费者对于同一服务并行调用多个提供者服务器，只要一个成功即调用结束</p>
<p>并返回结果。通常用于实时性要求较高的读操作，但其会浪费较多服务器资源。</p>
<p><strong>Broadcast</strong> </p>
<p>广播策略。广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有</p>
<p>提供者更新缓存或日志等本地资源信息。</p>
<h3 id="消费者端指定-1"><a href="#消费者端指定-1" class="headerlink" title="消费者端指定"></a><strong>消费者端指定</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--暴露服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:ref</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">ref</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.weixin&quot;</span> <span class="attr">cluster</span>=<span class="string">&quot;failfast&quot;</span> <span class="attr">reties</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务端指定-1"><a href="#服务端指定-1" class="headerlink" title="服务端指定"></a>服务端指定</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--暴露服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">ref</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.weixin&quot;</span> <span class="attr">cluster</span>=<span class="string">&quot;failfast&quot;</span> <span class="attr">reties</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="服务降级基础（面试题）"><a href="#服务降级基础（面试题）" class="headerlink" title="服务降级基础（面试题）"></a><strong>服务降级基础（面试题）</strong></h2><p> <strong>什么是服务降级</strong></p>
<p>服务降级，当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务有策略的降低服务级别，以释放服务器资源，保证核心任务的正常运行。</p>
<p><strong>服务降级方式</strong></p>
<p>能够实现服务降级方式很多，常见的有如下几种情况：</p>
<p> 部分服务暂停    </p>
<p> 全部服务暂停</p>
<p> 随机拒绝服务</p>
<p> 部分服务延迟</p>
<p><strong>服务降级与</strong> <strong>Mock</strong> <strong>机制</strong></p>
<p>Dubbo的服务降级采用的是mock机制。其具有两种降级处理方式：Mock Null降级处理，与 Mock Class 降级处理。</p>
<h3 id="Mock-Null降级处理"><a href="#Mock-Null降级处理" class="headerlink" title="Mock Null降级处理"></a>Mock Null降级处理</h3><p>只需要修改服务端</p>
<ul>
<li><p><strong>修改</strong> <strong>pom</strong> <strong>文件</strong>：由于这里不再需要 00-api 工程了，所以在 pom 文件中将对 00-api 工程的依赖删除即可。改为消费者和提供者在自己的项目中保留一份相同的接口</p>
<ul>
<li><pre><code class="java">//consumer自己保留的接口，provider也是如此
package com.abc.service;

public interface UserService &#123;
    String getUsernameById(int id);
    void addUser(String username);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- **修改** **spring-consumer.xml**: mock&#x3D;&quot;return null&quot;</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;userService&quot; mock&#x3D;&quot;return null&quot; check&#x3D;&quot;false&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.UserService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>修改消费者启动类</strong></p>
<ul>
<li><pre><code class="java">public static void main(String[] args) &#123;
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
    UserService service = (UserService) ac.getBean(&quot;userService&quot;);

    // 对于有返回值的方法，其返回结果为null
    String username = service.getUsernameById(3);
    System.out.println(&quot;username = &quot; + username);
    // 对于没有返回值的方法，其没有任何结果
    service.addUser(&quot;China&quot;);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### Mock Class 降级处理</span><br><span class="line"></span><br><span class="line">降级都是指的调用端(consumer)，所以是consumer需要修改</span><br><span class="line"></span><br><span class="line">- **定义** **Mock Class**</span><br><span class="line"></span><br><span class="line">  - 在业务接口所在的包中，本例为 com.abc.service 包，定义一个类，该类的命名需要满足以下规则：业务接口简单类名 + Mock</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    package com.abc.service;</span><br><span class="line">    </span><br><span class="line">    public class UserServiceMock implements UserService &#123;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public String getUsernameById(int id) &#123;</span><br><span class="line">            return &quot;没有该用户：&quot; + id;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public void addUser(String username) &#123;</span><br><span class="line">            System.out.println(&quot;添加该用户失败：&quot; + username);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>修改</strong> <strong>spring-consumer.xml</strong>: mock=”true”</p>
<ul>
<li><pre><code class="xml">    &lt;dubbo:reference id=&quot;userService&quot; mock=&quot;true&quot; check=&quot;false&quot;
                     interface=&quot;com.abc.service.UserService&quot;/&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **服务调用超时**</span><br><span class="line"></span><br><span class="line">前面的服务降级的发生，其实是由于消费者调用服务超时引起的，即从发出调用请求到获取到提供者的响应结果这个时间超出了设定的时限。默认服务调用超时时限为 1 秒。可以在消费者端与提供者端设置超时时限。</span><br><span class="line"></span><br><span class="line">### 生产者</span><br><span class="line"></span><br><span class="line">- **修改依赖**：由于这里不再需要 00-api 工程了，所以在 pom 文件中将对 00-api 工程的依赖删除即可。因为provider and consumer share the same interface in their responding projecct.</span><br><span class="line">- **定义接口实现类**</span><br><span class="line">  - 在 com.abc.provider 包中定义接口的实现类。该实现类中的业务方法添加一个 2 秒的Sleep，以延长向消费者返回结果的时间。</span><br><span class="line"></span><br><span class="line">### 消费者</span><br><span class="line"></span><br><span class="line">- 配置类：timeout&#x3D;&quot;2000&quot;</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;userService&quot; mock&#x3D;&quot;true&quot; timeout&#x3D;&quot;2000&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.UserService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h2><blockquote>
<ul>
<li><p><strong>直接限流</strong></p>
<ul>
<li><p>*executes** <strong>限流</strong> <strong>–</strong> <strong>仅提供者端</strong></p>
<ul>
<li><p>该属性仅能设置在提供者端。可以设置为接口级别，也可以设置为方法级别。限制的是服务（方法）并发执行数量。execute=”10”</p>
</li>
<li><pre><code>    &lt;dubbo:reference ref=&quot;userService&quot;  execute=&quot;10&quot;
                     interface=&quot;com.abc.service.UserService&quot;/&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **accepts** **限流** **–** **仅提供者端**</span><br><span class="line"></span><br><span class="line">  - 该属性仅可设置在提供者端的&lt;dubbo:provider&#x2F;&gt;与&lt;dubbo:protocol&#x2F;&gt;。用于对指定协议的连接数量进行限制。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    限制当前提供者在使用dubbo协议时最多接受10个消费者链接</span><br><span class="line">    &lt;dubbo:provider protocal&#x3D;&quot;dubbo&quot; accepts&#x3D;10&gt;&lt;&#x2F;dubbo:provider&gt;</span><br><span class="line">    </span><br><span class="line">    限制当前提供者在使用dubbo协议时最多接受10个消费者链接</span><br><span class="line">    &lt;dubbo:protocal name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20880&quot; accepts&#x3D;10&gt;&lt;&#x2F;dubbo:protocal&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>actives</strong> <strong>限流</strong> <strong>–</strong> <strong>两端</strong></p>
<ul>
<li><p>该限流方式与前两种不同的是，其可以设置在提供者端，也可以设置在消费者端。可以设置为接口级别，也可以设置为方法级别。</p>
</li>
<li><p><strong>提供者端限流</strong></p>
<p>根据消费者与提供者间建立的连接类型的不同，其意义也不同：</p>
<p> 长连接：表示当前长连接最多可以处理的请求个数。与长连接的数量没有关系。</p>
<p> 短连接：表示当前服务可以同时处理的短连接数量。</p>
<ul>
<li><pre><code class="xml">&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot; actives=&quot;10&quot;/&gt;

&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot;&gt;
    &lt;dubbo:method name=&quot;hello&quot; actives=&quot;10&quot;&gt;&lt;/dubbo:method&gt;
&lt;/dubbo:service&gt;

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **消费者端限流**</span><br><span class="line"></span><br><span class="line">  根据消费者与提供者间建立的连接类型的不同，其意义也不同：</span><br><span class="line"></span><br><span class="line">   长连接：表示当前消费者所发出的长连接中最多可以提交的请求个数。与长连接的数量没有关系。</span><br><span class="line"></span><br><span class="line">   短连接：表示当前消费者可以提交的短连接数量。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot; actives&#x3D;&quot;10&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot;&gt;</span><br><span class="line">    	&lt;dubbo:method name&#x3D;&quot;hello&quot; actives&#x3D;&quot;10&quot;&gt;&lt;&#x2F;dubbo:method&gt;</span><br><span class="line">    &lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>connections</strong> <strong>限流 - 两端</strong> </p>
<ul>
<li><p>可以设置在提供者端，也可以设置在消费者端。限定连接的个数。对于短连接，该属性效果与 actives 相同。但对于长连接，其限制的是长连接的个数。一般情况下，我们会使 connectons 与 actives 联用，让 connections 限制长连接个数，让actives 限制一个长连接中可以处理的请求个数。联用前提：使用默认的 Dubbo 服务暴露协议。</p>
</li>
<li><p><strong>提供者端限流</strong></p>
<ul>
<li><pre><code class="xml">&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot; connections=&quot;10&quot;/&gt;

&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot;&gt;
    &lt;dubbo:method name=&quot;hello&quot; connections=&quot;10&quot;&gt;&lt;/dubbo:method&gt;
&lt;/dubbo:service&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **消费者端限流**</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot; connections&#x3D;&quot;10&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot;&gt;</span><br><span class="line">    	&lt;dubbo:method name&#x3D;&quot;hello&quot; connections&#x3D;&quot;10&quot;&gt;&lt;&#x2F;dubbo:method&gt;</span><br><span class="line">    &lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>间接限流</strong></p>
<ul>
<li><p><strong>延迟连接 **– **仅消费者端</strong></p>
<ul>
<li><p>仅可设置在消费者端，且不能设置为方法级别。仅作用于 Dubbo 服务暴露协议。将长连接的建立推迟到消费者真正调用提供者时。可以减少长连接的数量。</p>
</li>
<li><pre><code class="xml">//消费者端该接口的所有方法都是延迟建立连接
&lt;dubbo:ref interface=&quot;com.abc.service.SomeService&quot; id=&quot;someService&quot; lazy=&quot;true&quot;/&gt;

//消费者端所有接口的所有方法都是延迟建立连接
&lt;dubbo:consumer lazy=&quot;true&quot;&gt;&lt;/dubbo:consumer&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **粘连连接** **–** **仅消费者**</span><br><span class="line"></span><br><span class="line">  - 仅能设置在消费者端，其可以设置为接口级别，也可以设置为方法级别。仅作用于Dubbo 服务暴露协议。其会使客户端尽量向同一个提供者发起调用，除非该提供者挂了，其会连接另一台。只要启用了粘连连接，其就会自动启用延迟连接。其限制的是流向，而非流量。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot; sticky&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot;&gt;</span><br><span class="line">    	&lt;dubbo:method name&#x3D;&quot;hello&quot; connections&#x3D;&quot;10&quot; sticky&#x3D;&quot;true&quot;&gt;&lt;&#x2F;dubbo:method&gt;</span><br><span class="line">    &lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>负载均衡 - 双端</strong></p>
<ul>
<li><p>可以设置在消费者端，亦可设置在提供者端；可以设置在接口级别，亦可设置在方法级别。其限制的是流向，而非流量。</p>
</li>
<li><pre><code>loadBalance=&quot;leastactive&quot;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">## **声明式缓存** - 仅消费者</span><br><span class="line"></span><br><span class="line">为了进一步提高消费者对用户的响应速度，减轻提供者的压力，Dubbo 提供了基于结果的声明式缓存。该缓存是基于消费者端的，所以使用很简单，只需修改消费者配置文件，与提供者无关。</span><br><span class="line"></span><br><span class="line">- **修改消费者配置文件**：仅需在&lt;dubbo:reference&#x2F;&gt;中添加 cache&#x3D;”true”属性即可。</span><br><span class="line">- **默认缓存** **1000** **个结果**: 声明式缓存中可以缓存多少个结果呢？默认可以缓存 1000 个结果。若超出 1000，将采用 LRU 策略来删除缓存，以保证最热的数据被缓存。注意，该删除缓存的策略不能修改。</span><br><span class="line">- **应用场景**: 应用于查询结果不会发生改变的情况，例如，查询某产品的序列号、订单、身份证号等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 多注册中心</span><br><span class="line"></span><br><span class="line">- 消费者</span><br><span class="line"></span><br><span class="line"> - 配置文件</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;xml</span><br><span class="line">         &lt;!--声明注册中心--&gt;</span><br><span class="line">         &lt;dubbo:registry id&#x3D;&quot;bjCenter&quot; address&#x3D;&quot;zookeeper:&#x2F;&#x2F;bjZK:2181&quot;&#x2F;&gt;</span><br><span class="line">         &lt;dubbo:registry id&#x3D;&quot;gzCenter&quot; address&#x3D;&quot;zookeeper:&#x2F;&#x2F;gzZK:2181&quot;&#x2F;&gt;</span><br><span class="line">         &lt;dubbo:registry id&#x3D;&quot;cqCenter&quot; address&#x3D;&quot;zookeeper:&#x2F;&#x2F;cqZK:2181&quot;&#x2F;&gt;</span><br><span class="line">     </span><br><span class="line">         &lt;!--指定调用bjCenter注册中心微信服务--&gt;</span><br><span class="line">         &lt;dubbo:reference id&#x3D;&quot;weixin&quot;  group&#x3D;&quot;pay.weixin&quot; registry&#x3D;&quot;bjCenter&quot;</span><br><span class="line">                          interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br><span class="line">     </span><br><span class="line">         &lt;!--指定调用gzCenter与cqCenter注册中心支付宝服务--&gt;</span><br><span class="line">         &lt;dubbo:reference id&#x3D;&quot;gzZhifubao&quot;  group&#x3D;&quot;pay.zhifubao&quot; registry&#x3D;&quot;gzCenter&quot;</span><br><span class="line">                          interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br><span class="line">         &lt;dubbo:reference id&#x3D;&quot;cqZhifubao&quot;  group&#x3D;&quot;pay.zhifubao&quot; registry&#x3D;&quot;cqCenter&quot;</span><br><span class="line">                          interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br><span class="line">     </span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>生产者</p>
<ul>
<li><p>配置文件</p>
<ul>
<li><pre><code class="xml">    &lt;!--声明注册中心--&gt;
    &lt;dubbo:registry id=&quot;bjCenter&quot; address=&quot;zookeeper://bjZK:2181&quot;/&gt;  &lt;!--北京中心--&gt;
    &lt;dubbo:registry id=&quot;shCenter&quot; address=&quot;zookeeper://shZK:2181&quot;/&gt;  &lt;!--上海中心--&gt;
    &lt;dubbo:registry id=&quot;gzCenter&quot; address=&quot;zookeeper://gzZK:2181&quot;/&gt;  &lt;!--广州中心--&gt;
    &lt;dubbo:registry id=&quot;cqCenter&quot; address=&quot;zookeeper://cqZK:2181&quot;/&gt;  &lt;!--重庆中心--&gt;

    &lt;!--注册Service实现类--&gt;
    &lt;bean id=&quot;weixinService&quot; class=&quot;com.abc.provider.WeixinServiceImpl&quot;/&gt;
    &lt;bean id=&quot;zhifubaoService&quot; class=&quot;com.abc.provider.ZhifubaoServiceImpl&quot;/&gt;

    &lt;!--暴露服务：同一个服务注册到不同的中心；不同的服务注册到不同的中心--&gt;
    &lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot;
                   ref=&quot;weixinService&quot; group=&quot;pay.weixin&quot; register=&quot;bjCenter, shCenter&quot;/&gt;
    &lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot;
                   ref=&quot;zhifubaoService&quot; group=&quot;pay.zhifubao&quot; register=&quot;gzCenter, cqCenter&quot;/&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">## **单功能注册中心** -- 仅提供者，但是提供者和消费者是相对概念</span><br><span class="line"></span><br><span class="line">注册中心提供服务发现、服务注册两种功能，但是某些场景下，我们只想用其中一个功能。</span><br><span class="line"></span><br><span class="line">这些仅订阅或仅注册，只对当前配置文件中的服务起作用，不会影响注册中心本身的功能。</span><br><span class="line"></span><br><span class="line">- **仅订阅**</span><br><span class="line"></span><br><span class="line">  - 概念: 对于某服务来说，其可以发现和调用注册中心中的其它服务，但不能被其它服务发现和调用，这种情形称为仅订阅。简单说就是，仅可去发现，但不能被发现。其底层的实现是，当前服务可以从注册中心下载注册列表，但其不会将自己的信息写入到注册列表。</span><br><span class="line"></span><br><span class="line">  - **设置方式**：对于“仅订阅”注册中心的实现，只需修改提供者配置文件，在&lt;dubbo:registry&#x2F;&gt;标签中添加 register&#x3D;”false”属性。即对于当前服务来说，注册中心不再接受其注册，但该服务可以通过注册中心去发现和调用其它服务。</span><br><span class="line"></span><br><span class="line">- **仅注册**</span><br><span class="line"></span><br><span class="line">  - 概念：对于某服务来说，其可以被注册中心的其它服务发现和调用，但不能发现和调用注册中心中的其它服务，这种情形称为仅注册。简单来说就是，仅可被发现，但不能去发现。[从底层实现来说就是，当前服务可以写入到注册列表，但其不能下载注册列表。]()</span><br><span class="line">  - 设置方式：对于“仅注册”注册中心的实现，[只需修改提供者配置文件]()，在&lt;dubbo:registry&#x2F;&gt;标签中添加 subscribe&#x3D;”false”的属性。即对于当前服务来说，注册中心中的其它服务可以发现和调用当前服务，但其不能发现和调用其它服务。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **服务暴露延迟 -- 仅提供者**</span><br><span class="line"></span><br><span class="line">如果我们的服务启动过程需要 warmup 事件，就可以使用 delay 进行服务延迟暴露。只需在服务提供者的&lt;dubbo:service&#x2F;&gt;标签中添加 delay 属性。其值可以有三类：</span><br><span class="line"></span><br><span class="line"> 正数：单位为毫秒，表示在提供者对象创建完毕后的指定时间后再发布服务。</span><br><span class="line"></span><br><span class="line"> 0：默认值，表示当前提供者创建完毕后马上向注册中心暴露服务。</span><br><span class="line"></span><br><span class="line"> -1：表示在 Spring 容器初始化完毕后再向注册中心暴露服务。</span><br><span class="line"></span><br><span class="line">&gt; [先提供者创建完成，然后Spring容器初始化完成]()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 消费者的异步调用</span><br><span class="line"></span><br><span class="line">在 Dubbo 简介时，我们分析了 Dubbo 的四大组件工作原理图，其中消费者调用提供者采用的是同步调用方式。其实，消费者对于提供者的调用，也可以采用异步方式进行调用。异步调用一般应用于提供者提供的是耗时性 IO 服务。</span><br><span class="line"></span><br><span class="line">比如consumer 需要同时调用 provider 的a服务消耗3ms，b服务5ms</span><br><span class="line"></span><br><span class="line">- 同步的话：消耗&#x3D;3+5</span><br><span class="line">- 异步的话：消耗&#x3D;min（3，5）</span><br><span class="line"></span><br><span class="line">### Future异步执行原理  -- 仅消费者</span><br><span class="line"></span><br><span class="line">异步方法调用执行原理如下图所示，其中实线为同步调用，而虚线为异步调用。</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190803211841665.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5NjUyMDM&#x3D;,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line"> UserThread：消费者线程</span><br><span class="line"></span><br><span class="line"> IOThrea：提供者线程</span><br><span class="line"></span><br><span class="line"> Server：对 IO 型操作的真正执行者</span><br><span class="line"></span><br><span class="line">&gt; get&#x2F;wait方法时阻塞的</span><br><span class="line"></span><br><span class="line">#### 提供者 -- 不需要做任何修改</span><br><span class="line"></span><br><span class="line">#### 消费者</span><br><span class="line"></span><br><span class="line">- 配置文件</span><br><span class="line"></span><br><span class="line">  - Third, Fourth异步方式</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;</span><br><span class="line">        &lt;dubbo:application name&#x3D;&quot;10-consumer-async&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot; &#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;otherService&quot;  timeout&#x3D;&quot;20000&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.OtherService&quot; &gt;</span><br><span class="line">            &lt;dubbo:method name&#x3D;&quot;doThird&quot; async&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;dubbo:method name&#x3D;&quot;doFourth&quot; async&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;dubbo:reference&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>测试类</p>
<ul>
<li><p>测试异步调用的请求时间</p>
<ul>
<li><p>请求非常快，但是没数据</p>
</li>
<li><pre><code>  public static void main(String[] args)
            throws ExecutionException, InterruptedException &#123;
        ApplicationContext ac =
                new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
        OtherService service = (OtherService) ac.getBean(&quot;otherService&quot;);

        // 记录异步调用开始时间
        long asyncStart = System.currentTimeMillis();

        // 异步调用
        service.doThird();
        service.doFourth();

        long syncInvokeTime = System.currentTimeMillis() - asyncStart;
        System.out.println(&quot;两个异步调用共计用时（毫秒）：&quot; + syncInvokeTime);
    &#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 测试异步调用，获取结果的时间</span><br><span class="line"></span><br><span class="line">  - 就比较慢，等待结果返回</span><br><span class="line"></span><br><span class="line">  - 注意：RpcContext.getContext().getFuture()是和异步调用成对出现的</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;java</span><br><span class="line">      String result1 &#x3D; service.doThird();</span><br><span class="line">      System.out.println(&quot;调用结果1 &#x3D; &quot; + result1);</span><br><span class="line">      Future&lt;String&gt; thirdFuture &#x3D; RpcContext.getContext().getFuture();</span><br><span class="line">      </span><br><span class="line">      String result3 &#x3D; service.doFourth();</span><br><span class="line">      System.out.println(&quot;调用结果3 &#x3D; &quot; + result3);</span><br><span class="line">      Future&lt;String&gt; fourFuture &#x3D; RpcContext.getContext().getFuture();</span><br></pre></td></tr></table></figure>

- 错误写法是: 导致thirdFuture和fourFuture都是最近的调用service.doFourth()的结果

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String result1 = service.doThird();</span><br><span class="line">String result3 = service.doFourth();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;调用结果1 = &quot;</span> + result1);</span><br><span class="line">Future&lt;String&gt; thirdFuture = RpcContext.getContext().getFuture();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;调用结果3 = &quot;</span> + result3);</span><br><span class="line">Future&lt;String&gt; fourFuture = RpcContext.getContext().getFuture();</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- ```java
  public static void main(String[] args)
              throws ExecutionException, InterruptedException &#123;
          ApplicationContext ac =
                  new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
          OtherService service = (OtherService) ac.getBean(&quot;otherService&quot;);

          // 记录异步调用开始时间
          long asyncStart = System.currentTimeMillis();

          // 异步调用
          String result1 = service.doThird();
          System.out.println(&quot;调用结果1 = &quot; + result1);
          Future&lt;String&gt; thirdFuture = RpcContext.getContext().getFuture();

          String result3 = service.doFourth();
          System.out.println(&quot;调用结果3 = &quot; + result3);
          Future&lt;String&gt; fourFuture = RpcContext.getContext().getFuture();

          // 阻塞
          String result2 = thirdFuture.get();
          System.out.println(&quot;调用结果2 = &quot; + result2);
          String result4 = fourFuture.get();
          System.out.println(&quot;调用结果4 = &quot; + result4);

          long useTime = System.currentTimeMillis() - asyncStart;
          System.out.println(&quot;获取到异步调用结果共计用时：&quot; + useTime);
      &#125;
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">### **CompletableFuture** **异步调用**  -- 消费者和生产者</span><br><span class="line"></span><br><span class="line">使用 Future 实现异步调用，对于无需获取返回值的操作来说不存在问题，但消费者若需要获取到最终的异步执行结果，则会出现问题：消费者在使用 Future 的 get()方法获取返回值时被阻塞, CPU被无意义的轮休消耗。</span><br><span class="line"></span><br><span class="line">为了解决这个问题，Dubbo 又引入了 CompletableFuture 来实现对提供者的异步调用。</span><br><span class="line"></span><br><span class="line">#### 消费者</span><br><span class="line"></span><br><span class="line">- 配置文件去除asyn属性</span><br><span class="line"></span><br><span class="line">- 公共接口类</span><br><span class="line"></span><br><span class="line">  - 以前是</span><br><span class="line"></span><br></pre></td></tr></table></figure>
public interface OtherService &#123;
    String doFirst();
    String doSecond();
    String doThird();
    String doFourth();
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 现在是</span><br><span class="line"></span><br></pre></td></tr></table></figure>
public interface OtherService &#123;
    String doFirst();
    String doSecond();

    CompletableFuture&lt;String&gt; doThird();
    CompletableFuture&lt;String&gt; doFourth();
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 主函数使用CompletableFuture</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">     public static void main(String[] args)</span><br><span class="line">                throws ExecutionException, InterruptedException &#123;</span><br><span class="line">            ApplicationContext ac &#x3D;</span><br><span class="line">                    new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);</span><br><span class="line">            OtherService service &#x3D; (OtherService) ac.getBean(&quot;otherService&quot;);</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; 记录异步调用开始时间</span><br><span class="line">            long asyncStart &#x3D; System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; 异步调用</span><br><span class="line">            CompletableFuture&lt;String&gt; doThirdFuture &#x3D; service.doThird();</span><br><span class="line">            CompletableFuture&lt;String&gt; doFourthFuture &#x3D; service.doFourth();</span><br><span class="line">    </span><br><span class="line">            long syncInvokeTime &#x3D; System.currentTimeMillis() - asyncStart;</span><br><span class="line">            System.out.println(&quot;两个异步调用共计用时（毫秒）：&quot; + syncInvokeTime);</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; 回调方法</span><br><span class="line">            doThirdFuture.whenComplete((result, throwable) -&gt; &#123;</span><br><span class="line">                if(throwable !&#x3D; null) &#123;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;异步调用提供者的doThird()返回值：&quot; + result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">            doFourthFuture.whenComplete((result, throwable) -&gt; &#123;</span><br><span class="line">                if(throwable !&#x3D; null) &#123;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;异步调用提供者的doFourth()返回值：&quot; + result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">            long getResultTime &#x3D; System.currentTimeMillis() - asyncStart;</span><br><span class="line">            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;（毫秒）：&quot; + getResultTime);</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><ul>
<li><p>和consumer一样，把公共接口类改了</p>
<ul>
<li><p>以前具体的接口实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String doThird() &#123;</span><br><span class="line">	sleep();</span><br><span class="line">	return &quot;doThird()&quot;;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>现在具体的接口实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="comment">// 耗时操作仍由业务线程调用</span></span><br><span class="line">       sleep();</span><br><span class="line">       CompletableFuture&lt;String&gt; future =</span><br><span class="line">               CompletableFuture.completedFuture(<span class="string">&quot;doThird()-----&quot;</span>);</span><br><span class="line">       <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">long</span> useTime = endTime - startTime;</span><br><span class="line">       System.out.println(<span class="string">&quot;doThird()方法执行用时：&quot;</span> + useTime);</span><br><span class="line">       <span class="keyword">return</span> future;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>Future 与 CompletableFuture 的对比：</p>
<ul>
<li><p>Future：Dubbo2.7.0 版本之前消费者异步调用提供者的实现方式。源自于 JDK5，对异步结果的获取采用了阻塞与轮询方式。</p>
</li>
<li><p>CompletableFuture：Dubbo2.7.0 版本之后消费者异步调用提供者的实现方式。源自于JDK8，对异步结果的获取采用了回调的方式。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://deepakvadgama.com/blog/completable-future-internals/">介绍Future与CompletableFuture的文章</a></p>
<h2 id="提供者的异步执行"><a href="#提供者的异步执行" class="headerlink" title="提供者的异步执行"></a><strong>提供者的异步执行</strong></h2><p>从前面“对提供者的异步调用”例子可以看出，消费者对提供者实现了异步调用，消费者线程的执行过程不再发生阻塞，但提供者对 IO 耗时操作仍采用的是同步调用，即 IO 操作仍会阻塞 Dubbo 的提供者线程。</p>
<blockquote>
<p>但需要注意，提供者对 IO 操作的异步调用，并不会提升 RPC 响应速度，因为耗时操作终归是需要消耗那么多时间后才能给出结果的。</p>
<p>对用户体验没什么提升，就是接口延迟；但是极大的提升了吞吐量，不再阻塞业务线程。</p>
</blockquote>
<ul>
<li><p>以前接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 耗时操作仍由业务线程调用, 所以阻塞了业务线程</span></span><br><span class="line">    sleep();</span><br><span class="line">    CompletableFuture&lt;String&gt; future =</span><br><span class="line">        CompletableFuture.completedFuture(<span class="string">&quot;doThird()-----&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> useTime = endTime - startTime;</span><br><span class="line">    System.out.println(<span class="string">&quot;doThird()方法执行用时：&quot;</span> + useTime);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在具体的接口实现:<font color="red"> 耗时操作不再由业务线程直接调用</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="comment">// 异步调用耗时操作</span></span><br><span class="line">       CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           <span class="comment">// 耗时操作是由CompletableFuture调用的，而不是由业务线程直接调用，所以不再阻塞业务线程</span></span><br><span class="line">           sleep();</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;doThird()&quot;</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;doThird()方法执行用时：&quot;</span> + (endTime - startTime));</span><br><span class="line">       <span class="keyword">return</span> future;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="属性配置优先级"><a href="#属性配置优先级" class="headerlink" title="属性配置优先级"></a><strong>属性配置优先级</strong></h2><p>Dubbo 配置文件中各个标签属性配置的优先级总原则是：</p>
<ul>
<li><p>方法级优先，接口级(服务级)次之，全局配置再次之。</p>
</li>
<li><p>如果级别一样，则消费方优先，提供方次之。</p>
</li>
</ul>
<p>另外，还有两个标签需要说明一下：</p>
<ul>
<li><p><a href="dubbo:consumer/">dubbo:consumer/</a>设置在消费者端，用于设置消费者端的默认配置，即消费者端的全局设置。当然也可以设置在提供者端。但是以消费者优先级高</p>
</li>
<li><p><a href="dubbo:provider/">dubbo:provider/</a>设置在提供者端，用于设置提供者端的默认配置，即提供者端的默认配置。当然也可以设置在消费者端。但是以消费者优先级高</p>
</li>
</ul>
<p><strong>配置建议</strong></p>
<p><strong>provider</strong> <strong>上配置合理的</strong> <strong>provider</strong> <strong>端属性</strong></p>
<p><strong>在</strong> <strong>provider</strong> <strong>上尽量多配置</strong> <strong>consumer</strong> <strong>端属性</strong></p>
<ul>
<li>因为provider更清楚自己的性能和服务</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ-01-%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ-01-%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">RocketMQ-01-入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-01 17:33:31" itemprop="dateCreated datePublished" datetime="2021-03-01T17:33:31+08:00">2021-03-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/20/database/redis/redis-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/20/database/redis/redis-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">redis-面试问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-20 10:22:35" itemprop="dateCreated datePublished" datetime="2021-02-20T10:22:35+08:00">2021-02-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-21 14:14:32" itemprop="dateModified" datetime="2023-03-21T14:14:32+08:00">2023-03-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p>【问题】</p>
<ul>
<li>Redis 有哪些数据类型？</li>
<li>Redis 的数据类型分别适用于什么样的场景？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 数据类型和应用\</em></strong></p>
<p>数据类型的特性和应用细节点较多，详情可以参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial/blob/master/docs/nosql/redis/redis-datatype.md">Redis 数据类型(opens new window)</a></p>
</blockquote>
<p>（1）Redis 支持五种基本数据类型：</p>
<ul>
<li>String：常用于 KV 缓存</li>
<li>Hash：存储结构化数据，如：产品信息、用户信息等。</li>
<li>List：存储列表，如：粉丝列表、文章评论列表等。可以通过 lrange 命令进行分页查询。</li>
<li>Set：存储去重列表，如：粉丝列表等。可以基于 set 玩儿交集、并集、差集的操作。例如：求两个人的共同好友列表。</li>
<li>Sorted Set：存储含评分的去重列表，如：各种排行榜。</li>
</ul>
<p>（2）除此以外，还有 Bitmaps、HyperLogLogs、GEO、Streams 等高级数据类型。</p>
<h2 id="Redis-zset跳表和压缩表"><a href="#Redis-zset跳表和压缩表" class="headerlink" title="Redis zset跳表和压缩表"></a>Redis zset跳表和压缩表</h2><p>ZSet 有两种不同的实现，分别是 ziplist 和 skiplist。具体使用哪种结构进行存储，规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ziplist：满足以下两个条件</span><br><span class="line"></span><br><span class="line">- [value,score] 键值对数量少于 128 个</span><br><span class="line"></span><br><span class="line">- 每个元素的长度小于 64 字节</span><br><span class="line"></span><br><span class="line">skiplist：不满足以上两个条件时使用跳表、组合了 hash 和 skiplist</span><br><span class="line"></span><br><span class="line">- hash 用来存储 value 到 score 的映射，这样就可以在 O(1) 时间内找到 value 对应的分数</span><br><span class="line"></span><br><span class="line">- skiplist 按照从小到大的顺序存储分数</span><br></pre></td></tr></table></figure>

<p>skiplist 每个元素的值都是 [value,score] 对使用 ziplist 的示意图如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210516211822874.png" alt="在这里插入图片描述"><br>使用跳表时的示意图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210516211842414.png" alt="在这里插入图片描述"><br>ziplist 压缩列表本文不是重点讨论范围，我们着重来看下跳跃表 skiplist。</p>
<h2 id="Redis-内存淘汰"><a href="#Redis-内存淘汰" class="headerlink" title="Redis 内存淘汰"></a>Redis 内存淘汰</h2><p>【问题】</p>
<ul>
<li>Redis 有哪些内存淘汰策略？</li>
<li>这些淘汰策略分别适用于什么场景？</li>
<li>Redis 有哪些删除失效 key 的方法？</li>
<li>如何设置 Redis 中键的过期时间？</li>
<li>如果让你实现一个 LRU 算法，怎么做？</li>
</ul>
<hr>
<p>【解答】</p>
<p>（1）Redis 过期策略是：<strong>定期删除+惰性删除</strong>。</p>
<ul>
<li>消极方法（passive way），在主键被访问时如果发现它已经失效，那么就删除它。</li>
<li>主动方法（active way），定期从设置了失效时间的主键中选择一部分失效的主键删除。</li>
</ul>
<p>（2）Redis 内存淘汰策略：</p>
<ul>
<li><strong><code>noeviction</code></strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。</li>
<li><strong><code>allkeys-lru</code></strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>allkeys-random</code></strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-lru</code></strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>volatile-random</code></strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-ttl</code></strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li>
</ul>
<p>（3）如何选择内存淘汰策略：</p>
<ul>
<li>如果数据呈现幂等分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 <code>allkeys-lru</code>。</li>
<li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 <code>allkeys-random</code>。</li>
<li><code>volatile-lru</code> 策略和 <code>volatile-random</code> 策略适合我们将一个 Redis 实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果。</li>
<li>将 key 设置过期时间实际上会消耗更多的内存，因此我们建议使用 <code>allkeys-lru</code> 策略从而更有效率的使用内存。</li>
</ul>
<p>（4）LRU 算法实现思路：可以继承 LinkedHashMap，并覆写 removeEldestEntry 方法来实现一个最简单的 LRUCache</p>
<h2 id="Redis大Key删除"><a href="#Redis大Key删除" class="headerlink" title="Redis大Key删除"></a>Redis大Key删除</h2><h3 id="1-异步删除"><a href="#1-异步删除" class="headerlink" title="(1) 异步删除"></a>(1) 异步删除</h3><ul>
<li>开启lazy free功能，如果触发自动过期删除，则会异步执行</li>
<li>使用unlink命令手动触发，会异步执行删除操作</li>
</ul>
<h3 id="2-使用分批删除"><a href="#2-使用分批删除" class="headerlink" title="(2) 使用分批删除"></a>(2) 使用分批删除</h3><p>对于集合类型的数据，可以通过客户端手动scan轮询的方式，每次只删除一部分的数据</p>
<h2 id="Redis实现限流"><a href="#Redis实现限流" class="headerlink" title="Redis实现限流"></a>Redis实现限流</h2><h3 id="第一种：基于Redis的setnx的操作"><a href="#第一种：基于Redis的setnx的操作" class="headerlink" title="第一种：基于Redis的setnx的操作"></a>第一种：基于Redis的setnx的操作</h3><p>我们在使用Redis的分布式锁的时候，大家都知道是依靠了setnx的指令，在CAS（Compare and swap）的操作的时候，同时给指定的key设置了过期实践（expire），我们在限流的主要目的就是为了在单位时间内，有且仅有N数量的请求能够访问我的代码程序。所以依靠setnx可以很轻松的做到这方面的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setNx(key, 20, 10,TimeUnit.Seconds)</span><br></pre></td></tr></table></figure>

<p>比如我们需要在10秒内限定20个请求，那么我们在setnx的时候可以设置过期时间10，当请求的setnx数量达到20时候即达到了限流效果。代码比较简单就不做展示了。当然这种做法的弊端是很多的，比如当统计1-10秒的时候，无法统计2-11秒之内，如果需要统计N秒内的M个请求，那么我们的Redis中需要保持N个key等等问题</p>
<h3 id="第二种：基于Redis的数据结构zset"><a href="#第二种：基于Redis的数据结构zset" class="headerlink" title="第二种：基于Redis的数据结构zset"></a>第二种：基于Redis的数据结构zset</h3><p>其实限流涉及的最主要的就是滑动窗口，上面也提到1-10怎么变成2-11。其实也就是起始值和末端值都各+1即可。</p>
<p>而我们如果用Redis的list数据结构可以轻而易举的实现该功能</p>
<p>我们可以将请求打造成一个zset数组，当每一次请求进来的时候，value保持唯一，可以用UUID生成，而score可以用当前时间戳表示，因为score我们可以用来计算当前时间戳之内有多少的请求数量。而zset数据结构也提供了range方法让我们可以很轻易的获取到2个时间戳内有多少请求</p>
<img src="https://img-blog.csdnimg.cn/img_convert/e15884cf9931cea8d8c2e88b94c7858c.webp?x-oss-process=image/format,png" alt="image.png" style="zoom:50%;" />





<img src="https://img-blog.csdnimg.cn/img_convert/cca8d7792e4958d52a43ff661ef7de74.webp?x-oss-process=image/format,png" alt="image.png" style="zoom:67%;" />

<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>【问题】</p>
<ul>
<li>Redis 有几种持久化方式？</li>
<li>Redis 的不同持久化方式的特性和原理是什么？</li>
<li>RDB 和 AOF 各有什么优缺点？分别适用于什么样的场景？</li>
<li>Redis 执行持久化时，可以处理请求吗？</li>
<li>AOF 有几种同步频率？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 持久化\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-persistence.html">Redis 持久化</a></p>
</blockquote>
<p>（1）Redis 支持两种持久化方式：RDB 和 AOF。</p>
<p>（2）RDB 即某一时刻的二进制数据快照。</p>
<p>Redis 会周期性生成 RDB 文件。</p>
<p>生成 RDB 流程：Redis fork 一个子进程，负责生成 RDB；生成 RDB 采用 Copy On Write 模式，此时，如果收到写请求，会在原副本上操作，不影响工作。</p>
<p>RDB 只能恢复生成快照时刻的数据，之后的数据无法恢复。生成 RDB 的资源开销高昂。RDB 适合做冷备。</p>
<p>（3）AOF 会将写命令不断追加到 AOF 文本日志末尾。</p>
<p>AOF 丢数据比 RDB 少，但文件会比 RDB 文件大很多。</p>
<p>一般，AOF 设置 <code>appendfsync</code> 同步频率为 <strong><code>everysec</code></strong> 即可。</p>
<p>（4）RDB or AOF</p>
<p>建议同时使用 RDB 和 AOF。用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>【问题】</p>
<ul>
<li>Redis 的并发竞争问题是什么？如何解决这个问题？</li>
<li>Redis 支持事务吗？</li>
<li>Redis 事务是严格意义的事务吗？Redis 为什么不支持回滚。</li>
<li>Redis 事务如何工作？</li>
<li>了解 Redis 事务中的 CAS 行为吗？</li>
</ul>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 的事务特性、原理\</em></strong></p>
<p>详情参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-quickstart.html#%E5%85%ADredis-%E4%BA%8B%E5%8A%A1">Redis 应用指南之 事务</a></p>
</blockquote>
<p><strong>Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去</strong>。</p>
<p>Redis 不支持回滚的理由：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p><code>MULTI</code> 、 <code>EXEC</code> 、 <code>DISCARD</code> 和 <code>WATCH</code> 是 Redis 事务相关的命令。</p>
<p>Redis 有天然解决这个并发竞争问题的类 CAS 乐观锁方案：每次要<strong>写之前，先判断</strong>一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>
<h2 id="Redis-管道"><a href="#Redis-管道" class="headerlink" title="#Redis 管道"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E7%AE%A1%E9%81%93">#</a>Redis 管道</h2><p>【问题】</p>
<ul>
<li>除了事务，还有其他批量执行 Redis 命令的方式吗？</li>
</ul>
<p>【解答】</p>
<p>Redis 是一种基于 C/S 模型以及请求/响应协议的 TCP 服务。Redis 支持管道技术。管道技术允许请求以异步方式发送，即旧请求的应答还未返回的情况下，允许发送新请求。这种方式可以大大提高传输效率。使用管道发送命令时，Redis Server 会将部分请求放到缓存队列中（占用内存），执行完毕后一次性发送结果。如果需要发送大量的命令，会占用大量的内存，因此应该按照合理数量分批次的处理。</p>
<h2 id="Redis-高并发"><a href="#Redis-高并发" class="headerlink" title="#Redis 高并发"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E9%AB%98%E5%B9%B6%E5%8F%91">#</a>Redis 高并发</h2><p>【问题】</p>
<ul>
<li>Redis 是单线程模型，为何吞吐量还很高？</li>
<li>Redis 的 IO 多路复用原理是什么？</li>
<li>Redis 集群如何分片和寻址？</li>
<li>Redis 集群如何扩展？</li>
<li>Redis 集群如何保证数据一致？</li>
<li>Redis 集群如何规划？你们公司的生产环境上如何部署 Redis 集群？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 集群\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-cluster.html">Redis 集群</a></p>
</blockquote>
<p>（1）单线程</p>
<p>Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 单机吞吐量也很高，能达到几万 QPS。</p>
<p>Redis 单线程模型，依然有很高的并发吞吐，原因在于：</p>
<ul>
<li>Redis 读写都是内存操作。</li>
<li>Redis 基于<strong>非阻塞的 IO 多路复用机制</strong>，同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</li>
<li>单线程，避免了线程创建、销毁、上下文切换的开销，并且避免了资源竞争。</li>
</ul>
<p>（2）扩展并发吞吐量、存储容量</p>
<p>Redis 的高性能（扩展并发吞吐量、存储容量）通过主从架构来实现。</p>
<p>Redis 集群采用主从模型，提供复制和故障转移功能，来保证 Redis 集群的高可用。通常情况，一主多从模式已经可以满足大部分项目的需要。根据实际的并发量，可以通过增加节点来扩展并发吞吐。</p>
<p>一主多从模式下，主节点负责写操作（单机几万 QPS），从节点负责查询操作（单机十万 QPS）。</p>
<p>进一步，如果需要缓存大量数据，就需要分区（sharding）。Redis 集群通过划分虚拟 hash 槽来分片，每个主节点负责一定范围的 hash 槽。当需要扩展集群节点时，重新分配 hash 槽即可，redis-trib 会自动迁移变更 hash 槽中所属的 key。</p>
<p>（3）Redis 集群数据一致性</p>
<p>Redis 集群基于复制特性实现节点间的数据一致性。</p>
<h2 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="#Redis 复制"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E5%A4%8D%E5%88%B6">#</a>Redis 复制</h2><p>【问题】</p>
<ul>
<li>Redis 复制的工作原理？Redis 旧版复制和新版复制有何不同？</li>
<li>Redis 主从节点间如何复制数据？</li>
<li>Redis 的数据一致性是强一致性吗？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 复制\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-replication.html">Redis 复制</a></p>
</blockquote>
<p>（1）旧版复制基于 <code>SYNC</code> 命令实现。分为同步（sync）和命令传播（command propagate）两个操作。这种方式存在缺陷：不能高效处理断线重连后的复制情况。</p>
<p>（2）新版复制基于 <code>PSYNC</code> 命令实现。同步操作分为了两块：</p>
<ul>
<li><p><strong><code>完整重同步（full resychronization）</code></strong> 用于初次复制；</p>
</li>
<li><p><code>部分重同步（partial resychronization）</code></p>
</li>
</ul>
<p>  用于断线后重复制。</p>
<ul>
<li>主从服务器的<strong>复制偏移量（replication offset）</strong></li>
<li>主服务器的<strong>复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行 ID</strong></li>
</ul>
<p>（3）Redis 集群主从节点复制的工作流程：</p>
<ul>
<li>步骤 1. 设置主从服务器</li>
<li>步骤 2. 主从服务器建立 TCP 连接。</li>
<li>步骤 3. 发送 PING 检查通信状态。</li>
<li>步骤 4. 身份验证。</li>
<li>步骤 5. 发送端口信息。</li>
<li>步骤 6. 同步。</li>
<li>步骤 7. 命令传播。</li>
</ul>
<h2 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="#Redis 哨兵"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E5%93%A8%E5%85%B5">#</a>Redis 哨兵</h2><p>【问题】</p>
<ul>
<li>Redis 如何实现高可用？</li>
<li>Redis 哨兵的功能？</li>
<li>Redis 哨兵的原理？</li>
<li>Redis 哨兵如何选举 Leader？</li>
<li>Redis 如何实现故障转移？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 哨兵\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-sentinel.html">Redis 哨兵</a></p>
</blockquote>
<p>（1）Redis 的高可用是通过哨兵来实现（Raft 协议的 Redis 实现）。Sentinel（哨兵）可以监听主服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<p>由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200131135847.png" alt="img"></p>
<h2 id="Redis-vs-Memcached"><a href="#Redis-vs-Memcached" class="headerlink" title="#Redis vs. Memcached"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-vs-memcached">#</a>Redis vs. Memcached</h2><p>【问题】</p>
<p>Redis 和 Memcached 有什么区别？</p>
<p>分布式缓存技术选型，选 Redis 还是 Memcached，为什么？</p>
<p>Redis 和 Memcached 各自的线程模型是怎样的？</p>
<p>为什么单线程的 Redis 性能却不输于多线程的 Memcached？</p>
<p>【解答】</p>
<p>Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。memcache 支持简单的数据类型，String。</p>
<p>Redis 支持数据的备份，即 master-slave 模式的数据备份。</p>
<p>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中</p>
<p>redis 的速度比 memcached 快很多</p>
<p>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的 IO 复用模型。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/19/database/redis/redis-6-%E9%94%81%E4%B8%8E3%E7%A7%8D%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/19/database/redis/redis-6-%E9%94%81%E4%B8%8E3%E7%A7%8D%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">redis-6-锁与常见缓存问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-19 17:54:12" itemprop="dateCreated datePublished" datetime="2021-02-19T17:54:12+08:00">2021-02-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-09 14:11:38" itemprop="dateModified" datetime="2021-06-09T14:11:38+08:00">2021-06-09</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis实现乐观锁"><a href="#Redis实现乐观锁" class="headerlink" title="Redis实现乐观锁"></a>Redis实现乐观锁</h1><h2 id="Redis乐观锁"><a href="#Redis乐观锁" class="headerlink" title="Redis乐观锁"></a>Redis乐观锁</h2><p>乐观锁基于CAS(Compare And Swap)思想(比较并替换)，是不具有互斥性，不会产生锁等待而消 耗资源，但是需要反复的重试，但也是因为重试的机制，能比较快的响应。因此我们可以利用redis来 实现乐观锁。</p>
<p>具体思路如下:</p>
<ul>
<li>监控 锁定量</li>
<li>如果该值被修改成功则表示该请求被通过， 反之表示该请求未通过。</li>
<li>从监控到修改到执行都需要在redis里操作，这样就需要用 到Redis事务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String watchKeys = <span class="string">&quot;watchKeys&quot;</span>; </span><br><span class="line">        <span class="comment">//初始值 </span></span><br><span class="line">        value=<span class="number">1</span> jedis.set(watchKeys, <span class="number">1</span>); </span><br><span class="line">        <span class="comment">//监听key为watchKeys的值 </span></span><br><span class="line">      	jedis.watch(watchkeys);</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        Transaction tx = jedis.multi();</span><br><span class="line">        <span class="comment">//watchKeys自增加一 </span></span><br><span class="line">      	tx.incr(watchKeys);</span><br><span class="line">        <span class="comment">//执行事务，如果其他线程对watchKeys中的value进行修改，则该事务将不会执行 </span></span><br><span class="line">      	<span class="comment">//通过redis事务以及watch命令实现乐观锁</span></span><br><span class="line">        List&lt;Object&gt; exec = tx.exec();</span><br><span class="line">        <span class="keyword">if</span> (exec == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;事务未执行&quot;</span>); &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;事务成功执行，watchKeys的value成功修改&quot;</span>); &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis乐观锁实现秒杀"><a href="#Redis乐观锁实现秒杀" class="headerlink" title="Redis乐观锁实现秒杀"></a>Redis乐观锁实现秒杀</h2><p>在生产环境里，经常会利用redis乐观锁来实现秒杀，Redis乐观锁是Redis事务的经典应用。</p>
<p>由于秒杀只有少部分请求能够成功，而大量的请求是并发产生的，所以如何确定哪个请求成功了，就是 由redis乐观锁来实现。</p>
<p>具体思路如下:</p>
<ul>
<li>监控锁定量，如果该值被修改了，那么则会失败，反之，成功。<a href="">用户首先尝试获取秒杀的资格。(通过事务watch()函数)</a></li>
<li><a href="">用户获取秒杀资格后，再去检查库存是否有库存(通过事务检查库存)</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKill</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//库存key</span></span><br><span class="line">          String redisKey = <span class="string">&quot;stock&quot;</span>;</span><br><span class="line">          ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6378</span>); </span><br><span class="line">              <span class="comment">// 可以被秒杀的库存的初始值，库存总共20个 </span></span><br><span class="line">              jedis.set(redisKey, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">              jedis.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">          executorService.execute(() -&gt; &#123;</span><br><span class="line">            Jedis jedis1 = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6378</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jedis1.watch(redisKey);<span class="comment">//乐观锁的核心业务</span></span><br><span class="line">                String redisValue = jedis1.get(redisKey);</span><br><span class="line">                <span class="keyword">int</span> valInteger = Integer.valueOf(redisValue);</span><br><span class="line">                String userInfo = UUID.randomUUID().toString();</span><br><span class="line">                <span class="comment">//用户成功获取抢夺的资格，然后检查库存量</span></span><br><span class="line">                <span class="keyword">if</span> (valInteger &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                    Transaction tx = jedis1.multi(); </span><br><span class="line">                  	tx.incr(redisKey);</span><br><span class="line">                    List list = tx.exec();</span><br><span class="line">                    <span class="comment">// 秒成功 失败返回空list而不是空</span></span><br><span class="line">                    <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;用户:&quot;</span> + userInfo + <span class="string">&quot;，秒杀成功!当前成功人数:&quot;</span> +(valInteger + <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 版本变化，被别人抢了。 </span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;用户:&quot;</span> + userInfo + <span class="string">&quot;，秒杀失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 秒完了 </span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;已经有20人秒杀成功，秒杀结束&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              	e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              	jedis1.close();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>



<h1 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h1><ul>
<li>单应用中使用锁(单进程多线程)： synchronized、ReentrantLock </li>
<li>分布式应用中使用锁(多进程多线程) ：分布式锁是控制分布式系统之间同步访问共享资源的一种方式</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用Redis的单线程特性对共享资源进行串行化处理</p>
<h2 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h2><h3 id="方式1（使用set命令实现）–推荐"><a href="#方式1（使用set命令实现）–推荐" class="headerlink" title="方式1（使用set命令实现）–推荐"></a>方式1（使用set命令实现）–推荐</h3><ul>
<li>“NX”:没有键值则设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 使用redis的set命令实现获取分布式锁 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> lockKey 可以就是锁 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> requestId 请求ID，保证同一性 uuid+threadID </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> expireTime 过期时间，避免死锁 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String lockKey,String requestId,<span class="keyword">int</span> expireTime)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//NX:保证互斥性 // hset 原子性操作 </span></span><br><span class="line">    String result = jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTime); </span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;OK&quot;</span>.equals(result)) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方式2（使用setnx命令实现）-–-并发会产生问题"><a href="#方式2（使用setnx命令实现）-–-并发会产生问题" class="headerlink" title="方式2（使用setnx命令实现） – 并发会产生问题"></a>方式2（使用setnx命令实现） – 并发会产生问题</h3><p><a href="">因为2个redis操作，即设置key和设置expireTime，不是原子性的复合操作，所以会有并发问题</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String lockKey,String requestId,<span class="keyword">int</span> expireTime)</span> </span>&#123; </span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId); </span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//成功设置 失效时间 </span></span><br><span class="line">        jedis.expire(lockKey, expireTime); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><h3 id="方式1（del命令实现）-–-并发会产生问题"><a href="#方式1（del命令实现）-–-并发会产生问题" class="headerlink" title="方式1（del命令实现） – 并发会产生问题"></a>方式1（del命令实现） – 并发会产生问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 释放分布式锁 * <span class="doctag">@param</span> lockKey * <span class="doctag">@param</span> requestId */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(String lockKey,String requestId)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123; </span><br><span class="line">        jedis.del(lockKey); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题在于如果调用jedis.del()方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的 锁。</p>
<p>那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行 jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将 客户端B的锁给解除了。</p>
</blockquote>
<h3 id="方式2（redis-lua脚本实现）–-推荐"><a href="#方式2（redis-lua脚本实现）–-推荐" class="headerlink" title="方式2（redis+lua脚本实现）– 推荐"></a>方式2（redis+lua脚本实现）– 推荐</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String lockKey, String requestId)</span> </span>&#123; </span><br><span class="line">    String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); </span><br><span class="line">    <span class="keyword">if</span> (result.equals(<span class="number">1L</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Redis常见缓存问题"><a href="#Redis常见缓存问题" class="headerlink" title="Redis常见缓存问题"></a>Redis常见缓存问题</h1><h2 id="数据读"><a href="#数据读" class="headerlink" title="数据读"></a>数据读</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote>
<p>查询缓存中永远不存在的一个值。因为这个值数据库没有。 </p>
</blockquote>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。</p>
<p>也就是说，对不存在的key进行高并发访问，导致数据库压力瞬间增大，这就叫做【缓存穿透】。</p>
<h4 id="解决方案1：缓存null数据"><a href="#解决方案1：缓存null数据" class="headerlink" title="解决方案1：缓存null数据"></a>解决方案1：缓存null数据</h4><p>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>
<h4 id="解决方案2：布隆空滤器"><a href="#解决方案2：布隆空滤器" class="headerlink" title="解决方案2：布隆空滤器"></a>解决方案2：布隆空滤器</h4><p>布隆过滤器是一种比较特殊的数据结构，有点类似与HashMap，在业务中我们可能会通过使用HashMap来判断一个值是否存在，它可以在<code>O(1)</code>时间复杂度内返回结果，效率极高，但是受限于存储容量，如果可能需要去判断的值超过亿级别，那么HashMap所占的内存就很可观了。</p>
<p>而<code>BloomFilter</code>解决这个问题的方案很简单。首先用多个bit位去代替HashMap中的数组，这样的话储存空间就下来了，之后就是对 Key 进行多次哈希，将 Key 哈希后的值所对应的 bit 位置为1。</p>
<p>当判断一个元素是否存在时，就去判断这个值哈希出来的比特位是否都为1，如果都为1，那么可能存在，也可能不存在（如下图F）。但是如果有一个bit位不为1，那么这个Key就肯定不存在。</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfeFWzvYrEVaicV3KqbocH8QeDrvYaTl9MH3iaCkYujx3fnWKa6ic9deA6Yff2owR1qiaJ5aYh9DJm6JHQ/640" alt="Image" style="zoom:50%;" />

<blockquote>
<p>注意：<code>BloomFilter</code>并不支持删除操作，只支持添加操作。这一点很容易理解，因为你如果要删除数据，就得将对应的bit位置为0，但是你这个Key对应的bit位可能其他的Key也对应着。</p>
</blockquote>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>缓存雪崩发生有几种情况，比如大量缓存集中在或者缓存同时在大范围中失效，出现了大量请求去访问数据库，从而导致CPU和内存过载，甚至停机。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">解决方案:</span><br><span class="line"></span><br><span class="line">1、 key的失效期分散开 不同的key设置不同的有效期</span><br><span class="line"></span><br><span class="line">2、设置二级缓存</span><br><span class="line"></span><br><span class="line">3、高可用</span><br><span class="line"></span><br><span class="line">4、服务降级</span><br></pre></td></tr></table></figure>

<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote>
<p>缓存击穿是指当前热点数据存储到期时，多个线程同时并发访问热点数据。因为缓存刚过期，所有并发请求都会到数据库中查询数据。（导致这些请求都访问到数据库）。 </p>
</blockquote>
<p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p>
<h4 id="解决方案1：将热点数据设置为永不过期"><a href="#解决方案1：将热点数据设置为永不过期" class="headerlink" title="解决方案1：将热点数据设置为永不过期"></a>解决方案1：将热点数据设置为永不过期</h4><p>会出现”写一致”问题</p>
<h4 id="解决方案2：加互斥锁"><a href="#解决方案2：加互斥锁" class="headerlink" title="解决方案2：加互斥锁"></a>解决方案2：加互斥锁</h4><p>分布式互斥锁可以控制查询数据库的线程访问，这样其他线程就处于等待状态，保证不会有大并发操作去操作数据库。但这种方案会导致系统的吞吐量下降，需要根据实际情况使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String value = redis.get(key);</span><br><span class="line"> <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// 代表缓存值过期</span></span><br><span class="line">     <span class="comment">// 设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">     <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">// 代表设置成功</span></span><br><span class="line">         value = db.get(key);</span><br><span class="line">         redis.set(key, value, expire_secs);</span><br><span class="line">         redis.del(key_mutex);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">         sleep(<span class="number">50</span>);</span><br><span class="line">         get(key);  <span class="comment">// 重试</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据写"><a href="#数据写" class="headerlink" title="数据写"></a>数据写</h2><blockquote>
<p>数据不一致的根源 ： 数据源不一样</p>
</blockquote>
<p>如何解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">强一致性很难，追求最终一致性</span><br><span class="line">互联网业务数据处理的特点</span><br><span class="line">高吞吐量</span><br><span class="line">低延迟</span><br><span class="line">数据敏感性低于金融业</span><br><span class="line">时序控制是否可行？</span><br><span class="line">先更新数据库再更新缓存或者先更新缓存再更新数据库</span><br><span class="line">本质上不是一个原子操作，所以时序控制不可行</span><br><span class="line">保证数据的最终一致性(延时双删)</span><br><span class="line">1、先更新数据库同时删除缓存项(key)，等读的时候再填充缓存</span><br><span class="line">2、2秒后再删除一次缓存项(key)</span><br><span class="line">3、设置缓存过期时间 Expired Time 比如 10秒 或1小时</span><br><span class="line">4、将缓存删除失败记录到日志中，利用脚本提取失败记录再次删除（缓存失效期过长 7*24）</span><br></pre></td></tr></table></figure>

<p>升级方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过数据库的binlog来异步淘汰key，利用工具(canal)将binlog日志采集发送到MQ中，然后通过ACK机制确认处理删除缓存。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/17/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Ladder/ss%E5%8D%A0%E7%94%A8vray%E7%AB%AF%E5%8F%A3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/17/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Ladder/ss%E5%8D%A0%E7%94%A8vray%E7%AB%AF%E5%8F%A3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">ss占用vray端口解决方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-17 22:17:44" itemprop="dateCreated datePublished" datetime="2021-02-17T22:17:44+08:00">2021-02-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-17 19:29:37" itemprop="dateModified" datetime="2021-03-17T19:29:37+08:00">2021-03-17</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前安装过ShadowsocksX-NG一直被封端口，决定换v2ray</p>
<p>但是使用v2ray死活上不去网，就提示以下这个问题</p>
<p><img src="https://ivpsr.com/wp-content/uploads/2020/11/1605841745-8a993752e9658af.jpg" alt="img"></p>
<p>打开mac的终端，找到电脑上Launchpad类似火箭一样的图标，点击Terminal打开终端</p>
<p>使用命令lsof -i:1086查看被占用的端口，看到PID:438这个进程</p>
<p><img src="https://ivpsr.com/wp-content/uploads/2020/11/1605842167-1a785dbb9ad6943.jpg" alt="img"></p>
<p>使用launchctl list | grep 438看启动项</p>
<p><img src="https://ivpsr.com/wp-content/uploads/2020/11/1605842328-c20ef55b3b45374.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 关闭服务</span><br><span class="line">launchctl stop com.qiuyuzhou.shadowsocksX-NG.local</span><br><span class="line"># 移除服务</span><br><span class="line"> launchctl unload ~&#x2F;Library&#x2F;LaunchAgents&#x2F;com.qiuyuzhou.shadowsocksX-NG.local.plist</span><br><span class="line"></span><br><span class="line"> rm -rf ~&#x2F;Library&#x2F;LaunchAgents&#x2F;com.qiuyuzhou.shadowsocksX-NG.*</span><br><span class="line"> rm -rf ~&#x2F;Library&#x2F;Preferences&#x2F;com.qiuyuzhou.ShadowsocksX-NG.plist</span><br><span class="line"> rm -rf ~&#x2F;Library&#x2F;ApplicationSupport&#x2F;ShadowsocksX-NG</span><br><span class="line"></span><br><span class="line">重启电脑</span><br></pre></td></tr></table></figure>

<p>再用lsof -i:1086</p>
<p>重新启动v2,已经看到v2ray占用了1086正在运行了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">springboot-面试题与知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-17 11:13:15" itemprop="dateCreated datePublished" datetime="2021-02-17T11:13:15+08:00">2021-02-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-27 17:27:01" itemprop="dateModified" datetime="2021-05-27T17:27:01+08:00">2021-05-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="SpringBootApplication了，请谈-一下你对这个注解的认识。"><a href="#SpringBootApplication了，请谈-一下你对这个注解的认识。" class="headerlink" title="@SpringBootApplication了，请谈 一下你对这个注解的认识。"></a>@SpringBootApplication了，请谈 一下你对这个注解的认识。</h3><p> Spring Boot中的@SpringBootApplication是一个组合注解。除了基本的元注解外，其 还组合了三个很重要的注解:</p>
<ul>
<li>@SpringBootConfiguration:其等价于@Configuration，表示当前类为一个配置类。</li>
<li>@ComponentScan:该注解用于配置应用中Bean的扫描指令，但其并没有进行真正的扫描</li>
<li>@EnableAutoConfiguration:这是核心注解，其开启了自动配置。对内置自动配置类的加载及对自定义 Bean 的扫描都是由该注解完成的。</li>
</ul>
<h3 id="ComponentScan，请谈一下你对这个注解的认识。"><a href="#ComponentScan，请谈一下你对这个注解的认识。" class="headerlink" title="@ComponentScan，请谈一下你对这个注解的认识。"></a>@ComponentScan，请谈一下你对这个注解的认识。</h3><p>@ComponentScan是@SpringBootApplication注解的一个组成注 解，用于配置使用@Configuration 定义的组件的扫描指令，并且支持同时使用 Spring 配置文件中的<a href="context:component-scan/">context:component-scan/</a>标签。该注解的注释说，该注解仅仅就 是配置了一下用于进行组件扫描的指令参数，并没有进行扫描，真正扫描并装配这些类是 @EnableAutoConfiguration 完成的。而这些指令参数就是通过该注解的属性进行配置的，例 如扫描哪里，扫描之前可以先进行怎样的过滤等。如果这些注解属性都没有配置，则默认会 扫描当前注解所标注类所在的包及其子孙包。</p>
<p>不过，对于这点，Spring Boot1.x 版本中仅会扫描当前标注类所在包的子孙包，不会扫 描标注类所在的包。但Spring Boot2.x版本中默认会扫描当前注解所标注类所在的包及其子 孙包。</p>
<p>对于一个 Spring Boot 工程，与自动配置相关的 Bean 均是由 Spring 容器管理的。而这些 Bean 的类型根据创建者的不同可以分为两种:</p>
<ul>
<li>一种是由程序员自定义的组件类，例如我们 自己定义的处理器类、Service 类等;</li>
<li>另一种是框架本身已经定义好的自动配置相关类。</li>
</ul>
<p>自定义类由@ComponentScan 指定的扫描指令进行扫描，而框架自身的自动配置相关类 在一个配置文件中存放，将来会被加载到内存。这两种类型的类都会由注解 @EnableAutoConfiguration 交给 Spring 容器来管理。</p>
<h3 id="EnableAutoConfiguration，对这个注解的认识。"><a href="#EnableAutoConfiguration，对这个注解的认识。" class="headerlink" title="@EnableAutoConfiguration，对这个注解的认识。"></a>@EnableAutoConfiguration，对这个注解的认识。</h3><p>首先，@Enable 开头这一类注解一般用于开启某一项功能，是为了简化代码的导入，即使用了该类注解，就会自动导入某些类。所以该类注解是组合注解，一般都会组合一个 @Import 注解，用于导入指定的多个类。@EnableXxx 的功能主要体现在这些被导入的类上， 而被导入的类一般有三种:</p>
<ul>
<li>配置类</li>
<li>可以实现动态选择的选择器</li>
<li>可以完成动态注解的注册器</li>
</ul>
<p>然后，Spring Boot 中的注解@ EnableAutoConfiguration 是@SpringBootApplication 注解的一个组成注解，该注解用于完成自动配置相关的自定义类及内置类的加载。其本身也是一个 组合注解。除了元注解外，还组合了@Import 与@AutoConfigurationPackage 两个注解。具体 分工如下:</p>
<ul>
<li><p>@Import: 用于加载SpringBoot中内置的及导入starter中META-INF/spring.factory配置中的自动配置类。</p>
</li>
<li><p>@AutoConfigurationPackage: 用于扫描、加载并注册自定义的组件类。</p>
</li>
</ul>
<h3 id="META-INF-spring-factory-配置文件对于-Spring-Boot-的自动配置很重要，为什么"><a href="#META-INF-spring-factory-配置文件对于-Spring-Boot-的自动配置很重要，为什么" class="headerlink" title="META-INF/spring.factory 配置文件对于 Spring Boot 的自动配置很重要，为什么?"></a>META-INF/spring.factory 配置文件对于 Spring Boot 的自动配置很重要，为什么?</h3><p>无论是 Spring Boot 内置的 META-INF/spring.factory 配置文件，还是导入 Starter 依赖中 的 META-INF/spring.factory 配置文件，对于 Spring Boot 自动配置来说很重要是因为，其包含 了一个 key-value 对，key 为 EnableAutoConfiguration 的全限定性类名，而 value 则为当前应 用中所有可用的自动配置类。所有可用的自动配置类都在这里声明，所以该文件对于 Spring Boot 自动配置来说很重要。</p>
<h3 id="Spring-Boot-官方给出的-Starter-工程的命名规范"><a href="#Spring-Boot-官方给出的-Starter-工程的命名规范" class="headerlink" title="Spring Boot 官方给出的 Starter 工程的命名规范"></a>Spring Boot 官方给出的 Starter 工程的命名规范</h3><p>Spring Boot 官方给出的 Starter 工程的命名需要遵循如下规范:</p>
<ul>
<li>Spring 官方定义的Starter格式为:spring-boot-starter-{name}，如spring-boot-starter-web。 </li>
<li>非官方Starter命名格式为:{name}-spring-boot-starter，如dubbo-spring-boot-starter。</li>
</ul>
<h3 id="Configuration-所注解的类称为配置类，其中的-Bean-方法可以创建相应实例，-Bean-方法实例的创建顺序什么"><a href="#Configuration-所注解的类称为配置类，其中的-Bean-方法可以创建相应实例，-Bean-方法实例的创建顺序什么" class="headerlink" title="@Configuration 所注解的类称为配置类，其中的@Bean 方法可以创建相应实例，@Bean 方法实例的创建顺序什么?"></a>@Configuration 所注解的类称为配置类，其中的@Bean 方法可以创建相应实例，@Bean 方法实例的创建顺序什么?</h3><p> @Configuration 所注解的类中的@Bean 方法实例的创建顺序即这些@Bean 方法的执 行顺序。首先可以为这些方法的执行添加执行条件，例如使用以@ConditionOn 开头的条件 注解。在这些条件都满足的情况下，这些方法的执行顺序即为其在@Configuration 注解类中 的定义顺序，先定义者先执行，其对应实例先创建。</p>
<h3 id="定义-Starter-的大体步骤。"><a href="#定义-Starter-的大体步骤。" class="headerlink" title="定义 Starter 的大体步骤。"></a>定义 Starter 的大体步骤。</h3><p>对于自定义 Starter，其工程命名格式为{name}-spring-boot-starterConfiguration。工程 需要导入配置处理器依赖。然工程中需要定义如下的类与配置:</p>
<ul>
<li><p>定义核心业务类，这是该Starter存在的意义。</p>
</li>
<li><p>定义自动配置类，其完成对核心业务类的实例化，并交给Spring容器。</p>
</li>
<li><p>若核心业务类中需要从配置文件获取配置数据，还需要定义一个用于封装配置文件中相关属性的类。</p>
</li>
<li><p>定义META-INF/spring.factories配置文件，用于对自动配置类进行注册。</p>
</li>
</ul>
<h3 id="在自动配置类中一般会涉及到很多的条件注解，简单介绍几个"><a href="#在自动配置类中一般会涉及到很多的条件注解，简单介绍几个" class="headerlink" title="在自动配置类中一般会涉及到很多的条件注解，简单介绍几个"></a>在自动配置类中一般会涉及到很多的条件注解，简单介绍几个</h3><p>在自动配置类定义中的确会用于到很多的条件注解，条件注解一般都是以 @ConditionalOn 开头的，例如:</p>
<ul>
<li><p>@ConditionalOnClass():条件判断注解，其可以标注在类与方法上，表示当参数指定的类在类路径下存在时才会创建当前类的 Bean，或当前方法指定的 Bean。</p>
</li>
<li><p>@ConditionalOnMissionBean:条件判断注解，其可以标注在类与方法上，表示当容器中不存在当前类或方法类型的对象时，将去创建一个相应的 Bean。不过，这里要查找的“容器”是可以指定的。通过 search 属性指定。其 search 的范围有三种:<a href="">仅搜索当前配置类容器</a>; <a href="">搜索所有层次的父类容器</a>，但不包含当前配置类容 器; <a href="">搜索当前配置类容器及其所有层次的父类容器</a>，这个是默认搜索范围。</p>
</li>
<li><p>@ConditionalOnBean():条件判断注解，其可以标注在类与方法上，表示当在容器中存在指定类的实例时才会创建当前类的 Bean，或当前方法指定的 Bean。</p>
</li>
</ul>
<h3 id="Spring-Boot-启动过程"><a href="#Spring-Boot-启动过程" class="headerlink" title="Spring Boot 启动过程"></a>Spring Boot 启动过程</h3><p> Spring Boot 的启动从大的方面来说需要经过以下两大阶段:加载 Spring Boot 配置文 件 application.yml，与完成自动配置。</p>
<p>而自动配置又包含以下两个大的步骤:加载自动配置相关的类，与扫描并注册自定义的 组件类。</p>
<p>加载Spring Boot配置文件是在启动类的run()方法执行时加载的。其大体要经历运行环 境准备、为环境准备过程添加监听、发布环境准备事件等步骤。</p>
<p>自动配置则是由组合注解 @SpringBootApplication 所包含的子注解 @EnableAutoConfiguration 完成。其不仅加载了 META-INF/spring.factories 中内置的自动配置 相关类，还完成了自定义类的加载与注册。若存在第三方 Starter，则其会将该 Starter 中 META-INF/spring.factories 中的自动配置相关类加载并装配。</p>
<h3 id="对-Spring-Boot-自动配置的理解。"><a href="#对-Spring-Boot-自动配置的理解。" class="headerlink" title="对 Spring Boot 自动配置的理解。"></a>对 Spring Boot 自动配置的理解。</h3><p>Spring Boot与SSM传统开发相比，其最大的特点是自动配置，不用再在xml文件中 做大量的配置了。自动配置的实现主要是通过自动配置类来完成的，自动配置类存在于两类 位置:一个是 Spring Boot 框架中内置的，一是从外部引入的 Starter 中。</p>
<p>具体来说，自动配置类的作用就是根据条件创建核心业务类的实例到 Spring 容器中， 以备该 Starter 的引用工程类中注入。当然，自动配置类还有一个作用:若创建核心业务类 时需要获取配置文件中的相关属性值，其也会将这些属性值封装为一个属性实例，以备核心 业务类使用。当然，自动配置类需要在 META-INF/spring.factories 中注册。</p>
<p>所以自动配置其实就是能够自动获取配置文件中的属性并创建相应核心业务类实例。</p>
<h3 id="现在准备解析-Spring-Cloud-中某子框架的源码，那么从哪里开始解析"><a href="#现在准备解析-Spring-Cloud-中某子框架的源码，那么从哪里开始解析" class="headerlink" title="现在准备解析 Spring Cloud 中某子框架的源码，那么从哪里开始解析?"></a>现在准备解析 Spring Cloud 中某子框架的源码，那么从哪里开始解析?</h3><p>对于一个 未曾阅读过的子框架源码，我认为从自动配置类开始解析可能是一个不错的选择。</p>
<p>我们知道 <a href="">Spring Cloud 是通过 Spring Boot 将其它第三方框架集成进来的</a>。<a href="">Spring Boot 最大的特点就是自动配置</a>，我们可以<a href="">通过导入相关 Starter 来实现需求功能的自动配置、相关核心业务类实例的创建等</a>。也就是说，核心业务类都是集中在自动配置类中的。所以从这里 下手分析应该是个不错的选择。</p>
<p>那么从哪里可以找到这个自动配置类呢?从导入的 starter 依赖工程的 META-INF 目录中 的 spring.factory 文件中可以找到。该文件的内容为 key-value 对，查找 EnableAutoConfiguration 的全限定性类名作为 key 的 value，这个 value 就是我们要找到的自动配置类。</p>
<h3 id="EnableConfigurationProperties-注解对于-Starter-的定义很重要"><a href="#EnableConfigurationProperties-注解对于-Starter-的定义很重要" class="headerlink" title="@EnableConfigurationProperties 注解对于 Starter 的定义很重要"></a>@EnableConfigurationProperties 注解对于 Starter 的定义很重要</h3><p>@EnableConfigurationProperties 注解在 Starter 定义时主要用于读取 application.yml 配 置文件中相关的属性，并封装到指定类型的实例中，以备 Starter 中的核心业务实例使用。</p>
<p>具体来说，它就是开启了对@ConfigurationProperties 注解的 Bean 的自动注册，注解到 Spring 容器中。这种 Bean 有两种注册方式:在配置类使用@Bean 方法注册，或直接使用该 注解的 value 属性进行注册。若在配置类中使用@Bean 注册，则需要在配置类中定义一个 @Bean 方法，该方法的返回值为“使用@ConfigurationProperties 注解标注”的类。若直接 使用该注解的 value 属性进行注册，则需要将这个“使用@ConfigurationProperties 注解标注” 的类作为 value 属性值出现即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">kafka-03-知识点与面试题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-17 08:42:46" itemprop="dateCreated datePublished" datetime="2021-02-17T08:42:46+08:00">2021-02-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="请简述-Kafka-中-Broker、Topic、Partition-及-Segment-间的关系。"><a href="#请简述-Kafka-中-Broker、Topic、Partition-及-Segment-间的关系。" class="headerlink" title="请简述 Kafka 中 Broker、Topic、Partition 及 Segment 间的关系。"></a>请简述 Kafka 中 Broker、Topic、Partition 及 Segment 间的关系。</h1><p>Kafka 中的 Broker 指的就是 Kafka 集群中的一个节点，就是一台 Kafka 主机。Broker 中可以存放很多的消息，但这些消息是分类存放的，一类就是一个 Topic。每一类的消息在 一台 Broker 中都被集中存放在了一起，被放在了一个目录中，这个目录称为 Partition。但消 息本身并不是文件，其需要存放到文件中。用于存放消息的文件称为 Segment。</p>
<p>一个 Topic 的消息可以被存放到多个 Broker 中，一个 Broker 中可以存放一个 Topic 的多个 Partition，而一个 Partition 中可以存放很多的 Segment，一个 Segment 中可以存放很多的 消息。</p>
<h1 id="Kafka-与其它-MQ-相比，其最大的特点就是高吞吐率。Kafka-中消息存放的顺序存放-是实现高吞吐率的重要特征。请简述一下-Kafka-中消息的顺序存放特性。"><a href="#Kafka-与其它-MQ-相比，其最大的特点就是高吞吐率。Kafka-中消息存放的顺序存放-是实现高吞吐率的重要特征。请简述一下-Kafka-中消息的顺序存放特性。" class="headerlink" title="Kafka 与其它 MQ 相比，其最大的特点就是高吞吐率。Kafka 中消息存放的顺序存放 是实现高吞吐率的重要特征。请简述一下 Kafka 中消息的顺序存放特性。"></a>Kafka 与其它 MQ 相比，其最大的特点就是高吞吐率。Kafka 中消息存放的顺序存放 是实现高吞吐率的重要特征。请简述一下 Kafka 中消息的顺序存放特性。</h1><p>Kafka 中消息的顺序存放指的是一个 Segment 中消息的存放是顺序存放的。为了能够 存放大量的消息，Kafka 是将消息直接存放在了磁盘。由于磁盘是一个低速 IO 设备，为了提 高 IO 速度，就想将 Broker 中同一 Topic 的消息顺序存放在磁盘。但一个 Topic 的消息量是非 常庞大的，但到底有多大，并不确定，因为其是一直在增长的。为了便于连续磁盘空间的分 配，就将一个 Topic 的消息写入到一个文件中，这个文件的最大大小通过配置可以固定。即 在磁盘中查找到一块连接的指定大小的空间是可以完成的。这个文件称为 Segment。随着消 息量的不断增长，Segment 文件越来越多，为了便于管理，将同一 Topic 的 Segment 文件都 存放到一个或多个目录中，这些目录就是 Partition。通过以上叙述可知，Segment 中的消息 是顺序存放的，而 Partition 中的这些 Segment 文件的存储并不是顺序存放的。</p>
<h1 id="Kafka-中的-Segment-实际是一套文件，其中最为重要的是-log-与-index-文件。这两个文件的文件名是相同的。请简述文件名的意义及这两个文件的关系。"><a href="#Kafka-中的-Segment-实际是一套文件，其中最为重要的是-log-与-index-文件。这两个文件的文件名是相同的。请简述文件名的意义及这两个文件的关系。" class="headerlink" title="Kafka 中的 Segment 实际是一套文件，其中最为重要的是.log 与.index 文件。这两个文件的文件名是相同的。请简述文件名的意义及这两个文件的关系。"></a>Kafka 中的 Segment 实际是一套文件，其中最为重要的是.log 与.index 文件。这两个文件的文件名是相同的。请简述文件名的意义及这两个文件的关系。</h1><p>Kafka 中的 segment 是一个逻辑概念，其包含两类重要的物理文件，分别为“.index” 文件和“.log”文件。“.log”文件中存放的是消息<!--相当于书的章节内容-->，而“.index”文件中存放的是“.log”文 件中消息的索引<!--相当于书的目录-->。</p>
<p>这两个文件的文件名是成对出现的，即会出现相同文件名的 log 与 index 文件。文件名 由 20 位数字字符组成，其要表示一个 64 位长度的数值(2 的 64 次方是一个长度为 20 的数 字)。但作为文件名，其数值长度不足 20 位的全部用 0 填补。</p>
<p>这个 64 位长度的数值表示当前 segment 文件之前有多少条消息。那么，第一个 segment 文件的文件名就应是由 20 个 0 组成，因为其前面没有消息了。</p>
<ul>
<li>第0号segment文件，表示其前面没有消息。<br>00000000000000000000.index<br>00000000000000000000.log</li>
<li>第170210号segment文件，表明其前面有170210个消息。<br>00000000000000170210.index<br>00000000000000170210.log</li>
<li>第239430号segment文件，表明其前面有239430个消息。<br>00000000000000239430.index<br>00000000000000239430.log</li>
</ul>
<h1 id="消费者准备消费编号为-170213-的消息，这个消费者是如何找到这条消息的-请简-述这个查找过程。"><a href="#消费者准备消费编号为-170213-的消息，这个消费者是如何找到这条消息的-请简-述这个查找过程。" class="headerlink" title="消费者准备消费编号为 170213 的消息，这个消费者是如何找到这条消息的?请简 述这个查找过程。"></a>消费者准备消费编号为 170213 的消息，这个消费者是如何找到这条消息的?请简 述这个查找过程。</h1><p>Kafka 中的消息是存放在相应相应 partition 的相应 segment 中的。对于消费者来说， 每个消费者其消费的 partition 是系统自动分配好的，所以其不用查找 partition。但一个 partition中的segment会有很多，而segment中包含index与log两个重要文件。简单来说， 消费者是通过 index 文件找到 log 文件中包含的消息的。</p>
<p>具体过程是这样的:170213这个称为消息在partition中的偏移量offset。首先拿170213 这个 offset 通过二分法在所有 segment 文件名中查找对应文件。当定位到 segment 文件名为 00000000000000170210 的文件后，进行减法运算:170213 – 170210 =3。然后再在该名称的 index 文件中定位到 2 号(编号从 0 开始)，而 2 号对应的偏移地址为 0348。最后在当前 log 文件中直接定位到 0348 地址处即可找到该消息。</p>
<p>不过，这里还有个问题:消费者并不知道这个消息的大小，而 log 中的消息是顺序存放 的。消费者是如何知道这条消息已经读取完毕了呢?存放在 log 文件中的消息并不仅仅是一 个单纯的消息，其是由若干元数据构成的、具有固定格式的一个消息体。即每个消息体都有 相应的开始标识位。当读到下一个消息的开始标识位时，表示当前消息已经结束。</p>
<h1 id="Kafka-中为了减轻单台-broker-的压力，一般会为-Topic-设置多个-partition。那么，一-个-Topic-设置多少个-partition-合适呢"><a href="#Kafka-中为了减轻单台-broker-的压力，一般会为-Topic-设置多个-partition。那么，一-个-Topic-设置多少个-partition-合适呢" class="headerlink" title="Kafka 中为了减轻单台 broker 的压力，一般会为 Topic 设置多个 partition。那么，一 个 Topic 设置多少个 partition 合适呢?"></a>Kafka 中为了减轻单台 broker 的压力，一般会为 Topic 设置多个 partition。那么，一 个 Topic 设置多少个 partition 合适呢?</h1><p> 假设某 topic 中有 N 个 partition，集群中有 M 个 broker，则 broker 与 partition 间的关系如下所述:</p>
<ul>
<li>若N&gt;M，<ul>
<li>且N是M的整数倍(N%M=0)，那么每个broker会平均存储该topic的多个partition。</li>
<li>若N&gt;M，但N不是M的整数倍(N%M!=0)，那么就会出现broker中partition分布不平均的情况。应尽量避免这种情况的发生，这种情况容易导致 Kafka 集群消息不均衡，各个 broker 的任务压力不均衡。</li>
</ul>
</li>
<li>若N&lt;M，则会有N个broker存储该topic的一个partition，剩下的(M-N)个broker将不存储该 topic 的 partition 消息。</li>
</ul>
<p>通过以上分析可知，partition 的数量最好是 broker 数量的整数倍。</p>
<h1 id="请总结一下Kafka中Consumer-Group中的Consumer与其要消费的Topic中的partition-间的数量关系。"><a href="#请总结一下Kafka中Consumer-Group中的Consumer与其要消费的Topic中的partition-间的数量关系。" class="headerlink" title="请总结一下Kafka中Consumer Group中的Consumer与其要消费的Topic中的partition 间的数量关系。"></a>请总结一下Kafka中Consumer Group中的Consumer与其要消费的Topic中的partition 间的数量关系。</h1><p>Consumer Group中组内consumer与其要消息的Topic的partition的关系是1:n，partition 与组内 consumer 的关系则是 1:1。也就是说，在稳定状态下，一旦为某组内 consumer 分配 了某一个或几个 partition 后，就不会发生变化了;反过来说，一旦为某 partition 分配了组 内 consumer，就不会再为其分配其它组内 consumer 了。</p>
<h1 id="Kafka-中一个-partition-只允许一个-Consumer-Group-中的一个组内-Consumer-进行消-费。请简述这样设计的优劣。"><a href="#Kafka-中一个-partition-只允许一个-Consumer-Group-中的一个组内-Consumer-进行消-费。请简述这样设计的优劣。" class="headerlink" title="Kafka 中一个 partition 只允许一个 Consumer Group 中的一个组内 Consumer 进行消 费。请简述这样设计的优劣。"></a>Kafka 中一个 partition 只允许一个 Consumer Group 中的一个组内 Consumer 进行消 费。请简述这样设计的优劣。</h1><p>Kafka中一个partition只允许一个Consumer Group中的一个组内Consumer进行消费。 而一个组内 Consumer 可以消费同一 Topic 的多个 parittion。</p>
<ul>
<li>好处是，对于每个 parition 中消费消费的偏移量控制简单。</li>
<li>不足是，无法让同一个组内的 consumer 均匀消费消 息，因为消息在同一 Topic 的 parition 中的存放并不是平均的。一旦组内 consumer 与 parition 的消费关系确立，则可能会导致某些组内 consumer 需要消费的消息量很大，有的组内 consumer 可能无消息可消费。</li>
</ul>
<h1 id="我们知道，Kafka-中-partition-的数量最好是-broker-数量的整数倍。但具体来说，是-一倍、两倍，还是三倍，如何选择呢"><a href="#我们知道，Kafka-中-partition-的数量最好是-broker-数量的整数倍。但具体来说，是-一倍、两倍，还是三倍，如何选择呢" class="headerlink" title="我们知道，Kafka 中 partition 的数量最好是 broker 数量的整数倍。但具体来说，是 一倍、两倍，还是三倍，如何选择呢?"></a>我们知道，Kafka 中 partition 的数量最好是 broker 数量的整数倍。但具体来说，是 一倍、两倍，还是三倍，如何选择呢?</h1><p>Kafka 中 partition 的数量最好是 broker 数量的整数倍。但应该设置为几倍，需要根据 实际需求中一个消费者组包含消费者的数量。我们知道，Kafka 的设计要求，同一消费者组 中两个消费者是不能同时消费同一个 partition 的。若 Consumer Group 中包含的消费者数量 较多，而其消费的 Topic 的 partition 数量较少，则会导致很多消息者是闲置的。降低了 Consumer Group 的消费能力。所以，一个 Topic 中包含的 partition 数量，与其消费者组中包 含的消费者数量要相匹配，这样可以充分发挥消费者组的消费能力。</p>
<h1 id="partition-Leader-与-Follower-间是主从还是主备关系"><a href="#partition-Leader-与-Follower-间是主从还是主备关系" class="headerlink" title="partition Leader 与 Follower 间是主从还是主备关系?"></a>partition Leader 与 Follower 间是主从还是主备关系?</h1><p>为了保障消息的安全性，我们会为 Kafka 的 parition 设置副本。每个 partition 可能 有多个副本，但有且仅有一个作为 Leader，其余的都是 Follower。</p>
<p>Kafka中partition Leader与Follower间是主备关系。Leader负责对外提供读写服务， 即 producer 与 consumer 操作的都是 parititon leader。所有 Follower 都需要从 Leader 同步消 息，但平时对外是不提供服务的。一旦 leader 出现问题，会从 follower 马上再选举出一个新 的 leader。</p>
<h1 id="在-Kafka-的副本中有-AR、ISR-与-OSR-概念，它们间是什么关系"><a href="#在-Kafka-的副本中有-AR、ISR-与-OSR-概念，它们间是什么关系" class="headerlink" title="在 Kafka 的副本中有 AR、ISR 与 OSR 概念，它们间是什么关系?"></a>在 Kafka 的副本中有 AR、ISR 与 OSR 概念，它们间是什么关系?</h1><p>Kafka中某个partition的所有的副本统称为Assigned Replicas，即AR。初始时leader 与所有 follower 都在 ISR(In-Sync Replicas)列表，即初始时 ISR = AR。ISR 中的 partition 是要从 leader 同步消息的。但同步会有延迟，只要延迟超过了阈值 replica.lag.time.max.ms，就会 把 follower 剔除出 ISR，移入 OSR(Outof-Sync Replicas)列表。故 AR=ISR+OSR。</p>
<p>ISR 由 leader 负责维护，leader 会对 OSR 中的 follower 进行定期检测，以查看其是否适 合重新进入到 ISR。</p>
<h1 id="请简述Rebalance-的概念"><a href="#请简述Rebalance-的概念" class="headerlink" title="请简述Rebalance 的概念"></a>请简述Rebalance 的概念</h1><p>在 Kafka 中，当消费者组中消费者数量发生变化，或 Topic 中的 partition 数量发生了 变化时， partition 的所有权会在消费者间转移，即 partition 会重新分配，这个过程称为再 均衡 Rebalance。</p>
<p>再均衡能够给消费者组及 broker 集群带来高可用性和伸缩性，但在再均衡期间消费者 是无法读取消息的，即整个 broker 集群有一小段时间是不可用的。因此要避免不必要的再 均衡。</p>
<h1 id="Kafka-中的-partition-leader-与-broker-controller-是由谁选举出来的"><a href="#Kafka-中的-partition-leader-与-broker-controller-是由谁选举出来的" class="headerlink" title="Kafka 中的 partition leader 与 broker controller 是由谁选举出来的?"></a>Kafka 中的 partition leader 与 broker controller 是由谁选举出来的?</h1><p>Kafka 中为了保障消息的高可用性，一般会为 partition 创建副本。副本中 partition leader 负责对外提供服务，而 partition follower 则仅同步 leader 中的数据。当 partition leader 出现 宕机， 则立马由 broker controller 从 follower 中选举出来一个新的 leader。其实所谓选举，其实就是 “按资排辈”。从 ISR 列表中找到第一个 follower 作为新的 leader。</p>
<p>broker controller负责管理分区与副本，例如partition leader的选举。broker controller 由 zk 负责选举。其选举算法就是 zk 中“Master 的选举”应用场景，即由 kafka 集群中的 broker 在 zk 中创建一个临时节点，谁先创建了谁就是 broker controller。一般情况下就是，哪个 broker 先启动了，哪个就是 broker controller。</p>
<h1 id="Kafka-中的生产者生产的消息被写入到了哪个-partition-消费者将-offset-提交到了-哪里-这两个问题有什么联系"><a href="#Kafka-中的生产者生产的消息被写入到了哪个-partition-消费者将-offset-提交到了-哪里-这两个问题有什么联系" class="headerlink" title="Kafka 中的生产者生产的消息被写入到了哪个 partition?消费者将 offset 提交到了 哪里?这两个问题有什么联系?"></a>Kafka 中的生产者生产的消息被写入到了哪个 partition?消费者将 offset 提交到了 哪里?这两个问题有什么联系?</h1><p> 前两个问题其实都是 Kafka 中生产者的消息路由策略。只不过，消费者提交的 offset 是一种特殊的消息，其是提交到了一个名称为__consumer_offsets 的特殊主题的相应 partition(<a href="">内置 topic 的 partition 中了，与用户的topic-partition在同一目录下</a>）。 __consumer_offsets 主题默认有 50 个分区。</p>
<p>对于普通消息的路由，其路由规则如下:</p>
<ol>
<li>若指定了消息要写入的 partition，则直接写入到指定的 partition;</li>
<li>若未指定 partition 但指定了消息的 key，则通过对 key 的 hash 值与 partition 数量取模，该取模结果就是要选出的 partition 索引;</li>
<li>若 partition 和 key 都未指定，则使用轮询算法选出一个 partition。</li>
</ol>
<p>对于消费者提交offset，其路由规则如下:</p>
<ol>
<li>这个offset是一种特殊的消息，该消息的key为消费者组的Id。 offset 要写入到__consumer_offsets 主题的哪个 partition，其索引的计算方式与前面说的相同: 通过 groupId 的 hashCode 与 50 取模。</li>
<li>最终这个 offset 被提交到了这个 partition。</li>
</ol>
<h1 id="Kafka-中消息的生产者会将消息写入到-broker-中，请详细描述一下这个写入过程。"><a href="#Kafka-中消息的生产者会将消息写入到-broker-中，请详细描述一下这个写入过程。" class="headerlink" title="Kafka 中消息的生产者会将消息写入到 broker 中，请详细描述一下这个写入过程。"></a>Kafka 中消息的生产者会将消息写入到 broker 中，请详细描述一下这个写入过程。</h1><p>消息生产者将消息发送给 broker，并形成最终的可供消费者消费的 log，是一个比较 复杂的过程。具体过程如下:</p>
<ol>
<li>producer 向 broker 集群提交连接请求，其所连接上的任意 broker 都会向其发送 broker controller 的通信 URL，即 broker controller 主机配置文件中的 listeners 地址</li>
<li>当 producer 指定了要生产消息的 topic 后，其会向 broker controller 发送请求，请求当前 topic 中所有 partition 的 leader 列表地址</li>
<li>broker controller 在接收到请求后，会从 zk 中查找到指定 topic 的所有 partition 的 leader， 并返回给 producer</li>
<li>producer 在接收到 leader 列表地址后，根据消息路由策略找到当前要发送消息所要发送 的 partition leader，然后将消息发送给该 leader</li>
<li>leader 将消息写入本地 log，并通知 ISR 中的 followers</li>
<li>ISR 中的 followers 从 leader 中同步消息后向 leader 发送 ACK</li>
<li>leader 收到所有 ISR 中的 followers 的 ACK 后，增加 HW，表示消费者已经可以消费到该位置了</li>
<li>当然，若 leader 在等待的 followers 的 ACK 超时了，发现还有 follower 没有发送 ACK，则会将该 follower 从 ISR 中清除，然后增加 HW。</li>
</ol>
<h1 id="Kafka-中的-HW-机制和HW-截断机制是什么"><a href="#Kafka-中的-HW-机制和HW-截断机制是什么" class="headerlink" title="Kafka 中的 HW 机制和HW 截断机制是什么?"></a>Kafka 中的 HW 机制和HW 截断机制是什么?</h1><p>HW，HighWatermark，高水位，表示 Consumer 可以消费到的最高 partition 偏移量。 在 Kafka 中与 HW 相关的机制有两种:HW 机制与 HW 截断机制。它们都是为了保证 partition leader 与 follower 间数据的一致性。只不过它们处理的场景不同。</p>
<ul>
<li>HW机制:该机制在Kafka集群正常运行状态下可以防止partitionleader与follower间出现数据不一致。该机制要求，对于 partition leader 新写入的消息，consumer 不能立 刻消费。leader 会等待该消息被所有 ISR 中的 partition follower 同步后才会更新 HW，此 时该消息才能被 consumer 消费。</li>
<li>HW截断机制:该机制在Kafka中partition leader出现宕机情况然后又恢复时，可以防 止 partition leader 与 follower 间出现数据不一致。当原 Leader 宕机后又恢复时，将其 LEO 回退到其宕机时的 HW，然后再与新的 Leader 进行数据同步，这种机制称为 HW 截 断机制。</li>
</ul>
<h1 id="Kafka-是如何保证消息发送的可靠性的"><a href="#Kafka-是如何保证消息发送的可靠性的" class="headerlink" title="Kafka 是如何保证消息发送的可靠性的?"></a>Kafka 是如何保证消息发送的可靠性的?</h1><p>Kafka 的消息生产者有一个配置属性 acks，用于指定消息发送的可靠性级别的。</p>
<ul>
<li>0值:异步发送。生产者向kafka发送消息但不需要kafka反馈成功ack。该方式效率最高，但可靠性最低。其可能会存在消息丢失的情况。</li>
<li>1值:同步发送，默认值。生产者发送消息给kafka，broker的partition leader在收到消息后马上发送成功 ack，生产者收到后才会再发送消息。如果一直未收到 kafka 的 ack，则生产者会认为消息发送失败，会重发消息。</li>
<li>-1值:同步发送。其值等同于all。生产者发送消息给kafka，kafka收到消息后要等到ISR列表中的所有副本都同步消息完成后，才向生产者发送成功 ack。如果一直未收到 kafka 的 ack，则认为消息发送失败，会自动重发消息。</li>
</ul>
<h1 id="Kafka-的消息生产者设置-acks-属性值为-1-时，能否使生产者确认它发送的消息发送-成功或失败呢"><a href="#Kafka-的消息生产者设置-acks-属性值为-1-时，能否使生产者确认它发送的消息发送-成功或失败呢" class="headerlink" title="Kafka 的消息生产者设置 acks 属性值为 1 时，能否使生产者确认它发送的消息发送 成功或失败呢?"></a>Kafka 的消息生产者设置 acks 属性值为 1 时，能否使生产者确认它发送的消息发送 成功或失败呢?</h1><p>Kafka 的消息生产者设置 acks 属性值为 1 时表示，生产者发送消息给 kafka，broker 的 partition leader 在收到消息后马上发送成功 ack，生产者收到后才会再发送消息。如果一 直未收到 kafka 的 ack，则生产者会认为消息发送失败，会重发消息。</p>
<p>该方式不能使生产者确认其发送的消息一定成功。例如，当 partition leader 收到消息后 向生产者发送了 ACK，在 ISR 中的 Follower 还未同步时 leader 挂了，此时，leader 先前收到 的消息对于 kafka 来说就不存在，但对于生产者来说，kafka 已经接收成功。但实际上该消息 已经丢失。所以，无法保证消息不丢失。</p>
<p>但该方式可以使生产者确认其发送的消息失败。只要在超时时限内生产者没有收到 ACK 就表示消息发送失败。发送失败，生产者会重新发送。</p>
<h1 id="Kafka-的消息生产者设置-acks-属性值为-all-时，基本可以保证消息的不丢失。但却可能会引发消息的重复接收。为什么"><a href="#Kafka-的消息生产者设置-acks-属性值为-all-时，基本可以保证消息的不丢失。但却可能会引发消息的重复接收。为什么" class="headerlink" title="Kafka 的消息生产者设置 acks 属性值为 all 时，基本可以保证消息的不丢失。但却可能会引发消息的重复接收。为什么?"></a>Kafka 的消息生产者设置 acks 属性值为 all 时，基本可以保证消息的不丢失。但却可能会引发消息的重复接收。为什么?</h1><p>Kafka 的消息生产者设置 acks 属性值为 all 时表示，生产者发送消息给 partition leader，partition leader 收到消息后要等到 ISR 列表中的所有副本都同步消息完成后，才向生产者发送成功 ack。如 果一直未收到 partition leader 的 ack，则认为消息发送失败，会自动重发消息。</p>
<p>这种模式下可靠性很高，很少会出现消息丢失的情况。但可能会出现部分 Follower 重复 接收消息的情况。例如生产者发送消息给partition leader，然后ISR中的follower要同步消 息。当 follower 同步还未完成时 partition leader 挂了，此时不会发送 ack 给生产者。由于发 送者没有收到 ack，所以生产者会再次发送消息给新的 Leader。若新的 Leader 曾经同步过一部分原来的消息，那么此时又接收到相同的消息，此时 leader 中的消息就会有重复消息。</p>
<p>该模式下 kafka 对消息的重复接收问题无法直接解决。但可以想办法对于重复接收的消 息不进行重复消费:为消息指定唯一标识 key，然后在消费者端定义去重机制。当然，消费者端的去重，是需要开发人员自己定义的。</p>
<h1 id="Kafka-中-partition-leader-若挂了，一般会选择-ISR-中的-follower-作为新的-leader-这是由谁完成的-若-ISR-中没有其它-follower-能否选举出新的-leader"><a href="#Kafka-中-partition-leader-若挂了，一般会选择-ISR-中的-follower-作为新的-leader-这是由谁完成的-若-ISR-中没有其它-follower-能否选举出新的-leader" class="headerlink" title="Kafka 中 partition leader 若挂了，一般会选择 ISR 中的 follower 作为新的 leader, 这是由谁完成的?若 ISR 中没有其它 follower 能否选举出新的 leader?"></a>Kafka 中 partition leader 若挂了，一般会选择 ISR 中的 follower 作为新的 leader, 这是由谁完成的?若 ISR 中没有其它 follower 能否选举出新的 leader?</h1><p>kafka中partition leader若挂了，broker controller会选择ISR中的follower作为新的 leader。若 ISR 中没有其它 follower 能否选举出新的 leader，可以通过 broker 的属性设置 unclean.leader.election.enable 的值来确定。</p>
<ul>
<li>若该值为false，则只能从ISR中选择。</li>
<li>若该值为true，在ISR中没有副本的情况下可以选择任何一个该Topic的partition作为新的 leader，该策略可用性高，但可靠性没有保证。</li>
</ul>
<h1 id="Kafka-中-partition-leader-若挂了，通过设置允许其从任意没有宕机的主机的-partition-中选举新的-leader，为什么可能导致大量数据的丢失"><a href="#Kafka-中-partition-leader-若挂了，通过设置允许其从任意没有宕机的主机的-partition-中选举新的-leader，为什么可能导致大量数据的丢失" class="headerlink" title="Kafka 中 partition leader 若挂了，通过设置允许其从任意没有宕机的主机的 partition 中选举新的 leader，为什么可能导致大量数据的丢失"></a>Kafka 中 partition leader 若挂了，通过设置允许其从任意没有宕机的主机的 partition 中选举新的 leader，为什么可能导致大量数据的丢失</h1><p>在 ISR 中没有副本的情况下可以选择的 partition 只能是 OSR 中的。一个 partition 只所以能够进入到 OSR，就是因为其与原来的 leader 的通信出现了问题。若该 partition 成为了 新的 leader，则可能会出现这个新的 leader 与其它所有副本均无法通信的情况。但由于其为 leader，所以其只会认为是其它副本出现了问题，从而导致该 leader 的 ISR 中没有 follower。 而没有 follower 的风险是很高的，这个 leader 的失效将会导致大量消息的丢失。</p>
<h1 id="Kafka-中，当一个-Consumer-Group-中仅包含一个-Consumer-时，若其消费能力较低，-则可能会引发重复消费。为什么-怎么解决"><a href="#Kafka-中，当一个-Consumer-Group-中仅包含一个-Consumer-时，若其消费能力较低，-则可能会引发重复消费。为什么-怎么解决" class="headerlink" title="Kafka 中，当一个 Consumer Group 中仅包含一个 Consumer 时，若其消费能力较低， 则可能会引发重复消费。为什么?怎么解决?"></a>Kafka 中，当一个 Consumer Group 中仅包含一个 Consumer 时，若其消费能力较低， 则可能会引发重复消费。为什么?怎么解决?</h1><p>正常情况下，consumer 在“自动提交超时时限”内消费完一批消息后会自动提交 offset。 但当 consumer 消费能力比较低时，其取出的一批消息在阈值时间内没有消费完毕，此时 consumer 会向 broker 提交一个异常。此时 broker 不会认为该 consumer 宕机，因为当前 consumer 向 broker 提交了信息。</p>
<p>对于 consumer 来说，由于本次消费过程在时限内没有完成，即没有成功，所以该 consumer 会再从该 partition 中拉取消息。由于前面没有提交 offset，所以这次拉取的消息与 上次的是相同的。该 consumer 又重新消费之前的那一批消息，然后就又出现了消费超时， 所以会造成死循环，一直消费相同的消息。</p>
<p>对于这种情况下的重复消费的解决方案是，延长 offset 自动提交时间，即<a href="">增加自动提交 超时时限 auto.commit.interval.ms 的值</a>。或<a href="">将自动提交改为手动提交</a>，真正消费完毕后再进 行提交。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/zookeeper-03-ZooKeeper%20%E5%85%AB%E7%A7%8D%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/zookeeper-03-ZooKeeper%20%E5%85%AB%E7%A7%8D%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">zookeeper-02-Leader的选举机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-16 19:48:27" itemprop="dateCreated datePublished" datetime="2021-02-16T19:48:27+08:00">2021-02-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-10 09:10:32" itemprop="dateModified" datetime="2022-02-10T09:10:32+08:00">2022-02-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41947378/article/details/107062257">https://blog.csdn.net/weixin_41947378/article/details/107062257</a></p>
<h2 id="1-配置维护"><a href="#1-配置维护" class="headerlink" title="1.配置维护"></a>1.配置维护</h2><p>分布式系统中，很多服务都是部署在集群中的，即多台服务器中部署着完全相同的应用，起着完全相同的作用。当然，集群中的这些服务器的配置文件是完全相同的。</p>
<p>若集群中服务器的配置文件需要进行修改，那么我们就需要逐台修改这些服务器中的配置文件。如果我们集群服务器比较少，那么这些修改还不是太麻烦，但如果集群服务器特别多，比如某些大型互联网公司的 Hadoop 集群有数千台服务器，那么纯手工的更改这些配置文件几乎就是一件不可能完成的任务。即使使用大量人力进行修改可行，但过多的人员参与，出错的概率大大提升，对于集群所形成的危险是很大的。</p>
<p>实现原理</p>
<p>zk 可以通过“发布/订阅模型”实现对集群配置文件的管理与维护。“发布/订阅模型”分为推模式（Push）与拉模式（Pull）。zk 的“发布/订阅模型”采用的是推拉相结合的模式。</p>
<p>和Nacos、Spring Cloud Config、携程的阿波罗 作用一样</p>
<p>其实现的具体步骤为：</p>
<p>Step1：发布者应用程序作为 zk 客户端首先需要在 zk 中创建一个节点，该节点的数据内容即为当前被监控集群主机的配置文件。<br>Step2：被监控集群主机在启动时首先需要从 zk 的节点上读取数据内容，即配置文件内容。<br>Step3：读取过数据内容后，再向 zk 的该节点注册数据内容变更的 watcher 监听。<br>Step4：发布者将更新过的配置文件内容更新到 zk 的对应节点数据内容上。此时 zk 会引发相应 watcher 事件，然后向每一个被监控主机推送 watcher 事件。<br>Step5：被监控集群主机在接收到 watcher 事件后，会触发本地 watcher 调用执行回调方法，回调方法会从 zk 中拉取节点的数据内容，即更新过的配置文件内容。</p>
<h2 id="2-命名服务"><a href="#2-命名服务" class="headerlink" title="2.命名服务"></a>2.命名服务</h2><p>命名服务是指可以为一定范围内的元素命名一个唯一标识，以与其它元素进行区分。在分布式系统中被命名的实体可以是集群中的主机、服务地址等。</p>
<p>2.2 实现原理</p>
<p>通过利用zk 中节点路径不可重复的特点来实现命名服务的。当然，也可以配带上顺序节点的有序性来体现唯一标识的顺序性。</p>
<p>具体实现步骤：</p>
<p>Step1：生成器在启动时首先需要在 zk 中创建一个根节点，例如/app<br>Step2：根据具体业务需求，在根节点/app 下创建多级子节点，每一级子节点名称使用对应级别的模块名称。例如，/app/一级模块名称/二级模块名称<br>Step3：再在模块节点下创建顺序节点，而节点名称可以根据业务需求指定。在生成时会自动为该名称添加上序号。此时该顺序节点的全路径即为生成的唯一标识</p>
<h2 id="3-集群监控"><a href="#3-集群监控" class="headerlink" title="3.集群监控"></a>3.集群监控</h2><p>对于集群，我们总是希望能够随时获取到当前集群中各个主机的运行时状态、当前集群中主机的存活状况等信息。通过 zk 可以实现对集群的随时监控。</p>
<p>3.1 基本原理<br>zk 进行集群管理的基本原理如下图所示。</p>
<p>图解：<br>监控系统启动的时候先在ZK中注册/clusterManager根节点，并注册子节点列表变更Watcher监听</p>
<p>被监控集群的主机一启动，就在/clusterManager根节点下创建相应的临时子节点（临时节点好处就是被监听的服务器如果挂了，会话就没了，临时节点就没了）</p>
<p>一但被监控集群有节点新加入或者挂了，就会触发子节点列表变更事件，监控系统就会触发Watcher的回调，更新信息，例如把这些子节点列表都读取过来，在界面上显示出来，即显示存活状态</p>
<p>除了显示存活状态，还可以让被监控的主机定时向自己的节点里面更新其他状态数据，这样监控系统可以随时获取这些状态数据</p>
<p>具体实现步骤是：</p>
<p>Step1：监控系统在启动时会在 zk 中创建一个根节点，例如/clusterManager<br>Step2：当集群主机应用启动后，就会自动在 zk 的监控系统根节点下创建一个对应的临时子节点，并将自己的运行状态定时写入到该临时节点，或根节点的数据内容中，例如主机当前正在处理的连接请求有多少，当前主机的权重等。写入到这两个节点的效果是不同的：<br>写到临时节点：临时节点消失后，从监控系统中根本就查找不到任何该临时节点对应主机的信息。<br>写入到根节点：可以获取到所有曾经存在过的节点信息。<br>Step3：监控系统在根节点/clusterManager 上注册一个 watcher 监听。一旦集群中增减主机，就会引发子节点数量变更的 watcher 事件。然后 zk 会将事件推送给监控系统<br>Step4：监控系统在接收到 zk 发送的事件后，调用相应的 watcher 对象回调，将变化情况显示到监控平台。<br>Step5：若集群主机状态信息是写入到根节点数据内容的，那么监控系统需要在根节点上再注册一个数据内容变更的 watcher 监听，以实时获取到集群主机的状态数据。<br>Step6：若集群主机状态信息是写入到对应临时节点的，那么监控系统需要在每个主机临时节点上注册数据内容变更的 watcher 监听，以实时获取到集群主机的状态数据。<br>3.2 分布式日志收集系统<br>下面以分布式日志收集系统为例来分析 zk 对于集群的管理。</p>
<p>（1） 系统组成<br>首先要清楚，分布式日志收集系统由四部分组成：日志源集群、日志收集器集群，zk集群，及监控系统。</p>
<p>（2） 系统工作原理</p>
<p>图解：<br>sourcehost这些源节点，设置为临时节点，监控存活状态很简单</p>
<p>收集器collector1/2/3…这些节点只能设置为持久节点，监控存活状态比较困难，怎么处理？</p>
<p>可以在collector持久节点下再创建收集器自己的临时节点，如果该临时节点没了，代表其收集器主机挂了</p>
<p>但是如果收集器的临时节点挂了，其收集器的持久节点，还有对应的源主机临时节点还在怎么办？</p>
<p>这个时候就需要将这些源主机的临时节点分配给其他收集器主机，怎么分配？</p>
<p>负载均衡，谁的压力小给谁，按照每个收集器收集的主机数量或者每个主机的日志产生量等判断<br>可以为每一个收集器主机分配一个负载量，然后把挂掉的collector对应的主机按照我们自己的分配方式，进行分配，比如找到压力最大的前几个收集器排除掉，然后把需要分配的主机分配给剩下的收集器。</p>
<p>如果要扩容，可以把压力最大的收集器，或者压力最大的前几个里面，挑出来分给新加的收集器</p>
<p>分布式日志收集系统的工作步骤有以下几步：</p>
<p>A、收集器的注册<br>在 zk 上创建各个收集器对应的节点。<br>B、 任务分配<br>系统根据收集器的个数，将所有日志源集群主机分组，分别分配给各个收集器。<br>C、 状态收集<br>这里的状态收集指的是两方面的收集：<br>日志源主机状态，例如，日志源主机是否存活，其已经产生多少日志等<br>收集器的运行状态，例如，收集器本身已经收集了多少字节的日志、当前 CPU、内存的使用情况等<br>D、任务再分配 Rebalance<br>当出现收集器挂掉或扩容，就需要动态地进行日志收集任务再分配了，这个过程称为Rebalance。只要发现某个收集器挂了，则系统进行任务再分配。</p>
<h2 id="4-DNS-服务"><a href="#4-DNS-服务" class="headerlink" title="4.DNS 服务"></a>4.DNS 服务</h2><p>zk 的 DNS 服务的功能主要是实现消费者与提供者的解耦合，防止提供者的单点问题，实现对提供者的负载均衡。</p>
<p>图解：<br>比如消费者想要调用service1，就先从ZK中把注册表（即Service1服务节点下所有主机列表）读到，然后内部根据负载均衡策略选一个主机调用服务<br>此时ZK提供的功能就是把服务提供者注册到ZK里面，然后消费者通过读取的注册表，负载均衡调用服务，即提供者写，调用者读。Dubbo就是这样实现的。</p>
<p>什么是 DNS<br>DNS，Domain Name System，域名系统，即可以将一个名称与特定的主机 IP 加端口号进行绑定。zk 可以充当 DNS 的作用，完成域名到主机的映射。</p>
<p>4.2 基本 DNS 实现原理<br>假设提供者应用程序 app1 与 app2 分别用于提供 service1 与 service2 两种服务，现要将其注册到 zk 中，具体的实现步骤如下图所示。</p>
<p>具体实现步骤：</p>
<p>Step1：在 zk 上为当前 DNS 功能创建一个根节点，例如/DNS。<br>Step2：以该提供者的服务名称为名在应用根节点下创建子节点，该节点即为域名节点，例如/DNS/ service1。<br>Step3：为域名节点添加数据内容，数据内容为当前服务的所有提供者主机地址集合，即多个提供者地址间使用逗号分隔。<br>4.3 具有状态收集功能的 DNS 实现原理</p>
<p>以上模型存在一个问题，如何获取各个提供者主机的健康状态、运行状态呢？可以为每一个域名节点再添加一个状态子节点，而该状态子节点的数据内容则为开发人员定义好的状态数据。这些状态数据是如何获取到的呢？是通过状态收集器（开发人员自行开发的）定期写入到 zk 的该节点中的。</p>
<p>一些其他情况的处理：</p>
<p>时间差问题：状态收集器是定时更新状态的，会导致提供者主机已经挂了，ZK还没跟新，恰好有消费者把ZK的数据内容读取到了，且调用服务的机器就是挂掉的</p>
<p>如何解决：方案很多，如下是为主机定义临时节点的解决方案</p>
<p>如果一个服务提供者全挂了怎么办？服务降级，降级点很多，例如消费者本身可以这么处理，提供者不行，用本地代码返回一些信息<br>降级目的就是增强用户体验</p>
<p>扩展-集群监控平台</p>
<p>PS：绿色都需要程序员来实现<br>阿里的 Dubbo 就是使用 Zookeeper 作为域名服务器的。</p>
<h2 id="5-Master-选举"><a href="#5-Master-选举" class="headerlink" title="5.Master 选举"></a>5.Master 选举</h2><p>集群是分布式系统中不可或却的组成部分，是为了解决分布式系统中计算单元的单点问题，水平扩展计算单元的处理能力的一种解决方案。</p>
<p>一般情况下，会在群集中选举出一个 Master，用于协调集群中的其它 Slave 主机，对于Slave 主机的状态具有决定权。</p>
<p>5.2 广告推荐系统</p>
<p>系统会根据用户画像，将用户归结为不同的种类。系统会为不同种类的用户推荐不同的广告。每个用户前端需要从广告推荐系统中获取到不同的广告 ID。</p>
<p>（2） 分析<br>这个向前端提供服务的广告推荐系统一定是一个集群，这样可以更加快速高效的为前端进行响应。需要注意，推荐系统对于广告 ID 的计算是一个相对复杂且消耗 CPU 等资源的过程。如果让集群中每一台主机都可以执行这个计算逻辑的话，那么势必会形成资源浪费，且降低了响应效率。此时，可以只让其中的一台主机去处理计算逻辑，然后将计算的结果写入到某中间存储系统中，并通知集群中的其它主机从该中间存储系统中共享该计算结果。那么，这个运行计算逻辑的主机就是 Master，而其它主机则为 Slave。</p>
<p>（3） 架构</p>
<p>用户画像：对用户，用一堆属性进行刻画，描述，一般用户画像系统少的20 维、30维，多的上百维，用户画像系统描述信息的维度越高，系统需要的性能就要越高，否则无法运算</p>
<p>整个广告推荐系统是一个集群，5台机器，如果让5台机器既处理读又处理运算，会导致用户前端体验比较差，每台Slave主机运行效率都比较低</p>
<p>所以Master负责运行，并写入到中间存储系统，Slave负责读</p>
<p>整个流程：用户前端访问Slave，Slave先去中间存储系统，如果有直接返回，如果没有，请求转给Master，由Master根据用户id，从用户画像系统找到对应的画像，然后再根据广告管理系统进行运算，把运算结果，广告的id存入中间存储系统，然后推给用户</p>
<p>所以这个系统就需要读写分离</p>
<h3 id="Master选举方式：zk-dbms-redis"><a href="#Master选举方式：zk-dbms-redis" class="headerlink" title="Master选举方式：zk,dbms,redis"></a>Master选举方式：zk,dbms,redis</h3><p>方案一：使用【 DBMS 的主键唯一】特性可以实现 Master 的选举。集群启动时，让所有集群主机向数据库某表中插入主键相同的记录。</p>
<ul>
<li>优点：启动 or 重新选举时，实现master选举</li>
<li>弊端：Master down时，主键记录无法被删除，导致无法重新选举</li>
</ul>
<p>方案二：使用 zk中【多个客户端对同一节点创建时，只有一个客户端可以成功】和【临时节点在client宕机时被zk删除】的特性实现。</p>
<ul>
<li>优点：启动 or 重新选举时，实现master选举；Master down时，可以重新选举</li>
</ul>
<p>具体来说，由三步完成：</p>
<p>Step1：多个客户端同时发起对同一临时节点/master-election/master 进行创建的请求，最终只能有一个客户端成功。这个成功的客户端主机就是 Master，其它客户端就是 Slave。<br>Step2：让 Slave 都向这个临时节点的父节点/master-election 注册一个子节点列表的watcher 监听。<br>Step3：一旦该 Master 宕机，临时节点就会消失，zk 服务器就会向所有 Slave 发送子节点变更事件，Slave 在接收到事件后会调用相应的回调方法，该回调方法会重新向这个父节点创建相应的临时子节点。谁创建成功，谁就是新的 Master。</p>
<h2 id="6-分布式同步"><a href="#6-分布式同步" class="headerlink" title="6.分布式同步"></a>6.分布式同步</h2><p>分布式同步，也称为分布式协调，是分布式系统中不可缺少的环节，是将不同的分布式组件有机结合起来的关键。对于一个在多台机器上运行的应用而言，通常需要一个协调者来控制整个系统的运行流程，例如执行的先后顺序，或执行与不执行等。</p>
<p>6.2 MySQL 数据复制总线<br>下面以“MySQL 数据复制总线”为例来分析 zk 的分布式同步服务。</p>
<p>（1） 数据复制总线组成<br>MySQL 数据复制总线是一个实时数据复制框架，用于在不同的 MySQL 数据库实例间（Mysql本身的主从做不到）进行异步数据复制。其核心部分由三部分组成：生产者、复制管道、消费者。</p>
<img src="https://img-blog.csdnimg.cn/20200701141844520.png" alt="在这里插入图片描述" style="zoom:50%;" />

<blockquote>
<p>生产者和消费者，是不同的DB厂商(图中有纰漏，比如生产者是oracle，消费者是mysql)、Mysql版本、Mys数据库实体 、数据库名、表，但是要求只拷贝某个表的某一个字段到另一个数据库表的某一个字段，即对两段的数据库没有任何要求</p>
</blockquote>
<p>那么，MySQL 数据复制总线系统中哪里需要使用 zk 的分布式同步功能呢？以上结构中可以显示看到存在的问题：replicator 存在单点问题。为了解决这个问题，就需要为其设置多个热备主机。那么，这些热备主机是如何协调工作的呢？这时候就需要使用 zk 来做协调工作了，即由 zk 来完成分布式同步工作。</p>
<p>（2） 数据复制总线工作原理</p>
<img src="https://img-blog.csdnimg.cn/20200701141958496.png" alt="在这里插入图片描述" style="zoom:67%;" />

<blockquote>
<p>绿色表示开发者自己实现的逻辑代码</p>
</blockquote>
<p>1.【协调者】启动阶段：创建【根节点/mysql_replicator】</p>
<ol start="2">
<li><p>【任务】阶段启动阶段：每一个复制任务【payRecord任务、orderRecord任务】都会在【根节点mysql_replicator】下创建一个子节点【pay_record节点, order_record节点】，每个任务的节点下都有【status节点】和【instances节点】，【协调者】会在【instanes节点】上注册子节点列表的【变更watcher】(注意：此时 host1-001, host2-002节点还没被创建）</p>
</li>
<li><p>【replicator】启动阶段：对【status节点】注册【数据内容watcher监听】，紧接着在【instances节点】下创建相应的【有序临时节点】</p>
</li>
<li><p>此时【协调者】对【instances节点】的【变更watcher】监听回调会被触发，回调会马上指定各个replicator主机的状态（按照自己定义的规则，例如哪个节点的序号最小就设置为RUNNING 状态，其他设置为STANDBY 状态），将状态写入【status节点】</p>
</li>
<li><p>status节点内容发生变更，马上触发replicator对status节点的数据内容watcher监听，回调中就会把status内容读取并解析，检测到自己状态是running就会进行复制任务</p>
</li>
</ol>
<p>5.进行复制任务中，每复制一条就会记录RUNNING主机对Binlog的消费点，记到instances里面</p>
<p>6.如果运行中的replicator挂了，意味着instances列表会发生变更，会触发协调者对应的子节点列表变更watcher监听，回调中会马上读取instances节点的所有子节点，指定新的replicator是running状态，其他是STANDBY 状态，写入到status节点</p>
<p>7.写入status节点后，又会马上触发replicator对status节点的数据内容watcher监听，replicator解析内容检测到自己是running后又开始复制任务，复制任务会首先从instances节点中拿到Binlog的消费点，从这之后做复制。</p>
<blockquote>
<p>思考：replicator的master选举，是否可以避开【协调者】呢？</p>
<p>当然可以，【5.Master选举】就给出了示例</p>
</blockquote>
<p>MySQL 复制总线的工作步骤，总的来说分为三步：<br>A、复制任务注册</p>
<p>复制任务注册实际就是指不同的复制任务在 zk 中创建不同的 znode，即将复制任务注册到 zk 中。</p>
<p>B、 replicator 热备</p>
<p>复制任务是由 replicator 主机完成的。为了防止 replicator 在复制过程中出现故障，replicator 采用热备容灾方案，即将同一个复制任务部署到多个不同的 replicator 主机上，但仅使一个处于 RUNNING 状态，而其它的主机则处于 STANDBY 状态。当 RUNNING 状态的主机出现故障，无法完成复制任务时，使某一个 STANDBY 状态主机转换为 RUNNING 状态，继续完成复制任务。</p>
<p>C、 主备切换</p>
<p>当 RUNNING 态的主机出现宕机，则该主机对应的子节点马上就被删除了，然后在当前处于 STANDBY 状态中的 replicator 中找到序号最小的子节点，然后将其状态马上修改为RUNNING，完成“主备切换”。</p>
<h2 id="7-分布式锁"><a href="#7-分布式锁" class="headerlink" title="7.分布式锁"></a>7.分布式锁</h2><p>分布式锁是控制分布式系统同步访问共享资源的一种方式。Zookeeper 可以实现分布式锁功能。根据用户操作类型的不同，可以分为排他锁与共享锁。</p>
<p>7.1 分布式锁的实现<br>在 zk 上对于分布式锁的实现，使用的是类似于“/xs_lock/[hostname]-请求类型-序号”的临时顺序节点。当客户端发出读写请求时会在 zk 中创建不同的节点。根据读写操作的不同及当前节点与之前节点的序号关系来执行不同的逻辑。</p>
<p>具体实现步骤：</p>
<p>Step1：当一个客户端向某资源发出读/写请求时，若发现其为第一个请求，则首先会在 zk中创建一个根节点。若节点已经存在，则无需创建。<br>Step2：根节点已经存在了，客户端在根节点上注册子节点列表变更的 watcher 监听。<br>Step3：watcher 注册完毕后，其会在根节点下人创建一个读/写操作的临时顺序节点。<br>Step4：节点创建完毕后，其就会马上触发客户端的 watcher 回调的执行。回调方法首先会将子节点列表读取，然后会查看序号比自己小的节点，并根据读写操作的不同，执行不同的逻辑。<br>如果当前节点是读，比自己小的都是读，就可以读<br>如果当前节点是写，只要有比自己小的，都不能写<br>Step5：客户端读写操作完毕，其与 zk 的连接断开，则 zk 中该会话对应的节点消失。<br>7.2 分布式锁的改进<br>前面的实现方式存在“羊群效应”，为了解决其所带来的性能下降，可以对前述分布式锁的实现进行改进。</p>
<p>由于一个操作而引发了大量的低效或无用的操作的执行，这种情况称为羊群效应。</p>
<p>当客户端请求发出后，在 zk 中创建相应的临时顺序节点后马上获取当前的/xs_lock 的所有子节点列表，但任何客户端都不再向/xs_lock 注册用于监听子节点列表变化的 watcher，而是改为根据请求类型的不同向“对其有影响的”子节点注册 watcher。</p>
<p>对其有影响：</p>
<p>如果当前节点是读，第一看自己是不是最小的，如果是肯定能执行，如果不是最小的，看我前面有没有写操作，如果有写操作，就不能读，并且只需要关注比自己小，并且最近的写节点即可,即对该节点注册 节点删除的监听Watcher，Watcher一回调就代表可以写了。<br>如果当前节点是写，如果不是最小的，则直接监听自己前一个节点，如果前一个节点被删除了，触发Watcher，在Watcher回调中，拉取根节点的子节点列表，判断自己前面还有没有节点，如果有，继续监听自己前面的节点，递归，直到自己前面没有节点即可写操作。<br>8. 分布式队列<br>说到分布式队列，我们马上可以想到 RabbitMQ、Kafka 等分布式消息队列中间件产品。zk 也可以实现简单的消息队列。</p>
<p>8.1 FIFO 队列</p>
<p>zk 实现 FIFO 队列的思路是：利用顺序节点的有序性，为每个数据在 zk 中都创建一个相应的节点。然后为每个节点都注册 watcher 监听。一个节点被消费，则会引发消费者消费下一个节点，直到消费完毕。</p>
<p>其具体的实现步骤是：</p>
<p>Step1：为每一个数据按照其到达的顺序为其创建顺序子节点，且将数据作为节点的数据内容。这个子节点可以是持久顺序子节点，也可以是临时顺序子节点。不同类型，后面的监听方案是不同的。<br>Step2：若注册的为持久顺序节点。每个消费者会向其所消费的那个节点的前一个节点注册一个“数据内容变更事件”的 watcher 监听。若其消费的是第一个节点，则无需注册监听，可以直接消费。<br>Step3：当一个消费者对一个数据消费过后，会马上修改该节点的数据内容。而该数据内容的变化会引发一个 watcherEvent 事件，并会将此事件发送给监听者。<br>Step4：监听者在接收到 watcherEvent 后，调用其回调方法。该回调方法会来读取其所要消费的节点的数据内容。该节点的数据内容被读取后，数据内容会被修改。而该修改会引发一个 watcherEvent 事件，并会将此事件发送给监听者，然后再循环执行第 4 步<br>8.2 分布式屏障 Barrier 队列</p>
<p>Barrier，屏障、障碍物。Barrier 队列是分布式系统中的一种同步协调器，规定了一个队列中的元素必须全部聚齐后才能继续执行后面的任务，否则一直等待。其常见于大规模分布式并行计算的应用场景中：最终的合并计算需要基于很多并行计算的子结果来进行。</p>
<p>zk 对于 Barrier 的实现原理是，在 zk 中创建一个/barrier 节点，其数据内容设置为屏障打开的阈值，即当其下的子节点数量达到该阈值后，app 才可进行最终的计算，否则一直等待。每一个并行运算完成，都会在/barrier 下创建一个子节点，直到所有并行运算完成。</p>
<p>其具体的实现步骤是：</p>
<p>Step1：创建一个/barrier 节点，其数据内容设置为屏障打开的阈值<br>Step2：应用程序向/barrier 注册一个 watcher 监听，监听其下的子节点数量变化<br>Step3：开始每一个并行计算。对于每个并行计算，每计算出一个子结果，就会在/barrier下创建一个子节点，而每增加一个节点，就会触发应用程序获取/barrier 的子节点列表，当子节点个数与阈值相等时，则会开启最终的合并计算，即打开了屏障</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/zookeeper-02-Leader%E7%9A%84%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/zookeeper-02-Leader%E7%9A%84%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">zookeeper-02-Leader的选举机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-16 19:48:27" itemprop="dateCreated datePublished" datetime="2021-02-16T19:48:27+08:00">2021-02-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>需要注意，对源码的阅读主要包含两方面。一个是对<a href="">重要类、重要成员变量、重要方法的注释的阅读</a>;一个是对<a href="">重要方法的业务逻辑</a>的分析。</p>
<h1 id="将-zookeeper-源码导入到-Idea"><a href="#将-zookeeper-源码导入到-Idea" class="headerlink" title="将 zookeeper 源码导入到 Idea"></a>将 <strong>zookeeper</strong> 源码导入到 <strong>Idea</strong></h1><h2 id="下载并安装-Ant"><a href="#下载并安装-Ant" class="headerlink" title="下载并安装 Ant"></a>下载并安装 <strong>Ant</strong></h2><p>(<strong>1</strong>) 下载 **Ant<br>** Ant 官网: <a target="_blank" rel="noopener" href="http://ant.apach.org/">http://ant.apach.org</a></p>
<p>(<strong>2</strong>) 安装配置 <strong>Ant</strong></p>
<p>在命令行窗口的任意目录下执行 Ant –version 命令，可以看到版本号，则说明 Ant 安装 成功。</p>
<h2 id="导入到-Idea"><a href="#导入到-Idea" class="headerlink" title="导入到 Idea"></a>导入到 <strong>Idea</strong></h2><p>打开 Idea，选择导入工程，找到 zk 的源码解压目录，直接导入。</p>
<h1 id="选举算法源码中的总思路"><a href="#选举算法源码中的总思路" class="headerlink" title="选举算法源码中的总思路"></a>选举算法源码中的总思路</h1><p>Zookeeper 的 Leader 选举类是 FastLeaderElection，该类是 ZAB 协议在 Leader 选举中的工 程应用，所以直接找到该类对其进行分析。该类中的最为重要的方法为 lookForLeader()，是 选举 Leader 的核心方法。该方法大体思路可以划分为以下几块:</p>
<h2 id="选举前的准备工作"><a href="#选举前的准备工作" class="headerlink" title="选举前的准备工作"></a>选举前的准备工作</h2><p>选举前需要做一些准备工作，例如，创建选举对象、创建选举过程中需要用到的集合、 初始化选举时限等。</p>
<p>将自己作为初始化 <strong>Leader</strong> 投出去</p>
<p>在当前 Server 第一次投票时会先将自己作为 Leader，然后将自己的选票广播给其它所 有 Server。</p>
<h2 id="验证自己的投票与大家的投票谁更适合做-Leader"><a href="#验证自己的投票与大家的投票谁更适合做-Leader" class="headerlink" title="验证自己的投票与大家的投票谁更适合做 Leader"></a>验证自己的投票与大家的投票谁更适合做 <strong>Leader</strong></h2><p>在“我选我”后，当前Server同样会接收到其它Server发送来的选票通知(Notification)。 通过 while 循环，遍历所有接收到的选票通知，比较谁更适合做 Leader。若找到一个比自己 更适合的 Leader，则修改自己选票，重新将新的选票广播出去。当然，每验证一个选票，则 会将其记录到一个集合中，将来用于进行票数统计。</p>
<h2 id="判断本轮选举是否应结束"><a href="#判断本轮选举是否应结束" class="headerlink" title="判断本轮选举是否应结束"></a>判断本轮选举是否应结束</h2><p>其实在每次验证过谁更适合做 Leader 后，就会马上判断当前的选举是否可以结束了， 即当前主机所推荐的这个选票是否过半了。若过半了，则直接完成后续的一些收尾工作，例 如清空选举过程中所使用的集合，以备下次使用;再例如，生成最终的选票，以备其它 Server 来同步数据。若没有过半，则继续从队列中读取出下一个来自于其它主机的选票，然后进行 验证。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/zookeeper-%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/zookeeper-%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">zookeeper-安装</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-16 09:57:32" itemprop="dateCreated datePublished" datetime="2021-02-16T09:57:32+08:00">2021-02-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-10 13:29:18" itemprop="dateModified" datetime="2022-02-10T13:29:18+08:00">2022-02-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h1><p>3个zk节点</p>
<h1 id="安装第一台zk"><a href="#安装第一台zk" class="headerlink" title="安装第一台zk"></a>安装第一台zk</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirrors.bfsu.edu.cn&#x2F;apache&#x2F;zookeeper&#x2F;zookeeper-3.6.2&#x2F;apache-zookeeper-3.6.2-bin.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压到/opt/apps目录下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf apache-zookeeper-3.6.2-bin.tar.gz -C /opt/apps</span><br></pre></td></tr></table></figure>

<p>创建软链接以屏蔽冗长版本号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /opt/apps/zookeeper-3.6.2 /opt/apps/zk</span><br></pre></td></tr></table></figure>

<h2 id="复制配置文件"><a href="#复制配置文件" class="headerlink" title="复制配置文件"></a><strong>复制配置文件</strong></h2><p>复制 Zookeeper 安装目录下的 conf 目录中的 zoo_sample.cfg 文件，并命名为 zoo.cfg。</p>
<h2 id="修改配置文件zoo-cfg"><a href="#修改配置文件zoo-cfg" class="headerlink" title="修改配置文件zoo.cfg"></a>修改配置文件zoo.cfg</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">新建数据目录</span></span><br><span class="line">dataDir=/opt/data/zookeeper</span><br><span class="line"><span class="meta">#</span><span class="bash">创建目录</span></span><br><span class="line">mkdir -p /opt/data/zk</span><br></pre></td></tr></table></figure>



<h2 id="注册-bin-目录"><a href="#注册-bin-目录" class="headerlink" title="注册 bin 目录"></a><strong>注册</strong> <strong>bin</strong> <strong>目录</strong></h2><p>为了保证zk目录下的命令全局可用，注册到bin目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export ZK_HOME=/opt/apps/zk</span><br><span class="line">export PATH=$ZK_HOME/bin/:$PATH</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="操作-zk"><a href="#操作-zk" class="headerlink" title="操作 zk"></a><strong>操作</strong> <strong>zk</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#开启 zk</span><br><span class="line">zkServer.sh start</span><br><span class="line"></span><br><span class="line">#查看状态</span><br><span class="line">zkServer.sh status</span><br><span class="line"></span><br><span class="line">#关闭zk</span><br><span class="line">zkServer.sh restart</span><br></pre></td></tr></table></figure>



<h1 id="验证单机安装"><a href="#验证单机安装" class="headerlink" title="验证单机安装"></a>验证单机安装</h1><p>是否可以对外提供服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 192.168.199.161:zk端口号</span><br></pre></td></tr></table></figure>

<p>如果无法访问，那么关闭防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
