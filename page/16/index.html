<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/16/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/16/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/database/redis/redis%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/Redis-%E7%BA%BF%E4%B8%8A%E9%AB%98%E5%BB%B6%E8%BF%9F%E6%8E%92%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/database/redis/redis%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/Redis-%E7%BA%BF%E4%B8%8A%E9%AB%98%E5%BB%B6%E8%BF%9F%E6%8E%92%E6%9F%A5/" class="post-title-link" itemprop="url">Redis-线上高延迟排查</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-06 12:04:04 / Modified: 13:22:05" itemprop="dateCreated datePublished" datetime="2021-05-06T12:04:04+08:00">2021-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="一条命令执行过程"><a href="#一条命令执行过程" class="headerlink" title="一条命令执行过程"></a>一条命令执行过程</h3><p>在本文场景下，延迟 (latency) 是指从客户端发送命令到客户端接收到命令返回值的时间间隔。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdhic9zTZh5xCllEzgLWRcOXQoemRPGek07hlpV6XpJsFTsnZuTyeVWg7Gymsd7yU84UOhwXMUSe3A/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>上图是 Redis 客户端发送一条命令的执行过程示意图，绿色的是执行步骤，而蓝色的则是可能出现的导致高延迟的原因。</p>
<h4 id="网络连接限制、网络传输速率和CPU性能等是所有服务端都可能产生的性能问题"><a href="#网络连接限制、网络传输速率和CPU性能等是所有服务端都可能产生的性能问题" class="headerlink" title="网络连接限制、网络传输速率和CPU性能等是所有服务端都可能产生的性能问题"></a>网络连接限制、网络传输速率和CPU性能等是所有服务端都可能产生的性能问题</h4><h4 id="Redis-自己可能导致高延迟"><a href="#Redis-自己可能导致高延迟" class="headerlink" title="Redis 自己可能导致高延迟"></a>Redis 自己可能导致高延迟</h4><ul>
<li>命令或者数据结构误用、持久化阻塞和内存交换。</li>
<li>而且，Redis 采用<a href="">单线程</a>和<a href="">事件驱动的机制</a>来处理网络请求，分别有对应的<a href="">连接应答处理器</a>，<a href="">命令请求处理器</a>和<a href="">命令回复处理器</a>来处理客户端的网络请求事件，处理完一个事件就继续处理队列中的下一个。一条命令处理出现了高延迟会影响接下来处于排队状态的其他命令。</li>
</ul>
<img src="https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdhic9zTZh5xCllEzgLWRcOXscLk1bRExg5BlLia5K6hRZQz1gUakMksxtLjkl7ibMDMz8m9ib2evyEYg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:50%;" />

<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><p>对于高延迟，Redis 原生提供慢查询统计功能，执行 slowlog get {n} 命令可以获取最近的 n 条慢查询命令，默认对于执行超过10毫秒(可配置)的命令都会记录到一个定长队列中，线上实例建议设置为1毫秒便于及时发现毫秒级以上的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 超过 slowlog-log-slower-than 阈值的命令都会被记录到慢查询队列中</span><br><span class="line"># 队列最大长度为 slowlog-max-lenslowlog-log-slower-than 10000s lowlog-max-len 128</span><br></pre></td></tr></table></figure>

<p>如果命令执行时间在毫秒级，则实例实际OPS只有1000左右。慢查询队列长度默认128，可适当调大。慢查询本身只记录了命令执行时间，不包括数据网络传输时间和命令排队时间，因此客户端发生阻塞异常 后，可能不是当前命令缓慢，而是在等待其他命令执行。需要重点比对异常和慢查询发生的时间点，确认是否有慢查询造成的命令阻塞排队。</p>
<h4 id="不合理的命令或者数据结构"><a href="#不合理的命令或者数据结构" class="headerlink" title="不合理的命令或者数据结构"></a>不合理的命令或者数据结构</h4><p>比如对一个包含上万个元素的 hash 结构执行 hgetall 操作，由于数据量比较大且命令算法复杂度是 O(n)，这条命令执行速度必然很慢。</p>
<p>这个问题就是典型的不合理使用命令和数据结构。对于高并发的场景我们应该尽量避免在大对象上执行算法复杂度超过 O(n) 的命令。对于键值较多的 hash 结构可以使用 scan 系列命令来逐步遍历，而不是直接使用 hgetall 来全部获取。</p>
<p>Redis 本身提供发现大对象的工具，对应命令：redis-cli-h {ip} -p {port} bigkeys。这条命令会使用 scan 从指定的 Redis DB 中持续采样，实时输出当时得到的 value 占用空间最大的 key 值，并在最后给出各种数据结构的 biggest key 的总结报告。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; redis-cli -h host -p 12345 --bigkeys</span><br></pre></td></tr></table></figure>

<h4 id="持久化阻塞"><a href="#持久化阻塞" class="headerlink" title="持久化阻塞"></a>持久化阻塞</h4><p>对于开启了持久化功能的Redis节点，需要排查是否是持久化导致的阻塞。持久化引起主线程阻塞的操作主要有：fork 阻塞、AOF刷盘阻塞。</p>
<p>fork 操作发生在 RDB 和 AOF 重写时，Redis 主线程调用 fork 操作产生共享内存的子进程，由子进程完成对应的持久化工作。如果 fork 操作本身耗时过长，必然会导致主线程的阻塞。</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdhic9zTZh5xCllEzgLWRcOXA2v2rmicbJ08REVFIiaYfMbvnJtMTqCV27OtND6ZCkibB9ia69ZWlmr3rw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:67%;" />

<p>Redis 执行 fork 操作产生的子进程内存占用量表现为与父进程相同，理论上需要一倍的物理内存来完成相应的操作。但是 Linux 具有写时复制技术 (copy-on-write)，父子进程会共享相同的物理内存页，当父进程处理写请求时会对需要修改的页复制出一份副本完成写操作，而子进程依然读取 fork 时整个父进程的内存快照。所以，一般来说，fork 不会消耗过多时间。</p>
<p>可以执行 <code>info stats</code>命令获取到 latestforkusec 指标，表示 Redis 最近一次 fork 操作耗时，如果耗时很大，比如超过1秒，则需要做出优化调整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; redis-cli -c -p 7000 info | grep -w latest_fork_useclatest_fork_usec:315</span><br></pre></td></tr></table></figure>

<p>当我们开启AOF持久化功能时，文件刷盘的方式一般采用每秒一次，后台线程每秒对AOF文件做 fsync 操作。当硬盘压力过大时，fsync 操作需要等待，直到写入完成。如果主线程发现距离上一次的 fsync 成功超过2秒，为了数据安全性它会阻塞直到后台线程执行 fsync 操作完成。这种阻塞行为主要是硬盘压力引起，可以查看 Redis日志识别出这种情况，当发生这种阻塞行为时，会打印如下日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Asynchronous AOF fsync is taking too long (disk is busy). \Writing the AOF buffer without waiting for fsync to complete, \this may slow down Redis.</span><br></pre></td></tr></table></figure>

<p>也可以查看 info persistence 统计中的 aofdelayedfsync 指标，每次发生 fdatasync 阻塞主线程时会累加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;info persistenceloading:0aof_pending_bio_fsync:0aof_delayed_fsync:0</span><br></pre></td></tr></table></figure>

<h4 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h4><p>内存交换（swap）对于 Redis 来说是非常致命的，Redis 保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把 Redis 使用的部分内存换出到硬盘，由于内存与硬盘读写速度差几个数量级，会导致发生交换后的 Redis 性能急剧下降。识别 Redis 内存交换的检查方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;redis-cli -p 6383 info server | grep process_id # 查询 redis 进程号</span><br><span class="line">&gt;cat &#x2F;proc&#x2F;4476&#x2F;smaps | grep Swap # 查询内存交换大小Swap: 0 kBSwap: 4 kBSwap: 0 kBSwap: 0 kB</span><br></pre></td></tr></table></figure>

<p>如果交换量都是0KB或者个别的是4KB，则是正常现象，说明Redis进程内存没有被交换。</p>
<p>有很多方法可以避免内存交换的发生。比如说：</p>
<ul>
<li>保证机器充足的可用内存</li>
<li>确保所有Redis实例设置最大可用内存(maxmemory)，防止极端情况下 Redis 内存不可控的增长。</li>
<li>降低系统使用swap优先级，如 <code>echo 10&gt;/proc/sys/vm/swappiness</code>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/05/database/redis/redis%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/Redis-%E7%BA%BF%E4%B8%8ACPU%E9%A3%99%E5%8D%87%E6%8E%92%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/05/database/redis/redis%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/Redis-%E7%BA%BF%E4%B8%8ACPU%E9%A3%99%E5%8D%87%E6%8E%92%E6%9F%A5/" class="post-title-link" itemprop="url">Redis-线上CPU飙升排查</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-05 23:10:13" itemprop="dateCreated datePublished" datetime="2021-05-05T23:10:13+08:00">2021-05-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-15 08:20:54" itemprop="dateModified" datetime="2021-06-15T08:20:54+08:00">2021-06-15</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Redis调用时间严重超时，这样高速的缓存反而变成了短板，由于数据一直没有返回，导致了请求响应变慢。</p>
<h2 id="网页监控"><a href="#网页监控" class="headerlink" title="网页监控"></a>网页监控</h2><p>通过阿里的 Grafana 监控，服务器的 CPU 负载、内存、网络输入输出都挺正常的，所以肯定是 Redis 出现了问题。</p>
<p>使用的是单节点的 32M 16GB 的阿里云 Redis，登录网页监控看性能监控，发现 CPU 使用情况飙升到100%</p>
<p>QPS 虽然从 1000 多升到 6000，但是远远低于极限值，连接数量从 0 升到 3000，也是远远低于极限值（可能用户刚上班，开始有请求，然后响应延迟，导致命令队列数量过多，打开很多连接）。</p>
<hr>
<h2 id="服务器命令监控"><a href="#服务器命令监控" class="headerlink" title="服务器命令监控"></a>服务器命令监控</h2><p>登录 Redis-cli，通过 info 命令查看服务器状态和命令统计，总结了两点异常点：</p>
<ul>
<li><p>查询 redis 慢指令 slowlog，排行前十的指令均为<code>keys _</code>，并且耗时严重，在当前业务流量下执行<code>keys _</code>，一定会阻塞业务，导致查询慢，cpu 高的。值得注意的是应用层面没有开放 <code>keys *</code> 接口，不排查有后台人为或后台程序触发该指令。</p>
<ul>
<li><p>通过 slowlog 命令查看慢命令（默认超过 10ms 就会被记录到日志，只会记录其命令执行的时间，不包含 IO 往返操作，也不记录单由网络延迟引起的响应慢）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xxxxx&gt; slowlog get 10</span><br><span class="line"> 3) 1) (integer) 411           </span><br><span class="line">    2) (integer) 1545386469     </span><br><span class="line">    3) (integer) 232663          </span><br><span class="line">    4) 1) &quot;keys&quot;              </span><br><span class="line">       2) &quot;mecury:*&quot;</span><br></pre></td></tr></table></figure>

<p>图中各字段表示的是：</p>
<ul>
<li>1=日志的唯一标识符</li>
<li>2=命令的执行时间点，以UNIX时间戳表示</li>
<li>3=查询命令执行时间，以微妙为单位，中的是230ms</li>
<li>4=执行的命令，以数组的形式排列。完整的命令是 keys mucury:*</li>
</ul>
</li>
<li><p>所以通过这些参数，基本可以确定，是突然有大量的<code>keys *</code>命令导致CPU负载升高，导致响应延迟，问题我们应用中没有开放<code>keys *</code>命令。最后将这些统计结果和慢命令发到研发群，发现是别的应用配置配成了我们的Redis，然后他们有个业务场景是爬数据，突然涌入大量的调用，不断的keys *，导致我们的Redis不堪重负，于是将配置修改正确，不再调用我们的Redis。</p>
</li>
</ul>
</li>
<li><p>查看 redis 指令执行情况，排除 ‘exec’,’flushall’ 等指令，业务使用指令中，耗时严重的有 setnx 有7.5千万次调用平均耗时 6s，setex 有8.4千万次调用平均耗时7.33s，del 有2.6亿次调用平均耗时69s，hmset 有1亿次调用平均耗时 64s，hmget 有6.8千万次调用平均耗时 9s，hgetall 有14亿次调用平均耗时 205s，keys 有2千万次调用平均耗时 3740s。</p>
<ul>
<li><p>通常而言，这些指令耗时与 value 大小呈正比，所以可以排查这些指令相关的数据近期有没有较大增长。或者近期有没有业务改造，会频繁使用上述指令，也会造成 cpu 高。</p>
</li>
<li><p>通过 info commandstats 可以查看 Redis 命令统计信息，其中命令格式是<br>调用次数、耗费CPU时间、每个命令平均耗费CPU(单位为微秒）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmdstat_XXX: calls&#x3D;XXX,usec&#x3D;XXX,usec_per_call&#x3D;XXX</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Redis 抖动可以先看网页监控</li>
<li>通过命令查看 Redis 指令状态和慢命令的情况</li>
<li>考虑优化 Redis 在代码中的使用情况</li>
<li>如果流量继续上升，需要考虑一下升级了</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E8%A7%A3%E5%86%B3Jar%E5%8C%85%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E8%A7%A3%E5%86%B3Jar%E5%8C%85%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81/" class="post-title-link" itemprop="url">解决Jar包依赖冲突</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-05 19:10:53" itemprop="dateCreated datePublished" datetime="2021-05-05T19:10:53+08:00">2021-05-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-16 13:30:17" itemprop="dateModified" datetime="2021-11-16T13:30:17+08:00">2021-11-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.sevenyuan.cn/">https://www.sevenyuan.cn/</a></p>
<h2 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h2><p>应用突然无法启动，查看 tomcat 报错原因，发现是 <strong>类转换失败 <code>ClassCastException</code></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class path contains multiple SLF4J binding</span><br><span class="line">23-May-2019 16:04:25.300 INFO [localhost-startStop-1] org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.</span><br><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/home/admin/xxx/WEB-INF/lib/slf4j-log4j12-1.6.1.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/home/admin/xxx/WEB-INF/lib/logback-classic-1.1.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">org.slf4j.impl.Log4jLoggerFactory cannot be cast to ch.qos.logback.classic.LoggerContext</span><br><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;cn.com.xxx.framework.log.integration.LogbackInitializer#0&#x27; defined in class path resource [spring/spring-log-init.xml]: Invocation of init method failed; nested exception is java.lang.ClassCastException: org.slf4j.impl.Log4jLoggerFactory cannot be cast to ch.qos.logback.classic.LoggerContext</span><br><span class="line">    ...    </span><br><span class="line">Caused by: java.lang.ClassCastException: org.slf4j.impl.Log4jLoggerFactory cannot be cast to ch.qos.logback.classic.LoggerContext</span><br><span class="line">    # 出问题的加载地方</span><br><span class="line"> at ch.qos.logback.ext.spring.LogbackConfigurer.initLogging(LogbackConfigurer.java:72)</span><br><span class="line"> at cn.com.xxx.framework.log.integration.LogbackInitializer.init(LogbackInitializer.java:49)</span><br><span class="line"> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line"> at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line"> at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line"> at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line"> at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1706)</span><br><span class="line"> at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1645)</span><br><span class="line"> at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1574)</span><br><span class="line"> ... 26 more</span><br><span class="line">23-May-2019 15:59:12.398 SEVERE [localhost-startStop-1] org.apache.catalina.core.StandardContext.startInternal One or more listeners failed to start. Full details will be found in the appropriate container log file</span><br></pre></td></tr></table></figure>

<h3 id="查看报错代码"><a href="#查看报错代码" class="headerlink" title="查看报错代码"></a>查看报错代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initLogging</span><span class="params">(String location)</span> <span class="keyword">throws</span> FileNotFoundException, JoranException </span>&#123;</span><br><span class="line">   String resolvedLocation = SystemPropertyUtils.resolvePlaceholders(location);</span><br><span class="line">   URL url = ResourceUtils.getURL(resolvedLocation);</span><br><span class="line">   LoggerContext loggerContext = (LoggerContext)StaticLoggerBinder.getSingleton().getLoggerFactory();</span><br><span class="line">   loggerContext.reset();</span><br><span class="line">   <span class="keyword">new</span> ContextInitializer(loggerContext).configureByResource(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过 <code>StaticLoggerBinder.getSingleton().getLoggerFactory()</code> 获取 logger 上下文这段代码报错了，通过仔细定位，发现了有两个 <code>StaticLoggerBinder</code> 类</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbucAM1dSp7ycZAXYI5C2Do953p5wHIylj4Owbjn4dxhRFlKac8xbQ1JU4GYfMnqAibw68ulsq2W0ggQ/640" alt="Image"></p>
<p><strong>更重要的是，他们两兄弟竟然虽然不是同一个 jar 包，但是包路径和名称都一模一样！！！</strong></p>
<p>由于我们需要的是 <code>logback</code> 包，而不是 <code>slf4j-log4j12</code> 包，所以需要排除掉 <code>slf4j-log4j12</code> 依赖。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h2><p>① 通过 POM 文件排查包冲突</p>
<p>② 安装 IDEA 的插件 <code>Maven Helper</code></p>
<p>③ 定位到编译 WAR 包的 POM 文件（我们框架定义的在 Deploy 模块中）</p>
<p>④ 在搜索框中，输入搜索内容，点击右键可以看到选项框</p>
<ul>
<li>Jump To Source（跳转到源文件处）</li>
<li>Exclude（排除掉）</li>
</ul>
<p>例如我点击了 <code>Exclude</code> ，就能看到 pom 文件中，这个依赖就被排除掉了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.com.xxx&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;framework-conf-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;xqy.framework.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a><strong>思考</strong></h2><p>包冲突解决是简单的，通过 maven 插件可以精确找到依赖，然后进行 Exclude，可是在本地开发、测试环境都没有出现的问题，却在预发环境出现了，所以排除了业务逻辑代码的原因，简单考虑了几个因素和原因：</p>
<ul>
<li>jdk 版本</li>
<li>tomcat 版本</li>
<li>类加载机制</li>
<li>第三方 jar 互相依赖</li>
</ul>
<p>由于 jdk 和 tomcat 这两者没有明显的报错原因，所以先去排查类的加载机制</p>
<hr>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>我们写的 Java 应用代码，一般是通过 <code>App ClassLoader</code> 应用加载器进行加载，它不会自己先去加载它，而是通过 <code>Extension ClassLoader</code> 扩展类加载器进行加载（其中扩展类加载器又会去找 <code>Bootstrap ClassLoader</code> 启动类加载器进行加载），只有父加载器无法加载情况下，才会让下级加载器进行加载。</p>
<hr>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>Java 使用的是双亲委派加载机制，通过查看 <code>ClassLoader</code> 类，可以对此有所了解。</p>
<p>类被成功加载后，将被放入到JVM Heap中存放 Class 实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        &#x2F;&#x2F; First, check if the class has already been loaded</span><br><span class="line">        &#x2F;&#x2F; 首先，检查 class 是否已经被加载</span><br><span class="line">        Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果没有被加载</span><br><span class="line">            long t0 &#x3D; System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 寻找 parent 加载器</span><br><span class="line">                    c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 如果父加载器不存在，则委托给启动类加载器加载</span><br><span class="line">                    c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; ClassNotFoundException thrown if class not found</span><br><span class="line">                &#x2F;&#x2F; from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; If still not found, then invoke findClass in order</span><br><span class="line">                &#x2F;&#x2F; to find the class.</span><br><span class="line">                &#x2F;&#x2F; 如果仍然无法加载，才会尝试自身加载</span><br><span class="line">                long t1 &#x3D; System.nanoTime();</span><br><span class="line">                c &#x3D; findClass(name);</span><br><span class="line">                &#x2F;&#x2F; this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="类加载顺序"><a href="#类加载顺序" class="headerlink" title="类加载顺序"></a>类加载顺序</h3><p>从代码中了解到，如果某个名字的类 <!--名字 = 类路径+类名称--> 被加载后，类加载器是不会再重新加载，所以我们的问题根本原因可以是出现在：</p>
<p><strong>先加载了 <code>org.slf4j</code> 包的 <code>org.slf4j.impl.StaticLoggerBinder</code>，同名的 <code>ch.qos.logback</code> 包下的 <code>StaticLoggerBinder</code> 类没有被加载</strong></p>
<blockquote>
<p>跟JAR文件的文件名有关。按照字母的顺序加载JAR文件。有了这个类以后，后面的类则不会加载了。</p>
<p>jvm 加载包名和类名相同的类时，先加载classpath中jar路径放在前面的，包名类名都相同，那jvm没法区分了，如果使用ide一般情况下是会提示发生冲突而报错，若不报错，只有第一个包被引入（在classpath路径下排在前面的包），第二个包会在classloader加载类时判断重复而忽略。</p>
</blockquote>
<hr>
<h3 id="查看加载顺序"><a href="#查看加载顺序" class="headerlink" title="查看加载顺序"></a>查看加载顺序</h3><p>在 jvm 启动脚本中，添加 <code>-verbose</code> 参数或者 <code>-XX:+TraceClassLoading</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Loaded java.lang.CloneNotSupportedException from &#x2F;Users&#x2F;jingqi&#x2F;.jrebel&#x2F;bootcache&#x2F;jrebel-bootstrap-89f567048120ef32b965233b5ba2f7ca.jar]</span><br><span class="line">[Loaded java.lang.Thread$State from &#x2F;Users&#x2F;jingqi&#x2F;.jrebel&#x2F;bootcache&#x2F;jrebel-bootstrap-89f567048120ef32b965233b5ba2f7ca.jar]</span><br><span class="line">[Loaded java.util.TreeMap$NavigableSubMap from &#x2F;Users&#x2F;jingqi&#x2F;.jrebel&#x2F;bootcache&#x2F;jrebel-bootstrap-89f567048120ef32b965233b5ba2f7ca.jar]</span><br><span class="line">[Loaded java.util.TreeMap$AscendingSubMap from &#x2F;Users&#x2F;jingqi&#x2F;.jrebel&#x2F;bootcache&#x2F;jrebel-bootstrap-89f567048120ef32b965233b5ba2f7ca.jar]</span><br><span class="line">[Loaded java.util.TreeMap$NavigableSubMap$EntrySetView from &#x2F;Users&#x2F;jingqi&#x2F;.jrebel&#x2F;bootcache&#x2F;jrebel-bootstrap-89f567048120ef32b965233b5ba2f7ca.jar]</span><br><span class="line">[Loaded java.util.TreeMap$AscendingSubMap$AscendingEntrySetView from &#x2F;Users&#x2F;jingqi&#x2F;.jrebel&#x2F;bootcache&#x2F;jrebel-bootstrap-89f567048120ef32b965233b5ba2f7ca.jar]</span><br><span class="line">[Loaded java.util.TreeMap$NavigableSubMap$SubMapIterator from &#x2F;Users&#x2F;jingqi&#x2F;.jrebel&#x2F;bootcache&#x2F;jrebel-bootstrap-89f567048120ef32b965233b5ba2f7ca.jar]</span><br><span class="line">[Loaded java.util.TreeMap$NavigableSubMap$SubMapEntryIterator from &#x2F;Users&#x2F;jingqi&#x2F;.jrebel&#x2F;bootcache&#x2F;jrebel-bootstrap-89f567048120ef32b965233b5ba2f7ca.jar]</span><br></pre></td></tr></table></figure>

<p>之前在本地开发中，IDEA 优化先加载了 <code>ch.qos.logback</code> 的 <code>StaticLoggerBinder</code> 类，然后后面的 <code>org.slf4j</code> 包下的同名类就没有被加载。</p>
<p>但这样也有个不明白，按理说加载顺序按照<strong>字母顺序</strong>加载，预发环境还是能够跟本地开发一样，加载到我们需要的类。实际上，加载器加载到的是另一个类，导致应用无法启动。</p>
<blockquote>
<p>问题就是jar的加载顺序问题，而这个顺序实际上是由文件系统决定的，linux内部是用inode来指示文件的。</p>
<p>这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p>
<p>Unix/linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p>
</blockquote>
<p>为了验证 <code>inode</code> 是否是问题的原因，我做了以下测试：</p>
<hr>
<h3 id="inode-测试加载顺序"><a href="#inode-测试加载顺序" class="headerlink" title="inode 测试加载顺序"></a>inode 测试加载顺序</h3><h4 id="本地-Tomcat8-测试（正常启动）"><a href="#本地-Tomcat8-测试（正常启动）" class="headerlink" title="本地 Tomcat8 测试（正常启动）"></a>本地 Tomcat8 测试（正常启动）</h4><p>将之前在 uat 环境有问题的代码版本重新打包，不使用 idea 工具，直接用 tomcat8 启动，并且在 <code>catalina.sh</code> 脚本中加入类加载打印参数 <code>-XX:+TraceClassLoading</code></p>
<p>catalina.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Register custom URL handlers</span><br><span class="line"># Do this here so custom URL handles (specifically &#39;war:...&#39;) can be used in the security policy</span><br><span class="line">JAVA_OPTS&#x3D;&quot;$JAVA_OPTS -XX:+TraceClassLoading&quot;</span><br></pre></td></tr></table></figure>

<p>查看 <code>catalina.out</code> 输入日志，发现先加载的是 logback 包中 <code>StaticLoggerBinder</code></p>
<p>在 <code>WEB-INF/lib</code> 下比较 inode 大小（正常解压和启动 logback &lt; slf4j)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll -i logback-classic-1.1.3.jar slf4j-log4j12-1.6.1.jar</span><br><span class="line">34153162 -rw-r-----  1 jingqi  staff   274K  8  1  2018 logback-classic-1.1.3.jar</span><br><span class="line">34153180 -rw-r-----  1 jingqi  staff   9.5K 10 17  2018 slf4j-log4j12-1.6.1.jar</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="本地-Tomcat8-测试（删包，先添加-slf4j，后添加-logback）"><a href="#本地-Tomcat8-测试（删包，先添加-slf4j，后添加-logback）" class="headerlink" title="本地 Tomcat8 测试（删包，先添加 slf4j，后添加 logback）"></a>本地 Tomcat8 测试（删包，先添加 slf4j，后添加 logback）</h4><ul>
<li>清理掉 catalina.out</li>
<li>重新上传包</li>
<li>比较 inode 大小</li>
<li>重新启动，查看类加载日志</li>
</ul>
<p><strong>比较 inode 大小（发现 slf4j &lt; logback)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ll -i logback-classic-1.1.3.jar slf4j-log4j12-1.6.1.jar</span><br><span class="line">34162396 -rw-r--r--  1 jingqi  staff   274K  8  1  2018 logback-classic-1.1.3.jar</span><br><span class="line">34162361 -rw-r--r--  1 jingqi  staff   9.5K 10 17  2018 slf4j-log4j12-1.6.1.jar</span><br></pre></td></tr></table></figure>

<p>重新启动后，查看 <code>catalina.out</code> 日志，发现类加载顺序与之前的一致，应用也能正常启动，所以本地开发无法复现 =-=</p>
<hr>
<h4 id="在-uat-环境服务器测试"><a href="#在-uat-环境服务器测试" class="headerlink" title="在 uat 环境服务器测试"></a>在 uat 环境服务器测试</h4><p>在 <code>WEB-INF/lib</code> 路径下，先将这两个包删掉，尝试有不同的上传顺序，模拟 tomcat 解压 war 包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[admin@uat-96-0-248 lib]$ rm logback-classic-1.1.3.jar  slf4j-log4j12-1.6.1.jar</span><br><span class="line">[admin@uat-96-0-248 lib]$ rz</span><br><span class="line">[admin@uat-96-0-248 lib]$ # Received &#x2F;Users&#x2F;jingqi&#x2F;Downloads&#x2F;slf4j-log4j12-1.6.1.jar</span><br><span class="line">[admin@uat-96-0-248 lib]$ rz</span><br><span class="line">[admin@uat-96-0-248 lib]$ # Received &#x2F;Users&#x2F;jingqi&#x2F;Downloads&#x2F;logback-classic-1.1.3.jar</span><br><span class="line"># 第一次上传顺序 1、slf4j-log4j12-1.6.1.jar 2、logback-classic-1.1.3.jar</span><br><span class="line"># inode 比较：slf4j &lt; logback</span><br><span class="line">[admin@uat-96-0-248 lib]$ ll -i logback-classic-1.1.3.jar slf4j-log4j12-1.6.1.jar</span><br><span class="line">396731 -rw-r--r-- 1 admin admin 280928 8月   1 2018 logback-classic-1.1.3.jar</span><br><span class="line">394075 -rw-r--r-- 1 admin admin   9753 10月 17 2018 slf4j-log4j12-1.6.1.jar</span><br><span class="line">[admin@uat-96-0-248 lib]$ rm logback-classic-1.1.3.jar  slf4j-log4j12-1.6.1.jar</span><br><span class="line">[admin@uat-96-0-248 lib]$ rz</span><br><span class="line">[admin@uat-96-0-248 lib]$ # Received &#x2F;Users&#x2F;jingqi&#x2F;Downloads&#x2F;logback-classic-1.1.3.jar</span><br><span class="line">[admin@uat-96-0-248 lib]$ rz</span><br><span class="line">[admin@uat-96-0-248 lib]$ # Received &#x2F;Users&#x2F;jingqi&#x2F;Downloads&#x2F;slf4j-log4j12-1.6.1.jar</span><br><span class="line"># 第二次上传顺序 1、logback-classic-1.1.3.jar 2、slf4j-log4j12-1.6.1.jar</span><br><span class="line"># inode 比较：logback &lt; slf4j</span><br><span class="line">[admin@uat-96-0-248 lib]$ ll -i logback-classic-1.1.3.jar slf4j-log4j12-1.6.1.jar</span><br><span class="line">394075 -rw-r--r-- 1 admin admin 280928 8月   1 2018 logback-classic-1.1.3.jar</span><br><span class="line">396731 -rw-r--r-- 1 admin admin   9753 10月 17 2018 slf4j-log4j12-1.6.1.jar</span><br></pre></td></tr></table></figure>

<p>分别测试了两种场景，发现只要这两个包都存在的情况下，无论 <code>inode</code> 两者的大小，都是先加载了 <code>slf4j</code> 包的类，导致启动报错</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></p>
<hr>
<h3 id="测试结束"><a href="#测试结束" class="headerlink" title="测试结束"></a>测试结束</h3><p>通过多种测试场景，发现本地开发、测试环境都无法复现的问题，在 uat 环境下，只要这两个包同时存在，都会启动报错</p>
<p>最后在官方文档发现这个：</p>
<blockquote>
<p>The order in which the JAR files in a directory are enumerated in the expanded class path is not specified and may vary from platform to platform and even from moment to moment on the same machine. A well-constructed application should not depend upon any particular order. If a specific order is required, then the JAR files can be enumerated explicitly in the class path.</p>
</blockquote>
<p>大意为：同一个目录下，jvm加载jar包顺序是无法保证的，每个系统的都不一样，甚至同一个系统不同的时刻加载都不一样。</p>
<p>于是乎，我也不纠结某台服务器上的类加载顺序，在开发阶段就先将这个包冲突的情况，给提前解决掉~</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><h3 id="冲突提示信息"><a href="#冲突提示信息" class="headerlink" title="冲突提示信息"></a>冲突提示信息</h3><ul>
<li><strong>java.lang.ClassNotFoundException</strong>：类型转换错误，这个报错跟我这次遇到的一样，本应该引入的是 <code>logback</code> 包的类，但是实际引入的是 <code>slf4j</code> 下的同名类，导致类型转换错误</li>
<li><strong>java.lang.NoSuchMethodError</strong>：找不到特定方法，如果有两个同名的包但是不同版本，例如 xxx-1.1和 xxx-1.2包同时存在，先加载了 1.1 版本的类，但是 1.2 版本中才提供了新方法，导致提示找不到特定方法</li>
<li><strong>java.lang.NoClassDefFoundError，java.lang.LinkageError</strong></li>
</ul>
<h3 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h3><p>1、查看 <code>catalina.sh</code> 堆栈信息，找到有问题的类</p>
<p>2、通过 IDEA ，在打包的 POM 文件中，使用 <code>Maven Helper</code> 插件找出冲突的依赖，确定项目需要的 jar 包，<code>Exclude</code> 掉不需要的依赖。</p>
<h3 id="提前预防"><a href="#提前预防" class="headerlink" title="提前预防"></a>提前预防</h3><p><strong>1、使用工具检查依赖冲突</strong></p>
<p>冲突检测插件 ：<code>maven-enforcer-plugin</code></p>
<p>引用新的第三方依赖（工具包或者框架包），通过 Maven 插件检查一下 conflict 依赖，提前进行 Exclude</p>
<p><strong>2、统一服务器版本</strong></p>
<p>在测试阶段，准备好和生产环境一样的服务器，提前进行测试，避免依赖冲突的 <code>WAR</code> 包上传到生产环境，例如我们有一台 UAT 服务器，与生产环境一样配置，提前测试</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/java%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/java%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">解决Jar包依赖冲突</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-05 19:10:53" itemprop="dateCreated datePublished" datetime="2021-05-05T19:10:53+08:00">2021-05-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-23 17:49:06" itemprop="dateModified" datetime="2023-03-23T17:49:06+08:00">2023-03-23</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java的多线程同步运行"><a href="#Java的多线程同步运行" class="headerlink" title="Java的多线程同步运行"></a>Java的多线程同步运行</h2><h3 id="2个线程轮流打印AB-gt-AB"><a href="#2个线程轮流打印AB-gt-AB" class="headerlink" title="2个线程轮流打印AB-&gt;AB"></a>2个线程轮流打印AB-&gt;AB</h3><h4 id="方法1：使用wait和notify"><a href="#方法1：使用wait和notify" class="headerlink" title="方法1：使用wait和notify"></a>方法1：使用wait和notify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       System.out.println( <span class="string">&quot;Hello World!&quot;</span> );</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">final</span> Object lockObj = <span class="keyword">new</span> Object();</span><br><span class="line">       <span class="comment">//A是否已经执行</span></span><br><span class="line">       AtomicBoolean aExecuted = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">      </span><br><span class="line">       <span class="keyword">final</span> Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (lockObj) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                       <span class="keyword">while</span> (aExecuted.get())</span><br><span class="line">                           lockObj.wait();</span><br><span class="line">                       System.out.println(<span class="string">&quot;Hello from a!&quot;</span>);</span><br><span class="line">                       aExecuted.set(<span class="keyword">true</span>);</span><br><span class="line">                       lockObj.notifyAll();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Thread b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (lockObj) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">1_000</span>);</span><br><span class="line">                       <span class="keyword">while</span> (!aExecuted.get())</span><br><span class="line">                           lockObj.wait();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                   &#125;</span><br><span class="line">                   lockObj.notifyAll();</span><br><span class="line">                   System.out.println(<span class="string">&quot;Hello from b!&quot;</span>);</span><br><span class="line">                   aExecuted.set(<span class="keyword">false</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       a.start();</span><br><span class="line">       b.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法2-：使用ReentractLock"><a href="#方法2-：使用ReentractLock" class="headerlink" title="方法2 ：使用ReentractLock"></a>方法2 ：使用ReentractLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lockObj = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">//A是否已经执行</span></span><br><span class="line">        <span class="keyword">final</span> AtomicBoolean aExecuted = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">final</span> Condition aCondition = lockObj.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lockObj.lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        <span class="keyword">while</span> (aExecuted.get())</span><br><span class="line">                            aCondition.await();</span><br><span class="line">                        System.out.println(<span class="string">&quot;Hello from a!&quot;</span>);</span><br><span class="line">                        aExecuted.set(<span class="keyword">true</span>);</span><br><span class="line">                        aCondition.signalAll();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                lockObj.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lockObj.lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1_000</span>);</span><br><span class="line">                        <span class="keyword">while</span> (!aExecuted.get())</span><br><span class="line">                            aCondition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    aCondition.signalAll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Hello from b!&quot;</span>);</span><br><span class="line">                    aExecuted.set(<span class="keyword">false</span>);</span><br><span class="line">                lockObj.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<h2 id="Spring问题"><a href="#Spring问题" class="headerlink" title="Spring问题"></a>Spring问题</h2><h3 id="spring为什么使用三级缓存而不是两级？"><a href="#spring为什么使用三级缓存而不是两级？" class="headerlink" title="spring为什么使用三级缓存而不是两级？"></a>spring为什么使用三级缓存而不是两级？</h3><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/445446018">https://www.zhihu.com/question/445446018</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简单来讲，就是通过第三级缓存（不是三级共同作用）的延迟初始化来达到循环依赖**一级缓存：** 存放初始化完全的 bean 实例缓存（用于查找，没有循环依赖一级缓存足够使用）</span><br><span class="line"></span><br><span class="line">**三级缓存：** bean 在实例化之后，会放入的未初始化的 bean 工厂方法来延迟初始化</span><br><span class="line">本质是调用&#96;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#getEarlyBeanReference&#96;方法的 bean 工厂匿名类</span><br><span class="line"></span><br><span class="line">**二级缓存：** 延迟初始化后（本质调用 getEarlyBeanReference 包装了 原先的 bean 实例）</span><br><span class="line">earlySingletonObjects.put(getEarlyBeanReference 返回的实例)</span><br><span class="line">singletonFactories.remove(bean 工厂实例)</span><br><span class="line">本质是防止&#96;getEarlyBeanReference&#96;bean 方法由于每次延迟初始化返回不同实例而导致注入的 bean 不是同一个</span><br><span class="line">例如&#96;() -&gt; getEarlyBeanReference(beanName, mbd, bean)&#96;会调用到构建代理的组件</span><br><span class="line">&#96;org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#getEarlyBeanReference&#96;</span><br><span class="line">如果没有二级缓存，会重复创建代理的实例的问题</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%B9%82%E7%AD%89%E6%80%A7-01-%E9%98%B2%E9%87%8D%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%B9%82%E7%AD%89%E6%80%A7-01-%E9%98%B2%E9%87%8D%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">高并发下保证接口的幂等性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-28 12:12:34" itemprop="dateCreated datePublished" datetime="2021-04-28T12:12:34+08:00">2021-04-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="保证幂等的手段"><a href="#保证幂等的手段" class="headerlink" title="保证幂等的手段"></a><strong>保证幂等的手段</strong></h2><p>保证幂等需要理清楚两件事情：幂等条件和期望结果。</p>
<ul>
<li><p>保证幂等的手段有<a href="">token令牌</a>、<a href="">分布式锁</a>、<a href="">去重表</a>、<a href="">数据库唯一索引</a>等，这些所谓的幂等手段实际上防重手段。防重本质是防止一个相同的请求被当成多个不同的请求来处理。</p>
</li>
<li><p>幂等的条件是知道这是一个相同的请求。防重和幂等本质上是两个不同的阶段。</p>
</li>
</ul>
<h2 id="使用幂等的场景"><a href="#使用幂等的场景" class="headerlink" title="使用幂等的场景"></a>使用幂等的场景</h2><h3 id="前端重复提交"><a href="#前端重复提交" class="headerlink" title="前端重复提交"></a>前端重复提交</h3><p>用户注册，用户创建商品等操作，前端都会提交一些数据给后台服务，后台需要根据用户提交的数据在数据库中创建记录。如果用户不小心多点了几次，后端收到了好几次提交，这时就会在数据库中重复创建了多条记录。这就是接口没有幂等性带来的 bug。</p>
<h3 id="接口超时重试"><a href="#接口超时重试" class="headerlink" title="接口超时重试"></a>接口超时重试</h3><p>对于给第三方调用的接口，有可能会因为网络原因而调用失败，这时，一般在设计的时候会对接口调用加上失败重试的机制。如果第一次调用已经执行了一半时，发生了网络异常。这时再次调用时就会因为脏数据的存在而出现调用异常。</p>
<h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><p>在使用消息中间件来处理消息队列，且手动 ack 确认消息被正常消费时。如果消费者突然断开连接，那么已经执行了一半的消息会重新放回队列。</p>
<p>当消息被其他消费者重新消费时，如果没有幂等性，就会导致消息重复消费时结果异常，如数据库重复数据，数据库数据冲突，资源重复等。</p>
<h2 id="防重手段实现幂等"><a href="#防重手段实现幂等" class="headerlink" title="防重手段实现幂等"></a>防重手段实现幂等</h2><h3 id="借助数据库"><a href="#借助数据库" class="headerlink" title="借助数据库"></a>借助数据库</h3><h4 id="先select再update-insert使用悲观锁"><a href="#先select再update-insert使用悲观锁" class="headerlink" title="先select再update/insert使用悲观锁"></a>先select再update/insert使用悲观锁</h4><p>使用悲观锁实现幂等性，一般是配合事务一起来实现，在没有使用悲观锁时，我们通常的执行过程是这样的，首先来判断数据的状态，执行 SQL 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一步：select status from table_name where id&#x3D;&#39;xxx&#39;;</span><br><span class="line"></span><br><span class="line">第二步：insert into table_name (id) values (&#39;xxx&#39;);</span><br><span class="line">		或者update table_name set status&#x3D;&#39;xxx&#39;;</span><br></pre></td></tr></table></figure>

<p><a href="">但这种情况因为是非原子操作，所以在高并发环境下可能会造成一个业务被执行两次的问题</a>，当一个程序在执行中时，而另一个程序也开始状态判断的操作。因为第一个程序还未来得及更改状态，所以第二个程序也能执行成功，这就导致一个业务被执行了两次。</p>
<ul>
<li>使用事务实现悲观锁，从而保证原子性  <!--这种方法感觉有问题，select操作在RR事务隔离级别下，可能读到的是过期版本的数据--></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;  <span class="comment"># 1.开始事务</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">&#x27;xxx&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># 2.查询状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. insert或者update</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name (<span class="keyword">id</span>) <span class="keyword">values</span> (<span class="string">&#x27;xxx&#x27;</span>); </span><br><span class="line">或者 <span class="keyword">update</span> table_name <span class="keyword">set</span> <span class="keyword">status</span>=<span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment"># 4.提交事务</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用select … for update ,这种和 synchronized 锁住先查再insert or update一样,但要避免死锁,效率也较差。针对单体 请求并发不大 可以推荐使用</li>
</ul>
<blockquote>
<p>在实现的过程中需要注意以下两个问题：</p>
<ul>
<li>如果使用的是 MySQL 数据库，必须选用 innodb 存储引擎，因为 innodb 支持事务；</li>
<li>id 字段一定要是主键或者是唯一索引，不然会锁表，影响其他业务执行。</li>
</ul>
</blockquote>
<h4 id="update使用多版本控制（乐观锁）"><a href="#update使用多版本控制（乐观锁）" class="headerlink" title="update使用多版本控制（乐观锁）"></a>update使用多版本控制（乐观锁）</h4><p>需要在表中增加一个<code>timestamp</code>或者<code>version</code>字段，这里以<code>version</code>字段为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set amount&#x3D;amount+100,version&#x3D;version+1where id&#x3D;123 and version&#x3D;1;</span><br></pre></td></tr></table></figure>



<h4 id="insert使用唯一索引"><a href="#insert使用唯一索引" class="headerlink" title="insert使用唯一索引"></a>insert使用唯一索引</h4><p>我们可以创建一个唯一索引的表来实现幂等性，在每次执行业务之前，先执行插入操作，因为唯一字段就是业务的 ID，因此如果重复插入的话会触发唯一约束而导致插入失败。在这种情况下（插入失败）我们就可以判定它为重复提交的请求。</p>
<p>虽说抛异常对数据来说没有影响，不会造成错误数据。但是为了保证接口幂等性，我们需要对该异常进行捕获，然后返回成功。</p>
<p>如果是<code>java</code>程序需要捕获：<code>DuplicateKeyException</code>异常，如果使用了<code>spring</code>框架还需要捕获：<code>MySQLIntegrityConstraintViolationException</code>异常。</p>
<h3 id="借助web-api入口"><a href="#借助web-api入口" class="headerlink" title="借助web api入口"></a>借助web api入口</h3><h4 id="使用Redis实现分布式锁"><a href="#使用Redis实现分布式锁" class="headerlink" title="使用Redis实现分布式锁"></a>使用Redis实现分布式锁</h4><p>由于<code>数据库分布式锁</code>的性能不太好，我们可以改用：<code>redis</code>或<code>zookeeper</code>。</p>
<p>鉴于现在很多公司分布式配置中心改用<code>apollo</code>或<code>nacos</code>，已经很少用<code>zookeeper</code>了，我们以<code>redis</code>为例介绍分布式锁。</p>
<p>目前主要有三种方式实现redis的分布式锁：</p>
<ol>
<li>setNx命令</li>
<li>set命令</li>
<li>Redission框架</li>
</ol>
<blockquote>
<p>需要特别注意的是：分布式锁一定要设置一个合理的过期时间，如果设置过短，无法有效的防止重复请求。如果设置过长，可能会浪费<code>redis</code>的存储空间，需要根据实际业务情况而定。</p>
</blockquote>
<h4 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h4><p>通过token 机制实现接口的幂等性,这是一种比较通用性的实现方法。</p>
<p>示意图如下：</p>
<img src="https://filescdn.proginn.com/863953bbd02d158b7d726d78b269339e/47e6218040f85184d170ef253514ca59.webp" alt="img" style="zoom:67%;" />

<p>具体流程步骤：</p>
<ol>
<li>客户端会先发送一个请求去获取 token，服务端会生成一个全局唯一的 ID 作为 token 保存在 redis 中，同时把这个 ID 返回给客户端</li>
<li>客户端第二次调用业务请求的时候必须携带这个 token</li>
<li>服务端会校验这个 token，如果校验成功，则执行业务，并删除 redis 中的 token</li>
<li>如果校验失败，说明 redis 中已经没有对应的 token，则表示重复操作，直接返回指定的结果给客户端</li>
</ol>
<blockquote>
<p>注意：</p>
<ol>
<li>对 redis 中是否存在 token 以及删除的代码逻辑建议用 Lua 脚本实现，保证原子性</li>
<li>全局唯一 ID 可以用百度的 uid-generator、美团的 Leaf 去生成</li>
</ol>
</blockquote>
<p>这种思路存在漏洞，如下图所示：<br><a target="_blank" rel="noopener" href="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/%E5%B9%82%E7%AD%89%E6%A3%80%E6%9F%A5%E5%92%8C%E6%8E%A5%E5%8F%A3%E9%87%8D%E8%AF%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.png"><img src="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/%E5%B9%82%E7%AD%89%E6%A3%80%E6%9F%A5%E5%92%8C%E6%8E%A5%E5%8F%A3%E9%87%8D%E8%AF%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.png" alt="幂等检查和接口重试之间的冲突"></a></p>
<p><a target="_blank" rel="noopener" href="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/%E5%B9%82%E7%AD%89%E6%A3%80%E6%9F%A5%E5%92%8C%E6%8E%A5%E5%8F%A3%E9%87%8D%E8%AF%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.png">幂等检查和接口重试之间的冲突</a></p>
<p>token 是只有在幂等检查结束后才会被保存下来的，如果下游服务还没执行完毕，触发上游 RPC 的超时重试机制，就会重新再发一次请求，这时如果上一次请求，仍然没有执行完毕，就会导致请求被执行了两次。<br>这里的漏洞是：进入下游 API 入口处的幂等检查逻辑，会经过查 <code>token -&gt; 保存 token -&gt; 设置超时时间</code>这个过程，可能会因为网络抖动而花费特别长的时间。如果超时是因此而导致的，幂等性检查就起不到作用了。<br>解决的办法是保证幂等检查的<strong>原子性</strong>，并且还需要注意存储的<strong>隔离性</strong>，这在一般的存储设计中是必须要考虑的。</p>
<blockquote>
<p>在这里吐槽一下我公司的实现，采用的是<code>setnx + expire</code>的方式，如果<code>setnx</code>后、<code>expire</code>前出错了，之后对该接口的重试也会直接被拦截了，也就是说幂等检查组件影响了正常的业务执行流程。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02-shiro%E5%85%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02-shiro%E5%85%A5%E5%8F%A3/" class="post-title-link" itemprop="url">shiro框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-23 08:04:48" itemprop="dateCreated datePublished" datetime="2021-04-23T08:04:48+08:00">2021-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="shiro入口"><a href="#shiro入口" class="headerlink" title="shiro入口"></a>shiro入口</h3><p>我们打算将 Shiro 放在 Web 应用中使用，只需在 web.xml 中做如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.apache.shiro.web.env.EnvironmentLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ShiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.shiro.web.servlet.ShiroFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ShiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> web.xml 才是整个 Web 应用的核心所在，Web 容器（例如：Tomcat）会提供一些监听器，用于监听 Web 应用的生命周期事件，有两个重要的点可以监听，一个是出生，另一个是死亡，具备这类特性的监听器就是 ServletContextListener。</p>
<p>Shiro 的 EnvironmentLoaderListener 就是一个典型的 ServletContextListener，它也是整个 Shiro Web 应用的入口，不妨先来看看它的静态结构吧：</p>
<p><img src="http://static.oschina.net/uploads/space/2014/0318/162859_TEXh_223750.png" alt="img"></p>
<ol>
<li><p>EventListener 是一个标志接口，里面没有任何的方法，Servlet 容器中所有的 Listener 都要继承这个接口<!--这是 Servlet 规范--></p>
</li>
<li><p>ServletContextListener 是一个 ServletContext 的监听器，用于监听容器的启动与关闭事件，包括如下两个方法：<br>  - void contextInitialized(ServletContextEvent sce); // 当容器启动时调用<br>  - void contextDestroyed(ServletContextEvent sce); // 当容器关闭时调用<br>  可以从 ServletContextEvent 中直接获取 ServletContext 对象。</p>
</li>
<li><p>EnvironmentLoaderListener 不仅实现了 ServletContextListener 接口，也扩展了 EnvironmentLoader 类，是为了在 Servlet 容器中调用 EnvironmentLoader 对象的生命周期方法。</p>
</li>
</ol>
<h4 id="EnvironmentLoader"><a href="#EnvironmentLoader" class="headerlink" title="EnvironmentLoader"></a>EnvironmentLoader</h4><p>EnvironmentLoaderListener 开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class EnvironmentLoaderListener extends EnvironmentLoader implements ServletContextListener &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 容器启动时调用</span><br><span class="line">    public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">        initEnvironment(sce.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 当容器关闭时调用</span><br><span class="line">    public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line">        destroyEnvironment(sce.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看来 EnvironmentLoaderListener 只是一个空架子而已，真正干活的人是它“爹”（EnvironmentLoader）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentLoader</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 可在 web.xml 的 context-param 中定义 WebEnvironment 接口的实现类（默认为 IniWebEnvironment）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENVIRONMENT_CLASS_PARAM = <span class="string">&quot;shiroEnvironmentClass&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 可在 web.xml 的 context-param 中定义 Shiro 配置文件的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_LOCATIONS_PARAM = <span class="string">&quot;shiroConfigLocations&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在 ServletContext 中存放 WebEnvironment 的 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENVIRONMENT_ATTRIBUTE_KEY = EnvironmentLoader.class.getName() + <span class="string">&quot;.ENVIRONMENT_ATTRIBUTE_KEY&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从 ServletContext 中获取相关信息，并创建 WebEnvironment 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebEnvironment <span class="title">initEnvironment</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="comment">// 确保 WebEnvironment 只能创建一次</span></span><br><span class="line">        <span class="keyword">if</span> (servletContext.getAttribute(ENVIRONMENT_ATTRIBUTE_KEY) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 WebEnvironment 实例</span></span><br><span class="line">            WebEnvironment environment = createEnvironment(servletContext);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 将 WebEnvironment 实例放入 ServletContext 中</span></span><br><span class="line">            servletContext.setAttribute(ENVIRONMENT_ATTRIBUTE_KEY, environment);</span><br><span class="line">            <span class="keyword">return</span> environment;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="comment">// 将异常对象放入 ServletContext 中</span></span><br><span class="line">            servletContext.setAttribute(ENVIRONMENT_ATTRIBUTE_KEY, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">            <span class="comment">// 将错误对象放入 ServletContext 中</span></span><br><span class="line">            servletContext.setAttribute(ENVIRONMENT_ATTRIBUTE_KEY, err);</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebEnvironment <span class="title">createEnvironment</span><span class="params">(ServletContext sc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确定 WebEnvironment 接口的实现类</span></span><br><span class="line">        Class&lt;?&gt; clazz = determineWebEnvironmentClass(sc);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 确保该实现类实现了 MutableWebEnvironment 接口</span></span><br><span class="line">        <span class="keyword">if</span> (!MutableWebEnvironment.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 从 ServletContext 中获取 Shiro 配置文件的位置参数，并判断该参数是否已定义</span></span><br><span class="line">        String configLocations = sc.getInitParameter(CONFIG_LOCATIONS_PARAM);</span><br><span class="line">        <span class="keyword">boolean</span> configSpecified = StringUtils.hasText(configLocations);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 若配置文件位置参数已定义，则需确保该实现类实现了 ResourceConfigurable 接口</span></span><br><span class="line">        <span class="keyword">if</span> (configSpecified &amp;&amp; !(ResourceConfigurable.class.isAssignableFrom(clazz))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 通过反射创建 WebEnvironment 实例，将其转型为 MutableWebEnvironment 类型，并将 ServletContext 放入该实例中</span></span><br><span class="line">        MutableWebEnvironment environment = (MutableWebEnvironment) ClassUtils.newInstance(clazz);</span><br><span class="line">        environment.setServletContext(sc);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 若配置文件位置参数已定义，且该实例是 ResourceConfigurable 接口的实例（实现了该接口），则将此参数放入该实例中</span></span><br><span class="line">        <span class="keyword">if</span> (configSpecified &amp;&amp; (environment <span class="keyword">instanceof</span> ResourceConfigurable)) &#123;</span><br><span class="line">            ((ResourceConfigurable) environment).setConfigLocations(configLocations);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 可进一步定制 WebEnvironment 实例（在子类中扩展）</span></span><br><span class="line">        customizeEnvironment(environment);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 调用 WebEnvironment 实例的 init 方法</span></span><br><span class="line">        LifecycleUtils.init(environment);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 返回 WebEnvironment 实例</span></span><br><span class="line">        <span class="keyword">return</span> environment;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; determineWebEnvironmentClass(ServletContext servletContext) &#123;</span><br><span class="line">        <span class="comment">// 从初始化参数（context-param）中获取 WebEnvironment 接口的实现类</span></span><br><span class="line">        String className = servletContext.getInitParameter(ENVIRONMENT_CLASS_PARAM);</span><br><span class="line">        <span class="comment">// 若该参数已定义，则加载该实现类</span></span><br><span class="line">        <span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ClassUtils.forName(className);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownClassException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则使用默认的实现类</span></span><br><span class="line">            <span class="keyword">return</span> IniWebEnvironment.class;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeEnvironment</span><span class="params">(WebEnvironment environment)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 销毁 WebEnvironment 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyEnvironment</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从 ServletContext 中获取 WebEnvironment 实例</span></span><br><span class="line">            Object environment = servletContext.getAttribute(ENVIRONMENT_ATTRIBUTE_KEY);</span><br><span class="line">            <span class="comment">// 调用 WebEnvironment 实例的 destroy 方法</span></span><br><span class="line">            LifecycleUtils.destroy(environment);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 移除 ServletContext 中存放的 WebEnvironment 实例</span></span><br><span class="line">            servletContext.removeAttribute(ENVIRONMENT_ATTRIBUTE_KEY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看来 EnvironmentLoader 就是为了：</p>
<ol>
<li><p>当容器启动时，读取 web.xml 文件，从中获取 WebEnvironment 接口的实现类（默认是 IniWebEnvironment），初始化该实例，并将其加载到 ServletContext 中。</p>
</li>
<li><p>当容器关闭时，销毁 WebEnvironment 实例，并从 ServletContext 将其移除。</p>
</li>
</ol>
<p>这里有两个配置项可以在 web.xml 中进行配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>shiroEnvironmentClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>WebEnvironment 接口的实现类<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>shiroConfigLocations<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>shiro.ini 配置文件的位置<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 EnvironmentLoader 中仅用于创建 WebEnvironment 接口的实现类，随后将由这个实现类来加载并解析 shiro.ini 配置文件。</p>
<h4 id="WebEnvironment"><a href="#WebEnvironment" class="headerlink" title="WebEnvironment"></a>WebEnvironment</h4><p>既然 WebEnvironment 如此重要，那么很有必要了解一下它的静态结构：</p>
<p><img src="http://static.oschina.net/uploads/space/2014/0318/163231_w73G_223750.png" alt="img"></p>
<ol>
<li><p>最底层的 IniWebEnvironment 是 WebEnvironment 接口的默认实现类，它将读取 ini 配置文件，并创建 WebEnvironment 实例。</p>
</li>
<li><p>可以断言，如果需要将 Shiro 配置定义在 XML 或 Properties 配置文件中，那就需要自定义一些WebEnvironment 实现类了。</p>
</li>
<li><p>WebEnvironment 的实现类不仅需要实现最顶层的 Environment 接口，还需要实现具有生命周期功能的 Initializable 与 Destroyable 接口。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IniWebEnvironment</span> <span class="keyword">extends</span> <span class="title">ResourceBasedWebEnvironment</span> <span class="keyword">implements</span> <span class="title">Initializable</span>, <span class="title">Destroyable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 默认 shiro.ini 路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_WEB_INI_RESOURCE_PATH = <span class="string">&quot;/WEB-INF/shiro.ini&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定义一个 Ini 对象，用于封装 ini 配置项</span></span><br><span class="line">    <span class="keyword">private</span> Ini ini;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Ini <span class="title">getIni</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ini;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIni</span><span class="params">(Ini ini)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ini = ini;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 当初始化时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从成员变量中获取 Ini 对象</span></span><br><span class="line">        Ini ini = getIni();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 从 web.xml 中获取配置文件位置（在 EnvironmentLoader 中已设置）</span></span><br><span class="line">        String[] configLocations = getConfigLocations();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 若成员变量中不存在，则从已定义的配置文件位置获取</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(ini)) &#123;</span><br><span class="line">            ini = getSpecifiedIni(configLocations);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 若已定义的配置文件中仍然不存在，则从默认的位置获取</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(ini)) &#123;</span><br><span class="line">            ini = getDefaultIni();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 若还不存在，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(ini)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 初始化成员变量</span></span><br><span class="line">        setIni(ini);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 解析配置文件，完成初始化工作</span></span><br><span class="line">        configure();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Ini <span class="title">getSpecifiedIni</span><span class="params">(String[] configLocations)</span> <span class="keyword">throws</span> ConfigurationException </span>&#123;</span><br><span class="line">        Ini ini = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span> &amp;&amp; configLocations.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 只能通过第一个配置文件的位置来创建 Ini 对象，且必须有一个配置文件，否则就会报错</span></span><br><span class="line">            ini = createIni(configLocations[<span class="number">0</span>], <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ini;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Ini <span class="title">createIni</span><span class="params">(String configLocation, <span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> ConfigurationException </span>&#123;</span><br><span class="line">        Ini ini = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 从指定路径下读取配置文件</span></span><br><span class="line">            ini = convertPathToIni(configLocation, required);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (required &amp;&amp; CollectionUtils.isEmpty(ini)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ini;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Ini <span class="title">convertPathToIni</span><span class="params">(String path, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">        Ini ini = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(path)) &#123;</span><br><span class="line">            InputStream is = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 若路径不包括资源前缀（classpath:、url:、file:），则从 ServletContext 中读取，否则从这些资源路径下读取</span></span><br><span class="line">            <span class="keyword">if</span> (!ResourceUtils.hasResourcePrefix(path)) &#123;</span><br><span class="line">                is = getServletContextResourceStream(path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is = ResourceUtils.getInputStreamForPath(path);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (required) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将流中的数据加载到 Ini 对象中</span></span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ini = <span class="keyword">new</span> Ini();</span><br><span class="line">                ini.load(is);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (required) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ini;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> InputStream <span class="title">getServletContextResourceStream</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 需要将路径进行标准化</span></span><br><span class="line">        path = WebUtils.normalize(path);</span><br><span class="line">        ServletContext sc = getServletContext();</span><br><span class="line">        <span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            is = sc.getResourceAsStream(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Ini <span class="title">getDefaultIni</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Ini ini = <span class="keyword">null</span>;</span><br><span class="line">        String[] configLocations = getDefaultConfigLocations();</span><br><span class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 先找到的先使用，后面的无需使用</span></span><br><span class="line">            <span class="keyword">for</span> (String location : configLocations) &#123;</span><br><span class="line">                ini = createIni(location, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (!CollectionUtils.isEmpty(ini)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ini;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> String[] getDefaultConfigLocations() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;</span><br><span class="line">            DEFAULT_WEB_INI_RESOURCE_PATH,              <span class="comment">// /WEB-INF/shiro.ini</span></span><br><span class="line">            IniFactorySupport.DEFAULT_INI_RESOURCE_PATH <span class="comment">// classpath:shiro.ini</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 清空这个 Bean 容器（一个 Map&lt;String, Object&gt; 对象，在 DefaultEnvironment 中定义）</span></span><br><span class="line">        <span class="keyword">this</span>.objects.clear();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建基于 Web 的 SecurityManager 对象（WebSecurityManager）</span></span><br><span class="line">        WebSecurityManager securityManager = createWebSecurityManager();</span><br><span class="line">        setWebSecurityManager(securityManager);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 初始化 Filter Chain 解析器（用于解析 Filter 规则）</span></span><br><span class="line">        FilterChainResolver resolver = createFilterChainResolver();</span><br><span class="line">        <span class="keyword">if</span> (resolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setFilterChainResolver(resolver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebSecurityManager <span class="title">createWebSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过工厂对象来创建 WebSecurityManager 实例</span></span><br><span class="line">        WebIniSecurityManagerFactory factory;</span><br><span class="line">        Ini ini = getIni();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(ini)) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> WebIniSecurityManagerFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> WebIniSecurityManagerFactory(ini);</span><br><span class="line">        &#125;</span><br><span class="line">        WebSecurityManager wsm = (WebSecurityManager) factory.getInstance();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 从工厂中获取 Bean Map 并将其放入 Bean 容器中</span></span><br><span class="line">        Map&lt;String, ?&gt; beans = factory.getBeans();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(beans)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.objects.putAll(beans);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> wsm;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> FilterChainResolver <span class="title">createFilterChainResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterChainResolver resolver = <span class="keyword">null</span>;</span><br><span class="line">        Ini ini = getIni();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(ini)) &#123;</span><br><span class="line">            <span class="comment">// Filter 可以从 [urls] 或 [filters] 片段中读取</span></span><br><span class="line">            Ini.Section urls = ini.getSection(IniFilterChainResolverFactory.URLS);</span><br><span class="line">            Ini.Section filters = ini.getSection(IniFilterChainResolverFactory.FILTERS);</span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(urls) || !CollectionUtils.isEmpty(filters)) &#123;</span><br><span class="line">                <span class="comment">// 通过工厂对象创建 FilterChainResolver 实例</span></span><br><span class="line">                IniFilterChainResolverFactory factory = <span class="keyword">new</span> IniFilterChainResolverFactory(ini, <span class="keyword">this</span>.objects);</span><br><span class="line">                resolver = factory.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看来 IniWebEnvironment 就是为了：</p>
<ol>
<li><p>查找并加载 shiro.ini 配置文件，首先从自身成员变量里查找，然后从 web.xml 中查找，然后从 /WEB-INF 下查找，然后从 classpath 下查找，若均未找到，则直接报错。</p>
</li>
<li><p>当找到了 ini 配置文件后就开始解析，此时构造了一个 Bean 容器（相当于一个轻量级的 IOC 容器），最终的目标是为了创建 WebSecurityManager 对象与 FilterChainResolver 对象，创建过程使用了 Abstract Factory 模式</p>
</li>
</ol>
<h4 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract Factory"></a>Abstract Factory</h4><p><img src="http://static.oschina.net/uploads/space/2014/0318/163354_8Zjs_223750.png" alt="img"></p>
<p>其中有两个 Factory 需要关注：<br>- WebIniSecurityManagerFactory 用于创建 WebSecurityManager。<br>- IniFilterChainResolverFactory 用于创建 FilterChainResolver。</p>
<p>通过以上分析，相信 EnvironmentLoaderListener 已经不再神秘了，无非就是在容器启动时创建 WebEnvironment 对象，并由该对象来读取 Shiro 配置文件，创建WebSecurityManager 与 FilterChainResolver 对象，它们都在后面将要出现的 ShiroFilter 中起到了重要作用。</p>
<p>从 web.xml 中同样可以得知，ShiroFilter 是整个 Shiro 框架的门面，因为它拦截了所有的请求，后面是需要 Authentication（认证）还是需要 Authorization（授权）都由它说了算。</p>
<h3 id="shiro-filter"><a href="#shiro-filter" class="headerlink" title="shiro filter"></a>shiro filter</h3><p>在上一篇中，我们分析了 Shiro Web 应用的入口 —— EnvironmentLoaderListener，它是一个 ServletContextListener，在 Web 容器启动的时候，它为我们创建了两个非常重要的对象：</p>
<ul>
<li><p>WebSecurityManager：它是用于 Web 环境的 SecurityManager 对象，通过读取 shiro.ini 中 [main] 片段生成的，我们可以通过 SecurityUtils.getSecurityManager 方法获取该对象。</p>
</li>
<li><p>FilterChainResolver：它是 shiro.ini 中 [urls] 片段所配置的 Filter Chain 的解析器，可对一个 URL 配置一个或多个 Filter（用逗号分隔），Shiro 也为我们提供了几个默认的 Filter。</p>
<p>Shiro Web 的第二个核心对象 —— ShiroFilter，它是在整个 Shiro Web 应用中请求的门户，也就是说，所有的请求都会被 ShiroFilter 拦截并进行相应的链式处理。</p>
</li>
</ul>
<p><img src="http://static.oschina.net/uploads/space/2014/0321/154813_mpy9_223750.png" alt="img"></p>
<h4 id="filter接口"><a href="#filter接口" class="headerlink" title="filter接口"></a>filter接口</h4><p>上图可见，ShiroFilter 往上竟然有五层，最上层是 Filter（即 javax.servlet.Filter），它是 Servlet 规范中的 Filter 接口，代码如下：<!--只有实现的sevlet的filter接口，才能被web容器识别和加载为filter--></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Filter &#123;</span><br><span class="line"></span><br><span class="line">    void init(FilterConfig filterConfig) throws ServletException;</span><br><span class="line"></span><br><span class="line">    void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;</span><br><span class="line"></span><br><span class="line">    void destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Filter 接口中的三个方法分别在 Filter 生命周期的三个时期内由 Web 容器来调用，分别是：初始化、执行、销毁。</p>
<p>但与 Filter 接口同一级别下竟然还有一个名为 ServletContextSupport 的类，它又是起什么作用的呢？</p>
<h4 id="封装ServletContext"><a href="#封装ServletContext" class="headerlink" title="封装ServletContext"></a>封装ServletContext</h4><p>打开 ServletContextSupport 的源码便知，它是 Shiro 为了封装 ServletContext 的而提供的一个类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 封装 ServletContext</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ServletContextSupport &#123;</span><br><span class="line"></span><br><span class="line">    private ServletContext servletContext;</span><br><span class="line"></span><br><span class="line">    public ServletContext getServletContext() &#123;</span><br><span class="line">        return servletContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setServletContext(ServletContext servletContext) &#123;</span><br><span class="line">        this.servletContext &#x3D; servletContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)</span><br><span class="line">    protected String getContextInitParam(String paramName) &#123;</span><br><span class="line">        return getServletContext().getInitParameter(paramName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServletContext getRequiredServletContext() &#123;</span><br><span class="line">        ServletContext servletContext &#x3D; getServletContext();</span><br><span class="line">        if (servletContext &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        return servletContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)</span><br><span class="line">    protected void setContextAttribute(String key, Object value) &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">            removeContextAttribute(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            getRequiredServletContext().setAttribute(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)</span><br><span class="line">    protected Object getContextAttribute(String key) &#123;</span><br><span class="line">        return getRequiredServletContext().getAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void removeContextAttribute(String key) &#123;</span><br><span class="line">        getRequiredServletContext().removeAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return toStringBuilder().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected StringBuilder toStringBuilder() &#123;</span><br><span class="line">        return new StringBuilder(super.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过这个类，我们可以方便的操纵 ServletContext 对象（使用其中的属性），那么这个 ServletContext 对象又是如何来初始化的呢？</p>
<p>不妨看看 Filter 与 ServletContextSupport 的子类 AbstractFilter 吧，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 初始化 ServletContext 并封装 FilterConfig</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class AbstractFilter extends ServletContextSupport implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    protected FilterConfig filterConfig;</span><br><span class="line"></span><br><span class="line">    public FilterConfig getFilterConfig() &#123;</span><br><span class="line">        return filterConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFilterConfig(FilterConfig filterConfig) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化 FilterConfig 与 ServletContext</span><br><span class="line">        this.filterConfig &#x3D; filterConfig;</span><br><span class="line">        setServletContext(filterConfig.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String getInitParam(String paramName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 从 FilterConfig 中获取初始参数</span><br><span class="line">        FilterConfig config &#x3D; getFilterConfig();</span><br><span class="line">        if (config !&#x3D; null) &#123;</span><br><span class="line">            return StringUtils.clean(config.getInitParameter(paramName));</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化 FilterConfig</span><br><span class="line">        setFilterConfig(filterConfig);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 在子类中实现该模板方法</span><br><span class="line">            onFilterConfigSet();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (e instanceof ServletException) &#123;</span><br><span class="line">                throw (ServletException) e;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new ServletException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onFilterConfigSet() throws Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看到这个类的第一感觉就是，它对 FilterConfig 进行了封装，为什么要封装 FilterConfig 呢？就是想通过它来获取 ServletContext。可见，在 init 方法中完成了 FilterConfig 的初始化，并提供了一个名为 onFilterConfigSet 的模板方法，让它的子类去实现其中的细节。</p>
<p>在阅读 AbstractFilter 的子类 NameableFilter 的源码之前，不妨先看看 NameableFilter 实现了一个很有意思的接口 Nameable，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 确保实现该接口的类可进行命名（具有唯一的名称）</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Nameable &#123;</span><br><span class="line"></span><br><span class="line">    void setName(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>仅提供了一个 setName 的方法，目的就是为了让其子类能够提供一个唯一的 Filter Name，如果子类不提供怎么办呢？</p>
<p>相信 Nameable 的实现类也就是 AbstractFilter 的子类 NameableFilter 会告诉我们想要的答案，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 提供 Filter Name 的 get&#x2F;set 方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class NameableFilter extends AbstractFilter implements Nameable &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    protected String getName() &#123;</span><br><span class="line">        &#x2F;&#x2F; 若成员变量 name 为空，则从 FilterConfig 中获取 Filter Name</span><br><span class="line">        if (this.name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            FilterConfig config &#x3D; getFilterConfig();</span><br><span class="line">            if (config !&#x3D; null) &#123;</span><br><span class="line">                this.name &#x3D; config.getFilterName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected StringBuilder toStringBuilder() &#123;</span><br><span class="line">        String name &#x3D; getName();</span><br><span class="line">        if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return super.toStringBuilder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">            sb.append(name);</span><br><span class="line">            return sb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看到了 NameableFilter 中的 getName 方法，我们应该清楚了，每个 Filter 必须有一个名字，可通过 setName 方法设置的，如果不设置就取该 Filter 默认的名字，也就是在 web.xml 中配置的 filter-name 了。此外，这里还通过一个 toStringBuilder 方法完成了类似 toString 方法，不过暂时还没什么用途，可能以后会有用。</p>
<p>以上这一切都是为了让每个 Filter 有一个名字，而且这个名字最好是唯一的（这一点在 Shiro 源码中没有得到控制）。此外，在 shiro.ini 的 [urls] 片段的配置满足一定规则的，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[urls]</span><br><span class="line">&#x2F;foo &#x3D; ssl, authc</span><br></pre></td></tr></table></figure>



<p>等号左边的是 URL，右边的是 Filter Chian，一个或多个 Filter，每个 Filter 用逗号进行分隔。</p>
<p>对于 /foo 这个 URL 而言，可先后通过 ssl 与 authc 这两个 Filter。如果我们同时配置了两个 ssl，这个 URL 会被 ssl 拦截两次吗？答案是否定的，因为 Shiro 为我们提供了一个“一次性 Filter”的原则，也就是保证了每个请求只能被同一个 Filter 拦截一次，而且仅此一次。</p>
<p>这样的机制是如何实现的呢？我们不妨看看 NameableFilter 的子类 OncePerRequestFilter 吧，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 确保每个请求只能被 Filter 过滤一次</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class OncePerRequestFilter extends NameableFilter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 已过滤属性的后缀名</span><br><span class="line">    public static final String ALREADY_FILTERED_SUFFIX &#x3D; &quot;.FILTERED&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 是否开启过滤功能</span><br><span class="line">    private boolean enabled &#x3D; true;</span><br><span class="line"></span><br><span class="line">    public boolean isEnabled() &#123;</span><br><span class="line">        return enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEnabled(boolean enabled) &#123;</span><br><span class="line">        this.enabled &#x3D; enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取 Filter 已过滤的属性名</span><br><span class="line">        String alreadyFilteredAttributeName &#x3D; getAlreadyFilteredAttributeName();</span><br><span class="line">        &#x2F;&#x2F; 判断是否已过滤</span><br><span class="line">        if (request.getAttribute(alreadyFilteredAttributeName) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 若已过滤，则进入 FilterChain 中下一个 Filter</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 若未过滤，则判断是否未开启过滤功能（其中 shouldNotFilter 方法将被废弃，由 isEnabled 方法取代）</span><br><span class="line">            if (!isEnabled(request, response) || shouldNotFilter(request)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 若未开启，则进入 FilterChain 中下一个 Filter</span><br><span class="line">                filterChain.doFilter(request, response);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 若已开启，则将已过滤属性设置为 true（只要保证 Request 中有这个属性即可）</span><br><span class="line">                request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE);</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 在子类中执行具体的过滤操作</span><br><span class="line">                    doFilterInternal(request, response, filterChain);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 当前 Filter 执行结束需移除 Request 中的已过滤属性</span><br><span class="line">                    request.removeAttribute(alreadyFilteredAttributeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String getAlreadyFilteredAttributeName() &#123;</span><br><span class="line">        String name &#x3D; getName();</span><br><span class="line">        if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            name &#x3D; getClass().getName();</span><br><span class="line">        &#125;</span><br><span class="line">        return name + ALREADY_FILTERED_SUFFIX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;UnusedParameters&quot;&#125;)</span><br><span class="line">    protected boolean isEnabled(ServletRequest request, ServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        return isEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)</span><br><span class="line">    protected boolean shouldNotFilter(ServletRequest request) throws ServletException &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如何确保每个请求只会被同一个 Filter 拦截一次呢？Shiro 提供了一个超简单的解决方案：在 Requet 中放置一个后缀为 .FILTERED 的属性，在执行具体拦截操作（即 doFilterInternal 方法）之前放入该属性，执行完毕后移除该属性。</p>
<p>在 Shiro 的 Filter Chian 配置中，如果我们想禁用某个 Filter，如何实现呢？OncePerRequestFilter 也为我们提供了一个 enabled 的属性，方便我们可以在 shiro.ini 中随时禁用某个 Filter，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">ssl.enabled &#x3D; false</span><br><span class="line"></span><br><span class="line">[urls]</span><br><span class="line">&#x2F;foo &#x3D; ssl, authc</span><br></pre></td></tr></table></figure>



<p>这样一来 ssl 这个 Filter 就被我们给禁用了，以后想开启 ssl 的话，完全不需要在 urls 配置中一个个手工来添加，只需把 ssl.enabled 设置为 true，或注释掉该行，或直接删除该行即可。</p>
<p>可见，OncePerRequestFilter 给我们提供了一个模板方法 doFilterInternal，在其子类中我们需要实现该方法的具体细节，那么谁来实现呢？不妨继续看下面的 AbstractShiroFilter 吧，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 确保可通过 SecurityUtils 获取 SecurityManager，并执行过滤器操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class AbstractShiroFilter extends OncePerRequestFilter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 是否可以通过 SecurityUtils 获取 SecurityManager</span><br><span class="line">    private static final String STATIC_INIT_PARAM_NAME &#x3D; &quot;staticSecurityManagerEnabled&quot;;</span><br><span class="line"></span><br><span class="line">    private WebSecurityManager securityManager;</span><br><span class="line">    private FilterChainResolver filterChainResolver;</span><br><span class="line">    private boolean staticSecurityManagerEnabled;</span><br><span class="line"></span><br><span class="line">    protected AbstractShiroFilter() &#123;</span><br><span class="line">        this.staticSecurityManagerEnabled &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WebSecurityManager getSecurityManager() &#123;</span><br><span class="line">        return securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSecurityManager(WebSecurityManager sm) &#123;</span><br><span class="line">        this.securityManager &#x3D; sm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public FilterChainResolver getFilterChainResolver() &#123;</span><br><span class="line">        return filterChainResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFilterChainResolver(FilterChainResolver filterChainResolver) &#123;</span><br><span class="line">        this.filterChainResolver &#x3D; filterChainResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isStaticSecurityManagerEnabled() &#123;</span><br><span class="line">        return staticSecurityManagerEnabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStaticSecurityManagerEnabled(boolean staticSecurityManagerEnabled) &#123;</span><br><span class="line">        this.staticSecurityManagerEnabled &#x3D; staticSecurityManagerEnabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这是 AbstractFilter 提供的在 init 时需要执行的方法</span><br><span class="line">    protected final void onFilterConfigSet() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 从 web.xml 中读取 staticSecurityManagerEnabled 参数（默认为 false）</span><br><span class="line">        applyStaticSecurityManagerEnabledConfig();</span><br><span class="line">        &#x2F;&#x2F; 初始化（在子类中实现）</span><br><span class="line">        init();</span><br><span class="line">        &#x2F;&#x2F; 确保 SecurityManager 必须存在</span><br><span class="line">        ensureSecurityManager();</span><br><span class="line">        &#x2F;&#x2F; 若已开启 static 标志，则将当前的 SecurityManager 放入 SecurityUtils 中，以后可以随时获取</span><br><span class="line">        if (isStaticSecurityManagerEnabled()) &#123;</span><br><span class="line">            SecurityUtils.setSecurityManager(getSecurityManager());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void applyStaticSecurityManagerEnabledConfig() &#123;</span><br><span class="line">        String value &#x3D; getInitParam(STATIC_INIT_PARAM_NAME);</span><br><span class="line">        if (value !&#x3D; null) &#123;</span><br><span class="line">            Boolean b &#x3D; Boolean.valueOf(value);</span><br><span class="line">            if (b !&#x3D; null) &#123;</span><br><span class="line">                setStaticSecurityManagerEnabled(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureSecurityManager() &#123;</span><br><span class="line">        &#x2F;&#x2F; 首先获取当前的 SecurityManager，若不存在，则创建默认的 SecurityManager（即 DefaultWebSecurityManager）</span><br><span class="line">        WebSecurityManager securityManager &#x3D; getSecurityManager();</span><br><span class="line">        if (securityManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">            securityManager &#x3D; createDefaultSecurityManager();</span><br><span class="line">            setSecurityManager(securityManager);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected WebSecurityManager createDefaultSecurityManager() &#123;</span><br><span class="line">        return new DefaultWebSecurityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这是 OncePerRequestFilter 提供的在 doFilter 时需要执行的方法</span><br><span class="line">    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        Throwable t &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 返回被 Shiro 包装过的 Request 与 Response 对象</span><br><span class="line">            final ServletRequest request &#x3D; prepareServletRequest(servletRequest, servletResponse, chain);</span><br><span class="line">            final ServletResponse response &#x3D; prepareServletResponse(request, servletResponse, chain);</span><br><span class="line">            &#x2F;&#x2F; 创建 Shiro 的 Subject 对象</span><br><span class="line">            final Subject subject &#x3D; createSubject(request, response);</span><br><span class="line">            &#x2F;&#x2F; 使用异步的方式执行相关操作</span><br><span class="line">            subject.execute(new Callable() &#123;</span><br><span class="line">                public Object call() throws Exception &#123;</span><br><span class="line">                    &#x2F;&#x2F; 更新 Session 的最后访问时间</span><br><span class="line">                    updateSessionLastAccessTime(request, response);</span><br><span class="line">                    &#x2F;&#x2F; 执行 Shiro 的 Filter Chain</span><br><span class="line">                    executeChain(request, response, chain);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (ExecutionException ex) &#123;</span><br><span class="line">            t &#x3D; ex.getCause();</span><br><span class="line">        &#125; catch (Throwable throwable) &#123;</span><br><span class="line">            t &#x3D; throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        if (t !&#x3D; null) &#123;</span><br><span class="line">            if (t instanceof ServletException) &#123;</span><br><span class="line">                throw (ServletException) t;</span><br><span class="line">            &#125;</span><br><span class="line">            if (t instanceof IOException) &#123;</span><br><span class="line">                throw (IOException) t;</span><br><span class="line">            &#125;</span><br><span class="line">            throw new ServletException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)</span><br><span class="line">    protected ServletRequest prepareServletRequest(ServletRequest request, ServletResponse response, FilterChain chain) &#123;</span><br><span class="line">        ServletRequest toUse &#x3D; request;</span><br><span class="line">        if (request instanceof HttpServletRequest) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取包装后的 Request 对象（使用 ShiroHttpServletRequest 进行包装）</span><br><span class="line">            HttpServletRequest http &#x3D; (HttpServletRequest) request;</span><br><span class="line">            toUse &#x3D; wrapServletRequest(http);</span><br><span class="line">        &#125;</span><br><span class="line">        return toUse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected ServletRequest wrapServletRequest(HttpServletRequest orig) &#123;</span><br><span class="line">        return new ShiroHttpServletRequest(orig, getServletContext(), isHttpSessions());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean isHttpSessions() &#123;</span><br><span class="line">        return getSecurityManager().isHttpSessionMode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)</span><br><span class="line">    protected ServletResponse prepareServletResponse(ServletRequest request, ServletResponse response, FilterChain chain) &#123;</span><br><span class="line">        ServletResponse toUse &#x3D; response;</span><br><span class="line">        if (!isHttpSessions() &amp;&amp; (request instanceof ShiroHttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取包装后的 Response 对象（使用 ShiroHttpServletResponse 进行包装）</span><br><span class="line">            toUse &#x3D; wrapServletResponse((HttpServletResponse) response, (ShiroHttpServletRequest) request);</span><br><span class="line">        &#125;</span><br><span class="line">        return toUse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected ServletResponse wrapServletResponse(HttpServletResponse orig, ShiroHttpServletRequest request) &#123;</span><br><span class="line">        return new ShiroHttpServletResponse(orig, getServletContext(), request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected WebSubject createSubject(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">        return new WebSubject.Builder(getSecurityManager(), request, response).buildWebSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)</span><br><span class="line">    protected void updateSessionLastAccessTime(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">        &#x2F;&#x2F; 仅对本地 Session 做如下操作</span><br><span class="line">        if (!isHttpSessions()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取 Subject（实际上是从 ThreadLocal 中获取的）</span><br><span class="line">            Subject subject &#x3D; SecurityUtils.getSubject();</span><br><span class="line">            if (subject !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 从 Subject 中获取 Session</span><br><span class="line">                Session session &#x3D; subject.getSession(false);</span><br><span class="line">                if (session !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 更新 Session 对象的 lastAccessTime 属性</span><br><span class="line">                    session.touch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain) throws IOException, ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取 Shiro 代理后的 FilterChain 对象，并进行链式处理</span><br><span class="line">        FilterChain chain &#x3D; getExecutionChain(request, response, origChain);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected FilterChain getExecutionChain(ServletRequest request, ServletResponse response, FilterChain origChain) &#123;</span><br><span class="line">        FilterChain chain &#x3D; origChain;</span><br><span class="line">        &#x2F;&#x2F; 获取 FilterChainResolver，若不存在，则返回原始的 FilterChain</span><br><span class="line">        FilterChainResolver resolver &#x3D; getFilterChainResolver();</span><br><span class="line">        if (resolver &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return origChain;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 通过 FilterChainResolver 获取 ProxiedFilterChain</span><br><span class="line">        FilterChain resolved &#x3D; resolver.getChain(request, response, origChain);</span><br><span class="line">        if (resolved !&#x3D; null) &#123;</span><br><span class="line">            chain &#x3D; resolved;</span><br><span class="line">        &#125;</span><br><span class="line">        return chain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个 AbstractShiroFilter 类代码稍微有点长，因为它干了许多的事情，主要实现了两个模板方法：onFilterConfigSet 与 doFilterInternal，以上代码中均已对它们做了详细的注释。</p>
<p>其中，在 onFilterConfigSet 中实际上提供了一个框架，只是将 SecurityManager 放入 SecurityUtils 这个工具类中，至于具体行为还是放在子类的 init 方法中去实现，而这个子类就是 ShiroFilter，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 初始化过滤器</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ShiroFilter extends AbstractShiroFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 从 ServletContext 中获取 WebEnvironment（该对象已通过 EnvironmentLoader 创建）</span><br><span class="line">        WebEnvironment env &#x3D; WebUtils.getRequiredWebEnvironment(getServletContext());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将 WebEnvironment 中的 WebSecurityManager 放入 AbstractShiroFilter 中</span><br><span class="line">        setSecurityManager(env.getWebSecurityManager());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将 WebEnvironment 中的 FilterChainResolver 放入 AbstractShiroFilter 中</span><br><span class="line">        FilterChainResolver resolver &#x3D; env.getFilterChainResolver();</span><br><span class="line">        if (resolver !&#x3D; null) &#123;</span><br><span class="line">            setFilterChainResolver(resolver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 ShiroFilter 中只用做初始化的行为，就是从 WebEnvironment 中分别获取 WebSecurityManager 与 FilterChainResolver，其它的事情都由它的父类去实现了。</p>
<p>到此为止，ShiroFilter 的源码已基本分析完毕，当然还有些非常有意思的代码，这里没有进行分析，例如：</p>
<ul>
<li>通过 ShiroHttpServletRequest 来包装 Request</li>
<li>通过 ShiroHttpServletResponse 来包装 Response</li>
<li>通过 Session 来代理 HttpSession</li>
<li>提供 FilterChain 的代理机制</li>
<li>使用 ThreadContext 来保证线程安全</li>
</ul>
<p>这些有意思的代码，我就不继续分析了，留点滋味让大家去慢慢品尝吧！</p>
<p>最后需要补充说明的是，Shiro 的 Filter 架构体系是非常庞大的，这里仅对 ShiroFilter 进行了分析，整个 Filter 静态结构看起来是这样的：</p>
<p><img src="http://static.oschina.net/uploads/space/2014/0321/172903_VINL_223750.png" alt="img"></p>
<p>可见，在 OncePerRequestFilter 下有两个分支，本文只分析了 ShiroFilter 这个分支，另外还有一个 AdviceFilter 分支，它提供了 AOP 功能的 Filter，这些 Filter 就是 Shiro 为我们提供的默认 Filter：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>anon</td>
<td><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/AnonymousFilter.html">org.apache.shiro.web.filter.authc.AnonymousFilter</a></td>
</tr>
<tr>
<td>authc</td>
<td><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.html">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</a></td>
</tr>
<tr>
<td>authcBasic</td>
<td><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/BasicHttpAuthenticationFilter.html">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</a></td>
</tr>
<tr>
<td>logout</td>
<td><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/LogoutFilter.html">org.apache.shiro.web.filter.authc.LogoutFilter</a></td>
</tr>
<tr>
<td>noSessionCreation</td>
<td><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/session/NoSessionCreationFilter.html">org.apache.shiro.web.filter.session.NoSessionCreationFilter</a></td>
</tr>
<tr>
<td>perms</td>
<td><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PermissionsAuthorizationFilter.html">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</a></td>
</tr>
<tr>
<td>port</td>
<td><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PortFilter.html">org.apache.shiro.web.filter.authz.PortFilter</a></td>
</tr>
<tr>
<td>rest</td>
<td><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.html">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</a></td>
</tr>
<tr>
<td>roles</td>
<td><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/RolesAuthorizationFilter.html">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</a></td>
</tr>
<tr>
<td>ssl</td>
<td><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/SslFilter.html">org.apache.shiro.web.filter.authz.SslFilter</a></td>
</tr>
<tr>
<td>user</td>
<td><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/UserFilter.html">org.apache.shiro.web.filter.authc.UserFilter</a></td>
</tr>
</tbody></table>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h3><p>to determine the identity of the user is through the sessionId, and the sessionId is stored in the cookie, we can return the sessionId as the response header to the front end after login, each request is accompanied by this information, then we customize a SessionManager, overwrite His getSessionId method can be:<br>Return the sessionId to the frontend after logging in:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(<span class="string">&quot;login&quot;</span>)</span><br><span class="line">@Responebody</span><br><span class="line">    public Result login(<span class="built_in">String</span> username, <span class="built_in">String</span> password, HttpServletResponse response)&#123;</span><br><span class="line">        Result result = <span class="literal">null</span>;</span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username,password);</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            Serializable id = subject.getSession().getId();</span><br><span class="line">            response.setHeader(<span class="string">&quot;token&quot;</span>,id.toString());<span class="regexp">/ /</span> Get the state <span class="keyword">of</span> the sessionId, <span class="keyword">return</span> to the front end</span><br><span class="line">            result = ResultGenerator.getSuucessResult();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            result = ResultGenerator.getFailResult(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Custom sessionManager, the way to get the sessionId is no longer a heavy cookie but in the requsetHeader:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyWebSessionManager</span> <span class="keyword">extends</span> <span class="title">DefaultWebSessionManager</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Serializable getSessionId(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = WebUtils.toHttp(request);</span><br><span class="line">        <span class="built_in">String</span> token = httpServletRequest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;token：&quot;</span>+token);</span><br><span class="line">        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, <span class="string">&quot;token&quot;</span>);</span><br><span class="line">        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, token);</span><br><span class="line">        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, <span class="built_in">Boolean</span>.TRUE);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Set to use the change sessionManager, generic can also use ioc injection without new:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public DefaultWebSecurityManager webSecurityManager(MyRealm myRealm)&#123;</span><br><span class="line">        DefaultWebSecurityManager webSecurityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        MyWebSessionManager webSessionManager = <span class="keyword">new</span> MyWebSessionManager();<span class="regexp">/ /</span> Use a custom sessionManager</span><br><span class="line">        webSessionManager.setGlobalSessionTimeout(<span class="number">360000</span>l);<span class="regexp">/ /</span> <span class="built_in">Set</span> the session expiration time <span class="number">1</span> hour</span><br><span class="line">        webSecurityManager.setSessionManager(webSessionManager);</span><br><span class="line">        webSecurityManager.setRealm(myRealm);</span><br><span class="line">        <span class="keyword">return</span> webSecurityManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>With such a simple configuration, most of the rights management of shiro can be realized by separating the front and back ends.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-concurrent-ConcurrentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-concurrent-ConcurrentHashMap/" class="post-title-link" itemprop="url">JDK-JUC-ConcurrentHashMap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-19 09:07:43" itemprop="dateCreated datePublished" datetime="2021-04-19T09:07:43+08:00">2021-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-10 12:06:43" itemprop="dateModified" datetime="2023-02-10T12:06:43+08:00">2023-02-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Jdk-7-ConcurrentHashMap"><a href="#Jdk-7-ConcurrentHashMap" class="headerlink" title="Jdk 7 ConcurrentHashMap"></a>Jdk 7 ConcurrentHashMap</h1><p>如何在高并发下提高系统吞吐是所有后端开发者追求的目标，Java并发的开创者Doug Lea在Java 7 ConcurrentHashMap的设计中给出了一些参考答案，<strong>自旋锁、CAS的使用、延迟写内存、volatile语义</strong>退化等不常见的技巧</p>
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/R7PtjL3tdAicMdbQfrvwSkfich8cYHngc1rpQ50iaXsQib1VWGqQLr22AgdZcyW71A5P2FpBd9nia1ahOJAXAXSVOOA/640" alt="Image" style="zoom:50%;" />

<p>对于<code>Java 7</code>来说</p>
<ol>
<li><code>ConcurrentHashMap</code>是一个线程安全的<code>Map</code>实现，其读取不需要加锁，通过引入<code>Segment</code>，可以做到写入的时候加锁力度足够小</li>
<li>由于引入了<code>Segment</code>，<code>ConcurrentHashMap</code>在读取和写入的时候需要需要做两次哈希，但这两次哈希换来的是更细力粒度的锁，也就意味着可以支持更高的并发</li>
<li>每个桶数组中的<code>key-value</code>对仍然以链表的形式存放在桶中，这一点和<code>HashMap</code>是一致的。</li>
</ol>
<p>细节问题：</p>
<ol>
<li><code>ConcurrentHashMap</code>的哪些操作需要加锁？</li>
<li><code>ConcurrentHashMap</code>的无锁读是如何实现的？</li>
<li>在多线程的场景下调用<code>size（）</code>方法获取<code>ConcurrentHashMap</code>的大小有什么挑战？<code>ConcurrentHashMap</code>是怎么解决的？</li>
<li>在有<code>Segment</code>存在的前提下，应该如何扩容的？</li>
</ol>
<p><code>HashMap</code>中最重要的点有四个：<strong>初始化</strong>，<strong>数据寻址-<code>hash</code>方法</strong>，<strong>数据存储-<code>put</code>方法</strong>,<strong>扩容-<code>resize</code>方法</strong>，对于<code>ConcurrentHashMap</code>来说，这四个操作依然是最重要的，但由于其引入了更复杂的数据结构，因此在调用<code>size()</code>查看整个<code>ConcurrentHashMap</code>的数量大小的时候也有不小的挑战</p>
<h2 id="new-ConcurrentHashMap"><a href="#new-ConcurrentHashMap" class="headerlink" title="new ConcurrentHashMap()"></a><code>new ConcurrentHashMap()</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 保证ssize是大于concurrencyLevel的最小的2的整数次幂</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻址需要两次哈希，哈希的高位用于确定segment，低位用户确定桶数组中的元素</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化方法中做了三件重要的事：</p>
<ol>
<li>确定了<code>segments</code>的数组的大小<code>ssize</code>，<code>ssize</code>根据入参<code>concurrencyLevel</code>确定，取大于<code>concurrencyLevel</code>的最小的2的整数次幂</li>
<li>确定哈希寻址时的偏移量，这个偏移量在确定元素在<code>segment</code>数组中的位置时会用到</li>
<li>初始化<code>segment</code>数组中的第一个元素，元素类型为<code>HashEntry</code>的数组，这个数组的长度为<code>initialCapacity / ssize</code>，即初始化大小除以<code>segment</code>数组的大小，<code>segment</code>数组中的其他元素在后续<code>put</code>操作时参考第一个已初始化的实例初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; </span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next; </span><br><span class="line"> </span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(HashEntry&lt;K,V&gt; n)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>HashEntry</code>和<code>HashMap</code>中的<code>HashEntry</code>作用是一样的，它是<code>ConcurrentHashMap</code>的数据项，这里要注意两个细节：</p>
<h3 id="细节一："><a href="#细节一：" class="headerlink" title="细节一："></a><strong>细节一：</strong></h3><p><code>HashEntry</code>的成员变量<code>value</code>和<code>next</code>是被关键字<code>volatile</code>修饰的，也就是说所有线程都可以及时检查到其他线程对这两个变量的改变，因而可以在不加锁的情况下读取到这两个引用的最新值</p>
<h3 id="细节二："><a href="#细节二：" class="headerlink" title="细节二："></a><strong>细节二：</strong></h3><p><code>HashEntry</code>的<code>setNext</code>方法中调用了<code>UNSAFE.putOrderedObject</code>，这个接口是属于<code>sun</code>安全库中的<code>api</code>，并不是<code>J2SE</code>的一部分，它的作用和<code>volatile</code>恰恰相反，调用这个<code>api</code>设值是使得<code>volatile</code>修饰的变量延迟写入主存，那到底是什么时候写入主存呢？</p>
<blockquote>
<p>JMM中有一条规定：</p>
<p>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p>
</blockquote>
<p>后文在讲<code>put</code>方法的时候我们再详细看<code>setNext</code>的用法</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>由于引入了<code>segment</code>，因此不管是调用<code>get</code>方法读还是调用<code>put</code>方法写，都需要做两次哈希，还记得在上文我们讲初始化的时候系统做了一件重要的事：</p>
<ul>
<li>确定哈希寻址时的偏移量，这个偏移量在确定元素在<code>segment</code>数组中的位置时会用到</li>
</ul>
<p>没错就是这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.segmentShift &#x3D; 32 - sshift;</span><br></pre></td></tr></table></figure>

<p>这里用32去减是因为<code>int</code>型的长度是32，有了<code>segmentShift</code>，<code>ConcurrentHashMap</code>是如何做第一次哈希的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 变量j代表着数据项处于segment数组中的第j项</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 如果segment[j]为null,则下面的这个方法负责初始化之</span></span><br><span class="line">    s = ensureSegment(j); </span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以<code>put</code>方法为例，变量<code>j</code>代表着数据项处于<code>segment</code>数组中的第<code>j</code>项。如下图所示假如<code>segment</code>数组的大小为2的n次方，则<code>hash &gt;&gt;&gt; segmentShift</code>正好取了key的哈希值的高n位，再与掩码<code>segmentMask</code>相与相当与仍然用key的哈希的高位来确定数据项在<code>segment</code>数组中的位置。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"><code>hash</code>方法与非线程安全的<code>HashMap</code>相似，这里不再细说。</p>
<h3 id="细节三："><a href="#细节三：" class="headerlink" title="细节三："></a><strong>细节三：</strong></h3><p>在延迟初始化<code>Segment</code>数组时，作者采用了<code>CAS</code>避免了加锁，而且<code>CAS</code>可以保证最终的初始化只能被一个线程完成。在最终决定调用<code>CAS</code>进行初始化前又做了两次检查，第一次检查可以避免重复初始化<code>tab</code>数组，而第二次检查则可以避免重复初始化<code>Segment</code>对象，每一行代码作者都有详细的考虑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset 实际的字节偏移量</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123; <span class="comment">// recheck 再检查一次是否已经被初始化</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s)) <span class="comment">// 使用 CAS 确保只被初始化一次</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a><code>put</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//细节4</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value); </span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k; <span class="comment">// 如果找到key相同的数据项，则直接替换</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// node不为空说明已经在自旋等待时初始化了，注意调用的是setNext，不是直接操作next</span></span><br><span class="line">                    node.setNext(first); </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 否则，在这里新建一个HashEntry</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>; <span class="comment">// 先加1</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 将新节点写入，注意这里调用的方法有门道</span></span><br><span class="line">                    setEntryAt(tab, index, node); </span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在整个<code>ConcurrentHashMap</code>的设计中非常出彩</p>
<h3 id="细节四："><a href="#细节四：" class="headerlink" title="细节四："></a><strong>细节四：</strong></h3><p>CPU的调度是公平的，好不容易轮到的时间片如果因为获取不到锁就将本线程挂起无疑会降低本线程的效率，更何况挂起之后还要重新调度，切换上下文，又是一笔不小的开销。如果可以遇见其他线程占有锁的时间不会很长，采用自旋将会是一个比较好的选择，在这里面也有一个权衡，如果别的线程占有锁的时间过长，反而是挂起阻塞等待性能好一点，我们来看下<code>ConcurrentHashMap</code>的做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123; <span class="comment">// 自旋等待</span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123; <span class="comment">// 这个桶中还没有写入k-v项</span></span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node 直接创建一个新的节点</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// key值相等，直接跳出去尝试获取锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 遍历链表</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待超过一定次数之后只能挂起线程，阻塞等待了</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123; </span><br><span class="line">            <span class="comment">// 如果头节点改变了，则重置次数，继续自旋等待</span></span><br><span class="line">            e = first = f; </span><br><span class="line">            retries = -<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConcurrentHashMap</code>的策略是tryLock()自旋,  (最多<code>MAX_SCAN_RETRIES</code>次); 如果还没有获取到锁则调用<code>lock</code>挂起阻塞等待，当然如果其他线程采用头插法改变了链表的头结点，则重置自旋等待次数。</p>
<h3 id="细节五："><a href="#细节五：" class="headerlink" title="细节五："></a><strong>细节五：</strong></h3><p>要知道，如果要从编码的角度提升系统的并发度，一个黄金法则就是减少并发临界区的大小。在<code>scanAndLockForPut</code>这个方法的设计上，有个小细节让我眼前一亮，就是在自旋的过程中初始化了一个<code>HashEntry</code>，这样做的好处就是线程在拿到锁之后不用初始化<code>HashEntry</code>了，占有锁的时间相应减小，进而提升性能。</p>
<h3 id="细节六："><a href="#细节六：" class="headerlink" title="细节六："></a><strong>细节六：</strong></h3><p>在<code>put</code>方法的开头，有这么一行不起眼的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashEntry&lt;K,V&gt;[] tab = table;</span><br></pre></td></tr></table></figure>

<p>看起来好像就是简单的临时变量赋值，其实大有来头，我们看一下<code>table</code>的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p><code>table</code>变量被关键字<code>volatile</code>修饰，<code>CPU</code>在处理<code>volatile</code>修饰的变量的时候会有下面的行为：</p>
<blockquote>
<p><strong>嗅探</strong></p>
<p>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里</p>
</blockquote>
<p>因此直接读取这类变量的读取和写入比普通变量的性能消耗更大，因此在<code>put</code>方法的开头将<code>table</code>变量赋值给一个普通的本地变量目的是为了消除<code>volatile</code>带来的性能损耗。这里就有另外一个问题：那这样做会不会导致<code>table</code>的语义改变，让别的线程读取不到最新的值呢？</p>
<h3 id="细节七："><a href="#细节七：" class="headerlink" title="细节七："></a><strong>细节七：</strong></h3><p>注意<code>put</code>方法中的这个方法：<code>entryAt()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">HashEntry&lt;K,V&gt; <span class="title">entryAt</span><span class="params">(HashEntry&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tab == <span class="keyword">null</span>) ? <span class="keyword">null</span> : (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的底层会调用<code>UNSAFE.getObjectVolatile</code>，这个方法的目的就是对于普通变量读取也能像<code>volatile</code>修饰的变量那样读取到最新的值，在前文中我们分析过，由于变量<code>tab</code>现在是一个普通的临时变量，如果直接调用<code>tab[i]</code>不一定能拿到最新的首节点的。细心的读者读到这里可能会想：为啥不刚开始就操作<code>volatile</code>变量呢?</p>
<h3 id="细节八："><a href="#细节八：" class="headerlink" title="细节八："></a><strong>细节八：</strong></h3><p>在<code>put</code>方法的实现中，如果链表中没有<code>key</code>值相等的数据项，则会把新的数据项插入到链表头写入到数组中，其中调用的方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; void setEntryAt(HashEntry&lt;K,V&gt;[] tab, int i, HashEntry&lt;K,V&gt; e) &#123;</span><br><span class="line">    UNSAFE.putOrderedObject(tab, ((long)i &lt;&lt; TSHIFT) + TBASE, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>putOrderedObject</code>这个接口写入的数据不会马上被其他线程获取到，而是在<code>put</code>方法最后调用<code>unclock</code>后才会对其他线程可见，参见前文中对JMM的描述：</p>
<blockquote>
<p>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p>
</blockquote>
<p>这样的好处有两个，第一是性能，因为在持有锁的临界区不需要有同步主存的操作，因此持有锁的时间更短。第二是保证了数据的一致性，在<code>put</code>操作的<code>finally</code>语句执行完之前，<code>put</code>新增的数据是不对其他线程展示的，这是<code>ConcurrentHashMap</code>实现无锁读的关键原因。</p>
<p>我们在这里稍微总结一下<code>put</code>方法里面最重要的三个细节，首先将<code>volatile</code>变量转为普通变量提升性能，因为在<code>put</code>中需要读取到最新的数据，因此接下来调用<code>UNSAFE.getObjectVolatile</code>获取到最新的头结点，但是通过调用<code>UNSAFE.putOrderedObject</code>让变量写入主存的时间延迟到<code>put</code>方法的结尾，一来缩小临界区提升性能，而来也能保证其他线程读取到的是完整数据。</p>
<h3 id="细节九："><a href="#细节九：" class="headerlink" title="细节九："></a><strong>细节九：</strong></h3><p>如果<code>put</code>真的需要往链表头插入数据项，那也得注意了，<code>ConcurrentHashMap</code>相应的语句是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.setNext(first);</span><br></pre></td></tr></table></figure>

<p>我们看下<code>setNext</code>的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void setNext(HashEntry&lt;K,V&gt; n) &#123;</span><br><span class="line">    UNSAFE.putOrderedObject(this, nextOffset, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>next</code>变量是用<code>volatile</code>关键字修饰的，这里调用<code>UNSAFE.putOrderedObject</code>相当于是改变了<code>volatile</code>的语义，这里面的考量有两个，第一个仍然是性能，这样的实现性能明显更高，这一点前文已经详细的分析过，第二点是考虑了语义的一致性，对于<code>put</code>方法来说因为其调用的是<code>UNSAFE.getObjectVolatile</code>，仍然能获取到最新的数据，对于<code>get</code>方法，在<code>put</code>方法未结束之前，是不希望不完整的数据被其他线程通过<code>get</code>方法读取的，这也是合理的。</p>
<h2 id="resize扩容"><a href="#resize扩容" class="headerlink" title="resize扩容"></a><code>resize</code>扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>) <span class="comment">//  Single node on list 只有一个节点，简单处理</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 保证下文中newTable[k]不会为null</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                        last != <span class="keyword">null</span>;</span><br><span class="line">                        last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes 对标记之前的不能重用的节点进行复制，再重新添加到新数组对应的hash桶中去</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node 部分的put功能，把新节点添加到链表的最前面</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分析过，在整个桶数组长度为2的正整数幂的情况下，扩容前同一个桶中的元素在扩容后只会分布在两个桶中，其中一个桶的下标保持不变，我们称之为旧桶，另一个桶的下标为旧桶下标加上旧的容量，我们称之为新桶，其实第一个for循环的目的就是在一个链表中找到最后一个应该移到新桶的数据项，直接移到新桶中，这样做是为了保证后面调用<code>HashEntry&lt;K,V&gt; n = newTable[k];</code>的时候不会读取到<code>null</code>。第二个<code>for</code>就比较简单了，将所有的数据项移到新的桶数组中，当所有的操作完成之后才将<code>newTable</code>赋值给<code>table</code>。</p>
<p><code>rehash</code>方法中是没有加锁的，并不是说调用这个方法不需要加锁，作者是在外层加了锁，这一点需要注意。</p>
<h2 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h2><p>之前在分析<code>HashMap</code>方法的时候我们并没有去讲<code>size</code>方法，因为在单线程环境下这个方法可以使用一个全局的变量解决，同样的方案当然也可以在多线程场景下使用，不过要在多线程环境下读取全局变量又会陷入到无尽的“锁”中，这是我们不愿意看到的，那<code>ConcurrentHashMap</code>是如何解决这个问题的呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面介绍<code>put</code>方法时我们选择忽略了一个小小的成员变量<code>modCount</code>，这个变量在这里大显身手，它的主要作用就是记录整个<code>Segment</code>中写入操作的次数，因为写入操作是会影响整个<code>ConcurrentHashMap</code>的大小的。</p>
<p>因为在读取<code>ConcurrentHashMap</code>大小的时候需要保证读到的是最新的值，因此其调用了<code>UNSAFE.getObjectVolatile</code>这个方法，虽然这个方法的性能比普通变量要差，但是比起全局加锁，可好多了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; Segment&lt;K,V&gt; segmentAt(Segment&lt;K,V&gt;[] ss, int j) &#123;</span><br><span class="line">    long u &#x3D; (j &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; 计算实际的字节偏移量</span><br><span class="line">    return ss &#x3D;&#x3D; null ? null : (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(ss, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="细节十："><a href="#细节十：" class="headerlink" title="细节十："></a><strong>细节十：</strong></h3><p>在<code>size</code>方法的设计上，<code>ConcurrentHashMap</code>先尝试无锁的方法，如果两次遍历所有<code>segment</code>数组的时候整个<code>ConcurrentHashMap</code>没有发生写入操作，则直接返回每个<code>segment</code>数组的<code>size()</code>之和，否则重新遍历，如果写入操作频繁，则不得已加锁处理，这里的加锁相当于是一个全局的锁，因为对<code>segment</code>数组的每一个元素都加了锁。那如何判断整个<code>ConcurrentHashMap</code>的写入是否频繁呢？就看无锁重试的次数，当无锁重试的次数超过阈值的话就全局加锁处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在看完<code>ConcurrentHashMap</code>中的这些细节之后我们尝试回答一下文章开头提出来的问题：</p>
<ol>
<li><p><code>ConcurrentHashMap</code>的哪些操作需要加锁？</p>
<p>答：只有写入操作才需要加锁，读取操作不需要加锁</p>
</li>
<li><p><code>ConcurrentHashMap</code>的无锁读是如何实现的？</p>
<p>答：首先<code>HashEntry</code>中的<code>value</code>和<code>next</code>都是有<code>volatile</code>修饰的，其次在写入操作的时候通过调用<code>UNSAFE</code>库延迟同步了主存，保证了数据的一致性</p>
</li>
<li><p>在多线程的场景下调用<code>size（）</code>方法获取<code>ConcurrentHashMap</code>的大小有什么挑战？<code>ConcurrentHashMap</code>是怎么解决的？</p>
<p>答：<code>size()</code>具有全局的语义，如何能保证在不加全局锁的情况下读取到全局状态的值是一个很大的挑战，<code>ConcurrentHashMap</code>通过查看<strong>两次无锁读</strong>中间是否发生了写入操作来决定读取到的<code>size()</code>是否可信，如果写入操作频繁，则再退化为<strong>全局加锁读取</strong>。</p>
</li>
<li><p>在有<code>Segment</code>存在的前提下，是如何扩容的？</p>
<p>答：<code>segment</code>数组的大小在一开始初始化的时候就已经决定了，扩容主要扩的是<code>HashEntry</code>数组，基本的思路与<code>HashTable</code>一致，但这是一个线程不安全方法，调用之前需要加锁。</p>
</li>
</ol>
<h1 id="Java-8-ConcurrentHashMap"><a href="#Java-8-ConcurrentHashMap" class="headerlink" title="Java 8 ConcurrentHashMap"></a>Java 8 ConcurrentHashMap</h1><p>在<code>Java 7</code>的源码中，作者对悲观锁的使用非常谨慎，大多都转换为自旋锁加<code>volatile</code>获得相同的语义，即使最后迫不得已要用，作者也会通过各种技巧减少锁的临界区。在上一篇文章中我们也有讲到，自旋锁在临界区比较小的时候是一个较优的选择是因为它避免了线程由于阻塞而切换上下文，但本质上它也是个锁，在自旋等待期间只有一个线程能进入临界区，其他线程只会自旋消耗<code>CPU</code>的时间片。<code>Java 8</code>中<code>ConcurrentHashMap</code>的实现通过一些巧妙的设计和技巧，避开了自旋锁的局限，提供了更高的并发性能。如果说<code>Java 7</code>版本的源码是在教我们如何将悲观锁转换为自旋锁，那么在<code>Java 8</code>中我们甚至可以看到如何将自旋锁转换为无锁的方法和技巧。</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdA8G9gcTVIgP3JZWCv0UibUvicIeiaDmgzDGzAh50zu8uibcTzY7acGCJI84Y9J86iaJ0aPK0mD9ASTdR6Q/640" alt="Image" style="zoom:50%;" />

<p>在开始本文之前，大家首先在心里还是要有这样的一张图，如果有同学对<code>HashMap</code>比较熟悉，那这张图也应该不会陌生。事实上在整体的数据结构的设计上<code>Java 8</code>的<code>ConcurrentHashMap</code>和<code>HashMap</code>基本上是一致的。</p>
<p><code>Java 7</code>中<code>ConcurrentHashMap</code>为了提升性能使用了很多的编程技巧，但是引入<code>Segment</code>的设计还是有很大的改进空间的，<code>Java 7</code>中<code>ConcurrrentHashMap</code>的设计有下面这几个可以改进的点：</p>
<ol>
<li><code>Segment</code>在扩容的时候非扩容线程对本<code>Segment</code>的写操作时都要挂起等待的</li>
<li>对<code>ConcurrentHashMap</code>的读操作需要做两次哈希寻址，在读多写少的情况下其实是有额外的性能损失的</li>
<li>尽管<code>size()</code>方法的实现中先尝试无锁读，但是如果在这个过程中有别的线程做写入操作，那调用<code>size()</code>的这个线程就会给整个<code>ConcurrentHashMap</code>加锁，这是整个<code>ConcurrrentHashMap</code>唯一一个全局锁，这点对底层的组件来说还是有性能隐患的</li>
<li>极端情况下（比如客户端实现了一个性能很差的哈希函数）<code>get()</code>方法的复杂度会退化到<code>O(n)</code>。</li>
</ol>
<p>针对1和2，在<code>Java 8</code>的设计是废弃了<code>Segment</code>的使用，将悲观锁的粒度降低至桶维度，因此调用<code>get</code>的时候也不需要再做两次哈希了。<code>size()</code>的设计是<code>Java 8</code>版本中最大的亮点，我们在后面的文章中会详细说明。至于红黑树，这篇文章仍然不做过多阐述。</p>
<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a><code>ForwardingNode</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="comment">// MOVED = -1，ForwardingNode的哈希值为-1</span></span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了普通的<code>Node</code>和<code>TreeNode</code>之外，<code>ConcurrentHashMap</code>还引入了一个新的数据类型<code>ForwardingNode</code>，我们这里只展示他的构造方法，<code>ForwardingNode</code>的作用有两个：</p>
<ul>
<li>在动态扩容的过程中标志某个桶已经被复制到了新的桶数组中</li>
<li>如果在动态扩容的时候有<code>get</code>方法的调用，则<code>ForwardingNode</code>将会把请求转发到新的桶数组中，以避免阻塞<code>get</code>方法的调用，<code>ForwardingNode</code>在构造的时候会将扩容后的桶数组<code>nextTable</code>保存下来。</li>
</ul>
<h3 id="UNSAFE-compareAndSwap"><a href="#UNSAFE-compareAndSwap" class="headerlink" title="UNSAFE.compareAndSwap"></a><code>UNSAFE.compareAndSwap</code></h3><p>这是在<code>Java 8</code>版本的<code>ConcurrentHashMap</code>实现<code>CAS</code>的工具，以<code>int</code>类型为例其方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Atomically update Java variable to &lt;tt&gt;x&lt;&#x2F;tt&gt; if it is currently</span><br><span class="line">* holding &lt;tt&gt;expected&lt;&#x2F;tt&gt;.</span><br><span class="line">* @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if successful</span><br><span class="line">*&#x2F;</span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                              int expected,</span><br><span class="line">                                              int x);</span><br></pre></td></tr></table></figure>

<p>相应的语义为：</p>
<blockquote>
<p>如果对象<code>o</code>起始地址偏移量为<code>offset</code>的值等于<code>expected</code>，则将该值设为<code>x</code>，并返回<code>true</code>表明更新成功，否则返回<code>false</code>，表明<code>CAS</code>失败</p>
</blockquote>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>) <span class="comment">// 检查参数</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)</span><br><span class="line">        initialCapacity = concurrencyLevel;</span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size); <span class="comment">// tableSizeFor，求不小于size的 2^n的算法，jdk1.8的HashMap中说过</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使是最复杂的一个初始化方法代码也是比较简单的，这里我们只需要注意两个点：</p>
<ul>
<li><code>concurrencyLevel</code>在<code>Java 7</code>中是<code>Segment</code>数组的长度，由于在<code>Java 8</code>中已经废弃了<code>Segment</code>，因此<code>concurrencyLevel</code>只是一个保留字段，无实际意义</li>
<li><code>sizeCtl</code>这个值第一次出现，这个值如果等于-1则表明系统正在初始化，如果是其他负数则表明系统正在扩容，在扩容时<code>sizeCtl</code>二进制的低十六位等于扩容的线程数加一，高十六位（除符号位之外）包含桶数组的大小信息</li>
</ul>
<h2 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a><code>put</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>put</code>方法将调用转发到<code>putVal</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 【A】延迟初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 【B】当前桶是空的，直接更新</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【C】如果当前的桶的第一个元素是一个ForwardingNode节点，则该线程尝试加入扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 【D】否则遍历桶内的链表或树，并插入</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 暂时折叠起来，后面详细看</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【F】流程走到此处，说明已经put成功，map的记录总数加一</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="桶数组的初始化"><a href="#桶数组的初始化" class="headerlink" title="桶数组的初始化"></a>桶数组的初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 说明已经有线程在初始化了，本线程开始自旋</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// CAS保证只有一个线程能走到这个分支</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// sc = n - n/4 = 0.75n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 恢复sizeCtl &gt; 0相当于释放锁</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化桶数组的过程中，系统如何保证不会出现并发问题呢，关键点在于自旋锁的使用，当有多个线程都执行<code>initTable</code>方法的时候，<code>CAS</code>可以保证只有一个线程能够进入到真正的初始化分支，其他线程都是自旋等待。这段代码中我们关注三点即可：</p>
<ul>
<li>依照前文所述，当有线程开始初始化桶数组时，会通过<code>CAS</code>将<code>sizeCtl</code>置为-1，其他线程以此为标志开始自旋等待</li>
<li>当桶数组初始化结束后将<code>sizeCtl</code>的值恢复为正数，其值等于0.75倍的桶数组长度，这个值的含义和之前<code>HashMap</code>中的<code>THRESHOLD</code>一致，是系统触发扩容的临界点</li>
<li>在<code>finally</code>语句中对<code>sizeCtl</code>的操作并没有使用<code>CAS</code>是因为<code>CAS</code>保证只有一个线程能够执行到这个地方</li>
</ul>
<h3 id="添加桶数组第一个元素"><a href="#添加桶数组第一个元素" class="headerlink" title="添加桶数组第一个元素"></a>添加桶数组第一个元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>put</code>方法的第二个分支会用<code>tabAt</code>判断当前桶是否是空的，如果是则会通过<code>CAS</code>写入，<code>tabAt</code>通过<code>UNSAFE</code>接口会拿到桶中的最新元素，<code>casTabAt</code>通过<code>CAS</code>保证不会有并发问题，如果<code>CAS</code>失败，则通过循环再进入其他分支</p>
<h3 id="判断是否需要新增线程扩容"><a href="#判断是否需要新增线程扩容" class="headerlink" title="判断是否需要新增线程扩容"></a>判断是否需要新增线程扩容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">    if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123;</span><br><span class="line">        int rs &#x3D; resizeStamp(tab.length);</span><br><span class="line">        while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;</span><br><span class="line">                (sc &#x3D; sizeCtl) &lt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; RESIZE_STAMP_SHIFT &#x3D; 16</span><br><span class="line">            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0)</span><br><span class="line">                break;</span><br><span class="line">            &#x2F;&#x2F; 这里将sizeCtl的值自增1，表明参与扩容的线程数量+1</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个地方我们就要详细说下<code>sizeCtl</code>这个标志位了，临时变量<code>rs</code>由<code>resizeStamp</code>这个方法返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int resizeStamp(int n) &#123;</span><br><span class="line">    &#x2F;&#x2F; RESIZE_STAMP_BITS &#x3D; 16</span><br><span class="line">    return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为入参<code>n</code>是一个<code>int</code>类型的值，所有<code>Integer.numberOfLeadingZeros(n)</code>的返回值介于0到32之间，如果转换成二进制</p>
<ul>
<li><code>Integer.numberOfLeadingZeros(n)</code>的最大值是：00000000 00000000 00000000 00100000</li>
<li><code>Integer.numberOfLeadingZeros(n)</code>的最小值是：00000000 00000000 00000000 00000000</li>
</ul>
<p>因此<code>resizeStampd</code>的返回值也就介于<code>00000000 00000000 10000000 00000000</code>到<code>00000000 00000000 10000000 00100000</code>之间，从这个返回值的范围可以看出来<code>resizeStamp</code>的返回值高16位全都是0，是不包含任何信息的。因此在<code>ConcurrrentHashMap</code>中，会把<code>resizeStamp</code>的返回值左移16位拼到<code>sizeCtl</code>中，这就是为什么<code>sizeCtl</code>的高16位包含整个<code>Map</code>大小的原理。有了这个分析，这段代码中比较长的<code>if</code>判断也就能看懂了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">    sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0)</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</code>保证所有线程要基于同一个旧的桶数组扩容</li>
<li><code>transferIndex &lt;= 0</code>已经有线程完成扩容任务了</li>
</ul>
<p>至于<code>sc == rs + 1 || sc == rs + MAX_RESIZERS</code>这两个判断条件如果是细心的同学一定会觉得难以理解，这个地方确实是JDK的一个<code>BUG</code>，这个<code>BUG</code>已经在<code>JDK 12</code>中修复，详细情况可以参考一下Oracle的官网：<a target="_blank" rel="noopener" href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427%EF%BC%8C%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E5%BA%94%E8%AF%A5%E5%86%99%E6%88%90%E8%BF%99%E6%A0%B7%EF%BC%9A%60sc">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427，这两个判断条件应该写成这样：`sc</a> == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1 || sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS<code>,因为直接比较</code>rs<code>和</code>sc`是没有意义的，必须要有移位操作。它表达的含义是</p>
<ul>
<li><code>sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1</code>当前扩容的线程数为0，即已经扩容完成了，就不需要再新增线程扩容</li>
<li><code>sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS</code>参与扩容的线程数已经到了最大，就不需要再新增线程扩容</li>
</ul>
<p>真正扩容的逻辑在<code>transfer</code>方法中，我们后面会详细看，不过有个小细节可以提前注意，如果<code>nextTable</code>已经初始化了，<code>transfer</code>会返回<code>nextTable</code>的的引用，后续可以直接操作新的桶数组。</p>
<h3 id="插入新值"><a href="#插入新值" class="headerlink" title="插入新值"></a>插入新值</h3><p>如果桶数组已经初始化好了，该扩容的也扩容了，并且根据哈希定位到的桶中已经有元素了，那流程就跟普通的<code>HashMap</code>一样了，唯一一点不同的就是，这时候要给当前的桶加锁，且看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; spread(key.hashCode());</span><br><span class="line">    int binCount &#x3D; 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)&#x2F;&#x2F; 折叠</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 折叠&#125;</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)&#x2F;&#x2F; 折叠</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal &#x3D; null;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                &#x2F;&#x2F; 要注意这里这个不起眼的判断条件</span><br><span class="line">                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                    if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; fh&gt;&#x3D;0的节点是链表，否则是树节点或者ForwardingNode</span><br><span class="line">                        binCount &#x3D; 1;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                    (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal &#x3D; e.val; &#x2F;&#x2F; 如果链表中有值了，直接更新</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val &#x3D; value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                &#x2F;&#x2F; 如果流程走到这里，则说明链表中还没值，直接连接到链表尾部</span><br><span class="line">                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 红黑树的操作先略过</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; put成功，map的元素个数+1</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中要特备注意一个不起眼的判断条件（上下文在源码上已经标注出来了）：<code>tabAt(tab, i) == f</code>，这个判断的目的是为了处理调用<code>put</code>方法的线程和扩容线程的竞争。因为<code>synchronized</code>是阻塞锁，如果调用<code>put</code>方法的线程恰好和扩容线程同时操作同一个桶，且调用<code>put</code>方法的线程竞争锁失败，等到该线程重新获取到锁的时候，当前桶中的元素就会变成一个<code>ForwardingNode</code>，那就会出现<code>tabAt(tab, i) != f</code>的情况。</p>
<h2 id="多线程动态扩容"><a href="#多线程动态扩容" class="headerlink" title="多线程动态扩容"></a>多线程动态扩容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n &#x3D; tab.length, stride;</span><br><span class="line">    if ((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride &#x3D; MIN_TRANSFER_STRIDE; &#x2F;&#x2F; subdivide range</span><br><span class="line">    if (nextTab &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F; 初始化新的桶数组</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab &#x3D; nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      &#x2F;&#x2F; try to cope with OOME</span><br><span class="line">            sizeCtl &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable &#x3D; nextTab;</span><br><span class="line">        transferIndex &#x3D; n;</span><br><span class="line">    &#125;</span><br><span class="line">    int nextn &#x3D; nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd &#x3D; new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    boolean advance &#x3D; true;</span><br><span class="line">    boolean finishing &#x3D; false; &#x2F;&#x2F; to ensure sweep before committing nextTab</span><br><span class="line">    for (int i &#x3D; 0, bound &#x3D; 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;&#x3D; bound || finishing)</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line">            else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;</span><br><span class="line">                i &#x3D; -1;</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                        (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                        nextBound &#x3D; (nextIndex &gt; stride ?</span><br><span class="line">                                    nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound &#x3D; nextBound;</span><br><span class="line">                i &#x3D; nextIndex - 1;</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable &#x3D; null;</span><br><span class="line">                table &#x3D; nextTab;</span><br><span class="line">                sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断是会否是最后一个扩容线程</span><br><span class="line">                if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                finishing &#x3D; advance &#x3D; true;</span><br><span class="line">                i &#x3D; n; &#x2F;&#x2F; recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i)) &#x3D;&#x3D; null)</span><br><span class="line">            advance &#x3D; casTabAt(tab, i, null, fwd);</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 只有最后一个扩容线程才有机会执行这个分支</span><br><span class="line">            advance &#x3D; true; &#x2F;&#x2F; already processed</span><br><span class="line">        else &#123; &#x2F;&#x2F; 复制过程与HashMap类似，这里不再赘述</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">               &#x2F;&#x2F; 折叠</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在深入到源码细节之前我们先根据下图看一下在<code>Java 8</code>中<code>ConcurrentHashMap</code>扩容的几个特点：</p>
<ul>
<li>新的桶数组<code>nextTable</code>是原先桶数组长度的2倍，这与之前<code>HashMap</code>一致</li>
<li>参与扩容的线程也是分段将<code>table</code>中的元素复制到新的桶数组<code>nextTable</code>中</li>
<li>桶一个桶数组中的元素在新的桶数组中均匀的分布在两个桶中，桶下标相差n(旧的桶数组的长度)，这一点依然与<code>HashMap</code>保持一致</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">image-20210424202636495</p>
<h3 id="各个线程之间如何通力协作"><a href="#各个线程之间如何通力协作" class="headerlink" title="各个线程之间如何通力协作"></a>各个线程之间如何通力协作</h3><p>先看一个关键的变量<code>transferIndex</code>，这是一个被<code>volatile</code>修饰的变量，这一点可以保证所有线程读到的一定是最新的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile int transferIndex;</span><br></pre></td></tr></table></figure>

<p>这个值会被第一个参与扩容的线程初始化，因为只有第一个参与扩容的线程才满足条件<code>nextTab == null</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (nextTab &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F; initiating</span><br><span class="line">    try &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">        nextTab &#x3D; nt;</span><br><span class="line">    &#125; catch (Throwable ex) &#123;      &#x2F;&#x2F; try to cope with OOME</span><br><span class="line">        sizeCtl &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    nextTable &#x3D; nextTab;</span><br><span class="line">    transferIndex &#x3D; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在了解了<code>transferIndex</code>属性的基础上，上面的这个循环就好理解了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">while (advance) &#123;</span><br><span class="line">    int nextIndex, nextBound;</span><br><span class="line">      &#x2F;&#x2F; 当bound &lt;&#x3D; i &lt;&#x3D; transferIndex的时候i自减跳出这个循环继续干活</span><br><span class="line">    if (--i &gt;&#x3D; bound || finishing)</span><br><span class="line">        advance &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 扩容的所有任务已经被认领完毕，本线程结束干活</span><br><span class="line">    else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;</span><br><span class="line">        i &#x3D; -1;</span><br><span class="line">        advance &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 否则认领新的一段复制任务，并通过&#96;CAS&#96;更新transferIndex的值</span><br><span class="line">    else if (U.compareAndSwapInt</span><br><span class="line">                (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                nextBound &#x3D; (nextIndex &gt; stride ?</span><br><span class="line">                            nextIndex - stride : 0))) &#123;</span><br><span class="line">        bound &#x3D; nextBound;</span><br><span class="line">        i &#x3D; nextIndex - 1;</span><br><span class="line">        advance &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>transferIndex</code>就像是一个游标，每个线程认领一段复制任务的时候都会通过CAS将其更新为<code>transferIndex - stride</code>， <code>CAS</code>可以保证<code>transferIndex</code>可以按照<code>stride</code>这个步长降到0。</p>
<h3 id="最后一个扩容线程需要二次确认？"><a href="#最后一个扩容线程需要二次确认？" class="headerlink" title="最后一个扩容线程需要二次确认？"></a>最后一个扩容线程需要二次确认？</h3><p>对于每一个扩容线程，<code>for</code>循环的变量<code>i</code>代表要复制的桶的在桶数组中的下标，这个值的上限和下限通过游标<code>transferIndex</code>和步长<code>stride</code>计算得来，当<code>i</code>减小为负数，则说明当前扩容线程完成了扩容任务，这时候流程会走到这个分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; i &gt;&#x3D; n || i + n &gt;&#x3D; nextn现在看来取不到</span><br><span class="line">if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;</span><br><span class="line">    int sc;</span><br><span class="line">    if (finishing) &#123; &#x2F;&#x2F; 【A】完成整个扩容过程</span><br><span class="line">        nextTable &#x3D; null;</span><br><span class="line">        table &#x3D; nextTab;</span><br><span class="line">        sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 【B】判断是否是最后一个扩容线程，如果是，则需要重新扫描一遍桶数组，做二次确认</span><br><span class="line">    if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;</span><br><span class="line">        &#x2F;&#x2F; (sc - 2) &#x3D;&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT 说明是最后一个扩容线程</span><br><span class="line">        if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F; 重新扫描一遍桶数组，做二次确认</span><br><span class="line">        finishing &#x3D; advance &#x3D; true;</span><br><span class="line">        i &#x3D; n; &#x2F;&#x2F; recheck before commit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为变量<code>finishing</code>被初始化为<code>false</code>，所以当线程第一次进入这个<code>if</code>分支的话，会先执行注释为【B】的这个分支，同时因为<code>sizeCtl</code>的低16位被初始化为参与扩容的线程数加一，因此，当条件<code>(sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT</code>满足时，就能证明当前线程就是最后一个扩容线程了，这这时候将<code>i</code>置为<code>n</code>重新扫描一遍桶数组，并且将<code>finishing</code>置为<code>true</code>保证当桶数组被扫描结束后能够进入注释为【A】的分支结束扩容。</p>
<p>这里就有一个问题，按照我们前面的分析，扩容线程能够通力协作，保证各自负责的桶数组的分段不重不漏，这里为什么还需要做二次确认么？有一个开发者在<code>concurrency-interest</code>这个邮件列表中也关于这件事咨询了<code>Doug Lea</code>(地址：<a target="_blank" rel="noopener" href="http://cs.oswego.edu/pipermail/concurrency-interest/2020-July/017171.html)%EF%BC%8C%E4%BB%96%E7%BB%99%E5%87%BA%E7%9A%84%E5%9B%9E%E5%A4%8D%E6%98%AF%EF%BC%9A">http://cs.oswego.edu/pipermail/concurrency-interest/2020-July/017171.html)，他给出的回复是：</a></p>
<blockquote>
<p>Yes, this is a valid point; thanks. The post-scan was needed in a previous version, and could be removed. It does not trigger often enough to matter though, so is for now another minor tweak that might be included next time CHM is updated.</p>
</blockquote>
<p>虽然<code>Doug</code>在邮件中的措辞用了could be, not often enough等，但也确认了最后一个扩容线程的二次检查是没有必要的。具体的复制过程与<code>HashMap</code>类似，感兴趣的读者可以翻一下<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzk0NjExMjU3Mg==&mid=2247484593&idx=1&sn=1329f371cc600813034535411c3a987f&chksm=c30a55e2f47ddcf47a6fc2fbd67be93ec4a87dd00dccbd60d9b602f591f9218cb526ac739a16&scene=21#wechat_redirect">高端的面试从来不会在HashMap的红黑树上纠缠太多</a>这篇文章。</p>
<h2 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a><code>size()</code>方法</h2><h3 id="addCount-方法"><a href="#addCount-方法" class="headerlink" title="addCount()方法"></a><code>addCount()方法</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 记录map元素总数的成员变量</span><br><span class="line">private transient volatile long baseCount;</span><br></pre></td></tr></table></figure>

<p>在<code>put</code>方法的最后，有一个<code>addCount</code>方法，因为<code>putVal</code>执行到此处说明已经成功新增了一个元素，所以<code>addCount</code>方法的作用就是维护当前<code>ConcurrentHashMap</code>的元素总数，在<code>ConcurrentHashMap</code>中有一个变量<code>baseCount</code>用来记录<code>map</code>中元素的个数，如下图所示，如果同一时刻有n个线程通过CAS同时操作<code>baseCount</code>变量，有且仅有一个线程会成功，其他线程都会陷入无休止的自旋当中，那一定会带来性能瓶颈。</p>
<p>为了避免大量线程都在自旋等待写入<code>baseCount</code>，<code>ConcurrentHashMap</code>引入了一个辅助队列，如下图所示，现在操作<code>baseCount</code>的线程可以分散到这个辅助队列中去了，调用<code>size()</code>的时候只需要将<code>baseCount</code>和辅助队列中的数值相加即可，这样就实现了调用<code>size()</code>无需加锁。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">image-20210420222306734</p>
<p>辅助队列是一个类型为<code>CounterCell</code>的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended static final class CounterCell &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">    CounterCell(long x) &#123; value &#x3D; x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以简单理解为只是包装了一个<code>long</code>型的变量<code>value</code>，还需要解决一个问题是，对于某个具体的线程它是如何知道操作辅助队列中的哪个值呢？答案是下面的这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int getProbe() &#123;</span><br><span class="line">    return UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProbe</code>方法会返回当前线程的一个唯一身份码，这个值是不会变的，因此可以将<code>getProbe</code>的返回值与辅助队列的长度作求余运算得到具体的下标，它的返回值可能是0，如果返回0则需要调用<code>ThreadLocalRandom.localInit()</code>初始化。<code>addCount</code>方法中有两个细节需要注意</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">    CounterCell[] as; long b, s;</span><br><span class="line">    &#x2F;&#x2F; 注意这里的判断条件，是有技巧的</span><br><span class="line">    if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">        !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123;</span><br><span class="line">        CounterCell a; long v; int m;</span><br><span class="line">        boolean uncontended &#x3D; true;</span><br><span class="line">        if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">            (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">            &#x2F;&#x2F; 变量uncontended记录着这个CAS操作是否成功</span><br><span class="line">            !(uncontended &#x3D;</span><br><span class="line">                U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &lt;&#x3D; 1)</span><br><span class="line">            return;</span><br><span class="line">        s &#x3D; sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    if (check &gt;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 检查是否需要扩容，后面再详细看</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节一：</p>
<p>首先我们要注意方法中刚进来的<code>if</code>判断条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">    !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者在这里巧妙的运用了逻辑短路，如果<code>(as = counterCells) != null</code>则后面的<code>CAS</code>是不会执行的，为什么要这么设置呢？作者有两点考虑：</p>
<ol>
<li>原因在于如果<code>(as = counterCells) != null</code>，则说明辅助队列已经初始化好了，相比于所有的线程都自旋等待<code>baseCount</code>这一个变量，让线程通过<code>CAS</code>去操作队列中的值有更大的可能性成功，因为辅助队列的最大长度为大于当前处理器个数的2的正整数幂，可以支持更大的并发</li>
<li>如果辅助队列还没有初始化好，直到有必要的时候再去创建队列，如何判断“必要性”呢？就看对<code>baseCount</code>的<code>CAS</code>操作能否成功，如果失败，就说明当前系统的并发已经比较高了，需要队列的辅助，否则直接操作<code>baseCount</code></li>
</ol>
<p>细节二：</p>
<p>只有当辅助队列已存在，且由<code>ThreadLocalRandom.getProbe()</code>在辅助队列中确定的位置不为<code>null</code>时，才对其做<code>CAS</code>操作，这本来是一个正常的防御性判断，但是<code>uncontended</code>记录了<code>CAS</code>是否成功，如果失败，则会在<code>fullAddCount</code>中调用<code>ThreadLocalRandom.advanceProbe</code>换一个身份码调整下当前线程在辅助队列的位置，避免所有线程都在辅助队列的同一个坑位自旋等待。</p>
<h3 id="fullAddCount-方法"><a href="#fullAddCount-方法" class="headerlink" title="fullAddCount()方法"></a><code>fullAddCount()</code>方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; See LongAdder version for explanation</span><br><span class="line">&#x2F;&#x2F; wasUncontended 记录着调用方CAS是否成功，如果失败则换一个辅助队列的元素继续CAS</span><br><span class="line">private final void fullAddCount(long x, boolean wasUncontended) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    if ((h &#x3D; ThreadLocalRandom.getProbe()) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      &#x2F;&#x2F; force initialization</span><br><span class="line">        h &#x3D; ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean collide &#x3D; false;                &#x2F;&#x2F; True if last slot nonempty</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; int n; long v;</span><br><span class="line">        &#x2F;&#x2F; 【A】如果辅助队列已经创建，则直接操作辅助队列</span><br><span class="line">        if ((as &#x3D; counterCells) !&#x3D; null &amp;&amp; (n &#x3D; as.length) &gt; 0) &#123;</span><br><span class="line">            if ((a &#x3D; as[(n - 1) &amp; h]) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (cellsBusy &#x3D;&#x3D; 0) &#123;            &#x2F;&#x2F; Try to attach new Cell</span><br><span class="line">                    CounterCell r &#x3D; new CounterCell(x); &#x2F;&#x2F; Optimistic create</span><br><span class="line">                    if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">                        boolean created &#x3D; false;</span><br><span class="line">                        try &#123;               &#x2F;&#x2F; Recheck under lock</span><br><span class="line">                            CounterCell[] rs; int m, j;</span><br><span class="line">                            if ((rs &#x3D; counterCells) !&#x3D; null &amp;&amp;</span><br><span class="line">                                (m &#x3D; rs.length) &gt; 0 &amp;&amp;</span><br><span class="line">                                rs[j &#x3D; (m - 1) &amp; h] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                rs[j] &#x3D; r;</span><br><span class="line">                                created &#x3D; true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            cellsBusy &#x3D; 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (created)</span><br><span class="line">                            break;</span><br><span class="line">                        continue;           &#x2F;&#x2F; Slot is now non-empty</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (!wasUncontended)       &#x2F;&#x2F; 如果调用方CAS失败了，本轮空跑，下一个循环换下标继续操作</span><br><span class="line">                wasUncontended &#x3D; true;      &#x2F;&#x2F; Continue after rehash</span><br><span class="line">            else if (U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))</span><br><span class="line">                break;</span><br><span class="line">            else if (counterCells !&#x3D; as || n &gt;&#x3D; NCPU) </span><br><span class="line">                &#x2F;&#x2F; 如果辅助队列长度已经超过了CPU个数，本轮空跑，下一个循环换下标继续操作</span><br><span class="line">                collide &#x3D; false;            &#x2F;&#x2F; At max size or stale</span><br><span class="line">            else if (!collide) &#x2F;&#x2F; 如果上一次操作失败了(CAS失败或者新建CounterCell失败)，本轮空跑，下一个循环换下标继续操作</span><br><span class="line">                collide &#x3D; true;</span><br><span class="line">            else if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; &#x2F;&#x2F; 如果连续两次操作辅助队列失败，则考虑扩容</span><br><span class="line">                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (counterCells &#x3D;&#x3D; as) &#123;&#x2F;&#x2F; Expand table unless stale</span><br><span class="line">                        CounterCell[] rs &#x3D; new CounterCell[n &lt;&lt; 1];</span><br><span class="line">                        for (int i &#x3D; 0; i &lt; n; ++i)</span><br><span class="line">                            rs[i] &#x3D; as[i];</span><br><span class="line">                        counterCells &#x3D; rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    cellsBusy &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                collide &#x3D; false;</span><br><span class="line">                continue;                   &#x2F;&#x2F; Retry with expanded table</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果上一次操作失败或者调用方CAS失败，都会走到这里，变换要操作的辅助队列下标</span><br><span class="line">            h &#x3D; ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 【B】如果辅助队列还未创建，则加锁创建</span><br><span class="line">        else if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; counterCells &#x3D;&#x3D; as &amp;&amp;</span><br><span class="line">                    U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">            boolean init &#x3D; false;</span><br><span class="line">            try &#123;                           &#x2F;&#x2F; Initialize table</span><br><span class="line">                if (counterCells &#x3D;&#x3D; as) &#123;</span><br><span class="line">                    CounterCell[] rs &#x3D; new CounterCell[2];</span><br><span class="line">                    rs[h &amp; 1] &#x3D; new CounterCell(x);</span><br><span class="line">                    counterCells &#x3D; rs;</span><br><span class="line">                    init &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                cellsBusy &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (init)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 【C】如果辅助队列创建失败(拿锁失败)，则尝试直接操作&#96;baseCount&#96;</span><br><span class="line">        else if (U.compareAndSwapLong(this, BASECOUNT, v &#x3D; baseCount, v + x))</span><br><span class="line">            break;                          &#x2F;&#x2F; Fall back on using base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>counterCells</code>是一个普通的数组，因此对其的写操作，包括初始化，扩容以及元素的写都需要加锁，加锁的方式是对全局变量<code>cellsBusy</code>的自旋锁。先看最外层的三个分支：</p>
<ul>
<li>【B】如果辅助队列还没有创建，则加锁创建</li>
<li>【C】如果因为拿锁失败导致辅助队列创建失败，则尝试自旋写入变量<code>baseCount</code>，万一真的成功了呢</li>
<li>【A】如果辅助队列已经创建了，则直接去操作辅助队列相应的元素</li>
</ul>
<p>注释中标注【A】的这个分支代码较多，其主要思路是如果通过<code>CAS</code>或者加锁操作辅助队列中的某个元素失败，则首先通过调用<code>ThreadLocalRandom.advanceProbe(h)</code>换一个队列中的元素继续操作，这次操作是否成功会记录在临时变量<code>collide</code>中。如果下一次操作还是失败，则说明此时的并发量比较大需要扩容了。如果辅助队列的长度已经超过了<code>CPU</code>的个数，那就不再扩容，继续换一个元素操作，因为同一时间能运行的线程数最大不会超过计算机的<code>CPU</code>个数。</p>
<p>在这个过程中有四个细节仍然需要注意：</p>
<p>细节一：</p>
<p><code>counterCells</code>只是一个普通的数组，因此并不是线程安全的，所以对其写操作需要加锁保证并发安全</p>
<p>细节二：</p>
<p>加锁的时候，作者做了一个<code>double-check</code>的动作，我看有的文章将其解读为“类似于单例模式的<code>double-check</code>”，这个是不对的，作者这样做的原因我们在上一篇文章中有讲过，首先第一个检查<code>cellsBusy == 0</code>是流程往下走的基础，如果<code>cellsBusy == 1</code>则直接拿锁失败退出，调用<code>h = ThreadLocalRandom.advanceProbe(h);</code>更新<code>h</code>后重试，如果<code>cellsBusy == 0</code>校验通过，则调用<code>CounterCell r = new CounterCell(x);</code>初始化一个<code>CounterCell</code>，这样做是为了减少自旋锁的临界区的大小，以此来提升并发性能</p>
<p>细节三：</p>
<p>在加锁的时候先判断下<code>cellsBusy</code>是否为0，如果为1那直接宣告拿锁失败，为什么这么做呢？因为相比于调用<code>UNSAFE</code>的<code>CAS</code>操作，直接读取<code>volatile</code>的消耗更少，如果直接读取<code>cellsBusy</code>已经能判断出拿锁失败，那就没必要再调用耗时更多的<code>CAS</code>了</p>
<p>细节四：</p>
<p>对<code>cellsBusy</code>从0到1的更改调用了<code>CAS</code>但是从1置为0却只用了赋值操作，这是因为<code>CAS</code>可以保证能走到这条语句的只有一个线程，因此可以用赋值操作来更改<code>cellsBusy</code>的值。</p>
<h3 id="sumCount"><a href="#sumCount" class="headerlink" title="sumCount"></a><code>sumCount</code></h3><p>前面两个方法主要是把<code>ConcurrentHashMap</code>中的元素个数分散的记录到<code>baseCount</code>和辅助队列中，调用<code>size()</code>方法的时候只需要把这些值相加即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    long n &#x3D; sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as &#x3D; counterCells; CounterCell a;</span><br><span class="line">    long sum &#x3D; baseCount;</span><br><span class="line">    if (as !&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a &#x3D; as[i]) !&#x3D; null)</span><br><span class="line">                sum +&#x3D; a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter01-%E7%AE%80%E5%8D%95web%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter01-%E7%AE%80%E5%8D%95web%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">chapter01-简单web服务器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-17 22:17:44" itemprop="dateCreated datePublished" datetime="2021-04-17T22:17:44+08:00">2021-04-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-20 18:06:45" itemprop="dateModified" datetime="2021-04-20T18:06:45+08:00">2021-04-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>三部分 + 回车</p>
<ul>
<li>请求方法    统一资源标识符(URI)    协议/版本</li>
<li>请求头</li>
<li>回车/换行: CRLF（carriage returen/LineFeed）</li>
<li>实体</li>
</ul>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>三部分</p>
<ul>
<li>协议    状态码    描述</li>
<li>响应头</li>
<li>响应实体段</li>
</ul>
<h2 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h2><p>套接字是网络连接的端点。套接字使应用程序可以从网络中读取数据，可以向网络中写入数据。<a href="">不同计算机上的两个应用程序可以通过连接发送或接收字节流，以此达到相互通信的目的</a>。为了从一个应用程序向另一个应用程序发送消息，需要知道另一个应用程序中套接字的IP地址和端口号。在Java中，套接字由java.net.Socket表示。<br>要创建一个套接字，可以使用Socket类中众多构造函数中的一个。其中一个构造函数接收两个参数：主机名和端口号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Socket (java.lang.String host, int port)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Socket (&quot;yahoo.com&quot;, 80);</span><br></pre></td></tr></table></figure>

<p>一旦成功地创建了Socket类的实例，就可以使用该实例发送或接收字节流。要发送字节流，需要调用Socket类的getOutputStream()方法获取一个java.io.OutputStream对象。要发送文本到远程应用程序，通常需要使用返回的OutputStream对象创建一个java.io.PrintWriter对象。若想要从连接的另一端接收字节流，需要调用Socket类的getInputStream()方法，该法会返回一个java.io.InputStream对象。</p>
<p><img src="https://yqfile.alicdn.com/642c4a62ac7a1790bca190ed30d4ab8006d1fbb6.png" alt="image"></p>
<p><img src="https://yqfile.alicdn.com/9303042d37ef3886d4aa73ce2a798cb7bae62eda.png" alt="image"></p>
<h2 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a><strong>ServerSocket类</strong></h2><p>Socket类表示一个客户端套接字。正因如此，需要使用java.net.ServerSocket类，这是服务器套接字的实现。<br>ServerSocket类与Socket类并不相同。服务器套接字要等待来自客户端的连接请求。当服务器套接字收到了连接请求后，它会创建一个Socket实例来处理与客户端的通信。<br>要创建一个服务器套接字，可以使用ServerSocket类提供的4个构造函数中的任意一个。需要指明IP地址和服务器套接字侦听的端口号。典型情况下，IP地址可以是127.0.0.1，即服务器套接字会侦听本地机器接收到的连接请求。服务器套接字侦听的IP地址称为绑定地址。服务器套接字的另一个重要属性是backlog，后者表示在服务器拒绝接收传入的请求之前，传入的连接请求的最大队列长度。<br>ServerSocket类的其中一个构造函数的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ServerSocket(int port, int backLog, InetAddress bindingAddress);</span><br></pre></td></tr></table></figure>

<p>ServerSocket对象侦听本地主机的8080端口，其backlog值为1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ServerSocket(8080, 1, InetAddress.getByName(&quot;127.0.0.1&quot;));</span><br></pre></td></tr></table></figure>

<p>在应用程序的入口点，也就是静态main函数中，创建一个HttpServer实例，然后调用其await()方法。顾名思义，await方法会在制定的端口上等待http请求，并对其进行处理，然后发送相应的消息回客户端。在接收到命令之前，它会一直保持等待的状态。</p>
<h2 id="HttpServer类"><a href="#HttpServer类" class="headerlink" title="HttpServer类"></a>HttpServer类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package simpleHttpServer;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class HttpServer &#123;</span><br><span class="line">    </span><br><span class="line">    public static final String WEB_ROOT &#x3D; System.getProperty(&quot;user.dir&quot;) + File.separator</span><br><span class="line">            + &quot;webroot&quot;;</span><br><span class="line">    </span><br><span class="line">    private static final String SHUTDOWN_COMMAND &#x3D; &quot;&#x2F;SHUTDOWN&quot;;</span><br><span class="line">    </span><br><span class="line">    private boolean shudown &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        HttpServer server &#x3D; new HttpServer();</span><br><span class="line">        server.await();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void await()&#123;</span><br><span class="line">        ServerSocket serverSocket &#x3D; null;</span><br><span class="line">        int port &#x3D; 8080;</span><br><span class="line">        </span><br><span class="line">        try&#123;</span><br><span class="line">            serverSocket &#x3D; new ServerSocket(port,1,InetAddress.getByName(&quot;127.0.0.1&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!this.shudown)&#123;</span><br><span class="line">            Socket socket &#x3D; null;</span><br><span class="line">            InputStream input &#x3D; null;</span><br><span class="line">            OutputStream output &#x3D; null;</span><br><span class="line">            </span><br><span class="line">            try&#123;</span><br><span class="line">                </span><br><span class="line">                socket &#x3D; serverSocket.accept();</span><br><span class="line">                input &#x3D; socket.getInputStream();</span><br><span class="line">                output &#x3D; socket.getOutputStream();</span><br><span class="line">                </span><br><span class="line">                Request request &#x3D; new Request(input);</span><br><span class="line">                request.parse();</span><br><span class="line">                </span><br><span class="line">                Response response &#x3D; new Response(output);</span><br><span class="line">                response.setRequest(request);</span><br><span class="line">                response.sendStaticResource();</span><br><span class="line">                </span><br><span class="line">                socket.close();</span><br><span class="line">                </span><br><span class="line">                this.shudown &#x3D; request.getUri().equals(SHUTDOWN_COMMAND);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个简单的web服务器，可以处理指定目录中的静态资源请求；用WEB_ROOT表示制定的目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String WEB_ROOT &#x3D; System.getProperty(&quot;user.dir&quot;) + File.separator + &quot;webroot&quot;;</span><br></pre></td></tr></table></figure>

<p>这里是指当前目录下的webroot文件夹下面的资源。<br>我们通过在游览器中输入这样的内容，进行资源的请求:<br><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/index.html">http://127.0.0.1:8080/index.html</a></p>
<h2 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h2><p>Request类表示一个Http请求，可以传递InputStream对象来创建Request对象，调用InputStream对象的read进行Http请求数据的读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package simpleHttpServer;</span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">public class Request &#123;</span><br><span class="line">    private InputStream input;</span><br><span class="line">    private String uri;</span><br><span class="line">    </span><br><span class="line">    public Request(InputStream input)&#123;</span><br><span class="line">        this.input &#x3D; input;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void parse()&#123;</span><br><span class="line">        StringBuffer request &#x3D; new StringBuffer(2048);</span><br><span class="line">        </span><br><span class="line">        int i;</span><br><span class="line">        byte[] buffer &#x3D; new byte[2048];</span><br><span class="line">        try&#123;</span><br><span class="line">            i &#x3D; input.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            i &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int j&#x3D;0;j&lt;i;j++)&#123;</span><br><span class="line">            request.append((char)buffer[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.print(request.toString());</span><br><span class="line">        this.uri &#x3D; this.parseUri(request.toString());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private String parseUri(String requestString)&#123;</span><br><span class="line">        int index1,index2;</span><br><span class="line">        index1 &#x3D; requestString.indexOf(&#39; &#39;);</span><br><span class="line">        if(index1 !&#x3D; -1)&#123;</span><br><span class="line">            index2 &#x3D; requestString.indexOf(&#39; &#39;, index1 + 1);</span><br><span class="line">            if(index2 &gt; index1)&#123;</span><br><span class="line">                return requestString.substring(index1 + 1,index2 );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getUri()&#123;</span><br><span class="line">        return this.uri;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Request类最重要的两个函数是parse和ParseUri；parse()方法会调用私有方法parseUri来解析HTTP请求的uri，初次之外，并没有做太多的工作。parseuri会将解析的URI存储在变量uri中。</p>
<p>我们以 <a target="_blank" rel="noopener" href="http://127.0.0.1:8080/index.html">http://127.0.0.1:8080/index.html</a> 请求为例，HTTP请求的请求行为<br>GET /index.html HTTP/1.1<br>parse()方法从传入的Request对象的InputStream对象中读取整个字节流，并且将字节数组存入缓冲区。然后用缓存区的数组初始化StringBuffer对象request。 这样再解析StringBuffer就可以解析到Uri。</p>
<h2 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h2><p>Response类表示Http相应。其定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package simpleHttpServer;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line"></span><br><span class="line">public class Response &#123;</span><br><span class="line">    </span><br><span class="line">    private static final int BUFFER_SIZE &#x3D; 1024;</span><br><span class="line">    private Request request;</span><br><span class="line">    private OutputStream output;</span><br><span class="line">    </span><br><span class="line">    public Response(OutputStream output)&#123;</span><br><span class="line">        this.output &#x3D; output;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setRequest(Request request)&#123;</span><br><span class="line">        this.request &#x3D; request;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void sendStaticResource()throws IOException&#123;</span><br><span class="line">        </span><br><span class="line">        byte[] bytes &#x3D; new byte[BUFFER_SIZE];</span><br><span class="line">        FileInputStream fis &#x3D; null;</span><br><span class="line">        </span><br><span class="line">        try&#123;</span><br><span class="line">            </span><br><span class="line">            File file &#x3D; new File(HttpServer.WEB_ROOT,request.getUri());</span><br><span class="line">            if(file.exists())&#123;</span><br><span class="line">                fis &#x3D; new FileInputStream(file);</span><br><span class="line">                int ch &#x3D; fis.read(bytes, 0, BUFFER_SIZE);</span><br><span class="line">                while(ch !&#x3D; -1)&#123;</span><br><span class="line">                    output.write(bytes, 0, ch);</span><br><span class="line">                    ch &#x3D; fis.read(bytes, 0, BUFFER_SIZE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                String errorMessage &#x3D; &quot;HTTP&#x2F;1.1 404 File Not Found\r\n&quot; + </span><br><span class="line">                            &quot;Content-Type: text&#x2F;html\r\n&quot; +</span><br><span class="line">                            &quot;Content-Length:23\r\n&quot; +</span><br><span class="line">                            &quot;\r\n&quot; + </span><br><span class="line">                            &quot;&lt;h1&gt;File Not Found&lt;&#x2F;h1&gt;&quot;;</span><br><span class="line">                output.write(errorMessage.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally&#123;</span><br><span class="line">            if(fis !&#x3D; null)&#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用OutputStream和Request来初始化Reponse，Response比较简单，得到Request的Uri，然后读取对应的file，如果file存在，则将file中的数据读取到缓存中，并且发送给游览器；如果file不存在，那么就发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;HTTP&#x2F;1.1 404 File Not Found\r\n&quot; + </span><br><span class="line">                            &quot;Content-Type: text&#x2F;html\r\n&quot; +</span><br><span class="line">                            &quot;Content-Length:23\r\n&quot; +</span><br><span class="line">                            &quot;\r\n&quot; + </span><br><span class="line">                            &quot;&lt;h1&gt;File Not Found&lt;&#x2F;h1&gt;&quot;;</span><br></pre></td></tr></table></figure>



<p>错误信息给游览器。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter02-%E7%AE%80%E5%8D%95servlet%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter02-%E7%AE%80%E5%8D%95servlet%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">chapter02-简单的Servlet容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-17 22:17:44" itemprop="dateCreated datePublished" datetime="2021-04-17T22:17:44+08:00">2021-04-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:33:18" itemprop="dateModified" datetime="2021-11-07T13:33:18+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!--servlet是什么？提供了什么功能？在整个web框架中处于什么位置？-->

<h2 id="javax-servlet-Servlet接口"><a href="#javax-servlet-Servlet接口" class="headerlink" title="javax.servlet.Servlet接口"></a><a target="_blank" rel="noopener" href="http://sishuok.com/forum/blogPost/list/4067.html;jsessionid=F387500832428F51B04251FC9481DB31">javax.servlet.Servlet接口</a></h2><p>Servlet接口需要实现下面的5个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Servlet 5个方法里，其中init()、service()、destroy()3个方法是servlet的生命周期方法。当servlet类被装载初始化后，servlet容器调用init()方法。servlet 容器只调用一次，以此表明servlet 已经被加载进服务中（The servlet container calls this method exactly once to indicate to the servlet that the servlet is being placed into service）。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在servlet收到任何请求之前，init()必须成功执行完。一个servlet程序可以重写此方法——添加那些紧需要执行一次的初始化代码，比如：加载数据库驱动、初始值等等。另一种情况，通常此方法都空着，不写任何代码。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//每当对此servlet发起请求时，Servlet容器都会调用其service()方法。Servlet容器传递javax.servlet.ServletRequest和javax.servlet.ServletResponse二个对象。ServletRequest对象包含客户端HTTP请求信息，ServletResponse对象封装servlet应答信息。在Servlet生命周期中，service()方法会被多次调用。&lt;!--这个客户请求就是为了请求这个servlet资源--&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, java.io.IOException </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">//当从服务中移除该servlet实例之前，Servlet容器会调用其destroy()方法。这通常发生在当Servlet容器关闭或Servlet容器需要更多空闲内存时。仅仅在所有 servlet 线程的 service() 方法已经退出或者超时淘汰时，destroy()方法才被调用（This method is called only after all threads within the servlet’s service() method have exited or after a timeout period has passed）。当Servlet容器调用了destroy()后，在同一个servlet中不可再调用service()方法。destroy()方法给servlet提供了释放它当初占用资源的机会，比如：内存、文件句柄、线程，并且确保任何持久化数据状态和servlet当前内存中状态同步一致。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> java.lang.String <span class="title">getServletInfo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>







<h2 id="Application-1"><a href="#Application-1" class="headerlink" title="Application 1"></a>Application 1</h2><p>下面从servlet容器的角度观察servlet的开发。在一个全功能servlet容器中，对servlet的每个HTTP请求来说，容器要做下面几件事：</p>
<ul>
<li>当第一次调用servlet时，要载入servlet类，调用init方法（仅此一次）；</li>
<li>针对每个request请求，创建一个Request对象和一个Resposne对象；</li>
<li>调用相应的servlet的service方法，将Request对象和Response对象作为参数传入；</li>
<li>当关闭servlet时，调用destroy方法，并卸载该servlet类。</li>
</ul>
<p>这里建立的servlet容器是一个很小的容器，没有实现所有的功能。因此，它仅能运行非常简单的servlet类，无法调用servlet的init和destroy方法。它能执行功能如下所示：</p>
<ul>
<li>等待HTTP请求；</li>
<li>创建Request和Response对象；</li>
<li><a href="">若请求的是一个静态资源，则调用StaticResourceProcessor对象的process方法，传入request和response对象;</a> </li>
<li><a href="">若请求的是servlet，则载入相应的servlet类，调用service方法，传入request对象和response对象。</a><!--其实servlet就是用户请求的一种资源--></li>
</ul>
<p><font color="red">注意: 在这个servlet中，每次请求servlet都会使用Class Loader载入servlet类。</font></p>
<p>该程序包括6个类：HttpServer1、Request、Response、StaticResourceProcessor、ServletProcessor1、Constants。</p>
<p><img src="https://yqfile.alicdn.com/2d4ea4f13960600f97c3391b641a0afa78a01d15.png" alt="image"></p>
<p>此应用Demo的入口(静态main()方法)在HttpServer1中。此main()方法创建了HttpServer1一个实例，并调用其await()方法。await()等待HTTP请求，为每次请求创建Request和Response对象，并且分发给StaticResourceProcessor实例或ServletProcessor实例——取决于请求的是静态资源还是servlet。</p>
<p>其中Constants类定义了其他类引用了的常量WEB_ROOT。WEB_ROOT标明了可被此Servlet容器使用的PrimitiveServlet和静态资源的位置地址。</p>
<p>HttpServer1实例保持等待接收HTTP请求直到接收到shutdown命令。发起shutdow命令和你第一章中操作一样。</p>
<h3 id="HttpServer1类"><a href="#HttpServer1类" class="headerlink" title="HttpServer1类"></a>HttpServer1类</h3><p>本应用Demo中的HttpServer1类似于第一章中的HttpServer类。然而，本HttpServer1可以服务于静态资源和servlet。当请求静态资源时，可在你的浏览器上输入如下类似URL：</p>
<p><a href="http://machinename:port/staticResource">http://machineName:port/staticResource</a></p>
<p>就像是在第 1 章提到的，你可以请求一个静态资源。</p>
<p>请求一个servlet时，使用如下类似URL：</p>
<p><a href="http://machinename:port/servlet/servletClass">http://machineName:port/servlet/servletClass</a></p>
<p>因此，假如你在本地请求一个名为 PrimitiveServlet 的 servlet，你在浏览器的地址栏或<br>者网址框中敲入：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/servlet/PrimitiveServlet">http://localhost:8080/servlet/PrimitiveServlet</a></p>
<p>本Servlet容器可以服务于PrimitiveServlet。如果你调用其他的servlet，如ModernServlet，那么此Servlet容器将会抛出异常。在后面的章节中，我们将会改造此应用，使其服务于更多的servlet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * WEB_ROOT is the directory where our HTML and other files reside.</span></span><br><span class="line"><span class="comment">     * For this package, WEB_ROOT is the &quot;webroot&quot; directory under the working</span></span><br><span class="line"><span class="comment">     * directory.</span></span><br><span class="line"><span class="comment">     * The working directory is the location in the file system</span></span><br><span class="line"><span class="comment">     * from where the java command was invoked.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// shutdown command</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SHUTDOWN_COMMAND = <span class="string">&quot;/SHUTDOWN&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the shutdown command received</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> shutdown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HttpServer1 server = <span class="keyword">new</span> HttpServer1();</span><br><span class="line">        server.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port, <span class="number">1</span>, InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop waiting for a request</span></span><br><span class="line">        <span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            InputStream input = <span class="keyword">null</span>;</span><br><span class="line">            OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                input = socket.getInputStream();</span><br><span class="line">                output = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// create Request object and parse</span></span><br><span class="line">                Request request = <span class="keyword">new</span> Request(input);</span><br><span class="line">                request.parse();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// create Response object</span></span><br><span class="line">                Response response = <span class="keyword">new</span> Response(output);</span><br><span class="line">                response.setRequest(request);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// check if this is a request for a servlet or a static resource              </span></span><br><span class="line">                <span class="keyword">if</span> (request.getUri().startsWith(<span class="string">&quot;/servlet/&quot;</span>)) &#123; <span class="comment">// a request for a servlet begins with &quot;/servlet/&quot;</span></span><br><span class="line">                    ServletProcessor1 processor = <span class="keyword">new</span> ServletProcessor1();</span><br><span class="line">                    processor.process(request, response);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    StaticResourceProcessor processor = <span class="keyword">new</span> StaticResourceProcessor();</span><br><span class="line">                    processor.process(request, response);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Close the socket</span></span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="comment">//check if the previous URI is a shutdown command</span></span><br><span class="line">                shutdown = request.getUri().equals(SHUTDOWN_COMMAND);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类的await()方法会一直等待HTTP请求，直到接收到一条关闭命令，这点与第1章中的await()方法类似。区别在于，本章中的await()方法可以将HTTP请求分发给StaticResourceProcessor对象或ServletProcessor对象来处理。<a href="">当URI包含字符串“/servlet/”时，会把请求转发给servletProcessor对象处理</a>。 <!--这就是UML类图中HttpServer持有1个ServletProcessor的原因--> 否则的话，把HTTP请求传递给StaticResourceProcessor对象处理。</p>
<h3 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h3><p>一个servlet的service()方法从servlet容器中接收javax.servlet.ServletRequest和javax.servlet.ServletResponse实例。<a href="">也就是说，对于每一个HTTP请求，servlet容器必须创建ServletRequest和ServletResponse对象，并且把它们传递给servlet的service()方法。</a></p>
<p>本Request类代表着一个请求对象被传递给servlet的service()方法。照此，它必须实现javax.servlet.ServletRequest 接口。本类实现了接口提供的所有方法。不过，我们想要让它非常简单，所以仅仅提供实现其中一些方法，我们在以下各章中再实现全部的方法。要编译此Request 类，你需要把这些方法的实现留空。查看本Request 类，你将会看到那些需要返回一个对象的方法返回了 null。</p>
<p>Request类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.how.tomcat.works.ex02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.RequestDispatcher;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletInputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> <span class="keyword">implements</span> <span class="title">ServletRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> InputStream input;</span><br><span class="line">  <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(InputStream input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.input = input;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUri</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uri;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">parseUri</span><span class="params">(String requestString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1, index2;</span><br><span class="line">    index1 = requestString.indexOf(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index1 != -<span class="number">1</span>) &#123;</span><br><span class="line">      index2 = requestString.indexOf(<span class="string">&#x27; &#x27;</span>, index1 + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (index2 &gt; index1)</span><br><span class="line">        <span class="keyword">return</span> requestString.substring(index1 + <span class="number">1</span>, index2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Read a set of characters from the socket</span></span><br><span class="line">    StringBuffer request = <span class="keyword">new</span> StringBuffer(<span class="number">2048</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      i = input.read(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      i = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">      request.append((<span class="keyword">char</span>) buffer[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(request.toString());</span><br><span class="line">    uri = parseUri(request.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* implementation of the ServletRequest*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String attribute)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Enumeration <span class="title">getAttributeNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getRealPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestDispatcher <span class="title">getRequestDispatcher</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getCharacterEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getContentLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Locale <span class="title">getLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Enumeration <span class="title">getLocales</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map <span class="title">getParameterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Enumeration <span class="title">getParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getParameterValues(String parameter) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BufferedReader <span class="title">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getRemoteAddr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getRemoteHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getServerName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getServerPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String attribute)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String encoding)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h3><p>本Response类实现了javax.servlet.ServletResponse。同样，此类必须实现接口提供的所有方法。 类似于Request类，我们除了getWriter()方法外留白了其它暂未具体实现的方法。</p>
<p>Response类代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">package org.how.tomcat.works.ex02;</span><br><span class="line"></span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Locale;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.ServletOutputStream;</span><br><span class="line"></span><br><span class="line">public class Response implements ServletResponse &#123;</span><br><span class="line"></span><br><span class="line">  private static final int BUFFER_SIZE &#x3D; 1024;</span><br><span class="line">  Request request;</span><br><span class="line">  OutputStream output;</span><br><span class="line">  PrintWriter writer;</span><br><span class="line"></span><br><span class="line">  public Response(OutputStream output) &#123;</span><br><span class="line">    this.output &#x3D; output;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setRequest(Request request) &#123;</span><br><span class="line">    this.request &#x3D; request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* This method is used to serve a static page *&#x2F;</span><br><span class="line">  public void sendStaticResource() throws IOException &#123;</span><br><span class="line">    byte[] bytes &#x3D; new byte[BUFFER_SIZE];</span><br><span class="line">    FileInputStream fis &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;* request.getUri has been replaced by request.getRequestURI *&#x2F;</span><br><span class="line">      File file &#x3D; new File(Constants.WEB_ROOT, request.getUri());</span><br><span class="line">      fis &#x3D; new FileInputStream(file);</span><br><span class="line">      &#x2F;*</span><br><span class="line">         HTTP Response &#x3D; Status-Line</span><br><span class="line">           *(( general-header | response-header | entity-header ) CRLF)</span><br><span class="line">           CRLF</span><br><span class="line">           [ message-body ]</span><br><span class="line">         Status-Line &#x3D; HTTP-Version SP Status-Code SP Reason-Phrase CRLF</span><br><span class="line">      *&#x2F;</span><br><span class="line">      int ch &#x3D; fis.read(bytes, 0, BUFFER_SIZE);</span><br><span class="line">      while (ch!&#x3D;-1) &#123;</span><br><span class="line">        output.write(bytes, 0, ch);</span><br><span class="line">        ch &#x3D; fis.read(bytes, 0, BUFFER_SIZE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (FileNotFoundException e) &#123;</span><br><span class="line">      String errorMessage &#x3D; &quot;HTTP&#x2F;1.1 404 File Not Found\r\n&quot; +</span><br><span class="line">        &quot;Content-Type: text&#x2F;html\r\n&quot; +</span><br><span class="line">        &quot;Content-Length: 23\r\n&quot; +</span><br><span class="line">        &quot;\r\n&quot; +</span><br><span class="line">        &quot;&lt;h1&gt;File Not Found&lt;&#x2F;h1&gt;&quot;;</span><br><span class="line">      output.write(errorMessage.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">      if (fis!&#x3D;null)</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;** implementation of ServletResponse  *&#x2F;</span><br><span class="line">  public void flushBuffer() throws IOException &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getBufferSize() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getCharacterEncoding() &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Locale getLocale() &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ServletOutputStream getOutputStream() throws IOException &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public PrintWriter getWriter() throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; autoflush is true, println() will flush,</span><br><span class="line">    &#x2F;&#x2F; but print() will not.</span><br><span class="line">    writer &#x3D; new PrintWriter(output, true);</span><br><span class="line">    return writer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean isCommitted() &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void reset() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void resetBuffer() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setBufferSize(int size) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setContentLength(int length) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setContentType(String type) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setLocale(Locale locale) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="StaticResourceProcessor类"><a href="#StaticResourceProcessor类" class="headerlink" title="StaticResourceProcessor类"></a>StaticResourceProcessor类</h3><p>本StaticResourceProcessor类服务于静态资源请求。 它只有一个process()方法。可见process()方法接收二个参数：org.how.tomcat.works.ex02.Request实例和org.how.tomcat.works.ex02.Response实例。此方法只是简单调用Response对象的sendStaticResource()。</p>
<p>StaticResourceProcessor类代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class StaticResourceProcessor &#123;</span><br><span class="line">    public void process(Request request, Response response) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            response.sendStaticResource();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServletProcessor1类"><a href="#ServletProcessor1类" class="headerlink" title="ServletProcessor1类"></a>ServletProcessor1类</h3><p>​     该类用于处理对servlet资源的请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletProcessor1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line">        String uri = request.getUri();</span><br><span class="line">        String servletName = uri.substring(uri.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        URLClassLoader loader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL[] urls = <span class="keyword">new</span> URL[<span class="number">1</span>];</span><br><span class="line">            URLStreamHandler streamHandler = <span class="keyword">null</span>;</span><br><span class="line">            File classPath = <span class="keyword">new</span> File(Constants.WEB_ROOT); <span class="comment">//类加载器需要加载的目标地址</span></span><br><span class="line"></span><br><span class="line">            String repository = (<span class="keyword">new</span> URL(<span class="string">&quot;file&quot;</span>, <span class="keyword">null</span>, classPath.getCanonicalPath() + File.separator)).toString();</span><br><span class="line">            urls[<span class="number">0</span>] = <span class="keyword">new</span> URL(<span class="keyword">null</span>, repository, streamHandler);</span><br><span class="line">            loader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class myClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myClass = loader.loadClass(servletName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            servlet = (Servlet) myClass.newInstance();  <span class="comment">//很有意思，使用的是newInstance()而不是new，因为把类加载与类实例化分开了</span></span><br><span class="line">            servlet.service((ServletRequest) request, (ServletResponse) response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本ServletProcessor1还是相当的简单，它只有process()一个方法。此方法接收2个参数：javax.servlet.ServletRequest实例和javax.servlet.ServletResponse实例。该方法从ServletRequest 中通过调用 getRequestUri 方法获得 URI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String uri &#x3D; request.getUri();1</span><br></pre></td></tr></table></figure>

<p>请记住 URI 是以下形式的：</p>
<p>/servlet/servletName</p>
<p>在此 servletName是servlet类的名字。</p>
<p>要加载 servlet 类，我们需要从 URI 中知道 servlet 的名称。我们可以使用下一行代码来获得 servlet 的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String servletName &#x3D; uri.substring(uri.lastIndexOf(&quot;&#x2F;&quot;) + 1);1</span><br></pre></td></tr></table></figure>

<p>接下去，process()方法加载 servlet。要完成这个，你需要创建一个类加载器并告诉这个类加载器要加载的类的位置。对于这个 servlet 容器，类加载器直接在 Constants.WEB_ROOT 指向的目录里边查找。Constants.WEB_ROOT就是指向工作目录下面的 webroot目录。</p>
<p><em>注意： 类加载器将在第 8 章详细讨论。</em></p>
<p>要加载 servlet，你可以使用 java.net.URLClassLoader 类，它是 java.lang.ClassLoader类的一个直接子类。当你拥有一个 URLClassLoader 实例，你可以使用它的loadClass()方法去加载一个 servlet 类。实例化URLClassLoader是简单的(Instantiating the URLClassLoader class is straightforward)。这个类有三个构造方法，其中最简单的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public URLClassLoader(URL[] urls);1</span><br></pre></td></tr></table></figure>

<p>这里 urls 是一个 java.net.URL 的对象数组，这些对象指向了加载类时候要查找的位置。任何以/结尾的 URL 都假设是一个目录。否则，会假定是一个将被下载并在需要的时候打开的 JAR 文件。</p>
<p>注意：在一个 servlet 容器里边，一个类加载器可以找到 servlet 的地方被称为资源库(repository）。</p>
<p>在我们的应用Demo里边，类加载器必须查找的地方只有一个，如工作目录下面的 webroot目录。因此，我们首先创建一单个 URL 组成的数组。URL 类提供了一系列的构造方法，所以有很多种方式构造一个 URL 对象。对于这个Demo来说，我们使用了和Tomcat 中另一个类的相同的构造方法。这个构造方法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public URL(URL context, java.lang.String spec, URLStreamHandler hander)throws MalformedURLException1</span><br></pre></td></tr></table></figure>

<p>你可以使用这个构造方法，并为第二个参数传递一个值，为第一个和第三个参数都传递null。不过，这里还有另外一个接受三个参数的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public URL(java.lang.String protocol, java.lang.String host,</span><br><span class="line">java.lang.String file) throws MalformedURLException12</span><br></pre></td></tr></table></figure>

<p>因此，假如你使用下面的代码时，编译器将不会知道你指的是哪个构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new URL(null, aString, null);1</span><br></pre></td></tr></table></figure>

<p>你可以通过告诉编译器第三个参数的类型来避开这个问题，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URLStreamHandler streamHandler &#x3D; null;</span><br><span class="line">new URL(null, aString, streamHandler);12</span><br></pre></td></tr></table></figure>

<p>对于第二个参数，你可以使用如下面的代码组成一个包含资源库(servlet 类可以被找到的地方)的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String repository &#x3D; (new URL(&quot;file&quot;, null,</span><br><span class="line">classPath.getCanonicalPath() + File.separator)).toString() ;12</span><br></pre></td></tr></table></figure>

<p>把所有的片段组合在一起，就是process() 方法中用来构造URLClassLoader 实例时的部分代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; create a URLClassLoader</span><br><span class="line">URL[] urls &#x3D; new URL[1];</span><br><span class="line">URLStreamHandler streamHandler &#x3D; null;</span><br><span class="line">File classPath &#x3D; new File(Constants.WEB_ROOT);</span><br><span class="line">String repository &#x3D; (new URL(&quot;file&quot;, null,</span><br><span class="line">classPath.getCanonicalPath() + File.separator)).toString() ;</span><br><span class="line">urls[0] &#x3D; new URL(null, repository, streamHandler);</span><br><span class="line">loader &#x3D; new URLClassLoader(urls);12345678</span><br></pre></td></tr></table></figure>

<p>注意：<br>用来生成资源库的代码是从 org.apache.catalina.startup.ClassLoaderFactory<br>的 createClassLoader()方 法 来 的 ， 而 生 成 URL 的 代 码 是 从<br>org.apache.catalina.loader.StandardClassLoader 的 addRepository()方法来的。不过，在以下各章之前你不必担心这些类。</p>
<p>当有了一个类加载器，你可以使用loadClass()方法加载一个 servlet：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class myClass &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    myClass &#x3D; loader.loadClass(servletName);</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException e) &#123;</span><br><span class="line">    System.out.println(e.toString());</span><br><span class="line">&#125;1234567</span><br></pre></td></tr></table></figure>

<p>然后，process()方法创建一个 servlet 类的实例, 并把它向下转换为javax.servlet.Servlet, 且调用 servlet 的 service() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Servlet servlet &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    servlet &#x3D; (Servlet) myClass.newInstance();</span><br><span class="line">    servlet.service((ServletRequest) request,(ServletResponse)      response);</span><br><span class="line">&#125;catch (Exception e) &#123;</span><br><span class="line">    System.out.println(e.toString());</span><br><span class="line">&#125;catch (Throwable e) &#123;</span><br><span class="line">    System.out.println(e.toString());</span><br><span class="line">&#125;123456789</span><br></pre></td></tr></table></figure>

<p><strong>2.2.6 运行Demo</strong></p>
<p>Windows 上运行该应用程序，在工作目录下面敲入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .&#x2F;lib&#x2F;servlet.jar;.&#x2F; org.how.tomcat.works.ex02.HttpServer11</span><br></pre></td></tr></table></figure>

<p>Linux 下，你使用一个冒号来分隔两个库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .&#x2F;lib&#x2F;servlet.jar:.&#x2F; org.how.tomcat.works.ex02.HttpServer11</span><br></pre></td></tr></table></figure>

<p>要测试该应用程序，在浏览器的地址栏或者网址框中敲入：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/index.html">http://localhost:8080/index.html</a></p>
<p>或者</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/servlet/PrimitiveServlet">http://localhost:8080/servlet/PrimitiveServlet</a></p>
<p>当调用 PrimitiveServlet 时，你将会在浏览器看到下面的文本：</p>
<p>Hello. Roses are red.</p>
<p>请注意，因为只是第一个字符串被刷新到浏览器，所以你不能看到第二个字符串 “Violets are<br>blue”。我们将在第 3 章修复这个问题。</p>
<h2 id="Application-2"><a href="#Application-2" class="headerlink" title="Application 2"></a>Application 2</h2><p>在之前的程序中，有一个严重的问题，必须将ex02.pyrmont.Request和ex02.pyrmont.Response分别转型为javax.servlet.ServletRequest和javax.servlet.ServletResponse，再作为参数传递给具体的servlet的service方法。这样并不安全，熟知servlet容器的人可以将ServletRequest和ServletResponse类向下转型为Request和Response类，并执行parse和sendStaticResource方法。</p>
<ul>
<li><p>一种解决方案是将这两个方法的访问修饰符改为默认的（即，default），这样就可以避免包外访问。<!--很多第三方jar包都这样使用，比如shiro--></p>
</li>
<li><p>另一种更好的方案是使用外观设计模式。uml图如下：</p>
</li>
</ul>
<p><img src="http://sishuok.com/forum/upload/2012/4/10/8cdb2ac0da1fdb61ed7cdfdb2694b664__%E6%9C%AA%E5%91%BD%E5%90%8D.jpg" alt="img"></p>
<p>在第二个应用程序中，添加了两个façade类，RequestFacade和ResponseFacade。RequestFacade类实现了ServletRequest接口，通过在其构造方法中传入一个ServletRequest类型引用的Request对象来实例化。ServletRequest接口中每个方法的实现都会调用Request对象的相应方法。但是，ServletRequest对象本身是private类型，这样就不能从类的外部进行访问。这里也不再将Request对象向上转型为ServletRequest对象，而是创建一个RequestFacade对象，并把它传给service方法。这样，就算是将在servlet中获取了ServletRequest对象，并向下转型为RequestFacade对象，也不能再访问ServletRequest接口中的方法了，就可以避免前面所说的安全问题。</p>
<blockquote>
<p>注意: 它的构造函数，接收一个Request对象，然后向上转型为ServletRequest对象，赋给其private成员变量request。该类的其他方法中，都是调用request的相应方法实现的，这样就将ServletRequest完整的封装得RequestFacade中了。</p>
</blockquote>
<p> serveltProcess方法修改以下部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    servlet = (Servlet) myClass.newInstance();  <span class="comment">//很有意思，使用的是newInstance()而不是new，因为把类加载与类实例化分开了, tomcat需要破坏双亲委派，使用线程级别的类加载器</span></span><br><span class="line">    servlet.service((ServletRequest) requestFacade, (ServletResponse) responseFacade);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-04-%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-04-%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">springboot-04-父子容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-16 09:30:13 / Modified: 09:31:22" itemprop="dateCreated datePublished" datetime="2021-04-16T09:30:13+08:00">2021-04-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Spring</code>就是父容器，<code>SpringMvc</code>就是子容器，子容器可以访问父容器的内容，父容器不能访问子容器的东西。有点类似java里面的继承的味道，子类可以继承父类共有方法和变量，可以访问它们，父类不可以访问子类的方法和变量。在这里就会衍生出几个比较经典的问题：</p>
<ul>
<li>为什么需要父子容器？</li>
<li>是否可以把所有类都通过<code>Spring</code>容器来管理？（<code>Spring</code>的<code>applicationContext.xml</code>中配置全局扫描)</li>
<li>是否可以把我们所需的类都放入<code>Spring-mvc</code>子容器里面来管理（<code>springmvc</code>的<code>spring-servlet.xml</code>中配置全局扫描）?</li>
<li>同时通过两个容器同时来管理所有的类？如果能够把上面这四个问题可以说个所以然来，个人觉得<code>Spring</code>的父子容器应该问题不大了。我们可以看下官网提供的父子容器的图片<img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZicd8HYAuu5icgYtIBibc3T8GDib34mBYBNS1e38p5kYfZvDicDtKcaPlKxFw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></li>
<li>上图中显示了2个<code>WebApplicationContext</code>实例，为了进行区分，分别称之为：<code>Servlet WebApplicationContext</code>(子容器)、<code>Root WebApplicationContext</code>(父容器)。</li>
<li><strong>Servlet WebApplicationContext</strong>：这是对J2EE三层架构中的<code>web</code>层进行配置，如控制器(<code>controller</code>)、视图解析器(<code>view resolvers</code>)等相关的bean。通过<code>spring mvc</code>中提供的DispatchServlet来加载配置，通常情况下，配置文件的名称为spring-servlet.xml。</li>
<li><strong>Root WebApplicationContext</strong>：这是对J2EE三层架构中的<code>service</code>层、<code>dao</code>层进行配置，如业务<code>bean</code>，数据源(<code>DataSource</code>)等。通常情况下，配置文件的名称为<code>applicationContext.xml</code>。在<code>web</code>应用中，其一般通过<code>ContextLoaderListener</code>来加载。</li>
</ul>
<h1 id="Spring的启动"><a href="#Spring的启动" class="headerlink" title="Spring的启动"></a>Spring的启动</h1><p>要想很好的理解它们之间的关系，我们就有必要先弄清楚Spring的启动流程。要弄清楚这个启动流程我们就需要搭建一个<code>SpringMvc</code>项目，说句实话，用惯了<code>SpringBooot</code>开箱即用,突然在回过头来搭建一个<code>SpringMvc</code>项目还真有点不习惯，一大堆的配置文件。（虽然也可以用注解来实现）具体怎么搭建<code>SpringMvc</code>项目这个就不介绍了，搭建好项目我们运行起来可以看到控制台会输出如下日志：<img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZicuuCX4lfhl92VWJQ5giccp4pIM7CeTUODe214USqP5gjibBNzNncwrWuA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">日志里面分别打印出了父容器和子容器分别的一个耗时。</p>
<h1 id="如何验证是有两个容器？"><a href="#如何验证是有两个容器？" class="headerlink" title="如何验证是有两个容器？"></a>如何验证是有两个容器？</h1><p>我们只需要<code>Controller</code>与我们的<code>Service</code>中实现<code>ApplicationContextAware</code>接口，就可以得知对应的管理容器：在<code>Service</code>所属的父容器里面我们可以看到父容器对应的对象是<code>XmlWebApplicationContext@3972</code><img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZica1FZbchfGhcNibEgZuL5QC0LZqicjwRZMiakEdicec0qy6LVKNWXVMMn9Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">在<code>Controller</code>中对应的容器对象是<code>XmlWebApplicationContext@4114</code><img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZiccPsA5gDib890BOuQmFb6OZ0Vxe4Vqhm4pjWYRsRKEDb4AcJN43Agibsg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">由此可见它们是两个不同的容器。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>我们知道<code>SpringServletContainerInitializer</code>从 <code>servlet 3.0</code>开始，<code>Tomcat</code> 启动时会自动加载实现了 <code>ServletContainerInitializer</code><br>接口的类（需要在 <code>META-INF/services</code> 目录下新建配置文件）也称为 <code>SPI（Service Provider Interface）</code> 机制，<code>SPI</code>的应用还是挺广的比如我们的<code>JDBC</code>、还有<code>Dubbo</code>框架里面都有用到，如果还有不是很了解<code>SPI</code>机制的 可以去学习下。所以我们的入口就是<code>SpringServletContainerInitializer</code>的<code>onStartup</code>方法，这也应该是web容器启动调用<code>Spring</code>相关的第一个方法。</p>
<h3 id="初始化SpringIoc"><a href="#初始化SpringIoc" class="headerlink" title="初始化SpringIoc"></a>初始化SpringIoc</h3><p>如果实在找不到入口的话，我们可以 根据控制台打印的日志，然后拿着日志进行反向查找这应该总能找到开始加载父容器的地方。启动的时候控制台应该会打印出“<code>Root WebApplicationContext: initialization started</code>” 我们拿着这个日志就能定位到代码了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;</span><br><span class="line">  if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) !&#x3D; null) &#123;</span><br><span class="line">   throw new IllegalStateException(</span><br><span class="line">     &quot;Cannot initialize context because there is already a root application context present - &quot; +</span><br><span class="line">     &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);</span><br><span class="line">  Log logger &#x3D; LogFactory.getLog(ContextLoader.class);</span><br><span class="line">  if (logger.isInfoEnabled()) &#123;</span><br><span class="line">   logger.info(&quot;Root WebApplicationContext: initialization started&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">   &#x2F;&#x2F; Store context in local instance variable, to guarantee that</span><br><span class="line">   &#x2F;&#x2F; it is available on ServletContext shutdown.</span><br><span class="line">   if (this.context &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过反射去创建context </span><br><span class="line">    this.context &#x3D; createWebApplicationContext(servletContext);</span><br><span class="line">   &#125;</span><br><span class="line">   if (this.context instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">    ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext) this.context;</span><br><span class="line">    if (!cwac.isActive()) &#123;</span><br><span class="line">     &#x2F;&#x2F; The context has not yet been refreshed -&gt; provide services such as</span><br><span class="line">     &#x2F;&#x2F; setting the parent context, setting the application context id, etc</span><br><span class="line">     if (cwac.getParent() &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; The context instance was injected without an explicit parent -&gt;</span><br><span class="line">      &#x2F;&#x2F; determine parent for root web application context, if any.</span><br><span class="line">      ApplicationContext parent &#x3D; loadParentContext(servletContext);</span><br><span class="line">      cwac.setParent(parent);</span><br><span class="line">     &#125;</span><br><span class="line">      &#x2F;&#x2F; IOC容器初始化</span><br><span class="line">     configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);</span><br><span class="line"></span><br><span class="line">   ClassLoader ccl &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">   if (ccl &#x3D;&#x3D; ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">    currentContext &#x3D; this.context;</span><br><span class="line">   &#125;</span><br><span class="line">   else if (ccl !&#x3D; null) &#123;</span><br><span class="line">    currentContextPerThread.put(ccl, this.context);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (logger.isInfoEnabled()) &#123;</span><br><span class="line">    long elapsedTime &#x3D; System.currentTimeMillis() - startTime;</span><br><span class="line">    logger.info(&quot;Root WebApplicationContext initialized in &quot; + elapsedTime + &quot; ms&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return this.context;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (RuntimeException | Error ex) &#123;</span><br><span class="line">   logger.error(&quot;Context initialization failed&quot;, ex);</span><br><span class="line">   servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">   throw ex;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是创建父容器的地方。</p>
<h3 id="初始化-Spring-MVC"><a href="#初始化-Spring-MVC" class="headerlink" title="初始化 Spring MVC"></a>初始化 Spring MVC</h3><p>接着我们再来看看创建子容器的地方：在<code>FrameworkServlet</code>类<img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZicBwHej2kQUFJGicQegEAuTo4q8V9j0GADxmpGDeajhTribicSWIgZEVu4Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">上述代码是不是会有个疑问我们怎么就会执行<code>FrameworkServlet</code>的<code>initServletBean</code>方法。这是由于我们在<code>web.xml</code> 里面配置了<code>DispatcherServlet</code>，然后web容器就会去调用<code>DispatcherServlet</code>的<code>init</code>方法，并且这个方法只会被执行一次。通过init方法就会去执行到<code>initWebApplicationContext</code>这个方法了，这就是web子容器的一个启动执行顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &#x2F;&#x2F; 如果不配置这个load-on-startup 1 不会再项目启动的时候执行inti方法。而是首次访问再启动</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">  &lt;&#x2F;servlet&gt;</span><br></pre></td></tr></table></figure>

<p>大概流程如下：<img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZic5eW09yvicicjcb8xtjbicVbZJ8zl2ZxdHwF3xGp5bTLMITqM9cMGeofCw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">从上述代码我们可以发现子容器是自己重新通过反射<code>new</code>了一个新的容器作为子容器， 并且设置自己的父容器为<code>Spring</code> 初始化创建的<code>WebApplicationContext</code>。然后就是去加载我们在<code>web.xml</code> 里面配置的<code>Springmvc</code>的配置文件，然后通过创建的子容器去执行<code>refresh</code>方法，这个方法我相信很多人应该都比较清楚了。</p>
<h1 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h1><p>我们知道了<code>Sping</code>父容器以及<code>SpingMvc</code>子容器的一个启动过程，以及每个容器都分别干了什么事情现在再回过头来看看上述四个问题。</p>
<ul>
<li><strong>为什么需要父子容器？</strong>父子容器的主要作用应该是划分框架边界。有点单一职责的味道。在<code>J2EE</code>三层架构中，在<code>service</code>层我们一般使用<code>spring</code>框架来管理， 而在<code>web</code>层则有多种选择，如<code>spring mvc、struts</code>等。因此，通常对于<code>web</code>层我们会使用单独的配置文件。例如在上面的案例中，一开始我们使用<code>spring-servlet.xml</code>来配置web层，使用applicationContext.xml来配置<code>service</code>、<code>dao</code>层。如果现在我们想把<code>web</code>层从<code>spring mvc</code>替换成<code>struts</code>，那么只需要将<code>spring-servlet.xml</code>替换成<code>Struts</code>的配置文件<code>struts.xml</code>即可，而<code>applicationContext.xml</code>不需要改变。</li>
<li>**是否可以把所有类都通过Spring父容器来管理？（Spring的applicationContext.xml中配置全局扫描)**所有的类都通过父容器来管理的配置就是如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan  use-default-filters&#x3D;&quot;false&quot;  base-package&#x3D;&quot;cn.javajr&quot;&gt;</span><br><span class="line">        &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Service&quot; &#x2F;&gt;</span><br><span class="line">        &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Component&quot; &#x2F;&gt;</span><br><span class="line">        &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Repository&quot; &#x2F;&gt;</span><br><span class="line">        &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<p>然后在<code>SpringMvc</code>的配置里面不配置扫描包路径。很显然这种方式是行不通的，这样会导致我们请求接口的时候产生<code>404</code>。因为在解析@ReqestMapping注解的过程中<code>initHandlerMethods</code>()函数只是对<code>Spring MVC</code> 容器中的<code>bean</code>进行处理的，并没有去查找父容器的<code>bean</code>， 因此不会对父容器中含有<code>@RequestMapping</code>注解的函数进行处理，更不会生成相应的<code>handler</code>。所以当请求过来时找不到处理的<code>handler</code>，导致404。<img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZicHpNuL6FGSbdMvS3NLfvDic3kECN4GvOl3Dlx9nEP78PQcAFVQG6w9cg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li><strong>是否可以把我们所需的类都放入Spring-mvc子容器里面来管理（springmvc的spring-servlet.xml中配置全局扫描）?**这个是把包的扫描配置<code>spring-servlet.xml</code>中这个是可行的。为什么可行因为无非就是把所有的东西全部交给子容器来管理了，子容器执行了<code>refresh</code>方法，把在它的配置文件里面的东西全部加载管理起来来了。虽然可以这么做不过一般应该是不推荐这么去做的，一般人也不会这么干的。</strong>如果你的项目里有用到事物、或者aop记得也需要把这部分配置需要放到Spring-mvc子容器的配置文件来，不然一部分内容在子容器和一部分内容在父容器,可能就会导致你的事物或者AOP不生效<strong>。（这里不就有个经典的八股文吗？</strong>你有遇到事物不起作用的时候**，其实这也是一种情况）</li>
<li><strong>同时通过两个容器同时来管理所有的类？</strong>这个问题应该是比较好回答了，肯定不会通过这种方式来的，先不说会不会引发其他问题，首先两个容器里面都放一份一样的对象，造成了内存浪费。再者的话子容器会覆盖父容器加载，本来可能父容器配置了事物生成的是代理对象，但是被子容器一覆盖，又成了原生对象。这就导致了你的事物不起作用了。在补充一个问题：<strong>SpringBoot 里面是否还有父子容器</strong>？我们下篇再见！</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>其实父子容器对于程序员来说是无感的，是一个并没有什么用的知识点，都是<code>Spring</code>帮我们处理了，但是我们还是需要知道有这么个东西，不然我们有可能遇到问题的时候可能不知道如何下手。比如为啥我这个事物不起作用了，我这个<code>aop</code>怎么也不行了，网上都是这么配置的。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
