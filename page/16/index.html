<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/16/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/16/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">177</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/10/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80ID/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/10/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80ID/" class="post-title-link" itemprop="url">分布式集群下生成唯一ID</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-10 13:54:56" itemprop="dateCreated datePublished" datetime="2020-11-10T13:54:56+08:00">2020-11-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-14 14:34:35" itemprop="dateModified" datetime="2021-04-14T14:34:35+08:00">2021-04-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>它山之石可以攻玉</p>
<h3 id="ref-links"><a href="#ref-links" class="headerlink" title="ref links:"></a>ref links:</h3><ol>
<li><p>介绍了唯一ID的使用场景以及常见的解决思路<br><a target="_blank" rel="noopener" href="https://www.javazhiyin.com/73643.html">https://www.javazhiyin.com/73643.html</a></p>
</li>
<li><p>如何利用UUID作为唯一ID存储在mysql中，并提高mysql性能 =&gt; 存储为number<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16122934/best-way-to-handle-large-uuid-as-a-mysql-table-primary-key">https://stackoverflow.com/questions/16122934/best-way-to-handle-large-uuid-as-a-mysql-table-primary-key</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/10950202/how-to-store-uuid-as-number">https://stackoverflow.com/questions/10950202/how-to-store-uuid-as-number</a></p>
</li>
<li><p>深入分析mysql为什么不推荐使用uuid或者雪花id作为主键<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wyq178/p/12548864.html">https://www.cnblogs.com/wyq178/p/12548864.html</a></p>
</li>
</ol>
<h2 id="简单分析一下需求"><a href="#简单分析一下需求" class="headerlink" title="简单分析一下需求"></a>简单分析一下需求</h2><p>所谓全局唯一的 id 其实往往对应是<strong>生成唯一记录标识的业务需求</strong>。</p>
<p>这个 id 常常是数据库的主键，数据库上会建立聚集索引（cluster index），即在物理存储上以这个字段排序。这个记录标识上的查询，往往又有分页或者排序的业务需求。所以往往要有一个time字段，并且在time字段上建立普通索引（non-cluster index）。</p>
<p>普通索引存储的是实际记录的指针，其访问效率会比聚集索引慢，如果记录标识在生成时能够基本按照时间有序，则可以省去这个time字段的索引查询。</p>
<p>这就引出了记录标识生成的两大核心需求：</p>
<ul>
<li>全局唯一</li>
<li>趋势有序</li>
</ul>
<h2 id="常见生成策略的优缺点对比"><a href="#常见生成策略的优缺点对比" class="headerlink" title="常见生成策略的优缺点对比"></a>常见生成策略的优缺点对比</h2><h3 id="用数据库的-auto-increment"><a href="#用数据库的-auto-increment" class="headerlink" title="用数据库的 auto_increment"></a>用数据库的 auto_increment</h3><p><strong>优点：</strong></p>
<ul>
<li>此方法使用数据库原有的功能，所以相对简单</li>
<li>能够保证唯一性</li>
<li>能够保证递增性</li>
<li>id 之间的步长是固定且可自定义的</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>可用性难以保证：数据库常见架构是 一主多从 + 读写分离，生成自增ID是写请求 主库挂了就玩不转了</li>
<li>扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且 难以扩展</li>
</ul>
<p><strong>改进方案：</strong></p>
<ul>
<li>冗余主库，避免写入单点</li>
<li>数据水平切分，保证各主库生成的ID不重复</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudlL2EP3TLE6MKFNCg3bJwqicUGPB3zibWNXkibQibHHBZCjhib8Pzz5u7aVnJryuiabDEKgsLiashe8Gj0w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>如上图所述，由1个写库变成3个写库，每个写库设置不同的 auto_increment 初始值，以及相同的增长步长，以保证每个数据库生成的ID是不同的（上图中DB 01生成0,3,6,9…，DB 02生成1,4,7,10，DB 03生成2,5,8,11…）</p>
<p>改进后的架构保证了可用性，但缺点是</p>
<ul>
<li>丧失了ID生成的“绝对递增性”：先访问DB 01生成0,3，再访问DB 02生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，目标是趋势递增，不是绝对递增</li>
<li>数据库的写压力依然很大，每次生成ID都要访问数据库</li>
</ul>
<p>为了解决这些问题，引出了以下方法：</p>
<h3 id="单点批量ID生成服务"><a href="#单点批量ID生成服务" class="headerlink" title="单点批量ID生成服务"></a>单点批量ID生成服务</h3><p>分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。</p>
<p>数据库写压力大，是因为每次生成ID都访问了数据库，可以使用批量的方式降低数据库写压力。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudlL2EP3TLE6MKFNCg3bJwqOP9UXxwIOCibhlXXiaSSGwmSTC80GBCA8LVxLcKxH89BtaO9lqzbMfqg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>如上图所述，<!--数据库使用双master保证可用性-->数据库中只存储当前ID的最大值，例如4。</p>
<p>假设每次批量拉取5个ID，客户端应用访问ID生成服务，</p>
<ol>
<li>ID生成服务将当前ID的最大值修改为4</li>
<li>客户端应用访问ID生成服务索要ID</li>
<li>ID生成服务依次派发0,1,2,3,4这些ID。</li>
<li>当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是数据库的压力就降低到原来的1/6。</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li>保证了ID生成的绝对递增有序</li>
<li>大大的降低了数据库的压力，ID生成可以做到每秒生成几万几十万个</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>服务仍然是单点</li>
<li>如果服务挂了，服务重启起来之后，继续生成ID可能会不连续，中间出现空洞（服务内存是保存着0,1,2,3,4，数据库中max-id是4，分配到3时，服务重启了，下次会从5开始分配，3和4就成了空洞，不过这个问题也不大）</li>
<li>虽然每秒可以生成几万几十万个ID，但毕竟还是有性能上限，无法进行水平扩展</li>
</ul>
<p><strong>改进方案</strong></p>
<ul>
<li>单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点：</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudlL2EP3TLE6MKFNCg3bJwqQvubrmA8V4J1H7UzCe1647T82GToR508bgiaLKLnMQ42MBGIyob1XdA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。这个切换的过程对调用方是透明的，可以自动完成，常用的技术是 vip+keepalived。另外，id generate service 也可以进行水平扩展，以解决上述缺点，但会引发一致性问题。</p>
<h3 id="uuid-guid"><a href="#uuid-guid" class="headerlink" title="uuid / guid"></a>uuid / guid</h3><p>不管是通过数据库，还是通过服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。uuid是一种常见的本地生成ID的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID uuid &#x3D; UUID.randomUUID();</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>本地生成ID，不需要进行远程调用，时延低</li>
<li>扩展性好，基本可以认为没有性能上限</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无法保证趋势递增</li>
<li>uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）</li>
</ul>
<h3 id="取当前毫秒数"><a href="#取当前毫秒数" class="headerlink" title="取当前毫秒数"></a>取当前毫秒数</h3><p>uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？- 取当前毫秒数是一种常见方案。（搜索公众号Java知音，回复“2021”，送你一份Java面试题宝典）</p>
<p><strong>优点：</strong></p>
<ul>
<li>本地生成ID，不需要进行远程调用，时延低</li>
<li>生成的ID趋势递增</li>
<li>生成的ID是整数，建立索引后查询效率高</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果并发量超过1000，会生成重复的ID</li>
<li>这个缺点要了命了，不能保证ID的唯一性。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。</li>
</ul>
<h3 id="使用-Redis-来生成-id"><a href="#使用-Redis-来生成-id" class="headerlink" title="使用 Redis 来生成 id"></a>使用 Redis 来生成 id</h3><p>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR 和 INCRBY 来实现。</p>
<p><strong>优点：</strong></p>
<ul>
<li>依赖于数据库，灵活方便，且性能优于数据库。</li>
<li>数字ID天然排序，对分页或者需要排序的结果很有帮助。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。</li>
<li>需要编码和配置的工作量比较大。</li>
</ul>
<h3 id="Twitter-开源的-Snowflake-算法"><a href="#Twitter-开源的-Snowflake-算法" class="headerlink" title="Twitter 开源的 Snowflake 算法"></a>Twitter 开源的 Snowflake 算法</h3><p>snowflake 是 twitter 开源的分布式ID生成算法，其核心思想为，一个long型的ID：</p>
<ul>
<li>41 bit 作为毫秒数 - 41位的长度可以使用69年</li>
<li>10 bit 作为机器编号 （5个bit是数据中心，5个bit的机器ID） - 10位的长度最多支持部署1024个节点</li>
<li>12 bit 作为毫秒内序列号 - 12位的计数顺序号支持每个节点每毫秒产生4096个ID序号</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudlL2EP3TLE6MKFNCg3bJwqoQPdvS7rxC9Z3VG6wryFPzah882ZqyIgfK9eoQsHuq9SQWdJYnibhAg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">Snowflake图示</p>
<p>算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。</p>
<p>该算法 java 版本的实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public class SnowflakeIdGenerator &#123;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 系统开始时间截 (UTC 2017-06-28 00:00:00)</span><br><span class="line">    private final long startTime &#x3D; 1498608000000L;</span><br><span class="line">    &#x2F;&#x2F; 机器id所占的位数</span><br><span class="line">    private final long workerIdBits &#x3D; 5L;</span><br><span class="line">    &#x2F;&#x2F; 数据标识id所占的位数</span><br><span class="line">    private final long dataCenterIdBits &#x3D; 5L;</span><br><span class="line">    &#x2F;&#x2F; 支持的最大机器id(十进制)，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)</span><br><span class="line">    &#x2F;&#x2F; -1L 左移 5位 (worker id 所占位数) 即 5位二进制所能获得的最大十进制数 - 31</span><br><span class="line">    private final long maxWorkerId &#x3D; -1L ^ (-1L &lt;&lt; workerIdBits);</span><br><span class="line">    &#x2F;&#x2F; 支持的最大数据标识id - 31</span><br><span class="line">    private final long maxDataCenterId &#x3D; -1L ^ (-1L &lt;&lt; dataCenterIdBits);</span><br><span class="line">    &#x2F;&#x2F; 序列在id中占的位数</span><br><span class="line">    private final long sequenceBits &#x3D; 12L;</span><br><span class="line">    &#x2F;&#x2F; 机器ID 左移位数 - 12 (即末 sequence 所占用的位数)</span><br><span class="line">    private final long workerIdMoveBits &#x3D; sequenceBits;</span><br><span class="line">    &#x2F;&#x2F; 数据标识id 左移位数 - 17(12+5)</span><br><span class="line">    private final long dataCenterIdMoveBits &#x3D; sequenceBits + workerIdBits;</span><br><span class="line">    &#x2F;&#x2F; 时间截向 左移位数 - 22(5+5+12)</span><br><span class="line">    private final long timestampMoveBits &#x3D; sequenceBits + workerIdBits + dataCenterIdBits;</span><br><span class="line">    &#x2F;&#x2F; 生成序列的掩码(12位所对应的最大整数值)，这里为4095 (0b111111111111&#x3D;0xfff&#x3D;4095)</span><br><span class="line">    private final long sequenceMask &#x3D; -1L ^ (-1L &lt;&lt; sequenceBits);</span><br><span class="line">   </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 工作机器ID(0~31)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private long workerId;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 数据中心ID(0~31)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private long dataCenterId;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 毫秒内序列(0~4095)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private long sequence &#x3D; 0L;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 上次生成ID的时间截</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private long lastTimestamp &#x3D; -1L;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构造函数</span><br><span class="line">     *</span><br><span class="line">     * @param workerId     工作ID (0~31)</span><br><span class="line">     * @param dataCenterId 数据中心ID (0~31)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public SnowflakeIdGenerator(long workerId, long dataCenterId) &#123;</span><br><span class="line">        if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;Worker Id can&#39;t be greater than %d or less than 0&quot;, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        if (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;DataCenter Id can&#39;t be greater than %d or less than 0&quot;, maxDataCenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        this.workerId &#x3D; workerId;</span><br><span class="line">        this.dataCenterId &#x3D; dataCenterId;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Methods&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    &#x2F;&#x2F; 线程安全的获得下一个 ID 的方法</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long timestamp &#x3D; currentTime();</span><br><span class="line">        &#x2F;&#x2F;如果当前时间小于上一次ID生成的时间戳: 说明系统时钟回退过 - 这个时候应当抛出异常</span><br><span class="line">        if (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果是同一时间生成的，则进行毫秒内序列</span><br><span class="line">        if (lastTimestamp &#x3D;&#x3D; timestamp) &#123;</span><br><span class="line">            sequence &#x3D; (sequence + 1) &amp; sequenceMask;</span><br><span class="line">            &#x2F;&#x2F;毫秒内序列溢出 即 序列 &gt; 4095</span><br><span class="line">            if (sequence &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;阻塞到下一个毫秒,获得新的时间戳</span><br><span class="line">                timestamp &#x3D; blockTillNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;时间戳改变，毫秒内序列重置</span><br><span class="line">        else &#123;</span><br><span class="line">            sequence &#x3D; 0L;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;上次生成ID的时间截</span><br><span class="line">        lastTimestamp &#x3D; timestamp;</span><br><span class="line">        &#x2F;&#x2F;移位并通过或运算拼到一起组成64位的ID</span><br><span class="line">        return ((timestamp - startTime) &lt;&lt; timestampMoveBits) &#x2F;&#x2F;</span><br><span class="line">                | (dataCenterId &lt;&lt; dataCenterIdMoveBits) &#x2F;&#x2F;</span><br><span class="line">                | (workerId &lt;&lt; workerIdMoveBits) &#x2F;&#x2F;</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 阻塞到下一个毫秒 即 直到获得新的时间戳</span><br><span class="line">    protected long blockTillNextMillis(long lastTimestamp) &#123;</span><br><span class="line">        long timestamp &#x3D; currentTime();</span><br><span class="line">        while (timestamp &lt;&#x3D; lastTimestamp) &#123;</span><br><span class="line">            timestamp &#x3D; currentTime();</span><br><span class="line">        &#125;</span><br><span class="line">        return timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获得以毫秒为单位的当前时间</span><br><span class="line">    protected long currentTime() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Test Case&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SnowflakeIdGenerator idWorker &#x3D; new SnowflakeIdGenerator(0, 0);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            long id &#x3D; idWorker.nextId();</span><br><span class="line">            &#x2F;&#x2F;System.out.println(Long.toBinaryString(id));</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/07/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/Nginx/linux%E5%AE%89%E8%A3%85nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/07/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/Nginx/linux%E5%AE%89%E8%A3%85nginx/" class="post-title-link" itemprop="url">linux安装nginx</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-07 15:28:54" itemprop="dateCreated datePublished" datetime="2020-11-07T15:28:54+08:00">2020-11-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-17 19:31:07" itemprop="dateModified" datetime="2021-03-17T19:31:07+08:00">2021-03-17</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>基础的操作教程，有yum仓库操作的介绍<br><a target="_blank" rel="noopener" href="https://www.cyberciti.biz/faq/how-to-install-and-use-nginx-on-centos-7-rhel-7/">https://www.cyberciti.biz/faq/how-to-install-and-use-nginx-on-centos-7-rhel-7/</a></li>
<li>Nginx official tutorial<br><a target="_blank" rel="noopener" href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install/">https://www.nginx.com/resources/wiki/start/topics/tutorials/install/</a></li>
<li>阿里云ECS实例的配置, 比较详细<br><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/699966">https://developer.aliyun.com/article/699966</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BECPU%E9%A3%99%E5%8D%87%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BECPU%E9%A3%99%E5%8D%87%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">查找CPU飙升的原因</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 09:24:42" itemprop="dateCreated datePublished" datetime="2020-11-05T09:24:42+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-11 14:38:13" itemprop="dateModified" datetime="2021-04-11T14:38:13+08:00">2021-04-11</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="第一步：找到耗费CPU的进程"><a href="#第一步：找到耗费CPU的进程" class="headerlink" title="第一步：找到耗费CPU的进程"></a>第一步：找到耗费CPU的进程</h2><p>首先，因为CPU飙升了，所以要查看CPU的相关信息，所以需要使用TOP命令</p>
<img src="/Users/qifei/Library/Application Support/typora-user-images/image-20201202174921436.png" alt="image-20201202174921436" style="zoom:50%;" />

<h2 id="第二步：找到耗费CPU的线程（10进制）"><a href="#第二步：找到耗费CPU的线程（10进制）" class="headerlink" title="第二步：找到耗费CPU的线程（10进制）"></a>第二步：找到耗费CPU的线程（10进制）</h2><p>根据1st step中的返回内容，看到进程号116664的CPU很高。所以，需要进一步锁定该进程内部的线程耗费CPU, 所以需要使用top -H -p [pid]命令查看线程， (也可使用shift -h进行切换)</p>
<p>![image-20201202175704489](/Users/qifei/Library/Application Support/typora-user-images/image-20201202175704489.png)</p>
<h2 id="第三步：找到耗费CPU的线程（16进制）"><a href="#第三步：找到耗费CPU的线程（16进制）" class="headerlink" title="第三步：找到耗费CPU的线程（16进制）"></a>第三步：找到耗费CPU的线程（16进制）</h2><p>根据2nd step中的返回内容，可以看到线程号117296(10进制)的java线程耗费CPU，所以需要查看该线程的详细信息，所以需要是一个jstack命令，但是，记住jstack中的nid（Native Thread ID)是系统线程id, 为16进制，需要使用top -Hp pid找到该线程的10进制pid，然后使用下边的命令打印出16进制线程nid</p>
<p>![image-20201202180132749](/Users/qifei/Library/Application Support/typora-user-images/image-20201202180132749.png)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf  &quot;%x\n&quot; 10进制nid</span><br></pre></td></tr></table></figure>

<h2 id="第四步：打印CPU的线程-16进制-栈信息"><a href="#第四步：打印CPU的线程-16进制-栈信息" class="headerlink" title="第四步：打印CPU的线程(16进制)栈信息"></a>第四步：打印CPU的线程(16进制)栈信息</h2><p>根据3rd step中的16进制线程号，使用 <!--注意：linux下进程和线程都用10进制pid表示--></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack pid | grep [nid]</span><br></pre></td></tr></table></figure>

<p>命令，查询该线程的详细信息</p>
<p>![image-20201202180409819](/Users/qifei/Library/Application Support/typora-user-images/image-20201202180409819.png)</p>
<h2 id="第五步：分析栈信息中的线程状态"><a href="#第五步：分析栈信息中的线程状态" class="headerlink" title="第五步：分析栈信息中的线程状态"></a>第五步：分析栈信息中的线程状态</h2><p>当然更常见的是我们对整个 jstack 文件进行分析，通常我们会比较关注 WAITING 和 TIMED_WAITING 的部分，BLOCKED 就不用说了。我们可以使用命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat jstack.log | grep &quot;java.lang.Thread.State&quot; | sort -nr | uniq -c</span><br></pre></td></tr></table></figure>

<p>来对 jstack 的状态有一个整体的把握，如果 WAITING 之类的特别多，那么多半是有问题啦。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9zpsDC09P5ww0K7GTAYZbhxfc6VfyucR5Lf7TGY2mbfBN14UicSbOPIQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="正则表达式消耗CPU"><a href="#正则表达式消耗CPU" class="headerlink" title="正则表达式消耗CPU"></a>正则表达式消耗CPU</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; patternList = <span class="keyword">new</span> ArrayList&lt;&gt;;</span><br><span class="line">patternList.add(<span class="string">&quot;Here I am&quot;</span>);</span><br><span class="line">patternList.add ....;</span><br><span class="line"></span><br><span class="line">String[] patternMatch = &#123;<span class="string">&quot;[\\\w\\\\s]....&quot;</span>, <span class="string">&quot;[\\\s\\\\w]&quot;</span>,...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:patternList)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;patternMatch.length; i++)&#123;</span><br><span class="line">		Pattern pattern = Pattern.compile(patternMatch[i]);</span><br><span class="line">    </span><br><span class="line">    Matcher matcher = pattern.matcher(s);</span><br><span class="line">    <span class="keyword">if</span>(matcher.matches()) system.out.println(<span class="string">&quot;match!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用第五步时：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State: Running</span><br><span class="line">		at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BEGC%E9%A3%99%E5%8D%87%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BEGC%E9%A3%99%E5%8D%87%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">查找GC飙升的原因</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 09:24:42" itemprop="dateCreated datePublished" datetime="2020-11-05T09:24:42+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-23 13:56:00" itemprop="dateModified" datetime="2021-04-23T13:56:00+08:00">2021-04-23</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="第一步：找到目标进程pid"><a href="#第一步：找到目标进程pid" class="headerlink" title="第一步：找到目标进程pid"></a>第一步：找到目标进程pid</h2><p>ps 命令找到对应进程的 pid(10进制) <!--nid是16进制--></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep <span class="string">&quot;进程名称pid&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="第二步：找到目标进程pid的gc情况"><a href="#第二步：找到目标进程pid的gc情况" class="headerlink" title="第二步：找到目标进程pid的gc情况"></a>第二步：找到目标进程pid的gc情况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc pid 1000</span><br></pre></td></tr></table></figure>

<p>命令来对 gc 分代变化情况进行观察，1000 表示采样间隔(ms)，</p>
<p>S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU 分别代表两个 Survivor 区、Eden 区、老年代、元数据区的容量和使用量。</p>
<p>YGC/YGT、FGC/FGCT、GCT 则代表 YoungGc、FullGc 的耗时和次数以及总耗时。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9MKs9HzKAziao22GmRcTGHArZ0vdmRianvicN58y2sM2Ne3mhZfb3Vg0oA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h2 id="第三步：对症下药"><a href="#第三步：对症下药" class="headerlink" title="第三步：对症下药"></a>第三步：对症下药</h2><ul>
<li>如果YoungGC频率很高，因为大多数对象都是朝生夕死，所以要让他们在YongGC之前就死亡，那么应该增加Eden区的容量，减少YongGC发生的时间间隔</li>
</ul>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><h3 id="YGC-频繁"><a href="#YGC-频繁" class="headerlink" title="YGC 频繁"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">YGC 频繁</a></h3><p>直接查看 gc log 并不直观，我们可以借用一些可视化工具来帮助我们分析， <code>[gceasy](https://gceasy.io/)</code> 是个挺不错的网站，我们把 gc log 上传上去后， gceasy 可以帮助我们生成各个维度的图表帮助分析。</p>
<p>查看 gceasy 生成的报告，发现我们服务的 gc 吞吐量是 95%，它指的是 JVM 运行业务代码的时长占 JVM 总运行时长的比例，这个比例确实有些低了，运行 100 分钟就有 5 分钟在执行 gc。幸好这些 GC 中绝大多数都是 YGC，单次时长可控且分布平均，这使得我们服务还能平稳运行。</p>
<p>解决这个问题要么是减少对象的创建，要么就增大 young 区。前者不是一时半会儿都解决的，需要查找代码里可能有问题的点，分步优化。</p>
<p>而后者虽然改一下配置就行，但以我们对 GC 最直观的印象来说，增大 young 区，YGC 的时长也会迅速增大。</p>
<p>其实这点不必太过担心，我们知道 YGC 的耗时是由 <code>GC 标记 + GC 复制</code> 组成的，相对于 GC 复制，GC 标记是非常快的。而 young 区内大多数对象的生命周期都非常短，如果将 young 区增大一倍，GC 标记的时长会提升一倍，但到 GC 发生时被标记的对象大部分已经死亡， GC 复制的时长肯定不会提升一倍，所以我们可以放心增大 young 区大小。</p>
<p>由于低内存旧机器都被换掉了，我把堆大小调整到了 12G，young 区保留为 8G。</p>
<h3 id="分代调整"><a href="#分代调整" class="headerlink" title="分代调整"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">分代调整</a></h3><p>除了 GC 太频繁之外，GC 后各分代的平均大小也需要调整。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffvuL0XJJboo4ouy9mNX1iaUdW1Fu9hNnP8UgA5Fy5Me51KgFxx16AQfe4tfEG2icI43eicHCn6kHH0A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">图片</p>
<p>我们知道 GC 的提升机制，每次 GC 后，JVM 存活代数大于 <code>MaxTenuringThreshold</code> 的对象提升到老年代。当然，JVM 还有动态年龄计算的规则：按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值，但看各代总的内存大小，是达不到 survivor 区的一半的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffvuL0XJJboo4ouy9mNX1iaUtjnuXmDx8BicpSpteU9T1XJUwwtZn8zCXgSlzoAIzaiaWG3whgj5h2hA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">图片</p>
<p>所以这十五个分代内的对象会一直在两个 survivor 区之间来回复制，再观察各分代的平均大小，可以看到，四代以上的对象已经有一半都会保留到老年区了，所以可以将这些对象直接提升到老年代，以减少对象在两个 survivor 区之间复制的性能开销。</p>
<p>所以我把 MaxTenuringThreshold 的值调整为 4，将存活超过四代的对象直接提升到老年代。</p>
<h3 id="偏向锁停顿"><a href="#偏向锁停顿" class="headerlink" title="偏向锁停顿"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">偏向锁停顿</a></h3><p>还有一个问题是 gc log 里有很多 18ms 左右的停顿，有时候连续有十多条，虽然每次停顿时长不长，但连续多次累积的时间也非常可观。</p>
<p>1.8 之后 JVM 对锁进行了优化，添加了偏向锁的概念，避免了很多不必要的加锁操作，但偏向锁一旦遇到锁竞争，取消锁需要进入 <code>safe point</code>，导致 STW。</p>
<p>解决方式很简单，JVM 启动参数里添加 <code>-XX:-UseBiasedLocking</code> 即可。</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">结果</a></h3><p>调整完 JVM 参数后先是对服务进行压测，发现性能确实有提升，也没有发生严重的 GC 问题，之后再把调整好的配置放到线上机器进行灰度，同时收集 gc log，再次进行分析。</p>
<p>由于 young 区大小翻倍了，所以 YGC 的频率减半了，GC 的吞量提升到了 97.75%。平均 GC 时长略有上升，从 60ms 左右提升到了 66ms，还是挺符合预期的。</p>
<p>由于 CMS 在进行 GC 时也会清理 young 区，CMS 的时长也受到了影响，CMS 的最终标记和并发清理阶段耗时增加了，也比较正常。</p>
<p>另外我还统计了对业务的影响，之前因为 GC 导致超时的请求大大减少了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BE%E5%86%85%E5%AD%98%E9%A3%99%E5%8D%87%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BE%E5%86%85%E5%AD%98%E9%A3%99%E5%8D%87%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">查找内存飙升的原因</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 09:24:42" itemprop="dateCreated datePublished" datetime="2020-11-05T09:24:42+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-06 13:40:10" itemprop="dateModified" datetime="2021-04-06T13:40:10+08:00">2021-04-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>内存问题排查起来相对比 CPU 麻烦一些，场景也比较多。主要包括 OOM、GC 问题和堆外内存。一般来讲，我们会先用free命令先来检查一发内存的各种情况。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9gR3via3V6ebgfOicYMjKPMQ3iaLjs0icnM97myJbYVibXfiaiaThhzbgHetrA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>堆内内存</p>
<p>内存问题大多还都是堆内内存问题。表象上主要分为 OOM 和 Stack Overflo。</p>
<p>OOM</p>
<p>JMV 中的内存不足，OOM 大致可以分为以下几种：</p>
<p><strong>Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread</strong></p>
<p>这个意思是没有足够的内存空间给线程分配 Java 栈，基本上还是线程池代码写的有问题，比如说忘记 shutdown，所以说应该首先从代码层面来寻找问题，使用 jstack 或者 jmap。如果一切都正常，JVM 方面可以通过指定Xss来减少单个 thread stack 的大小。另外也可以在系统层面，可以通过修改/etc/security/limits.confnofile 和 nproc 来增大 os 对线程的限制</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9hpBEFNxR6KgLN9R8sI8ZrnichpqPmVlVvsPcH84O4tWTAv2diaoEFMNg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><strong>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</strong></p>
<p>这个意思是堆的内存占用已经达到-Xmx 设置的最大值，应该是最常见的 OOM 错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过 jstack 和 jmap 去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。</p>
<p><strong>Caused by: java.lang.OutOfMemoryError: Meta space</strong></p>
<p>这个意思是元数据区的内存占用已经达到XX:MaxMetaspaceSize设置的最大值，排查思路和上面的一致，参数方面可以通过XX:MaxPermSize来进行调整(这里就不说 1.8 以前的永久代了)。</p>
<p>Stack Overflow</p>
<p>栈内存溢出，这个大家见到也比较多。</p>
<p><strong>Exception in thread “main” java.lang.StackOverflowError</strong></p>
<p>表示线程栈需要的内存大于 Xss 值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起 OOM。</p>
<p>使用 JMAP 定位代码内存泄漏</p>
<p>上述关于 OOM 和 Stack Overflo 的代码排查方面，我们一般使用 JMAPjmap -dump:format=b,file=filename pid来导出 dump 文件</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9e8gQWnOAvmXjvHOCSHcyicIstYlacBsMW2YcHxeOepTnvXVNfYCp9Pg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>通过 mat(Eclipse Memory Analysis Tools)导入 dump 文件进行分析，内存泄漏问题一般我们直接选 Leak Suspects 即可，mat 给出了内存泄漏的建议。另外也可以选择 Top Consumers 来查看最大对象报告。和线程相关的问题可以选择 thread overview 进行分析。除此之外就是选择 Histogram 类概览来自己慢慢分析，大家可以搜搜 mat 的相关教程。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9oRjPiazyEkL5xF1xnvbIfibnBz5JTnkw1vyuNficNuIpNZvYg5JpXiauFw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都 new 对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发 gc；ByteBuffer 缓存分配不合理等都会造成代码 OOM。</p>
<p>另一方面，我们可以在启动参数中指定-XX:+HeapDumpOnOutOfMemoryError来保存 OOM 时的 dump 文件。</p>
<p>gc 问题和线程</p>
<p>gc 问题除了影响 CPU 也会影响内存，排查思路也是一致的。一般先使用 jstat 来查看分代变化情况，比如 youngGC 或者 fullGC 次数是不是太多呀；EU、OU 等指标增长是不是异常呀等。</p>
<p>线程的话太多而且不被及时 gc 也会引发 oom，大部分就是之前说的unable to create new native thread。除了 jstack 细细分析 dump 文件外，我们一般先会看下总体线程，通过pstreee -p pid |wc -l。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9Qiby29R0TM1vleXDqBVlgok2fvBEbwDrbxSzvibE1W38R52MhcF4XSCg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>或者直接通过查看/proc/pid/task的数量即为线程数量。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9ELzXlh7ibibJgEiakg91XynOmiaKETIpA4YAh2IR0aBW2e9TdczzXCDiauw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>堆外内存</p>
<p>如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用 Netty 导致的，那错误日志里可能会出现OutOfDirectMemoryError错误，如果直接是 DirectByteBuffer，那会报OutOfMemoryError: Direct buffer memory。</p>
<p>堆外内存溢出往往是和 NIO 的使用相关，一般我们先通过 pmap 来查看下进程占用的内存情况pmap -x pid | sort -rn -k3 | head -30，这段意思是查看对应 pid 倒序前 30 大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9wPvdqWzauQRPCon769dudGQP6B0zj7ucdX5xBnlLjqrQzukrT3N5Cw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>我们如果确定有可疑的内存端，需要通过 gdb 来分析gdb –batch –pid {pid} -ex “dump memory filename.dump {内存起始地址} {内存起始地址+内存块大小}”</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9XHyuhia3QJankbxnDNwJ11yKX7NQ6VlicWmIB1miblPHeKNH6b58wJtAg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>获取 dump 文件后可用 heaxdump 进行查看hexdump -C filename | less，不过大多数看到的都是二进制乱码。</p>
<p>NMT 是 Java7U40 引入的 HotSpot 新特性，配合 jcmd 命令我们就可以看到具体内存组成了。需要在启动参数中加入 -XX:NativeMemoryTracking=summary 或者 -XX:NativeMemoryTracking=detail，会有略微性能损耗。</p>
<p>一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线jcmd pid VM.native_memory baseline。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs982vnIibTNvCxibgdt8z16Hj1M1VRxxwlgxjtXvn9VEHQMXWx4qic7wvJQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>然后等放一段时间后再去看看内存增长的情况，通过jcmd pid VM.native_memory detail.diff(summary.diff)做一下 summary 或者 detail 级别的 diff。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs93mricZdIwEGYzKKeiacqOeibDDy4bJbwA59kV6ianWQHiaHqDYoq5EL4ricA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9D5UwssOfdZoKY6583NPxPxudbLo9YTIZ9zBVGbeL71ChVw6GSPrsfw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>可以看到 jcmd 分析出来的内存十分详细，包括堆内、线程以及 gc(所以上述其他内存异常其实都可以用 nmt 来分析)，这边堆外内存我们重点关注 Internal 的内存增长，如果增长十分明显的话那就是有问题了。</p>
<p>detail 级别的话还会有具体内存段的增长情况，如下图。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9LUccDnQ3onwXfgibP0icNftOx6U9Q5acw8iaD34l3DMJVYgUBSpSJM0tg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>此外在系统层面，我们还可以使用 strace 命令来监控内存分配 strace -f -e “brk,mmap,munmap” -p pid</p>
<p>这边内存分配信息主要包括了 pid 和内存地址。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9fv1wibbYCBLLIalwWQ442BQmEdagRw0Boob3tmo1Rq1TNb1QQpQxqLQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如 DirectByteBuffer 分配内存的话，是需要 full GC 或者手动 system.gc 来进行回收的(所以最好不要使用-XX:+DisableExplicitGC)。那么其实我们可以跟踪一下 DirectByteBuffer 对象的内存情况，通过jmap -histo:live pid手动触发 fullGC 来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过-XX:MaxDirectMemorySize进行调整。如果没有什么变化，那就要使用 jmap 去分析那些不能被 gc 的对象，以及和 DirectByteBuffer 之间的引用关系了。</p>
<h1 id="GC-问题"><a href="#GC-问题" class="headerlink" title="GC 问题"></a>GC 问题</h1><p>堆内内存泄漏总是和 GC 异常相伴。不过 GC 问题不只是和内存问题相关，还有可能引起 CPU 负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下 GC 相关问题。</p>
<p>我们在 CPU 章介绍了使用 jstat 来获取当前 GC 分代变化信息。而更多时候，我们是通过 GC 日志来排查问题的，在启动参数中加上-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps来开启 GC 日志。</p>
<p>常见的 Young GC、Full GC 日志含义在此就不做赘述了。</p>
<p>针对 gc 日志，我们就能大致推断出 youngGC 与 fullGC 是否过于频繁或者耗时过长，从而对症下药。我们下面将对 G1 垃圾收集器来做分析，这边也建议大家使用 G1-XX:+UseG1GC。</p>
<p><strong>youngGC 过频繁</strong></p>
<p>youngGC 频繁一般是短周期小对象较多，先考虑是不是 Eden 区/新生代设置的太小了，看能否通过调整-Xmn、-XX:SurvivorRatio 等参数设置来解决问题。如果参数正常，但是 young gc 频率还是太高，就需要使用 Jmap 和 MAT 对 dump 文件进行进一步排查了。</p>
<p><strong>youngGC 耗时过长</strong></p>
<p>耗时过长问题就要看 GC 日志里耗时耗在哪一块了。以 G1 日志为例，可以关注 Root Scanning、Object Copy、Ref Proc 等阶段。Ref Proc 耗时长，就要注意引用相关的对象。Root Scanning 耗时长，就要注意线程数、跨代引用。Object Copy 则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的 Root Scanning 和正常时间段比增长较多，那就是起的线程太多了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs95F2hYyL4XzKclBfIYcA1tZOrXqSXrJLystsoULld4PhyWPrJsaEXzQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><strong>触发 fullGC</strong></p>
<p>G1 中更多的还是 mixedGC，但 mixedGC 可以和 youngGC 思路一样去排查。触发 fullGC 了一般都会有问题，G1 会退化使用 Serial 收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。</p>
<p>fullGC 的原因可能包括以下这些，以及参数调整方面的一些思路：</p>
<ul>
<li>并发阶段失败：在并发标记阶段，MixGC 之前老年代就被填满了，那么这时候 G1 就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数-XX:ConcGCThreads。</li>
<li>晋升失败：在 GC 的时候没有足够的内存供存活/晋升对象使用，所以触发了 Full GC。这时候可以通过-XX:G1ReservePercent来增加预留内存百分比，减少-XX:InitiatingHeapOccupancyPercent来提前启动标记，-XX:ConcGCThreads来增加标记线程数也是可以的。</li>
<li>大对象分配失败：大对象找不到合适的 region 空间进行分配，就会进行 fullGC，这种情况下可以增大内存或者增大-XX:G1HeapRegionSize。</li>
<li>程序主动执行 System.gc()：不要随便写就对了。</li>
</ul>
<p>另外，我们可以在启动参数中配置-XX:HeapDumpPath=/xxx/dump.hprof来 dump fullGC 相关的文件，并通过 jinfo 来进行 gc 前后的 dump</p>
<p>jinfo -flag +HeapDumpBeforeFullGC pid</p>
<p>jinfo -flag +HeapDumpAfterFullGC pid</p>
<p>jinfo -flag +HeapDumpBeforeFullGC pid</p>
<p>jinfo -flag +HeapDumpAfterFullGC pid</p>
<p>这样得到 2 份 dump 文件，对比后主要关注被 gc 掉的问题对象来定位问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BE%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BE%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">查找内存飙升的原因</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 09:24:42" itemprop="dateCreated datePublished" datetime="2020-11-05T09:24:42+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-06 13:45:21" itemprop="dateModified" datetime="2021-04-06T13:45:21+08:00">2021-04-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>磁盘问题和 CPU 一样是属于比较基础的。首先是磁盘空间方面，我们直接使用df -hl来查看文件系统状态</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs91rAhM7DCqdDZ3TPIj3qicJ9XBZvh5gs6hUqFbmFuG3BjqD3VEgzO5KA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>更多时候，磁盘问题还是性能上的问题。我们可以通过 iostatiostat -d -k -x来进行分析</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9kicWZHgeMphDonPQtaIpZvgsDtMXxXI6Thxj73jjuthFFYtsNscMlTw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>最后一列%util可以看到每块磁盘写入的程度，而rrqpm/s以及wrqm/s分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。</p>
<p>另外我们还需要知道是哪个进程在进行读写，一般来说开发自己心里有数，或者用 iotop 命令来进行定位文件读写的来源。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9UOwicNicwS7ep640BTUJSqvBthicFV3Aqnf5icOHzEzpojGxhTapRrdVug/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>不过这边拿到的是 tid，我们要转换成 pid，可以通过 readlink 来找到 pidreadlink -f /proc/*/task/tid/../..。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9QWIicSI5EmMFHkIlR9yAl1WrPHdiafIOuiaVGiaEt4JuF8b6mcGQXVsmOQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>找到 pid 之后就可以看这个进程具体的读写情况cat /proc/pid/io</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9AHPZScGmI5wr9EfaLHibwO5ovVL4Yiccb6E03KuOSGiaM55vPC2jrCTLA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>我们还可以通过 lsof 命令来确定具体的文件读写情况lsof -p pid</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs977LolSkIQ1coxHc5ibhfpQFiakUeWs0IYMDmib207Vx6aCK8tDyelW1rQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BE%E7%A8%8B%E5%BA%8Fhang%E4%BD%8F%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BE%E7%A8%8B%E5%BA%8Fhang%E4%BD%8F%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">查找CPU飙升的原因</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 09:24:42" itemprop="dateCreated datePublished" datetime="2020-11-05T09:24:42+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-11 15:20:56" itemprop="dateModified" datetime="2021-04-11T15:20:56+08:00">2021-04-11</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><h3 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (l1)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;holding l1&quot;</span>);</span><br><span class="line">               Thread.sleep(<span class="number">500</span>);              </span><br><span class="line">               <span class="keyword">synchronized</span> (l2)&#123;</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;releasing l1&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (l2)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;holding l2&quot;</span>);</span><br><span class="line">               Thread.sleep(<span class="number">500</span>);</span><br><span class="line">               <span class="keyword">synchronized</span> (l1)&#123;</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;releasing l2&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用jstack命令"><a href="#使用jstack命令" class="headerlink" title="使用jstack命令"></a>使用jstack命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [pid] | grep BLOCKED</span><br></pre></td></tr></table></figure>

<p>看到两个线程blocked，他们互相waiting to lock 和locked</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-1&quot; #13 prio=5 os_prio=31 tid=0x00007fe5aea2c800 nid=0x4003 waiting for monitor entry [0x0000700006eba000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at Solution.lambda$main$1(Solution.java:38)</span><br><span class="line">	- waiting to lock &lt;0x00000007957da970&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x00000007957da980&gt; (a java.lang.Object)</span><br><span class="line">	at Solution$$Lambda$2/2094777811.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot; #12 prio=5 os_prio=31 tid=0x00007fe5aea2b800 nid=0x3d03 waiting for monitor entry [0x0000700006db7000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at Solution.lambda$main$0(Solution.java:25)</span><br><span class="line">	- waiting to lock &lt;0x00000007957da980&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x00000007957da970&gt; (a java.lang.Object)</span><br><span class="line">	at Solution$$Lambda$1/2075203460.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>



<h2 id="IO-异常"><a href="#IO-异常" class="headerlink" title="IO 异常"></a>IO 异常</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BE%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E6%89%BE%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">查找内存飙升的原因</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 09:24:42" itemprop="dateCreated datePublished" datetime="2020-11-05T09:24:42+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-06 13:42:03" itemprop="dateModified" datetime="2021-04-06T13:42:03+08:00">2021-04-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>涉及到网络层面的问题一般都比较复杂，场景多，定位难，成为了大多数开发的噩梦，应该是最复杂的了。这里会举一些例子，并从 tcp 层、应用层以及工具的使用等方面进行阐述。</p>
<p>超时</p>
<p>超时错误大部分处在应用层面，所以这块着重理解概念。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。</p>
<ul>
<li>读写超时。readTimeout/writeTimeout，有些框架叫做 so_timeout 或者 socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa 的超时指的也是读超时。读写超时一般都只针对客户端设置。</li>
<li>连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边 connectionTimeout 就有些五花八门了，Jetty 中表示空闲连接清理时间，Tomcat 则表示连接维持的最大时间。</li>
<li>其他。包括连接获取超时 connectionAcquireTimeout 和空闲连接清理超时 idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。</li>
</ul>
<p>我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。</p>
<p>在实际开发中，我们关心最多的应该是接口的读写超时了。</p>
<p>如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的 tcp 连接。而如果接口设置的过短，那么接口超时就会非常频繁。</p>
<p>服务端接口明明 rt 降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。</p>
<p>TCP 队列溢出</p>
<p>tcp 队列溢出是个相对底层的错误，它可能会造成超时、rst 等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9ueiaWMwEibnlkQFibePsaOaoLJ963hJibxPmWzrHM1SiaN6Yy3CV7NDgwEQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在 server 收到 client 的 syn 后，把消息放到 syns queue，回复 syn+ack 给 client，server 收到 client 的 ack，如果这时 accept queue 没满，那就从 syns queue 拿出暂存的信息放入 accept queue 中，否则按 tcp_abort_on_overflow 指示的执行。</p>
<p>tcp_abort_on_overflow 0 表示如果三次握手第三步的时候 accept queue 满了那么 server 扔掉 client 发过来的 ack。tcp_abort_on_overflow 1 则表示第三步的时候如果全连接队列满了，server 发送一个 rst 包给 client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多connection reset / connection reset by peer。</p>
<p>那么在实际开发中，我们怎么能快速定位到 tcp 队列溢出呢？</p>
<p><strong>netstat 命令，执行 netstat -s | egrep “listen|LISTEN”</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs95rEegaooMnc2icOmZC1icYTsv9QdJR5QAoaaavN5WDSvSFqpDKvsdwibg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>如上图所示，overflowed 表示全连接队列溢出的次数，sockets dropped 表示半连接队列溢出的次数。</p>
<p><strong>ss 命令，执行 ss -lnt</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9hORTeGqWHPiblNhIGjQbMq8D30G7N102kzibKDPvBuLicn9ibGOVghZ0FQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>上面看到 Send-Q 表示第三列的 listen 端口上的全连接队列最大为 5，第一列 Recv-Q 为全连接队列当前使用了多少。</p>
<p>接着我们看看怎么设置全连接、半连接队列大小吧：</p>
<p>全连接队列的大小取决于 min(backlog, somaxconn)。backlog 是在 socket 创建的时候传入的，somaxconn 是一个 os 级别的系统参数。而半连接队列的大小取决于 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。</p>
<p>在日常开发中，我们往往使用 servlet 容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在 Tomcat 中 backlog 叫做acceptCount，在 Jetty 里面则是acceptQueueSize。</p>
<p>RST 异常</p>
<p>RST 包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。</p>
<p>在实际开发中，我们往往会看到connection reset / connection reset by peer错误，这种情况就是 RST 包导致的。</p>
<p><strong>端口不存在</strong></p>
<p>如果像不存在的端口发出建立连接 SYN 请求，那么服务端发现自己并没有这个端口则会直接返回一个 RST 报文，用于中断连接。</p>
<p><strong>主动代替 FIN 终止连接</strong></p>
<p>一般来说，正常的连接关闭都是需要通过 FIN 报文实现，然而我们也可以用 RST 报文来代替 FIN，表示直接终止连接。实际开发中，可设置 SO_LINGER 数值来控制，这种往往是故意的，来跳过 TIMED_WAIT，提供交互效率，不闲就慎用。</p>
<p><strong>客户端或服务端有一边发生了异常，该方向对端发送 RST 以告知关闭连接</strong></p>
<p>我们上面讲的 tcp 队列溢出发送 RST 包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。</p>
<p><strong>接收到的 TCP 报文不在已知的 TCP 连接内</strong></p>
<p>比如，一方机器由于网络实在太差 TCP 报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的 TCP 报文，但由于对应的 TCP 连接已不存在，那么会直接发一个 RST 包以便开启新的连接。</p>
<p><strong>一方长期未收到另一方的确认报文，在一定时间或重传次数后发出 RST 报文</strong></p>
<p>这种大多也和网络环境相关了，网络环境差可能会导致更多的 RST 报文。</p>
<p>之前说过 RST 报文多会导致程序报错，在一个已关闭的连接上读操作会报connection reset，而在一个已关闭的连接上写操作则会报connection reset by peer。通常我们可能还会看到broken pipe错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到 RST，报出connection reset错后继续读写数据报的错，这个在 glibc 源码注释中也有介绍。</p>
<p>我们在排查故障时候怎么确定有 RST 包的存在呢？当然是使用 tcpdump 命令进行抓包，并使用 wireshark 进行简单分析了。tcpdump -i en0 tcp -w xxx.cap，en0 表示监听的网卡。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9COFn2RA5jjh48hSA3fV2XEktBejp2icUX9aOe50ES9KquSs7CSPTNqg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>接下来我们通过 wireshark 打开抓到的包，可能就能看到如下图所示，红色的就表示 RST 包了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs92HUlM0egemTGj5w6viaZadhXQicjAaCY5ngzX2VdNUxw33uSV6WLlMaQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>TIME_WAIT 和 CLOSE_WAIT</p>
<p>TIME_WAIT 和 CLOSE_WAIT 是啥意思相信大家都知道。</p>
<p>在线上时，我们可以直接用命令netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’来查看 time-wait 和 close_wait 的数量</p>
<p>用 ss 命令会更快ss -ant | awk ‘{++S[$1]} END {for(a in S) print a, S[a]}’</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9MOYdcUgic9TrAcAKZVYoG6pRdoEUoTibuOcIEHpQJYdoXTzqh7Q8XzdA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>TIME_WAIT</p>
<p>time_wait 的存在一是为了丢失的数据包被后面连接复用，二是为了在 2MSL 的时间范围内正常关闭连接。它的存在其实会大大减少 RST 包的出现。</p>
<p>过多的 time_wait 在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:</p>
<p>#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</p>
<p>net.ipv4.tcp_tw_reuse = 1</p>
<p>#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭</p>
<p>net.ipv4.tcp_tw_recycle = 1</p>
<p>#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</p>
<p>net.ipv4.tcp_tw_reuse = 1</p>
<p>#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭</p>
<p>net.ipv4.tcp_tw_recycle = 1</p>
<p>当然我们不要忘记在 NAT 环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小tcp_max_tw_buckets，超过这个数的 time_wait 都会被干掉，不过这也会导致报time wait bucket table overflow的错。</p>
<p>CLOSE_WAIT</p>
<p>close_wait 往往都是因为应用程序写的有问题，没有在 ACK 后再次发起 FIN 报文。close_wait 出现的概率甚至比 time_wait 要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。</p>
<p>想要定位这类问题，最好是通过 jstack 来分析线程堆栈来排查问题，具体可参考上述章节。这里仅举一个例子。</p>
<p>开发同学说应用上线后 CLOSE_WAIT 就一直增多，直到挂掉为止，jstack 后找到比较可疑的堆栈是大部分线程都卡在了countdownlatch.await方法，找开发同学了解后得知使用了多线程但是确没有 catch 异常，修改后发现异常仅仅是最简单的升级 sdk 后常出现的class not found。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E8%AF%A2%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E8%BF%87%E5%A4%9A%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E6%9F%A5%E8%AF%A2%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E8%BF%87%E5%A4%9A%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">查询CPU在线程上下文切换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 09:24:42" itemprop="dateCreated datePublished" datetime="2020-11-05T09:24:42+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-06 13:39:19" itemprop="dateModified" datetime="2021-04-06T13:39:19+08:00">2021-04-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="使用vm命令"><a href="#使用vm命令" class="headerlink" title="使用vm命令"></a>使用vm命令</h2><p>针对频繁上下文问题，我们可以使用vmstat命令来进行查看</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9P2IZ2fVgz8z03pyhRm5cIqch7ytg9hmpoO64iapPlUjjiaUZ1PuRJd8Q/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h2 id="查看具体状态"><a href="#查看具体状态" class="headerlink" title="查看具体状态"></a>查看具体状态</h2><p>cs(context switch)一列则代表了上下文切换的次数。</p>
<p>如果我们希望对特定的 pid 进行监控那么可以使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -w pid</span><br></pre></td></tr></table></figure>

<p>命令，cswch 和 nvcswch 表示自愿及非自愿切换。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9clBLQdNkmNResib4bKMzSjClHpTXHJSaBWia0buP1uoahp4qVcgx2oDg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/apache-http-client%E5%BC%95%E8%B5%B7%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%81%87%E6%AD%BB%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/apache-http-client%E5%BC%95%E8%B5%B7%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%81%87%E6%AD%BB%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">apache http client引起的线程假死or卡死问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-04 13:47:46" itemprop="dateCreated datePublished" datetime="2020-11-04T13:47:46+08:00">2020-11-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-02 18:09:22" itemprop="dateModified" datetime="2020-12-02T18:09:22+08:00">2020-12-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>它山之石可以攻玉</p>
<h3 id="ref-links"><a href="#ref-links" class="headerlink" title="ref links:"></a>ref links:</h3><ol>
<li><p>如何一步一步找到问题的原因是假死<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/baomw/article/details/84070428?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v28-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v28-3.nonecase">https://blog.csdn.net/baomw/article/details/84070428?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v28-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v28-3.nonecase</a></p>
</li>
<li><p>详细指令的参数说明，并且有详细脚本：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wyb628/p/8566337.html">https://www.cnblogs.com/wyb628/p/8566337.html</a></p>
</li>
<li><p>jstack返回的详细解释：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38451161/article/details/98035500">https://blog.csdn.net/weixin_38451161/article/details/98035500</a></p>
</li>
<li><p>http client的死锁原因深究，以及如何查看git官网的bug修复通知<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/549294286/p/11241277.html">https://www.cnblogs.com/549294286/p/11241277.html</a></p>
</li>
<li><p>http client 无限卡死的原因<br><a target="_blank" rel="noopener" href="https://www.oschina.net/question/2298861_240814">https://www.oschina.net/question/2298861_240814</a><br><a target="_blank" rel="noopener" href="https://www.oschina.net/question/2272252_2176034">https://www.oschina.net/question/2272252_2176034</a></p>
</li>
<li><p>http client 无限卡死的解决方法：设置3个超时时间，并且在spirng中的设置;<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/403d75d310e8">https://www.jianshu.com/p/403d75d310e8</a></p>
</li>
</ol>
<p>思考：</p>
<ol>
<li>什么是假死？</li>
<li>Socket timeout 会stuck，而且如果不设置timeout, 那么不抛出异常</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
