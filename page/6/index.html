<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>BootFei&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="BootFei&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BootFei&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-编程语言/Java/jdk/JDK-IO-Serializable" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-IO-Serializable/" class="article-date">
  <time datetime="2021-05-28T08:43:54.000Z" itemprop="datePublished">2021-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-IO-Serializable/">JDK-IO-Serializable</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java序列化与反序列化"><a href="#Java序列化与反序列化" class="headerlink" title="Java序列化与反序列化"></a>Java序列化与反序列化</h2><ul>
<li>序列化：将对象写入到IO流中</li>
<li>反序列化：从IO流中恢复对象</li>
</ul>
<p>序列化机制允许将实现序列化的Java对象转换为字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。</p>
<p>要想有序列化的能力，得实现<code>Serializable</code>接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class SerializableTest implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -3751255153289772365L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM会在运行时判断类的<code>serialVersionUID</code>来验证版本一致性，如果传来的字节流中的serialVersionUID与本地相应类的serialVersionUID相同则认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException:com.taobao.query.TestSerializable;</span><br><span class="line"> local class incompatible: stream classdesc serialVersionUID = -7165097063094245447,local class    serialVersionUID = 6678378625230229450</span><br></pre></td></tr></table></figure>

<h2 id="Jackson序列化"><a href="#Jackson序列化" class="headerlink" title="Jackson序列化"></a>Jackson序列化</h2><h2 id="Dubbo与序列化"><a href="#Dubbo与序列化" class="headerlink" title="Dubbo与序列化"></a>Dubbo与序列化</h2><img src="https://mmbiz.qpic.cn/mmbiz_jpg/R7PtjL3tdAickVUF9IZmibFdmF1FlgL2NuBu5TXia3HmibyicxYfMkYv7YzoGKy4ISEs8MEs3CjMw28JdxibnibFHCPfA/640" alt="Image" style="zoom:67%;" />

<p>图片来源：<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/dev/design/">https://dubbo.apache.org/zh/docs/v2.7/dev/design/</a></p>
<p>从Dubbo的调用链可以发现是有一个序列化节点的，其支持的序列化协议一共有四种：</p>
<ol>
<li>dubbo序列化：阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它</li>
<li>hessian2序列化：hessian是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的hessian lite，它是dubbo RPC默认启用的序列化方式</li>
<li>json序列化：目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。</li>
<li>java序列化：主要是采用JDK自带的Java序列化实现，性能很不理想。</li>
</ol>
<p>如果在RPC中使用了Java序列化，那下面的这三个坑一定注意不要踩</p>
<h3 id="类实现Serializable接口但没有指定serialVersionUID"><a href="#类实现Serializable接口但没有指定serialVersionUID" class="headerlink" title="类实现Serializable接口但没有指定serialVersionUID"></a>类实现<code>Serializable</code>接口但没有指定<code>serialVersionUID</code></h3><p>如果实现了<code>Serializable</code>的类没有指定<code>serialVersionUID</code>，编译器编译的时候会根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，这就决定了这个类在序列化上一定不是向前兼容的</p>
<p>假如我们先有<code>Student</code>这样的一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static int startId &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">        id &#x3D; startId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将其序列化到磁盘：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        FileOutputStream fileOut =</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/student.ser&quot;</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">        out.writeObject(student);</span><br><span class="line">        out.close();</span><br><span class="line">        fileOut.close();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Serialized data is saved in /tmp/student.ser&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (</span><br><span class="line">            IOException i) &#123;</span><br><span class="line">        i.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后给<code>Student</code>类加一个字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> startId = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="comment">// 注意这里我们已经加了一个属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = startId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再去解码，发现程序会抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.idealism.base.Student; local class incompatible: stream classdesc serialVersionUID &#x3D; -1534228028811562580, local class serialVersionUID &#x3D; 630353564791955009</span><br><span class="line"> at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699)</span><br><span class="line"> at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2001)</span><br><span class="line"> at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1848)</span><br><span class="line"> at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2158)</span><br><span class="line"> at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459)</span><br><span class="line"> at com.idealism.base.SerializableTest.deserialize(SerializableTest.java:34)</span><br><span class="line"> at com.idealism.base.SerializableTest.main(SerializableTest.java:9)</span><br></pre></td></tr></table></figure>

<p>根因是RPC的参数实现了<code>Serializable</code>接口，但是没有指定<code>serialVersionUID</code>，编译器会根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，当服务端类升级之后导致了服务端发送给客户端的字节流中的<code>serialVersionUID</code>发生了改变，因此当客户端反序列化去检查<code>serialVersionUID</code>字段的时候发现发生了变化被判定了异常。</p>
<h3 id="父类实现Serializable接口，并且指定了serialVersionUID但是子类没有指定serialVersionUID"><a href="#父类实现Serializable接口，并且指定了serialVersionUID但是子类没有指定serialVersionUID" class="headerlink" title="父类实现Serializable接口，并且指定了serialVersionUID但是子类没有指定serialVersionUID"></a>父类实现<code>Serializable</code>接口，并且指定了<code>serialVersionUID</code>但是子类没有指定<code>serialVersionUID</code></h3><p>我们对前面的例子中的<code>Student</code>类稍微改一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Base&#123;</span><br><span class="line"></span><br><span class="line">    private static int startId &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">        id &#x3D; startId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中父类长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Base implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 218886242758597651L;</span><br><span class="line"></span><br><span class="line">    private Date gmtCreate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们按照之前的讨论在本地进行一次序列化和反序列化，程序依然抛异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.idealism.base.Student; local class incompatible: stream classdesc serialVersionUID &#x3D; 1049562984784675762, local class serialVersionUID &#x3D; 7566357243685852874</span><br><span class="line"> at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699)</span><br><span class="line"> at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2001)</span><br><span class="line"> at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1848)</span><br><span class="line"> at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2158)</span><br><span class="line"> at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459)</span><br><span class="line"> at com.idealism.base.SerializableTest.deserialize(SerializableTest.java:34)</span><br><span class="line"> at com.idealism.base.SerializableTest.main(SerializableTest.java:9)</span><br></pre></td></tr></table></figure>

<p>我们在设计类的时候公共属性要放到基类，这条经验指导放到这个case中仍然不太正确，而且这个case比上一个还要隐蔽，问题是子类中的<code>serialVersionUID</code>仍然是编译器自动生成的。当然可以把父类中<code>serialVersionUID</code>的改为非<code>private</code>来解这个问题，不过我仍然建议每个有序列化需求的类都显式指定<code>serialVersionUID</code>的值。</p>
<p>如果序列化遇到类之间的组合或者继承关系，则Java按照下面的规则处理：</p>
<ul>
<li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化，而不管其是否实现了<code>Serializable</code>接口</li>
<li>如果子类实现了<code>Serializable</code>，则序列化时只序列化子类，不会序列化父类中的属性</li>
<li>如果父类实现了<code>Serializable</code>，则序列化时子类和父类都会被序列化，异常场景如本例所指</li>
</ul>
<p>还有一点要注意：如果类的实例中有静态变量，改属性不会被序列化和反序列化</p>
<h3 id="类中有枚举值"><a href="#类中有枚举值" class="headerlink" title="类中有枚举值"></a>类中有枚举值</h3><p>《阿里巴巴开发规约》中有这么一条：</p>
<blockquote>
<p>【强制】二方库例可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象。</p>
<p>说明：由于升级原因，导致双方的枚举类不尽相同，在接口解析，类反序列化时出现异常</p>
</blockquote>
<p>这里会出现这样一个限制的原因是Java对枚举的序列化和反序列化采用完全不同的策略。序列化的结果中仅包含枚举的名字，而不包含枚举的具体定义，反序列化的时候客户端从序列化结果中读取枚举的name，然后调用<code>java.lang.Enum#valueOf</code>根据本地的枚举定义获取具体的枚举值。</p>
<p>我们仍然用之前的代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 2528736437985230667L;</span><br><span class="line">    </span><br><span class="line">    private static int startId &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    &#x2F;&#x2F; 新增字段，校服尺码，其类型是一个枚举</span><br><span class="line">    private SchoolUniformSizeEnum schoolUniformSize;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">        id &#x3D; startId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如学生这个类中新增了一个校服尺码的枚举值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum SchoolUniformSizeEnum &#123;</span><br><span class="line">    SMALL,</span><br><span class="line">    MEDIUM,</span><br><span class="line">    LARGE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如服务端此时对这个枚举进行了升级，但是客户端的二方包中仍然只有三个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum SchoolUniformSizeEnum &#123;</span><br><span class="line">    SMALL,</span><br><span class="line">    MEDIUM,</span><br><span class="line">    LARGE,</span><br><span class="line">    OVERSIZED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果服务端有逻辑给客户端返回了这个新增的枚举值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static void serialize() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Student student &#x3D; new Student();</span><br><span class="line">        &#x2F;&#x2F; 服务端升级了枚举</span><br><span class="line">        student.setSchoolUniformSize(SchoolUniformSizeEnum.OVERSIZED);</span><br><span class="line">        FileOutputStream fileOut &#x3D;</span><br><span class="line">                new FileOutputStream(&quot;&#x2F;tmp&#x2F;student.ser&quot;);</span><br><span class="line">        ObjectOutputStream out &#x3D; new ObjectOutputStream(fileOut);</span><br><span class="line">        out.writeObject(student);</span><br><span class="line">        out.close();</span><br><span class="line">        fileOut.close();</span><br><span class="line">        System.out.printf(&quot;Serialized data is saved in &#x2F;tmp&#x2F;student.ser&quot;);</span><br><span class="line">    &#125; catch (</span><br><span class="line">            IOException i) &#123;</span><br><span class="line">        i.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为客户端的包还没有升级，所以当客户端读到这个新的字节流并序列化的时候会因为找不到对应的枚举值而抛异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidObjectException: enum constant OVERSIZED does not exist in class com.idealism.base.SchoolUniformSizeEnum</span><br><span class="line"> at java.io.ObjectInputStream.readEnum(ObjectInputStream.java:2130)</span><br><span class="line"> at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1659)</span><br><span class="line"> at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2403)</span><br><span class="line"> at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2327)</span><br><span class="line"> at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2185)</span><br><span class="line"> at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459)</span><br><span class="line"> at com.idealism.base.SerializableTest.deserialize(SerializableTest.java:36)</span><br><span class="line"> at com.idealism.base.SerializableTest.main(SerializableTest.java:9)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-IO-Serializable/" data-id="cm6lsyz5k005ek2dlf37561r9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编程语言/Java/jdk/JDK-lang-Object-wait-notify" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-lang-Object-wait-notify/" class="article-date">
  <time datetime="2021-05-28T07:09:45.000Z" itemprop="datePublished">2021-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-lang-Object-wait-notify/">JDK-lang-Thread</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JVM线程状态与锁的关系"><a href="#JVM线程状态与锁的关系" class="headerlink" title="JVM线程状态与锁的关系"></a>JVM线程状态与锁的关系</h2><p>sleep、wait、join都会使线程进入阻塞状态(waiting/timed_waiting状态)，同时也都会释放cpu资源</p>
<blockquote>
<p>yield是释放cpu资源，然后又抢夺cpu资源，目的是为了让其它线程有机会获取cpu资源进行处理，但是线程状态还是runnable。</p>
</blockquote>
<p>sleep如果是在锁方法内执行，比如同步代码块或者重入锁方法内执行，是不会释放锁。而wait会释放锁。</p>
<ul>
<li>wait用于锁机制，sleep不是，这也是为什么sleep不释放锁，wait释放锁的原因，</li>
<li>sleep是线程的方法，跟锁没关系，</li>
<li>wait，notify，notifyall 都是Object对象的方法，是一起使用的，用于锁机制。</li>
</ul>
<p>有个特殊的Thread.sleep(0)，操作这个动作是让出cpu，让其它线程又机会获取cpu资源执行</p>
<h2 id="wait-官方说明"><a href="#wait-官方说明" class="headerlink" title="wait()官方说明"></a>wait()官方说明</h2><p>The recommended approach to waiting is to check the condition being awaited in a while loop around the call to wait, as shown in the example below. Among other things, this approach avoids problems that can be caused by spurious wakeups.<br> synchronized (obj) {      while (<condition does not hold> and <timeout not exceeded>) {          long timeoutMillis = … ; // recompute timeout values          int nanos = … ;          obj.wait(timeoutMillis, nanos);      }      … // Perform action appropriate to condition or timeout  }</p>
<h2 id="notify-官方说明"><a href="#notify-官方说明" class="headerlink" title="notify()官方说明"></a>notify()官方说明</h2><p>Wakes up all threads that are waiting on this object’s monitor. A thread waits on an object’s monitor by calling one of the wait methods.<br>The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object. The awakened threads will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable privilege or disadvantage in being the next thread to lock this object.<br>This method should only be called by a thread that is the owner of this object’s monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.<br>Throws:<br>IllegalMonitorStateException – if the current thread is not the owner of this object’s monitor.</p>
<p><img src="https://2.bp.blogspot.com/-7yTGxlOBfu4/VvUdKBO3RhI/AAAAAAAAFYE/tSNS9y3Gb2sGPE4nrnTvllraf0lYOt-SA/w615-h461/Wait%2Band%2BNotify%2BJava%2BConcurrency.jpg" alt="&quot;wait notify and notifyall in java synchronized"></p>
<blockquote>
<p>Since the wait() method in Java also releases the lock prior to waiting and reacquires the lock prior to returning from the <a target="_blank" rel="noopener" href="http://javarevisited.blogspot.com/2011/12/difference-between-wait-sleep-yield.html">wait() method</a>, we must use this lock to ensure that checking the condition (buffer is full or not) and setting the condition (taking element from the buffer) is atomic which can be achieved by using synchronized method or block in Java.</p>
<p>Read more: <a target="_blank" rel="noopener" href="https://javarevisited.blogspot.com/2011/05/wait-notify-and-notifyall-in-java.html#ixzz7w2kARh54">https://javarevisited.blogspot.com/2011/05/wait-notify-and-notifyall-in-java.html#ixzz7w2kARh54</a></p>
</blockquote>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>无论是wait()还是notify()，其执行的前提条件都是：该线程首先持有资源对象object的锁。否则的话，就会抛出IllegalMonitorStateException异常。<br> <code>wait(long timeout)</code>：和wait()方法类似的还有一个wait(long timeout)，如果线程一直没有被唤醒，当超时时间到了，就会自动被唤醒。<br> <code>notifyAll()</code>：notify()方法，也对应有一个notifyAll()方法，该方法会将等待队列里的所有线程都唤醒，唤醒后的线程行为和notify()保持一致。</p>
<p>事实上一个线程被唤醒的方式包括以下几种：</p>
<ul>
<li>其他线程调用object的notify()方法， 而该线程刚好被从等待队列中选中.</li>
<li>其他线程调用了notifyAll()方法。</li>
<li>其他线程通过interrupt中断了该线程。</li>
<li>等待超时时间到达，线程被自动唤醒。</li>
</ul>
<p>刚刚上文也提到了执行notify和wait，必须先获取到资源对象的锁，获取锁的方式有三种：</p>
<ul>
<li>执行对象的同步方法。</li>
<li>执行对象的同步代码块。</li>
<li>对于类对象，执行类的静态同步方法。</li>
</ul>
<h3 id="wait-和sleep"><a href="#wait-和sleep" class="headerlink" title="wait()和sleep()"></a>wait()和sleep()</h3><p>首先，wait必须要在获得了当前对象的对象锁代码块中执行（可以理解为调用哪个对象的wait方法，调用的时候就要处于哪个对象的同步代码块中），而sleep则没有这个限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wait(); <span class="comment">//可以 没问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wait(); <span class="comment">//不可以，没有处于this的同步代码块中，抛出IllegalMonitorStateException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(其他对象) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait() <span class="comment">// 不可以，这里只获得了其他对象的锁，但是却调用了this的wait，抛出IllegalMonitorStateException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(其他对象) &#123;</span><br><span class="line">        其他对象.wait() <span class="comment">// 可以，没问题，不一定非得是this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也许你注意到了，wait()必须配合synchronized使用？为什么呢？那就是wait()有个很有意思的特性，<strong>执行wait()后的睡眠期间，会释放掉通过synchronized获得的锁，直到被唤醒的时候会重新获得锁</strong>，而sleep()会在线程睡眠期间依然持有这个锁，也就是说，在同步代码块中用wait()睡眠后，其他线程也能够获得对象的锁。</p>
<p>wait()的睡眠状态被notity()或notifyAll()唤醒时，不会抛出异常，sleep()导致的睡眠只能被interrupt()方法唤醒，同时sleep()会抛出异常，若interrupt()唤醒的是由wait()导致的睡眠，wait()同样会抛出异常。</p>
<p>同时，由于wait()会释放掉锁，因此一个对象中可能会同时存在多个线程由于wait()导致的睡眠</p>
<h3 id="notify-与notifyAll"><a href="#notify-与notifyAll" class="headerlink" title="notify()与notifyAll()"></a>notify()与notifyAll()</h3><p>notify()会将对象的一个线程从wait()导致的睡眠状态中唤醒，至于是哪个线程，则是随机的。</p>
<p>而notifyAll()则是唤醒对象所有由于wait()导致的睡眠。由于wait()被唤醒后会对对象加锁，如果没能拿到锁会暂时先阻塞着直到有机会拿到锁，因此依然是线程安全的。</p>
<h3 id="简易消息队列的实现"><a href="#简易消息队列的实现" class="headerlink" title="简易消息队列的实现"></a>简易消息队列的实现</h3><p>现在就利用上面的特性，实现一个简单的阻塞型消息队列吧。</p>
<p>消息队列是一个典型的消费者-生产者模型，当消费者消费时，若消息队列为空，则一直等待（阻塞执行），直到生产者生产了一个消息，此时消费者阻塞消除并获得一个消息</p>
<p>这里阻塞的关键是队列空时等待，非空时唤醒</p>
<p>消息队列类完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用锁实现的消息队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列关闭标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 使用链表作为消息容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg   消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取链表的锁之后，向链表添加消息，最后尝试唤醒链表对象（如果在等待的话）</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;消息队列已关闭&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(msg);</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭消息队列，并唤醒消费者的等待（如果在等待的话）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            stop = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费消息，若无消息将会一直阻塞，直到有消息或队列关闭，若消息队列已关闭则不再阻塞且返回null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 拿到的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取对象的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> queue.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stop &amp;&amp; queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 由于关闭队列也有可能退出上面的循环，所以要再判断一次长度</span></span><br><span class="line">                <span class="keyword">if</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> queue.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MessageQueue mq = <span class="keyword">new</span> MessageQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开1个线程消费消息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               String msg = mq.consume();</span><br><span class="line">               System.out.println(<span class="string">&quot;消费消息：&quot;</span> + msg);</span><br><span class="line">               <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;队列关闭&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            mq.product(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产消息：&quot;</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mq.stop();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行可以观察到每0.1秒生产一个消息，紧接着就被消费，最后程序退出 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-lang-Object-wait-notify/" data-id="cm6lsyz5m005tk2dl0vjw43vm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编程语言/Java/jdk/JDK-lang-Thread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-lang-Thread/" class="article-date">
  <time datetime="2021-05-28T07:09:45.000Z" itemprop="datePublished">2021-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-lang-Thread/">JDK-lang-Thread</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="操作系统中线程状态"><a href="#操作系统中线程状态" class="headerlink" title="操作系统中线程状态"></a>操作系统中线程状态</h3><p>传统的进（线）程状态一般划分如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfednyicQRNkh1ibicsEjORXmQPvuebO2CAvYA39TwmEx3t5agr9HlYDO9wxvRoW8eGut9tzZUGvvJyNg/640" alt="图片"></p>
<h3 id="jdk中线程状态"><a href="#jdk中线程状态" class="headerlink" title="jdk中线程状态"></a>jdk中线程状态</h3><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><h5 id="包含OS的ready和running状态"><a href="#包含OS的ready和running状态" class="headerlink" title="包含OS的ready和running状态"></a>包含OS的ready和running状态</h5><p>runnable 状态实质上是包括了 ready 状态和running 状态。</p>
<blockquote>
<p>A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</p>
</blockquote>
<p>通常，Java的线程状态是服务于监控的，如果线程切换得是如此之快，那么区分 ready 与 running 就没什么太大意义了。</p>
<p>现今主流的 JVM 实现都把 Java 线程一一映射到操作系统底层的线程上，把调度委托给了操作系统，我们在虚拟机层面看到的状态实质是对底层状态的映射及包装。JVM 本身没有做什么实质的调度，把底层的 ready 及 running 状态映射上来也没多大意义，因此，统一成为runnable 状态是不错的选择。</p>
<h5 id="包含OS中由于IO引起的wait状态"><a href="#包含OS中由于IO引起的wait状态" class="headerlink" title="包含OS中由于IO引起的wait状态"></a>包含OS中由于IO引起的wait状态</h5><p>一旦线程中执行到 I/O 有关的代码，相应线程立马被切走，然后调度 ready 队列中另一个线程来运行。这时执行了 I/O 的线程就不再运行，处于上图中的 waiting 状态。</p>
<p>而当 I/O 完成时，则用一种叫中断 （interrupt）的机制来通知 cpu：</p>
<p>cpu 会收到一个比如说来自硬盘的Interrput信号，并进入中断处理例程，CPU正在执行的线程因此被Interrput，回到 ready 队列。而先前因 I/O 而waiting 的线程随着 I/O 的完成也再次回到 ready 队列，这时 cpu 可能会选择它来执行。</p>
<blockquote>
<p>进行阻塞式 I/O 操作时，Java 的线程状态究竟是什么？是 BLOCKED？还是 WAITING？</p>
</blockquote>
<p>其实状态还是 RUNNABLE。</p>
<p>网络阻塞时同理，比如socket.accept，我们说这是一个“阻塞式(blocked)”式方法，但线程状态还是 RUNNABLE。</p>
<blockquote>
<p>至少我们看到了，进行传统上的 IO 操作时，口语上我们也会说“阻塞”，但这个“阻塞”与线程的 BLOCKED 状态是两码事！</p>
</blockquote>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>首先还是前面说的，注意分清两个层面：</p>
<ul>
<li><p>JVM层面：当进行阻塞式的 IO 操作时，或许底层的操作系统线程确实处在阻塞状态，但我们关心的是 JVM 的线程状态。JVM 把那些都视作资源，cpu 也好，硬盘，网卡也罢，有东西在为线程服务，它就认为线程在“执行”。</p>
</li>
<li><p>操作系统：操作系统的线程状态是围绕着 cpu 这一核心去述说的，这与 JVM 的侧重点是有所不同的。</p>
</li>
</ul>
<p>前面我们也强调了“Java 线程状态的改变通常只与自身显式引入的机制有关”，如果 JVM 中的线程状态发生改变了，通常是自身机制引发的。</p>
<blockquote>
<p>比如 synchronize 机制有可能让线程进入BLOCKED 状态，sleep，wait等方法则可能让其进入 WATING 之类的状态。</p>
</blockquote>
<p>它与传统的线程状态的对应可以如下来看：</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfednyicQRNkh1ibicsEjORXmQPEQSACKpCTzaaLPDxT4MNqw0KgSqLFX6LxM8qFbf61zybHibUGM8n3Cw/640" alt="图片" style="zoom: 50%;" />

<p>RUNNABLE 状态对应了传统的 ready， running 以及部分的 waiting 状态。</p>
<h4 id="BLOCKED-阻塞状态"><a href="#BLOCKED-阻塞状态" class="headerlink" title="BLOCKED: 阻塞状态"></a>BLOCKED: 阻塞状态</h4><p>等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态</p>
<h4 id="WAITING-等待状态"><a href="#WAITING-等待状态" class="headerlink" title="WAITING: 等待状态"></a>WAITING: 等待状态</h4><p>处于等待状态的线程是由于执行了3个方法中的任意方法。 </p>
<ol>
<li>Object.wait() with no timeout</li>
<li>Thread.join() with no timeout</li>
<li>LockSupport.park()</li>
</ol>
<p>处于waiting状态的线程会等待另外一个线程处理特殊的行为。 </p>
<p>再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态</p>
<blockquote>
<p>比如线程处于WAITING状态，这个时候可以分析一下notifyAll或者signalAll方法的调用时机是否不对。</p>
</blockquote>
<h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING:"></a>TIMED_WAITING:</h4><p>有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。  </p>
<ol>
<li><p>Thread.sleep(long millis)</p>
</li>
<li><p>Object.wait(long) with timeout </p>
</li>
<li><p>Thread.join(long) with timeout</p>
</li>
<li><p>LockSupport.parkNanos(Object blocker, long deadline)</p>
</li>
<li><p>LockSupport.parkUntil(long deadline)</p>
</li>
</ol>
<h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>线程中止的状态，这个线程已经完整地执行了它的任务</p>
<h3 id="java线程不同状态之间的转换"><a href="#java线程不同状态之间的转换" class="headerlink" title="java线程不同状态之间的转换"></a>java线程不同状态之间的转换</h3><p><img src="http://f1.babyitellyou.com/sp1/img/20201206/1ed0ebb5d7a15469d852e640d8daa0dd.png" alt="img"></p>
<h4 id="RUNNABLE-gt-BLOCKED状态"><a href="#RUNNABLE-gt-BLOCKED状态" class="headerlink" title="RUNNABLE -&gt; BLOCKED状态"></a>RUNNABLE -&gt; BLOCKED状态</h4><p>代码执行到synchronized代码块和synchronized方法 时候要获取到锁，就变成BLOCKED状态。</p>
<blockquote>
<p><strong>我们平时所谓的 Java 在调用阻塞式 API 时，线程会阻塞，指的是操作系统线程的状态，并不是 Java 线程的状态。</strong></p>
</blockquote>
<h4 id="RUNNABLE-gt-WAITING状态"><a href="#RUNNABLE-gt-WAITING状态" class="headerlink" title="RUNNABLE -&gt; WAITING状态"></a>RUNNABLE -&gt; WAITING状态</h4><p>根据官方文档，线程执行到代码Object#wait()，Thread.join，LockSupport#park()时候线程会转移到该前状态。</p>
<h4 id="RUNNABLE-gt-TIMED-WAITING状态"><a href="#RUNNABLE-gt-TIMED-WAITING状态" class="headerlink" title="RUNNABLE -&gt; TIMED_WAITING状态"></a>RUNNABLE -&gt; TIMED_WAITING状态</h4><p>根据定义线程执行到Thread.sleep(long millis)，Object.wait(long timeout)，Thread.join(long millis)，LockSupport.parkNanos(Object blocker, long deadline)，LockSupport.parkUntil(long deadline)，和waitting相比主要是有个等待时间，且比waiting多了个sleep操作。</p>
<h4 id="BLOCKED-gt-RUNNABLE状态"><a href="#BLOCKED-gt-RUNNABLE状态" class="headerlink" title="BLOCKED -&gt; RUNNABLE状态"></a>BLOCKED -&gt; RUNNABLE状态</h4><p>线程获得 监视器锁(synchronized 隐式锁)时，就又会从 BLOCKED 转换到 RUNNABLE 状态</p>
<h4 id="WAITING-gt-RUNNABLE状态"><a href="#WAITING-gt-RUNNABLE状态" class="headerlink" title="WAITING -&gt; RUNNABLE状态"></a>WAITING -&gt; RUNNABLE状态</h4><p>对于Object.wait()，其它线程执行了同一个对象的Object#notify()或者nofityAll()时候唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<p>对于Thread.join()，其它线程执行完毕或者抛出异常后唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<p>对于LockSupport#park，在别处执行了此Thread的LockSuport#unPark时候唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<h4 id="TIMED-WAITING-gt-RUNNABLE状态"><a href="#TIMED-WAITING-gt-RUNNABLE状态" class="headerlink" title="TIMED_WAITING -&gt; RUNNABLE状态"></a>TIMED_WAITING -&gt; RUNNABLE状态</h4><p>对于Object.wait(long timeout)，线程阻塞timeout时间后，或者在timeout时间内其它线程执行了同一个对象的Object#notify()或者nofityAll()时候唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<p>对于Thread.join(long millis)，线程阻塞millis时间后，或者millis时间内其它线程执行完毕或者抛出异常后唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<p>对于LockSupport.parkNanos(Object blocker, long deadline)和LockSupport.parkUntil(long deadline)，线程阻塞deadline时间后，或者在别处执行了此Thread的LockSuport#unPark时候唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<p>Thread.sleep(long millis)，休眠millis时间后线程自动唤醒，或者线程被打断休眠，也会被唤醒。线程由WAITING -&gt; RUNNABLE。</p>
<h2 id="jstack显示的java线程状态"><a href="#jstack显示的java线程状态" class="headerlink" title="jstack显示的java线程状态"></a>jstack显示的java线程状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack PID(10进制)</span><br></pre></td></tr></table></figure>

<p>生成线程堆栈文件</p>
<blockquote>
<p>java.lang.Thread.State: BLOCKED 线程处于阻塞状态，遇到了synchronized处于阻塞状态</p>
<p>java.lang.Thread.State: RUNNABLE 线程处于正运行状态，或者阻塞在IO状态 </p>
<p>java.lang.Thread.State: TIMED_WAITING (on object monitor) Object.wait(long)加超时时间操作 java.lang.Thread.State: TIMED_WAITING (parking) 通过LockSupport.parkXXX加超时时间操作 java.lang.Thread.State: TIMED_WAITING (sleeping) 通过Thread.sleep加休眠时间操作 </p>
<p>java.lang.Thread.State: WAITING (on object monitor) Object.wait()无超时时间操作 </p>
<p>java.lang.Thread.State: WAITING (parking) 通过LockSupport.park())操作</p>
</blockquote>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>除了Object.nofity()，nofityAll()，LockSupport.unPark(Thread)操作唤醒线程或者超时自动唤醒线程，工作中也经常使用到interrupt() 方法对阻塞中的线程(WAITING、TIMED_WAITING 状态)进行中断，以便使线程从阻塞(WAITING、TIMED_WAITING 状态)中被唤醒。interrupt()操作是给正在处于阻塞状态的线程发个中断通知，以便线程从阻塞中唤醒过来。</p>
<p>线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的 interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态(中间可能存在BLOCKED状态)，同时线程 A 的代码会触发 InterruptedException 异常。通过查看Object.wait()，Thread.join()方法上都有throws InterruptedException。这个异常的触发条件就是：其他线程调用了该线程的 interrupt() 方法。</p>
<p>当RUNNABLE状态线程在阻塞到IO操作时候，此时线程状态还是RUNNABLE ，但是实际在linux线程模型中是阻塞状态，比如线程A阻塞在 java.nio.channels.Selector.select() 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 的 java.nio.channels.Selector 会立即返回。</p>
<h2 id="线程池内线程的状态"><a href="#线程池内线程的状态" class="headerlink" title="线程池内线程的状态"></a>线程池内线程的状态</h2><ul>
<li><p>预热阶段，线程状态也是从NEW-&gt;RUNNABLE-BLOCKED/WAITING/TIMED_WAITING状态</p>
</li>
<li><p>线程池活动达到core线程后，接入的请求都会存放到队列内，如果队列内任务为空，那么Worker线程getTask()阻塞，处于waiting状态</p>
</li>
</ul>
<p><img src="http://f1.babyitellyou.com/sp1/img/20201206/87d263be12c962900f8a33fa6b68e264.png" alt="img"></p>
<p>其中代码@1和@2底层都是使用的LockSupport.park()挂起线程 <!--ReentrantLock锁--> ，因此，线程池内的线程空闲时候，线程状态是waiting状态。</p>
<p>验证如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocateServiceImpl</span> <span class="keyword">implements</span> <span class="title">AllocateService</span>, <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor pool;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().</span><br><span class="line">                setNameFormat(<span class="string">&quot;my-pool-%d&quot;</span>).build();</span><br><span class="line">        pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">60L</span>, TimeUnit.MINUTES, </span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">1024</span>), threadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        pool.prestartAllCoreThreads();<span class="comment">//启动所有线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动后使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack pid</span><br></pre></td></tr></table></figure>

<p>验证截图如下</p>
<p><img src="http://f1.babyitellyou.com/sp1/img/20201206/8484f37a0899c7617f7fc4e9db310e82.png" alt="img"></p>
<h2 id="JVM线程状态与cpu关系"><a href="#JVM线程状态与cpu关系" class="headerlink" title="JVM线程状态与cpu关系"></a>JVM线程状态与cpu关系</h2><blockquote>
<p>NEW 这线程刚创建，还未执行, CPU=0%</p>
<p>RUNNABLE 线程处于可运行状态，但是实际可能是正在运行或者等待io资源，因此不能完全确定是否在使用cpu资源。 </p>
<p>BLOCKED 线程阻塞状态，肯定不会使用cpu资源 </p>
<p>WAITING 线程休眠状态，肯定不会使用cpu资源 </p>
<p>TIMED_WAITING 线程休眠状态，肯定不会使用cpu资源</p>
</blockquote>
<p>通过上面分析，在分析cpu100%问题时候，<code>jstack PID</code> 后，只需要查看dump结果中处于RUNNABLE状态的线程即可，但是处于RUNNABLE状态的线程，不代表就一定正在使用cpu资源，因此要特定分析（通过代码分析）。通常是通过top -Hp PID确定使用cpu资源高的线程后，再通过多次jstack操作，查看哪些线程堆栈一直处于RUNNABLE。</p>
<p>举例如下：</p>
<p>1.处于waiting，timed_waiting，blocked状态肯定不消化cpu，如下图，分析cpu时候忽略这些线程</p>
<p><img src="http://f1.babyitellyou.com/sp1/img/20201206/7cbd9e0e3d0429f3457a83cc93986736.png" alt="img"></p>
<p>2.比如下面这个，虽然处于RUNNABLE状态，实际上是阻塞在监听接入连接上（阻塞在网络IO上），因此实际是不使用cpu资源</p>
<p><img src="http://f1.babyitellyou.com/sp1/img/20201206/aac05a22a9f161e09ff13ccd498d4e3c.png" alt="img"></p>
<p>3.如下图这个，线程状态是RUNNABLE，这里是使用正则表达式解析，正在使用cpu资源</p>
<p><img src="http://f1.babyitellyou.com/sp1/img/20201206/ce38281f97a1a12abb4811f2b11f94d6.png" alt="img"></p>
<h2 id="JVM线程状态与锁的关系"><a href="#JVM线程状态与锁的关系" class="headerlink" title="JVM线程状态与锁的关系"></a>JVM线程状态与锁的关系</h2><p>sleep、wait、join都会使线程进入阻塞状态(waiting/timed_waiting状态)，同时也都会释放cpu资源</p>
<blockquote>
<p>yield是释放cpu资源，然后又抢夺cpu资源，目的是为了让其它线程有机会获取cpu资源进行处理，但是线程状态还是runnable。</p>
</blockquote>
<p>sleep如果是在锁方法内执行，比如同步代码块或者重入锁方法内执行，是不会释放锁。而wait会释放锁。</p>
<ul>
<li>wait用于锁机制，sleep不是，这也是为什么sleep不释放锁，wait释放锁的原因，</li>
<li>sleep是线程的方法，跟锁没关系，</li>
<li>wait，notify，notifyall 都是Object对象的方法，是一起使用的，用于锁机制。</li>
</ul>
<p>有个特殊的Thread.sleep(0)，操作这个动作是让出cpu，让其它线程又机会获取cpu资源执行</p>
<h3 id="wait-和sleep"><a href="#wait-和sleep" class="headerlink" title="wait()和sleep()"></a>wait()和sleep()</h3><p>前面synchronized关键字的用法讲完了，该轮到wait和sleep了。可能会有点好奇，为什么wait和sleep要一块讲？因为我一开始也搞不懂他们的区别，只知道wait()是Object类的实例方法，sleep()是Thread类的实例方法。作用都是使让代码停下来。</p>
<p>但后来研究了下，两者使用起来还是有一定的差别的。</p>
<p>首先，wait必须要在获得了当前对象的对象锁代码块中执行（可以理解为调用哪个对象的wait方法，调用的时候就要处于哪个对象的同步代码块中），而sleep则没有这个限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wait(); <span class="comment">//可以 没问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wait(); <span class="comment">//不可以，没有处于this的同步代码块中，抛出IllegalMonitorStateException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(其他对象) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait() <span class="comment">// 不可以，这里只获得了其他对象的锁，但是却调用了this的wait，抛出IllegalMonitorStateException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(其他对象) &#123;</span><br><span class="line">        其他对象.wait() <span class="comment">// 可以，没问题，不一定非得是this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也许你注意到了，wait()必须配合synchronized使用？为什么呢？那就是wait()有个很有意思的特性，<strong>执行wait()后的睡眠期间，会释放掉通过synchronized获得的锁，直到被唤醒的时候会重新获得锁</strong>，而sleep()会在线程睡眠期间依然持有这个锁，也就是说，在同步代码块中用wait()睡眠后，其他线程也能够获得对象的锁。</p>
<p>wait()的睡眠状态被notity()或notifyAll()唤醒时，不会抛出异常，sleep()导致的睡眠只能被interrupt()方法唤醒，同时sleep()会抛出异常，若interrupt()唤醒的是由wait()导致的睡眠，wait()同样会抛出异常。</p>
<p>同时，由于wait()会释放掉锁，因此一个对象中可能会同时存在多个线程由于wait()导致的睡眠</p>
<h3 id="notify-与notifyAll"><a href="#notify-与notifyAll" class="headerlink" title="notify()与notifyAll()"></a>notify()与notifyAll()</h3><p>notify()会将对象的一个线程从wait()导致的睡眠状态中唤醒，至于是哪个线程，则是随机的。</p>
<p>而notifyAll()则是唤醒对象所有由于wait()导致的睡眠。由于wait()被唤醒后会对对象加锁，如果没能拿到锁会暂时先阻塞着直到有机会拿到锁，因此依然是线程安全的。</p>
<h3 id="简易消息队列的实现"><a href="#简易消息队列的实现" class="headerlink" title="简易消息队列的实现"></a>简易消息队列的实现</h3><p>现在就利用上面的特性，实现一个简单的阻塞型消息队列吧。</p>
<p>消息队列是一个典型的消费者-生产者模型，当消费者消费时，若消息队列为空，则一直等待（阻塞执行），直到生产者生产了一个消息，此时消费者阻塞消除并获得一个消息</p>
<p>这里阻塞的关键是队列空时等待，非空时唤醒</p>
<p>消息队列类完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用锁实现的消息队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列关闭标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 使用链表作为消息容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg   消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取链表的锁之后，向链表添加消息，最后尝试唤醒链表对象（如果在等待的话）</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;消息队列已关闭&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(msg);</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭消息队列，并唤醒消费者的等待（如果在等待的话）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            stop = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费消息，若无消息将会一直阻塞，直到有消息或队列关闭，若消息队列已关闭则不再阻塞且返回null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 拿到的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取对象的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> queue.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stop &amp;&amp; queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 由于关闭队列也有可能退出上面的循环，所以要再判断一次长度</span></span><br><span class="line">                <span class="keyword">if</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> queue.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MessageQueue mq = <span class="keyword">new</span> MessageQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开1个线程消费消息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               String msg = mq.consume();</span><br><span class="line">               System.out.println(<span class="string">&quot;消费消息：&quot;</span> + msg);</span><br><span class="line">               <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;队列关闭&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            mq.product(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产消息：&quot;</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mq.stop();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行可以观察到每0.1秒生产一个消息，紧接着就被消费，最后程序退出 </p>
<h2 id="线程中断-1"><a href="#线程中断-1" class="headerlink" title="线程中断"></a>线程中断</h2><h3 id="3个中断相关的方法"><a href="#3个中断相关的方法" class="headerlink" title="3个中断相关的方法"></a>3个中断相关的方法</h3><p> 停止一个线程意味着在任务处理完任务之前停掉正在做的操作，也就是放弃当前的操作。</p>
<p>在java中有以下3种方法可以终止正在运行的线程：</p>
<ol>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li>
<li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</li>
<li>使用interrupt方法中断线程。</li>
</ol>
<h4 id="Method1-interrupt-中断线程-软中断"><a href="#Method1-interrupt-中断线程-软中断" class="headerlink" title="Method1: interrupt()中断线程(软中断)"></a>Method1: interrupt()中断线程(软中断)</h4><blockquote>
<p>Interrupts this thread.<br>Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.</p>
<p>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</p>
</blockquote>
<p>调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程，无法硬中断线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span>+(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：可以看到线程继续运行，并没有中断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">i&#x3D;499998</span><br><span class="line">i&#x3D;499999</span><br><span class="line">i&#x3D;500000</span><br></pre></td></tr></table></figure>

<h4 id="Method2-静态方法interrupted-判断当前线程是否中断状态"><a href="#Method2-静态方法interrupted-判断当前线程是否中断状态" class="headerlink" title="Method2: 静态方法interrupted()判断当前线程是否中断状态"></a>Method2: 静态方法interrupted()判断当前线程是否中断状态</h4><blockquote>
<p>Tests whether the current thread has been interrupted. <font color='red'>The interrupted status of the thread is cleared by this method. In other words, if this method were to be called twice in succession, the second call would return false</font>&gt; (unless the current thread were interrupted again, after the first call had cleared its interrupted status and before the second call had examined it).<br>A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.<br>Returns:<br>true if the current thread has been interrupted; false otherwise.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> interrupted&#123;</span><br><span class="line">	<span class="keyword">return</span> currentThread().isInterrputed(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interrupted(): 测试<font color='red'>当前线程</font>是否已经中断，线程的中断状态由该方法清除。 换句话说，如果连续两次调用该方法，则第二次调用返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;stop 1??&quot;</span> + thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">&quot;stop 2??&quot;</span> + thread.interrupted());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop 1??false</span><br><span class="line">stop 2??false</span><br></pre></td></tr></table></figure>

<p>类Run.java中虽然是在thread对象上调用以下代码：thread.interrupt(), 后面又使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;stop 1??&quot; + thread.interrupted());</span><br><span class="line">System.out.println(&quot;stop 2??&quot; + thread.interrupted());</span><br></pre></td></tr></table></figure>

<p>来判断thread对象所代表的线程是否停止，但从控制台打印的结果来看，线程并未停止，这也证明了interrupted()方法的解释，测试<a href="">当前线程</a>是否已经中断。这个当前线程是main主线程，它从未中断过，而是子线程thread中断了，所以打印的结果是两个false.</p>
<p>如何使main线程产生中断效果呢？就是把thread.interrupt改为main线程interrupt <!--Thread.currentThread()获取当前main线程--></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;stop 1??&quot;</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;stop 2??&quot;</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop 1??true</span><br><span class="line">stop 2??false</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p>方法interrupted()的确判断出当前线程是否是停止状态。</p>
<h4 id="Method3-isInterrupted-判断线程是否中断状态"><a href="#Method3-isInterrupted-判断线程是否中断状态" class="headerlink" title="Method3: isInterrupted()判断线程是否中断状态"></a>Method3: isInterrupted()判断线程是否中断状态</h4><blockquote>
<p>Tests whether this thread has been interrupted. <font color='red'>The interrupted status of the thread is unaffected by this method.</font><br>A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.<br>Returns:<br>true if this thread has been interrupted; false otherwise.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isInterrupted&#123;</span><br><span class="line">	<span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span></span><br></pre></td></tr></table></figure>

<p>isInterrupted()并<font color='red'>不清除中断状态</font>,所有连续2次调用并不清除中断状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;stop 1??&quot;</span> + thread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;stop 2??&quot;</span> + thread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop 1??true</span><br><span class="line">stop 2??true</span><br></pre></td></tr></table></figure>

<h3 id="捕获中断状态"><a href="#捕获中断状态" class="headerlink" title="捕获中断状态"></a>捕获中断状态</h3><h4 id="通过判断中断状态，抛出异常，停止线程"><a href="#通过判断中断状态，抛出异常，停止线程" class="headerlink" title="通过判断中断状态，抛出异常，停止线程"></a>通过判断中断状态，抛出异常，停止线程</h4><p>在线程中用for语句来判断一下线程是否是停止状态，如果是停止状态，则后面的代码不再运行即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程已经终止， for循环不再执行&quot;</span>);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span>+(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;这是for循环外面的语句，也会被执行&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入MyThread.java类中的catch了。。。&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>建议使用“抛异常”的方法来实现线程的停止，因为在catch块中还可以将异常向上抛，使线程停止事件得以传播。</p>
</blockquote>
<h4 id="通过捕获InterruptedException停止"><a href="#通过捕获InterruptedException停止" class="headerlink" title="通过捕获InterruptedException停止"></a>通过捕获InterruptedException停止</h4><p>如果线程在sleep()状态下停止线程，会是什么效果呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程开始。。。&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在沉睡中被停止, 进入catch， 调用isInterrupted()方法的结果是：&quot;</span> + <span class="keyword">this</span>.isInterrupted());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Run.java运行的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程开始。。。</span><br><span class="line">在沉睡中被停止, 进入catch， 调用isInterrupted()方法的结果是：false</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native Method)</span><br><span class="line"> at thread.MyThread.run(MyThread.java:12)</span><br></pre></td></tr></table></figure>

<p>从打印的结果来看， 如果在sleep状态下停止某一线程，会进入catch语句，并且清除停止状态值，使之变为false。</p>
<p>前一个实验是先sleep然后再用interrupt()停止，与之相反的操作在学习过程中也要注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程开始。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;先停止，再遇到sleep，进入catch异常&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i&#x3D;9998</span><br><span class="line">i&#x3D;9999</span><br><span class="line">先停止，再遇到sleep，进入catch异常</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native Method)</span><br><span class="line"> at thread.MyThread.run(MyThread.java:15)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-lang-Thread/" data-id="cm6lsyz5n0066k2dlfvj5h85d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法/排序算法/堆排序(stack-sorting)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/28/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F(stack-sorting)/" class="article-date">
  <time datetime="2021-05-28T02:59:50.000Z" itemprop="datePublished">2021-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/28/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F(stack-sorting)/">堆排序(stack-sorting)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/28/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F(stack-sorting)/" data-id="cm6lsyz5f0046k2dlhf0jem4y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-中间件/Kafka/kafka-03-解决顺序性和消息挤压" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-03-%E8%A7%A3%E5%86%B3%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%92%8C%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B/" class="article-date">
  <time datetime="2021-05-27T11:20:31.000Z" itemprop="datePublished">2021-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-03-%E8%A7%A3%E5%86%B3%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%92%8C%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B/">kafka-03-保障消息有序性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h2><h3 id="为什么要保证消息的顺序"><a href="#为什么要保证消息的顺序" class="headerlink" title="为什么要保证消息的顺序"></a>为什么要保证消息的顺序</h3><p>订单有很多状态，比如：下单、支付、完成、撤销等，不可能<code>下单</code>的消息都没读取到，就先读取<code>支付</code>或<code>撤销</code>的消息吧，如果真的这样，数据产生错乱</p>
<h3 id="如何保证消息顺序"><a href="#如何保证消息顺序" class="headerlink" title="如何保证消息顺序"></a>如何保证消息顺序</h3><h4 id="方案1：producer端只写固定的partition（有缺陷）"><a href="#方案1：producer端只写固定的partition（有缺陷）" class="headerlink" title="方案1：producer端只写固定的partition（有缺陷）"></a>方案1：producer端只写固定的partition（有缺陷）</h4><p><code>kafka</code>的<code>topic</code>是无序的，但是一个<code>topic</code>包含多个<code>partition</code>，每个<code>partition</code>内部是有序的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqOzug1A48UnG15tonQ3wBkbB5yicVnHpydn5Hq2PwiawKTVj8Vk6DB7sQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>只要保证生产者写消息时，按照一定的规则写到同一个<code>partition</code>，不同的消费者读不同的<code>partition</code>的消息，就能保证生产和消费者消息的顺序。</p>
<p>同一个<code>商户编号</code>的消息写到同一个<code>partition</code>，<code>topic</code>中创建了<code>4</code>个<code>partition</code>，然后部署了<code>4</code>个消费者节点，构成<code>消费者组</code>，一个<code>partition</code>对应一个消费者节点。从理论上说，这套方案是能够保证消息顺序的。<img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqrza43TUBKePfwRPaSrtSJiclN6ibdof2qKwyhIfGoicR4Z6C2icQP5vWuA/640" alt="Image"></p>
<p><strong>优点</strong></p>
<ul>
<li>保障了producer发送信息的时候，是有序的</li>
</ul>
<p><strong>缺陷</strong></p>
<ul>
<li>不能保障Topic的partition接收信息，是有序的。比如，公司在那段时间网络经常不稳定，业务接口时不时报超时，业务请求时不时会连不上数据库，某条数据丢失了；还有，因为网络原因，最早发送的信息，最晚被topic接收 <!--不过，可以通过topic发送ack解决--></li>
</ul>
<h4 id="方案2：producer端异步失败重试，consumer端做判断"><a href="#方案2：producer端异步失败重试，consumer端做判断" class="headerlink" title="方案2：producer端异步失败重试，consumer端做判断"></a>方案2：producer端异步失败重试，consumer端做判断</h4><p><code>同步重试机制</code>在出现异常的情况，会严重影响消息消费者的消费速度，降低它的吞吐量。</p>
<p>如果用<code>异步重试机制</code>，处理失败的消息就得保存到<code>重试表</code>下来。</p>
<p>但有个新问题立马出现：<strong>只存一条消息如何保证顺序？</strong></p>
<p>存一条消息的确无法保证顺序，假如：”下单“消息失败了，还没来得及异步重试。此时，”支付“消息被消费了，它肯定是不能被正常消费的。</p>
<p>这时有种更简单的方案浮出水面：消费者在处理消息时，先判断该<code>订单号</code>在<code>重试表</code>有没有数据，如果有则直接把当前消息保存到<code>重试表</code>。如果没有，则进行业务处理，如果出现异常，把该消息保存到<code>重试表</code>。</p>
<p>后来我们用<code>elastic-job</code>建立了<code>失败重试机制</code>，如果重试了<code>7</code>次后还是失败，则将该消息的状态标记为<code>失败</code>，发邮件通知开发人员。</p>
<h2 id="消息挤压"><a href="#消息挤压" class="headerlink" title="消息挤压"></a>消息挤压</h2><h3 id="挤压原因1：消息体过大"><a href="#挤压原因1：消息体过大" class="headerlink" title="挤压原因1：消息体过大"></a>挤压原因1：消息体过大</h3><p>一次简单的消息从生产到消费过程，需要经过<code>2次网络IO</code>和<code>2次磁盘IO</code>。如果消息体过大，势必会增加IO的耗时，进而影响kafka生产和消费的速度。消费者速度太慢的结果，就会出现消息积压情况。</p>
<p>可以这样设计了：</p>
<ol>
<li>订单系统发送的消息体只用包含：id和状态等关键信息。</li>
<li>后厨显示系统消费消息后，通过id调用订单系统的订单详情查询接口获取数据。</li>
<li>后厨显示系统判断数据库中是否有该订单的数据，如果没有则入库，有则更新。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqib2hB0qSIXBPjxAH1vZQbn97tcMKQBmWBDL1Rc1ytjLXoXcCPic301pQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="挤压原因2：路由规则不合理"><a href="#挤压原因2：路由规则不合理" class="headerlink" title="挤压原因2：路由规则不合理"></a>挤压原因2：路由规则不合理</h3><p>不是所有<code>partition</code>上的消息都有积压，而是只有一个。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqdaENvsBRclJSZ2zvNoXxfpDS9IgJvpM6icibHB8Y32Jt4khMicw7wictmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>刚开始，我以为是消费那个<code>partition</code>消息的节点出了什么问题导致的。但是经过排查，没有发现任何异常。</p>
<p>发现，有几个商户的订单量特别大，刚好这几个商户被分到同一个<code>partition</code>，使得该<code>partition</code>的消息量比其他<code>partition</code>要多很多。</p>
<p>这时我们才意识到，发消息时按<code>商户编号</code>路由<code>partition</code>的规则不合理，可能会导致有些<code>partition</code>消息太多，消费者处理不过来，而有些<code>partition</code>却因为消息太少，消费者出现空闲的情况。</p>
<p>为了避免出现这种分配不均匀的情况，我们需要对发消息的路由规则做一下调整。</p>
<p>用订单号做路由相对更均匀，不会出现单个订单发消息次数特别多的情况。除非是遇到某个人一直加菜的情况，但是加菜是需要花钱的，所以其实同一个订单的消息数量并不多。调整后按<code>订单号</code>路由到不同的<code>partition</code>，同一个订单号的消息，每次到发到同一个<code>partition</code>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqoJO69ia8Fv9p1uc0HEHaJcYg85VaBlsHm25ubexHCFmmicbVWsN6IACA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="如何处理消息挤压？"><a href="#如何处理消息挤压？" class="headerlink" title="如何处理消息挤压？"></a>如何处理消息挤压？</h3><p>每个<code>partition</code>都积压了<code>十几万</code>的消息没有消费，比以往加压的消息数量增加了<code>几百倍</code>。</p>
<p>原来是有其他业务在JOB中批量发消息导致的问题导致。</p>
<p><strong>积压的这<code>十几万</code>的消息该如何处理呢？</strong></p>
<ul>
<li><p>直接调大<code>partition</code>数量是不行的，历史消息已经存储到4个固定的<code>partition</code>，只有新增的消息才会到新的<code>partition</code>。我们重点需要处理的是已有的partition。</p>
</li>
<li><p>直接加<code>consumer</code>服务节点也不行，因为<code>kafka</code>允许同topic的多个<code>partition</code>被一个<code>consumer</code>消费，但不允许一个<code>partition</code>被同组的多个<code>consumer</code>消费，可能会造成资源浪费。</p>
</li>
<li><p>用多线程处理，改成了用<code>线程池</code>处理消息，核心线程和最大线程数都配置成了<code>50</code>。线程数是可以通过<code>zookeeper</code>动态调整的</p>
</li>
</ul>
<img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqt9gnrBjrNqmrxqjJlghuZszz8ibdGic6KbthGAdYX8yqkSibxFlH1ibFeA/640" alt="图片" style="zoom:50%;" />

<p>顺便说一下，<a href="">对于要求严格保证消息顺序的场景，可以将线程池改成多个队列，每个队列用单线程处理</a>。</p>
<h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p><code>kafka</code>消费消息时支持三种模式：</p>
<ul>
<li>at most once模式 最多一次。保证每一条消息commit成功之后，再进行消费处理。消息可能会丢失，但不会重复。</li>
<li>at least once模式 至少一次。保证每一条消息处理成功之后，再进行commit。消息不会丢失，但可能会重复。</li>
<li>exactly once模式 精确传递一次。将offset作为唯一id与消息同时处理，并且保证处理的原子性。消息只会处理一次，不丢失也不会重复。但这种方式很难做到。</li>
</ul>
<p><code>kafka</code>默认的模式是<code>at least once</code>，但这种模式可能会产生<a href="">重复消费</a>的问题，所以我们的业务逻辑必须做<a href="">幂等设计</a>。</p>
<p>而我们的业务场景保存数据时使用了<code>INSERT INTO ...ON DUPLICATE KEY UPDATE</code>语法，不存在时插入，存在时更新，是天然支持幂等性的。</p>
<h2 id="多环境消费问题"><a href="#多环境消费问题" class="headerlink" title="多环境消费问题"></a>多环境消费问题</h2><p>我们当时线上环境分为：<code>pre</code>(预发布环境) 和 <code>prod</code>(生产环境)，两个环境共用同一个数据库，并且共用同一个kafka集群。</p>
<p>需要注意的是，在配置<code>kafka</code>的<code>topic</code>的时候，要加前缀用于区分不同环境。pre环境的以pre_开头，比如：pre_order，生产环境以prod_开头，比如：prod_order，防止消息在不同环境中串了。</p>
<p>但有次运维在<code>pre</code>环境切换节点，配置<code>topic</code>的时候，配错了，配成了<code>prod</code>的<code>topic</code>。刚好那天，我们有新功能上<code>pre</code>环境。结果悲剧了，<code>prod</code>的有些消息被<code>pre</code>环境的<code>consumer</code>消费了，而由于消息体做了调整，导致<code>pre</code>环境的<code>consumer</code>处理消息一直失败。</p>
<p>其结果是生产环境丢了部分消息。不过还好，最后生产环境消费者通过重置<code>offset</code>，重新读取了那一部分消息解决了问题，没有造成太大损失。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-03-%E8%A7%A3%E5%86%B3%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%92%8C%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B/" data-id="cm6lsyz5g004ik2dl9htw4y7g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/开源项目/任务调度框架/Quartz-集群原理分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/Quartz-%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2021-05-26T06:44:16.000Z" itemprop="datePublished">2021-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/Quartz-%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">Quartz-集群原理分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Quartz集群部署实践"><a href="#Quartz集群部署实践" class="headerlink" title="Quartz集群部署实践"></a>Quartz集群部署实践</h2><p>CRM中Quartz与Spring结合使用，Spring通过提供org.springframework.scheduling.quartz下的封装类对Quartz支持。</p>
<p><strong>Quartz集群部署：</strong></p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/c45f767d.png" alt="Quartz集群部署"></p>
<p>Quartz集群中的每个节点是一个独立的Quartz应用，它又管理着其他的节点。该集群需要分别对每个节点分别启动或停止，不像应用服务器的集群，独立的Quartz节点并不与另一个节点或是管理节点通信。Quartz应用是通过数据库表来感知到另一应用。只有使用持久的JobStore才能完成Quqrtz集群。</p>
<p><strong>基于Spring的集群配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 调度工厂 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;quartzScheduler&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;quartzProperties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.scheduler.instanceName&quot;</span>&gt;</span>CRMscheduler<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.scheduler.instanceId&quot;</span>&gt;</span>AUTO<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 线程池配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.threadPool.class&quot;</span>&gt;</span>org.quartz.simpl.SimpleThreadPool<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.threadPool.threadCount&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.threadPool.threadPriority&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- JobStore 配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.class&quot;</span>&gt;</span>org.quartz.impl.jdbcjobstore.JobStoreTX<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 集群配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.isClustered&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.clusterCheckinInterval&quot;</span>&gt;</span>15000<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.maxMisfiresToHandleAtATime&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.misfireThreshold&quot;</span>&gt;</span>120000<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.tablePrefix&quot;</span>&gt;</span>QRTZ_<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schedulerName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CRMscheduler&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--必须的，QuartzScheduler 延时启动，应用启动完后 QuartzScheduler 再启动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;startupDelay&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;applicationContextSchedulerContextKey&quot;</span> <span class="attr">value</span>=<span class="string">&quot;applicationContextKey&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--可选，QuartzScheduler 启动时更新己存在的Job，这样就不用每次修改targetObject后删除qrtz_job_details表对应记录了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;overwriteExistingJobs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置自动启动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoStartup&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册触发器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;triggers&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;userSyncScannerTrigger&quot;</span> /&gt;</span></span><br><span class="line">                     ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册jobDetail --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jobDetails&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schedulerListeners&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;quartzExceptionSchedulerListener&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.class属性为JobStoreTX，将任务持久化到数据中。因为集群中节点依赖于数据库来传播Scheduler实例的状态，你只能在使用JDBC JobStore时应用Quartz集群。</span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.isClustered属性为true，通知Scheduler实例要它参与到一个集群当中。</span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.clusterCheckinInterval属性定义了Scheduler实例检入到数据库中的频率(单位：毫秒)。Scheduler检查是否其他的实例到了它们应当检入的时候未检入；这能指出一个失败的Scheduler实例，且当前 Scheduler会以此来接管任何执行失败并可恢复的Job。通过检入操作，Scheduler 也会更新自身的状态记录。clusterChedkinInterval越小，Scheduler节点检查失败的Scheduler实例就越频繁。默认值是 15000 (即15 秒)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Quartz集群原理分析"><a href="#Quartz集群原理分析" class="headerlink" title="Quartz集群原理分析"></a>Quartz集群原理分析</h2><h3 id="Quartz集群数据库表"><a href="#Quartz集群数据库表" class="headerlink" title="Quartz集群数据库表"></a>Quartz集群数据库表</h3><p>Quartz的集群部署方案在架构上是分布式的，没有负责集中管理的节点，而是利用数据库锁的方式来实现集群环境下进行并发控制。BTW，分布式部署时需要保证各个节点的系统时间一致。</p>
<p>Quartz数据库核心表如下：</p>
<table>
<thead>
<tr>
<th align="left">Table Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">QRTZ_CALENDARS</td>
<td align="left">存储Quartz的Calendar信息</td>
</tr>
<tr>
<td align="left">QRTZ_CRON_TRIGGERS</td>
<td align="left">存储CronTrigger，包括Cron表达式和时区信息</td>
</tr>
<tr>
<td align="left">QRTZ_FIRED_TRIGGERS</td>
<td align="left">存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息</td>
</tr>
<tr>
<td align="left">QRTZ_PAUSED_TRIGGER_GRPS</td>
<td align="left">存储已暂停的Trigger组的信息</td>
</tr>
<tr>
<td align="left">QRTZ_SCHEDULER_STATE</td>
<td align="left">存储少量的有关Scheduler的状态信息，和别的Scheduler实例</td>
</tr>
<tr>
<td align="left"><strong>QRTZ_LOCKS</strong></td>
<td align="left"><strong>存储程序的悲观锁的信息</strong></td>
</tr>
<tr>
<td align="left">QRTZ_JOB_DETAILS</td>
<td align="left">存储每一个已配置的Job的详细信息</td>
</tr>
<tr>
<td align="left">QRTZ_JOB_LISTENERS</td>
<td align="left">存储有关已配置的JobListener的信息</td>
</tr>
<tr>
<td align="left">QRTZ_SIMPLE_TRIGGERS</td>
<td align="left">存储简单的Trigger，包括重复次数、间隔、以及已触的次数</td>
</tr>
<tr>
<td align="left">QRTZ_BLOG_TRIGGERS</td>
<td align="left">Trigger作为Blob类型存储</td>
</tr>
<tr>
<td align="left">QRTZ_TRIGGER_LISTENERS</td>
<td align="left">存储已配置的TriggerListener的信息</td>
</tr>
<tr>
<td align="left">QRTZ_TRIGGERS</td>
<td align="left">存储已配置的Trigger的信息</td>
</tr>
</tbody></table>
<p>其中，QRTZ_LOCKS就是Quartz集群实现同步机制的行锁表，其表结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--QRTZ_LOCKS表结构</span><br><span class="line">CREATE TABLE &#96;QRTZ_LOCKS&#96; (</span><br><span class="line">  &#96;LOCK_NAME&#96; varchar(40) NOT NULL,</span><br><span class="line">   PRIMARY KEY (&#96;LOCK_NAME&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">--QRTZ_LOCKS记录</span><br><span class="line">+-----------------+ </span><br><span class="line">| LOCK_NAME       |</span><br><span class="line">+-----------------+ </span><br><span class="line">| CALENDAR_ACCESS |</span><br><span class="line">| JOB_ACCESS      |</span><br><span class="line">| MISFIRE_ACCESS  |</span><br><span class="line">| STATE_ACCESS    |</span><br><span class="line">| TRIGGER_ACCESS  |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>

<p>可以看出QRTZ_LOCKS中有5条记录，代表5把锁，分别用于实现多个Quartz Node对Job、Trigger、Calendar访问的同步控制。</p>
<h3 id="Quartz线程模型"><a href="#Quartz线程模型" class="headerlink" title="Quartz线程模型"></a>Quartz线程模型</h3><p>在Quartz中有两类线程：Scheduler调度线程和任务执行线程。</p>
<ul>
<li><p>调度主线程(QuartzSchedulerThread)：QuartzScheduler被创建时创建一个QuartzSchedulerThread实例。</p>
</li>
<li><p>任务执行线程：Quartz不会在主线程(QuartzSchedulerThread)中处理用户的Job。Quartz把线程管理的职责委托给ThreadPool，一般的设置使用SimpleThreadPool。SimpleThreadPool创建了一定数量的WorkerThread实例来使得Job能够在线程中进行处理。WorkerThread是定义在SimpleThreadPool类中的内部类，它实质上就是一个线程。例如，CRM中配置如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 线程池配置 --&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.threadPool.class&quot;&gt;org.quartz.simpl.SimpleThreadPool&lt;&#x2F;prop&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.threadPool.threadCount&quot;&gt;20&lt;&#x2F;prop&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.threadPool.threadPriority&quot;&gt;5&lt;&#x2F;prop&gt;</span><br></pre></td></tr></table></figure>



<h3 id="集群源码分析"><a href="#集群源码分析" class="headerlink" title="集群源码分析"></a>集群源码分析</h3><p>Quartz究竟是如何保证集群情况下trgger处理的信息同步？</p>
<p>下面跟着源码一步一步分析，调度主线程(QuartzSchedulerThread)包含有决定何时下一个Job将被触发的处理循环，主要逻辑在其run()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> lastAcquireFailed = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">while</span> (!halted.get()) &#123;</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();</span><br><span class="line">     <span class="keyword">if</span>(availThreadCount &gt; <span class="number">0</span>) &#123; </span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="comment">//调度器在trigger队列中寻找30秒内一定数目的trigger(需要保证集群节点的系统时间一致)</span></span><br><span class="line">     triggers = qsRsrcs.getJobStore().acquireNextTriggers(</span><br><span class="line">                            now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="comment">//触发trigger</span></span><br><span class="line">     List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers);</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="comment">//释放trigger</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; triggers.size(); i++) &#123;</span><br><span class="line">         qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可知，QuartzScheduler调度线程不断获取trigger，触发trigger，释放trigger。下面分析trigger的获取过程，qsRsrcs.getJobStore()返回对象是JobStore，集群环境配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- JobStore 配置 --&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.jobStore.class&quot;&gt;org.quartz.impl.jdbcjobstore.JobStoreTX&lt;&#x2F;prop&gt;</span><br></pre></td></tr></table></figure>

<p>JobStoreTX继承自JobStoreSupport，而JobStoreSupport的acquireNextTriggers、triggersFired、releaseAcquiredTrigger方法负责具体trigger相关操作，都必须获得TRIGGER_ACCESS锁。核心逻辑在executeInNonManagedTXLock方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">executeInNonManagedTXLock</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String lockName, </span></span></span><br><span class="line"><span class="function"><span class="params">        TransactionCallback&lt;T&gt; txCallback, <span class="keyword">final</span> TransactionValidator&lt;T&gt; txValidator)</span> <span class="keyword">throws</span> JobPersistenceException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> transOwner = <span class="keyword">false</span>;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getLockHandler().requiresConnection()) &#123;</span><br><span class="line">                conn = getNonManagedTXConnection();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取锁</span></span><br><span class="line">            transOwner = getLockHandler().obtainLock(conn, lockName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn = getNonManagedTXConnection();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> T result = txCallback.execute(conn);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            commitConnection(conn);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JobPersistenceException e) &#123;</span><br><span class="line">            rollbackConnection(conn);</span><br><span class="line">            <span class="keyword">if</span> (txValidator == <span class="keyword">null</span> || !retryExecuteInNonManagedTXLock(lockName, <span class="keyword">new</span> TransactionCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">execute</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> JobPersistenceException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> txValidator.validate(conn, result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long sigTime = clearAndGetSignalSchedulingChangeOnTxCompletion();</span><br><span class="line">        <span class="keyword">if</span>(sigTime != <span class="keyword">null</span> &amp;&amp; sigTime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            signalSchedulingChangeImmediately(sigTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JobPersistenceException e) &#123;</span><br><span class="line">        rollbackConnection(conn);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        rollbackConnection(conn);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JobPersistenceException(<span class="string">&quot;Unexpected runtime exception: &quot;</span></span><br><span class="line">                + e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            releaseLock(lockName, transOwner);      <span class="comment">//释放锁</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cleanupConnection(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上代码可知Quartz集群基于数据库锁的同步操作流程如下图所示：</p>
<img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/05dac2dd.png" alt="Quartz集群基于锁的同步方案" style="zoom: 67%;" />





<p>一个调度器实例在执行涉及到分布式问题的数据库操作前，首先要获取QUARTZ_LOCKS表中对应的行级锁，获取锁后即可执行其他表中的数据库操作，随着操作事务的提交，行级锁被释放，供其他调度实例获取。集群中的每一个调度器实例都遵循这样一种严格的操作规程。</p>
<p>getLockHandler()方法返回的对象类型是Semaphore，获取锁和释放锁的具体逻辑由该对象维护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Semaphore &#123;</span><br><span class="line"></span><br><span class="line">     boolean obtainLock(Connection conn, String lockName) throws LockException;</span><br><span class="line"></span><br><span class="line">     void releaseLock(String lockName) throws LockException;</span><br><span class="line"></span><br><span class="line">     boolean requiresConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口的实现类完成具体操作锁的逻辑，在JobStoreSupport的初始化方法中注入的Semaphore具体类型是StdRowLockSemaphore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setLockHandler(new StdRowLockSemaphore(getTablePrefix(), getInstanceName(), getSelectWithLockSQL()));</span><br></pre></td></tr></table></figure>

<p>StdRowLockSemaphore的源码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class StdRowLockSemaphore extends DBSemaphore &#123;</span><br><span class="line">&#x2F;&#x2F;锁定SQL语句</span><br><span class="line">public static final String SELECT_FOR_LOCK &#x3D; &quot;SELECT * FROM &quot;</span><br><span class="line">        + TABLE_PREFIX_SUBST + TABLE_LOCKS + &quot; WHERE &quot; + COL_LOCK_NAME</span><br><span class="line">        + &quot; &#x3D; ? FOR UPDATE&quot;;</span><br><span class="line"></span><br><span class="line">public static final String INSERT_LOCK &#x3D; &quot;INSERT INTO &quot; + TABLE_PREFIX_SUBST </span><br><span class="line">        + TABLE_LOCKS + &quot;(&quot; + COL_SCHEDULER_NAME + &quot;, &quot; </span><br><span class="line">        + COL_LOCK_NAME + &quot;) VALUES (&quot; + SCHED_NAME_SUBST + &quot;, ?)&quot;; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定锁定SQL</span><br><span class="line">protected void executeSQL(Connection conn, String lockName, String expandedSQL) throws LockException &#123;</span><br><span class="line">    PreparedStatement ps &#x3D; null;</span><br><span class="line">    ResultSet rs &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ps &#x3D; conn.prepareStatement(expandedSQL);</span><br><span class="line">        ps.setString(1, lockName);</span><br><span class="line">        ......</span><br><span class="line">        rs &#x3D; ps.executeQuery();</span><br><span class="line">        if (!rs.next()) &#123;</span><br><span class="line">            throw new SQLException(Util.rtp(</span><br><span class="line">                &quot;No row exists in table &quot; + TABLE_PREFIX_SUBST +</span><br><span class="line">                TABLE_LOCKS + &quot; for lock named: &quot; + lockName, getTablePrefix()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (SQLException sqle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ...... &#x2F;&#x2F;release resources</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取QRTZ_LOCKS行级锁</span><br><span class="line">public boolean obtainLock(Connection conn, String lockName) throws LockException &#123;</span><br><span class="line">    lockName &#x3D; lockName.intern();</span><br><span class="line"></span><br><span class="line">    if (!isLockOwner(conn, lockName)) &#123;</span><br><span class="line">        executeSQL(conn, lockName, expandedSQL);</span><br><span class="line"></span><br><span class="line">        getThreadLocks().add(lockName);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;释放QRTZ_LOCKS行级锁</span><br><span class="line">public void releaseLock(Connection conn, String lockName) &#123;</span><br><span class="line">    lockName &#x3D; lockName.intern();</span><br><span class="line"></span><br><span class="line">    if (isLockOwner(conn, lockName)) &#123;</span><br><span class="line">        getThreadLocks().remove(lockName);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下Quartz集群同步机制：每当要进行与某种业务相关的数据库操作时，先去QRTZ_LOCKS表中查询操作相关的业务对象所需要的锁，在select语句之后加for update来实现。例如，TRIGGER_ACCESS表示对任务触发器相关的信息进行修改、删除操作时所需要获得的锁。这时，执行查询这个表数据的SQL形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from QRTZ_LOCKS t where t.lock_name&#x3D;&#39;TRIGGER_ACCESS&#39; for update</span><br></pre></td></tr></table></figure>

<p>当一个线程使用上述的SQL对表中的数据执行查询操作时，若查询结果中包含相关的行，数据库就对该行进行ROW LOCK；若此时，另外一个线程使用相同的SQL对表的数据进行查询，由于查询出的数据行已经被数据库锁住了，此时这个线程就只能等待，直到拥有该行锁的线程完成了相关的业务操作，执行了commit动作后，数据库才会释放了相关行的锁，这个线程才能继续执行。</p>
<p>通过这样的机制，在集群环境下，结合悲观锁的机制就可以防止一个线程对数据库数据的操作的结果被另外一个线程所覆盖，从而可以避免一些难以觉察的错误发生。当然，达到这种效果的前提是需要把Connection设置为手动提交，即autoCommit为false。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="为什么我在一台机器上，看不到Job打印的执行日志"><a href="#为什么我在一台机器上，看不到Job打印的执行日志" class="headerlink" title="为什么我在一台机器上，看不到Job打印的执行日志"></a><strong>为什么我在一台机器上，看不到Job打印的执行日志</strong></h3><p>因为Quartz是分布式搭建的，触发定时任务时，只在集群中的某一台机器上执行。所以，我查看的机器，不是执行的机器，所以看不到也正常。我就在本地测试的时候，发现其他同事也开着程序。。。。导致定时任务一直在他们那里执行，我根本看不到。。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/Quartz-%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" data-id="cm6lsyz5x0091k2dl326l6az3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/开源项目/身份认证/shiro应用-05-过滤器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-05-%E8%BF%87%E6%BB%A4%E5%99%A8/" class="article-date">
  <time datetime="2021-05-24T09:39:13.000Z" itemprop="datePublished">2021-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-05-%E8%BF%87%E6%BB%A4%E5%99%A8/">shiro应用-05-过滤器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们都知道shiro是个认证权限框架，除了登录、退出逻辑我们需要侵入项目代码之外，验证用户是否已经登录、是否拥有权限的代码其实都是过滤器来完成的，可以这么说，shiro其实就是一个过滤器链集合。</p>
<p>那么今天我们详细讨论一下shiro底层到底给我们提供了多少默认的过滤器供我们使用，又都有什么用呢？带着问题，我们先去shiro官网看看对于默认过滤器集的说明。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://shiro.apache.org/web.html#default-filters">http://shiro.apache.org/web.h…</a></li>
</ul>
<blockquote>
<p>When running a web-app, Shiro will create some useful default Filter instances and make them available in the [main] section automatically. You can configure them in main as you would any other bean and reference them in your chain definitions.</p>
<p>The default Filter instances available automatically are defined by the DefaultFilter enum and the enum’s name field is the name available for configuration.</p>
</blockquote>
<p>默认筛选器实例由DefaultFilter enum中定义，enum s name字段是可用于配置的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public enum DefaultFilter &#123;</span><br><span class="line"></span><br><span class="line">    anon(AnonymousFilter.class),</span><br><span class="line">    authc(FormAuthenticationFilter.class),</span><br><span class="line">    authcBasic(BasicHttpAuthenticationFilter.class),</span><br><span class="line">    logout(LogoutFilter.class),</span><br><span class="line">    noSessionCreation(NoSessionCreationFilter.class),</span><br><span class="line">    perms(PermissionsAuthorizationFilter.class),</span><br><span class="line">    port(PortFilter.class),</span><br><span class="line">    rest(HttpMethodPermissionFilter.class),</span><br><span class="line">    roles(RolesAuthorizationFilter.class),</span><br><span class="line">    ssl(SslFilter.class),</span><br><span class="line">    user(UserFilter.class);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于知道我们常用的anon、authc、perms、roles、user过滤器是哪里来的了！这些过滤器我们都是可以直接使用的。</p>
<img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/8e77bde372b64a83baa2c7d782137a61.png" alt="img" style="zoom: 33%;" />



<h4 id="AbstractFilter"><a href="#AbstractFilter" class="headerlink" title="AbstractFilter"></a>AbstractFilter</h4><p>这个过滤器还得说说，shiro最底层的抽象过滤器，虽然我们极少直接继承它，它通过实现<code>Filter</code>获得过滤器的特性。</p>
<p>完成一些过滤器基本初始化操作，<code>FilterConfig</code>：过滤器配置对象，用于servlet容器在初始化期间将信息传递给其他过滤器。</p>
<h4 id="NameableFilter"><a href="#NameableFilter" class="headerlink" title="NameableFilter"></a>NameableFilter</h4><p>命名过滤器，给过滤器定义名称！也是比较基层的过滤器了，未拓展其他功能，我们很少会直接继承这个过滤器。为重写doFilter方法。</p>
<h4 id="OncePerRequestFilter"><a href="#OncePerRequestFilter" class="headerlink" title="OncePerRequestFilter"></a>OncePerRequestFilter</h4><p>重写doFilter方法，保证每个servlet方法只会被过滤一次。可以看到doFilter方法中，第一行代码就是<code>String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName();</code>然后通过<code>request.getAttribute(alreadyFilteredAttributeName) != null</code>来判断过滤器是否已经被调用过，从而保证过滤器不会被重复调用。</p>
<p>进入方法之前，先标记<code>alreadyFilteredAttributeName</code>为True，抽象<code>doFilterInternal</code>方法执行之后再remove掉<code>alreadyFilteredAttributeName</code>。</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/391f6d511eb5486e82611a2774eac82f.png" alt="img"></p>
<p>所以OncePerRequestFilter过滤器保证只会被一次调用的功能，提供了抽象方法<code>doFilterInternal</code>让后面的过滤器可以重写，执行真正的过滤器处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected abstract void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">            throws ServletException, IOException;</span><br></pre></td></tr></table></figure>



<h4 id="AdviceFilter"><a href="#AdviceFilter" class="headerlink" title="AdviceFilter"></a>AdviceFilter</h4><p>看到Advice，很自然想到切面环绕编程，一般有pre、post、after几个方法。所以这个AdviceFilter过滤器就是提供了和AOP相似的切面功能。</p>
<p>继承OncePerRequestFilter过滤器重写doFilterInternal方法，我们可以先看看：</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/1f169663547f42119c98d93f4d4ab97b.png" alt="img"></p>
<p>可以看到上面4个序号：</p>
<ol>
<li>preHandle 前置过滤，默认true</li>
<li>executeChain 执行真正代码过滤逻辑-&gt;chain.doFilter</li>
<li>postHandle 后置过滤</li>
<li>cleanup 其实主要逻辑是afterCompletion方法</li>
</ol>
<p>于是，我们从OncePerRequestFilter的一个doFilterInternal分化成了切面编程，更容易前后控制执行逻辑。所以如果继承AdviceFilter时候，我们可以重写preHandle方法，判断用户是否满足已登录或者其他业务逻辑，返回false时候表示不通过过滤器。</p>
<h4 id="PathMatchingFilter"><a href="#PathMatchingFilter" class="headerlink" title="PathMatchingFilter"></a>PathMatchingFilter</h4><p>请求路径匹配过滤器，通过匹配请求url，判断请求是否需要过滤，如果url未在需要过滤的集合内，则跳过，否则进入<code>isFilterChainContinued</code>的onPreHandle方法。</p>
<p>我们可以看下代码：</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/62f7317fd4ec467682f3da3aa11a3c87.png" alt="img"></p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/b568d5dceb2b4a19aad6fd72348f5e58.png" alt="img"></p>
<p>从上面3个步骤中可以看到，PathMatchingFilter提供的功能是：自定义匹配url，匹配上的请求最终跳转到<code>onPreHandle</code>方法。</p>
<p>这个过滤器为后面的常用过滤器提供的基础，比如我们在config中配置如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;login &#x3D; anon</span><br><span class="line">&#x2F;admin&#x2F;* &#x3D; authc</span><br></pre></td></tr></table></figure>

<p>拦截/login请求，经过AnonymousFilter过滤器，我们可以看下</p>
<ul>
<li>org.apache.shiro.web.filter.authc.AnonymousFilter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AnonymousFilter extends PathMatchingFilter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 公众号：MarkerHub</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) &#123;</span><br><span class="line">        &#x2F;&#x2F; Always return true since we allow access to anyone</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AnonymousFilter重写了onPreHandle方法，只不过直接返回了true，说明拦截的链接可以直接通过，不需要其他拦截逻辑。</p>
<p>而authc-&gt;FormAuthenticationFilter也是间接继承了PathMatchingFilter。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FormAuthenticationFilter extends AuthenticatingFilter</span><br></pre></td></tr></table></figure>

<p>所以，需要拦截某个链接进行业务逻辑过滤的可以继承PathMatchingFilter方法拓展哈。</p>
<h4 id="AccessControlFilter"><a href="#AccessControlFilter" class="headerlink" title="AccessControlFilter"></a>AccessControlFilter</h4><p>访问控制过滤器。继承PathMatchingFilter过滤器，重写onPreHandle方法，又分出了两个抽象方法来控制</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/63cb9b7e06f249089c88fa25f480ddd3.png" alt="img"></p>
<ul>
<li>isAccessAllowed 是否允许访问</li>
<li>onAccessDenied 是否拒绝访问</li>
</ul>
<p>所以，我们现在可以通过重写这个抽象两个方法来控制过滤逻辑。另外多提供了3个方法，方便后面的过滤器使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">saveRequestAndRedirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    saveRequest(request);</span><br><span class="line">    redirectToLogin(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">saveRequest</span><span class="params">(ServletRequest request)</span> </span>&#123;</span><br><span class="line">    WebUtils.saveRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">redirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String loginUrl = getLoginUrl();</span><br><span class="line">    WebUtils.issueRedirect(request, response, loginUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中redirectToLogin提供了调整到登录页面的逻辑与实现，为后面的过滤器发现未登录跳转到登录页面提供了基础。</p>
<h4 id="AuthenticationFilter"><a href="#AuthenticationFilter" class="headerlink" title="AuthenticationFilter"></a>AuthenticationFilter</h4><p>继承AccessControlFilter，重写了isAccessAllowed方法，通过判断用户是否已经完成登录来判断用户是否允许继续后面的逻辑判断。这里可以看出，从这个过滤器开始，后续的判断会与用户的登录状态相关，直接继承这些过滤器，我们不需要再自己手动去判断用户是否已经登录。并且提供了登录成功之后跳转的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AuthenticationFilter extends AccessControlFilter &#123;</span><br><span class="line">    public void setSuccessUrl(String successUrl) &#123;</span><br><span class="line">        this.successUrl &#x3D; successUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123;</span><br><span class="line">        Subject subject &#x3D; getSubject(request, response);</span><br><span class="line">        return subject.isAuthenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AuthenticatingFilter"><a href="#AuthenticatingFilter" class="headerlink" title="AuthenticatingFilter"></a>AuthenticatingFilter</h4><p>继承AuthenticationFilter，提供了自动登录、是否登录请求等方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公众号：MarkerHub</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticatingFilter</span> <span class="keyword">extends</span> <span class="title">AuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERMISSIVE = <span class="string">&quot;permissive&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO - complete JavaDoc</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">executeLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AuthenticationToken token = createToken(request, response);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;createToken method implementation returned null. A valid non-null AuthenticationToken &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;must be created in order to execute a login attempt.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Subject subject = getSubject(request, response);</span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="keyword">return</span> onLoginSuccess(token, subject, request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> onLoginFailure(token, e, request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AuthenticationToken <span class="title">createToken</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公众号：MarkerHub</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.isAccessAllowed(request, response, mappedValue) ||</span><br><span class="line">                (!isLoginRequest(request, response) &amp;&amp; isPermissive(mappedValue));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>executeLogin 执行登录</li>
<li>onLoginSuccess 登录成功跳转</li>
<li>onLoginFailure 登录失败跳转</li>
<li>createToken 创建登录的身份token</li>
<li>isAccessAllowed 是否允许被访问</li>
<li>isLoginRequest 是否登录请求</li>
</ul>
<p>这个方法提供了自动登录，比如我们获取到token之后实行自动登录</p>
<h4 id="FormAuthenticationFilter"><a href="#FormAuthenticationFilter" class="headerlink" title="FormAuthenticationFilter"></a>FormAuthenticationFilter</h4><p>基于form表单的账号密码自动登录的过滤器，我们只需要看这个方法就明白，和renren-fast的实现相似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AuthenticatingFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_USERNAME_PARAM = <span class="string">&quot;username&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PASSWORD_PARAM = <span class="string">&quot;password&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_REMEMBER_ME_PARAM = <span class="string">&quot;rememberMe&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationToken <span class="title">createToken</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        String username = getUsername(request);</span><br><span class="line">        String password = getPassword(request);</span><br><span class="line">        <span class="keyword">return</span> createToken(username, password, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公众号：MarkerHub</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoginRequest(request, response)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLoginSubmission(request, response)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                    log.trace(<span class="string">&quot;Login submission detected.  Attempting to execute login.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> executeLogin(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                    log.trace(<span class="string">&quot;Login page view.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//allow them to see the login page ;)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">&quot;Attempting to access a path which requires authentication.  Forwarding to the &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Authentication url [&quot;</span> + getLoginUrl() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            saveRequestAndRedirectToLogin(request, response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onAccessDenied调用executeLogin方法。默认的token是UsernamepasswordToken。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-05-%E8%BF%87%E6%BB%A4%E5%99%A8/" data-id="cm6lsyz5z009rk2dl70lv838e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-链路追踪/java探针-类加载问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2021-05-22T03:08:25.000Z" itemprop="datePublished">2021-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/">java探针-类加载问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>得益于Java SE 6提供的Instrumentation接口。基于Instrumentation可开发运行时修改class字节码的Java Agent应用（Java探针），可在<a href="">类加载之前替换类的字节码</a>、或在<a href="">类加载之后通过重新加载类方式修改类的字节码</a>。</p>
<p>只是实现运行时修改class字节码还不足以称为“探针”。基于Instrumentation开发的Java Agent，只需要在Java应用启动命令上加上虚拟机参数“-javaagent”指定Java Agent应用jar包的位置，而不需要在工程项目中引入其jar包，即可将探针插入应用代码的各个角落。通过<a href="">与应用使用不同的类加载实现环境隔离</a>，让人有种Java Agent是吸附在应用上运行的错觉。</p>
<h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>由父类加载器加载的类，不能引用子类加载器加载的类，否则会抛出NoClassDefFoundError。</p>
<p>JDK提供的<code>java.*</code>类都由启动类加载器加载。如果我们在<code>java agent</code>中修改<code>java.*</code>包下的类，插入调用logback打印日记的代码，结果会怎样？由于<code>java agent</code>包下的logback由AppClassLoader加载，而加载<code>java.*</code>包下的类是BootClassLoader(AppClassLoader的父类加载器)，在<code>java.*</code>包下的类中插入调用logback打印日记的代码，首先在加载<code>java.*</code>包下的类时，jvm会查看BootClassLoader有没有加载过这个类，如果没有加载过尝试加载，但BootClassLoader加载不了logback包的类，而启动类加载器不会向子类加载器去询问，即使子类加载器加载了这个类。所以就会出现NoClassDefFoundError。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>如果非要修改java包下的类，且非要在java包下的类中访问项目中我们编写的类或者第三方jar包提供的类、或者我们编写的javaagent包下的类，如何避免NoClassDefFoundError呢？</p>
<p>研究下Arthas:</p>
<ul>
<li>用于接收埋点代码上报事件的类（Spy）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Spy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method beforMethod;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method completeMethod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(String className, String methodName, String descriptor, Object[] params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beforMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforMethod.invoke(<span class="keyword">null</span>, className, methodName, descriptor, params);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object returnValueOrThrowable, String className, String methodName, String descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (completeMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                completeMethod.invoke(<span class="keyword">null</span>, returnValueOrThrowable, className, methodName, descriptor);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>before：方法执行之前上报；</p>
<p>complete：方法return之前或者抛出异常之前上报，当方法抛出异常时，第一个参数为异常，否则第一个参数为返回值</p>
<p>methodName: 上报方法</p>
</blockquote>
<ul>
<li>将Spy放在一个独立的jar包下，在premain、agentmain方法中调用Instrumentation的appendToBootstrapClassLoaderSearch方法，将Spy类所在的jar包交由启动类加载器扫描加载，如下代码所示。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; agent-spy.jar</span><br><span class="line">String agentSpyJar &#x3D; jarPath[1];</span><br><span class="line">File spyJarFile &#x3D; new File(agentSpyJar);</span><br><span class="line">instrumentation.appendToBootstrapClassLoaderSearch(new JarFile(spyJarFile));</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在Spy类中打印类加载器，如果打印的结果为null，则说明Spy类是由启动类加载器加载的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final class Spy &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Spy class loader is &quot; + Spy.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Agent与应用环境隔离"><a href="#实现Agent与应用环境隔离" class="headerlink" title="实现Agent与应用环境隔离"></a>实现Agent与应用环境隔离</h2><p>隔离是避免Agent污染应用自身，使开发Java Agent无需考虑引入的jar包是否与目标应用引入的jar包冲突。</p>
<h3 id="与springboot隔离失败原因"><a href="#与springboot隔离失败原因" class="headerlink" title="与springboot隔离失败原因"></a>与springboot隔离失败原因</h3><p>Java Agent与Spring Boot应用相遇时会发生什么？</p>
<p>Spring Boot应用打包后，将Agent附着到应用启动可能会抛出醒目的NoClassDefFoundError异常，背后的原因是<a href="">Agent与打包后的Spring Boot应用使用了不同的类加载器</a>。</p>
<ul>
<li>Agent的jar包由AppClassLoader加载。我们可能会在Agent中调用被监控的SpringBoot应用的代码，也可能调用Agent依赖的第三方jar包的API，而这些jar包恰好在SpringBoot应用中也有导入，就可能会出现NoClassDefFoundError。</li>
<li>SpringBoot应用打包后，JVM进程启动入口不再是我们写的main方法，而是SpringBoot生成的启动类。SpringBoot使用自定义的类加载器（LaunchedClassLoader）加载jar中的类和第三方jar包中的类，该类加载器的父类加载器为AppClassLoader。也就是说，SpringBoot应用打包后，加载java agent包下的类加载器是SpringBoot的类加载器的父类。</li>
</ul>
<blockquote>
<p>疑惑？这在IDEA中测试是不会发生的</p>
<p>因为在IDEA中，项目的class文件和第三方库是通过AppClassLoader加载的，而使用-javaagent指定的jar也是通过AppClassLoader加载，所以在idea中测试不会遇到这个问题。</p>
</blockquote>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>让加载agent包不使用AppClassLoader加载器加载，而是使用自定义的类加载器加载。</p>
<p>参考Alibaba开源的Arthas的实现，自定义URLClassLoader加载agent包以及agent依赖的第三方jar包。</p>
<p>由于premain或者agentmain方法所在的类由jvm使用AppClassLoader所加载，所以必须将agent拆分为两个jar包。核心功能放在agent-core包下，premain或者agentmain方法所在的类放在agent-boot包下。在premain或者agentmain方法中使用自定义的URLClassLoader类加载器加载agent-core。</p>
<ul>
<li>自定义类加载器OnionClassLoader，继承URLClassLoader，如下代码所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnionClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnionClassLoader</span><span class="params">(URL[] urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(urls, ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (loadedClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadedClass;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优先从parent（SystemClassLoader）里加载系统类，避免抛出ClassNotFoundException</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; (name.startsWith(<span class="string">&quot;sun.&quot;</span>) || name.startsWith(<span class="string">&quot;java.&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> aClass;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在构造方法中指定OnionClassLoader的父类加载器为AppClassLoader的父类加载器。</p>
<p><code>ClassLoader.getSystemClassLoader()</code>：获取系统类加载器（AppClassLoader）</p>
<ul>
<li>在premain或者agentmain方法中使用OnionClassLoader类加载器加载agent-core。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File agentJarFile = <span class="keyword">new</span> File(agentJar);</span><br><span class="line"><span class="keyword">final</span> ClassLoader agentLoader = <span class="keyword">new</span> OnionClassLoader(<span class="keyword">new</span> URL[]&#123;agentJarFile.toURI().toURL()&#125;);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; transFormer = agentLoader.loadClass(<span class="string">&quot;com.msyc.agent.core.OnionClassFileTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt; constructor = transFormer.getConstructor(String.class);</span><br><span class="line">Object instance = constructor.newInstance(opsParams);</span><br><span class="line"></span><br><span class="line">instrumentation.addTransformer((ClassFileTransformer) instance);</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>根据agent-core.jar所在绝对路径构造OnionClassLoader；</li>
<li>加载agent-core.jar下的ClassFileTransformer；</li>
<li>使用反射创建ClassFileTransformer实例；</li>
<li>将ClassFileTransformer添加到Instrumentation;</li>
</ul>
</blockquote>
<p>OnionClassFileTransformer类所依赖的agent-core包下的类，自然也会被使用OnionClassLoader类加载器加载，包括agent-core依赖的第三方jar包。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/yibbONzdtFf2t8JVXHNXRpibzSgFAqUAMkfyP8gypoicPR23f3cqb0icdKtGjjAicYowOAHJr07HqlV9YPbqqqPE4qg/640" alt="图片"></p>
<h2 id="适配webmvc框架"><a href="#适配webmvc框架" class="headerlink" title="适配webmvc框架"></a><strong>适配webmvc框架</strong></h2><p>生成分布式调用链日记的难点在于方法埋点和方法调用日记串连。</p>
<p>分布式调用链日记串连的方式有多种，笔者采用的是最简单的方式：打点id+打点时间。</p>
<ul>
<li>对于同进程内的同线程，可用打点id将调用的方法串连起来，根据打点时间与一个累加器的值排序方法调用日记。</li>
<li>对于不同进程，通过传递打点id可将不同应用的打点日记串连起来，根据打点时间排序。</li>
</ul>
<p>例如，适配webmvc框架的目的是从请求头获取调用来源传递过来的打点ID(事务ID)。对DispatcherServlet#doDispatch方法插桩，从HttpServletRequest参数获取请求头“S-Tid”。“S-Tid”是自定义的请求头参数，用于传递打点ID。</p>
<p>笔者在实现适配webmvc和openfeign时都遇到了同样的问题，如在适配webmvc时，修改DispatcherServlet的doDispatch方法时，asm框架抛出java.lang.TypeNotPresentException。</p>
<ul>
<li>java.lang.TypeNotPresentException：当应用程序试图使用表示类型名称的字符串对类型进行访问，但无法找到带有指定名称的类型定义时，抛出该异常。</li>
</ul>
<p>其原因是，使用asm框架改写DispatcherServlet类时，asm会使用Class.forName方法加载符号引用的类，如果加载不到目标类则抛出TypeNotPresentException。</p>
<p>默认asm会使用加载自身的类加载器去尝试加载当前改写类所依赖的一些类，而加载asm框架使用的类加载器与加载agent-core包使用的是同一个类加载器，DispatcherServlet则由SpringBoot的LaunchedClassLoader类加载器所加载。</p>
<p>好在ClassFileTransformer#transform方法传递了用于加载当前类的类加载器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class OnionClassFileTransformer implements ClassFileTransformer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public byte[] transform(ClassLoader loader, String className,                             Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                            ProtectionDomain protectionDomain,                             byte[] classfileBuffer) &#123;</span><br><span class="line">             &#x2F;&#x2F; ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>如果当前需要改写的类是DispatcherServlet，则transform方法的第一个参数为即将用于加载DispatcherServlet类的类加载器；</li>
</ul>
<p>我们只需要指定asm使用ClassFileTransformer#transform方法传递进来的类加载器加载DispatcherServlet依赖的类即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassWriter classWriter &#x3D; new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES) &#123;</span><br><span class="line">       @Override</span><br><span class="line">       protected ClassLoader getClassLoader() &#123;</span><br><span class="line">            return loader;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>如代码所示，我们重写asm的ClassWriter类的getClassLoader方法，返回的类加载器是ClassFileTransformer#transform方法传递进来的类加载器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/" data-id="cm6lsyz560013k2dla0b61ncp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-中间件/Kafka/kafka-分析与调优-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-01/" class="article-date">
  <time datetime="2021-05-21T04:34:40.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-01/">kafka-分析与调优</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Kafka报-IO-Exception-many-open-files"><a href="#Kafka报-IO-Exception-many-open-files" class="headerlink" title="Kafka报 IO Exception(many open files)"></a>Kafka报 IO Exception(many open files)</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><hr>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVd71ajm8l4SQibTbQic73zsFR1OryAj6gpuVAfviaTAyQzKmMNK1y5et2w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>首先我们要能看懂Kafka-manager上的一些监控指标，topic列表中关于topic的信息项如下所示：</p>
<ul>
<li><p>Brokers Spread %<br>该topic中队列在Broker中的使用率，例如集群中有5个broker，但topic只在４个broker上创建了队列，那使用率为80％。</p>
</li>
<li><p>Brokers Skew %<br>topic的队列倾斜率。如果集群中存在5个broker节点，topic的总分区数量为4,副本因子为2，但这些队列只分布在其中的４台broker中。那topic的<strong>broker使用率(Broker Spread)为80%**。<br>众所周知，引入多节点的目的就是负载均衡，队列在broker中的分配自然是希望越均衡越好，期望每台broker上存储2个队列(副本因子为2，总共８个队列)，表示没有发生倾斜，如果一台broker中的存在３个队列，而另外一个broker上１个队列，那说明发生了倾斜，</strong>计算公式为超过平均队列数的broker节点个数除以总所在Broker数量**，其Brokers Skew等于(1/3)=33%。  <!--队列就是：分区 + 副本--></p>
</li>
<li><p>Brokers Leader Skew %<br>topic分区中Leader分区的倾斜率。在Kafka中，<strong>只有分区的Leader节点具有读写权限</strong>，真正影响读写性能的是Leader分区是否均衡，试想一下，如果一个topic有6个分区，但所有的Leader分区只分布在一两个Broker节点上，这个<strong>topic的写入、读取性能将受到制约，这个值建议维持在0％</strong>。</p>
</li>
<li><p>Replicas<br>副本数、副本因子，即一个分区数据存储的份数，该数值包含Leader分区。</p>
</li>
<li><p>Under Replicated %<br>没有跟上复制进度的副本比例，在Kafka的复制模型中，主分区负责读写，该复制组内的其他副本从主节点同步数据，如果跟不上主节点的复制进度，将被提出ISR，被剔除ISR的副本不具备选举Leader的资格，<strong>这个数据如果长期或频繁高于0，说明集群一定出现了问题</strong>。</p>
</li>
</ul>
<p>Producer Message/Sec<br>消息发送实时TPS，通过JMX采集，需要在kafka-manager中开启如下参数：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVibB9l70MzWAEFyUMZIvia0bxQrJYlciaeCmPBFNwWjJI95TiaUV293sX5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li>Summed Recent Offsets<br>该主题当前最大的消息偏移量。</li>
</ul>
<p>经过对Topic列表观察，发现开发环境存在大量的topic都只有一个队列，并且都分布在第一节点上，其截图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVRdFRpiaHaB1GsEt8uibID722MYlxAurdoJnTK6EcIKrtDzGZjkqL5vjA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">在这里插入图片描述</p>
<p>从界面上对应的指标：Brokers Spread即Broker的利用率只有３分之一，抽取几个数据量大的主题，判断其路由信息，得知都分布在第一个Broker节点上，这样就导致其中一个节点大量出现文章开头部分提到的错误：<strong>Too many open files</strong>。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><hr>
<h5 id="3-1-扩分区"><a href="#3-1-扩分区" class="headerlink" title="3.1 扩分区"></a>3.1 扩分区</h5><p>问题定位出来了，由于Broker利用率不均匀，大量topic只创建了一个队列，并且还集中落到了第一个节点。</p>
<p>针对这种情况，首先想到的方案：扩分区。</p>
<h5 id="3-1-1-通过Kafka-manager"><a href="#3-1-1-通过Kafka-manager" class="headerlink" title="3.1.1 通过Kafka-manager"></a>3.1.1 通过Kafka-manager</h5><p>Step1：在Kafka-manager的topic列表，点击具体的topic，进入详情页面，点击[add Partitions]，如图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVPXLfzpo8iaZoYQarg7ws4SczYTMFxic6YCNvJoYFmLs4kLl6Qwad1Ekg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>Step2：点击增加分区，弹出如下框：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVfuicI2KEPBO13zgMaw4Qbrcoe8meRTz2vyCDkx4QeicY8k9bYHZxk6oQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>说明如下：</p>
<ul>
<li>Partitions<br>扩容后的总分区个数，并不是本次增加的分区个数。</li>
<li>Brokers<br>分区需要分布的Broker，建议全选，充分利用整个集群的性能。</li>
</ul>
<h5 id="3-1-2-运维命令"><a href="#3-1-2-运维命令" class="headerlink" title="3.1.2 运维命令"></a>3.1.2 运维命令</h5><p>可以通过Kafka提供的kafka-topics命令，修改topic的分区，具体参考如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVzjZFWZ47UpkVb3iaNkWMHqenWIXsCBjuGW1T1e42cRiaWiby6sQf4lJzQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<blockquote>
<p>温馨提示：对这些运维命令不熟悉没关系，基本都提供了–help</p>
</blockquote>
<h5 id="3-2-分区移动"><a href="#3-2-分区移动" class="headerlink" title="3.2 分区移动"></a>3.2 分区移动</h5><p>由于存在大量的只有一个分区的topic，并且这些topic都分布到了第一个节点，是不是可以将某些topic的分区移动到其他节点呢？</p>
<p>接下来介绍一下分区移动如何操作。</p>
<h5 id="3-2-1-kafka-manager"><a href="#3-2-1-kafka-manager" class="headerlink" title="3.2.1 kafka-manager"></a>3.2.1 kafka-manager</h5><p>Step1：进入topic详情页面，点击[Generate Partition Assignments]，如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVm6ibJZh43iaVwh40jX6Fz3AsbnibricqkmBWbOHRVhdMH5UiaMRhicPQic3Hw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>Step2：进入页面后，选择需要迁移到的brroker，还可以改变topic的副本因子，最后点击[Generate Partition Assignments]，如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVa0Z8umQiaib5DRzibX2I0icvPyMdiaEm3Px6F8ERyGFy9cBziaQEwIN0QzGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>Step3：点击完成后，此时只是生成了分区迁移计划，并没有真正的执行，需要点击[Reassign Parttions]按钮。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVAceM0RH9Ktq7URs2FpdA404icN4qExz8ib0u0kJiaFNCHHz9QcZqDMVHg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h5 id="3-2-2-运维命令"><a href="#3-2-2-运维命令" class="headerlink" title="3.2.2 运维命令"></a>3.2.2 运维命令</h5><p>Step1：首先我们需要准备需要执行迁移的topic信息，例如将如下信息保存在文件dw_test_kafka_040802-topics-to-move.json中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;topics&quot;:</span><br><span class="line">    [</span><br><span class="line">        &#123;&quot;topic&quot;:&quot;dw_test_kafka_040802&quot;&#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Step2：使用kafka提供的kafka-reassign-partitions.sh命令生成执行计划</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVAUy43eHQT4wodWDoyINRX7icKnHesVuh6korWVXqjf3VrtYBZGU9gTw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>上面的参数其实对照kafka-manager的图理解起来会更快，点出如下关键点：</p>
<ul>
<li>–broker-list<br>分区需要分布的broker。如果多个，使用双引号，例如 “0,1,2”。</li>
<li>–topics-to-move-json-file<br>需要执行迁移的topic列表。</li>
<li>–generate<br>表示生成执行计划(并不真正执行)</li>
</ul>
<p>执行成功后会输出当前的分区分布计划与新的执行计划，通常我们可以先将当前的执行计划存储到一个备份目录中，将新生成的计划存储到一个文件中。</p>
<p>Step3：使用kafka提供的kafka-reassign-partitions.sh命令执行分区迁移计划</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVianvMtHR60SJxxBeHga7AZ7IsibjuAtTQL02R7hmFRy8wWgVv49brWGA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>其关键点如下：</p>
<ul>
<li>–reassignment-json-file<br>指定上一步骤生成的执行计划。</li>
</ul>
<p>执行成功过后输出Successfully，重分区是一个非常复杂的过程，命令执行完成后，并不会真正执行完成，可以通过查询主题的详细信息来判断是否真正迁移成功。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVDGxJwcvfIUpiaxrjI16DiaEL9FR3HzmvjzeoPAOGvLwZhRpDHqpjwpOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h4 id="进阶与架构思维"><a href="#进阶与架构思维" class="headerlink" title="进阶与架构思维"></a>进阶与架构思维</h4><hr>
<p>通过kafka-reassign-partitions.sh对分区进行迁移，会影响业务方的正常使用吗？即会影响消息的消费与发送吗？</p>
<p>我们需要对分区迁移的实现原理做进一步探究，本文暂不从源码角度详细剖析，只是举例阐述一下分区迁移的实现机制。</p>
<p>需求：一个TopicA的其中一个分区p0，分布在broker id为1,2,3上，目前要将其迁移到brokerId为4,5,6。</p>
<p>在介绍迁移过程之前，我们先定义三个变量：</p>
<ul>
<li>OAR<br>迁移前分区的分布情况。</li>
<li>RAR<br>迁移后的分区分布情况</li>
<li>AR<br>当前运行过程中的分区分布情况</li>
</ul>
<p>结合上述例子，其整个迁移步骤如下：</p>
<table>
<thead>
<tr>
<th align="center">AR</th>
<th align="center">Leader(ISR)</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{1,2,3}</td>
<td align="center">1{1,2,3}</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">1{1,2,3}</td>
<td align="left">首先基于RAR集合(迁移后的新broker)上创建对应的分区，并开始从Leader同步数据</td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">1{1,2,3,4,5,6}</td>
<td align="left">新创建的副本追上主节点的进度，并进入ISR集合</td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">4{1,2,3,4,5,6}</td>
<td align="left">如果Leader不在RAR所在的集合中，则发起一次选举，将Leader变更为RAR中其中一台。</td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">4{4,5,6}</td>
<td align="left">将OAR中的副本状态设置为OfflineReplica(下线)，将其从ISR中剔除</td>
</tr>
<tr>
<td align="center">{4,5,6}</td>
<td align="center">4{4,5,6}</td>
<td align="left">删除下线的副本，完成整个迁移操作</td>
</tr>
</tbody></table>
<p>从上面这个过程，只有在Leader选举期间会对消息发送、消息消费造成影响，但通过Zookeeper实现Leader选举可在秒级别响应，结合Kafka消息发送端的缓冲队列、重试机制，在理论上可以做到对业务无影响。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-01/" data-id="cm6lsyz5h004nk2dlhpuoh1cr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-数据库中间件/分库分表技术/分库分表-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%8A%80%E6%9C%AF/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-01/" class="article-date">
  <time datetime="2021-05-21T01:21:40.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%8A%80%E6%9C%AF/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-01/">分库分表-01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/q_MMXEphKl56ngLy8R6jmg">https://mp.weixin.qq.com/s/q_MMXEphKl56ngLy8R6jmg</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%8A%80%E6%9C%AF/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-01/" data-id="cm6lsyz5j0053k2dlg22j4l7j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/7/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/">juc</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/oom/">oom</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/oom/">oom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/spring/">spring</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/" rel="tag">JDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/annotation/" rel="tag">annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cluster/" rel="tag">cluster</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jstack/" rel="tag">jstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock/" rel="tag">lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/net/" rel="tag">net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/next/" rel="tag">next</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/" rel="tag">reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-starter/" rel="tag">spring starter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/startup/" rel="tag">startup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transaction/" rel="tag">transaction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtual-machine/" rel="tag">virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vm/" rel="tag">vm</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDK/" style="font-size: 11.11px;">JDK</a> <a href="/tags/annotation/" style="font-size: 10px;">annotation</a> <a href="/tags/cluster/" style="font-size: 10px;">cluster</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/hexo/" style="font-size: 12.22px;">hexo</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/jstack/" style="font-size: 14.44px;">jstack</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/lock/" style="font-size: 10px;">lock</a> <a href="/tags/mysql/" style="font-size: 16.67px;">mysql</a> <a href="/tags/net/" style="font-size: 10px;">net</a> <a href="/tags/next/" style="font-size: 11.11px;">next</a> <a href="/tags/redis/" style="font-size: 15.56px;">redis</a> <a href="/tags/reflect/" style="font-size: 10px;">reflect</a> <a href="/tags/spring-starter/" style="font-size: 10px;">spring starter</a> <a href="/tags/springboot/" style="font-size: 18.89px;">springboot</a> <a href="/tags/startup/" style="font-size: 17.78px;">startup</a> <a href="/tags/transaction/" style="font-size: 11.11px;">transaction</a> <a href="/tags/virtual-machine/" style="font-size: 12.22px;">virtual machine</a> <a href="/tags/vm/" style="font-size: 13.33px;">vm</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%A1%86%E6%9E%B6-04-bean%E5%8C%85-Bean/">spring框架-04-bean包-Bean</a>
          </li>
        
          <li>
            <a href="/2022/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-HashMap/">JDK-util-HashMap</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E5%9C%BA%E6%99%AF/">mysql - 常见事务问题解决方案</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">mysql - 面试问题</a>
          </li>
        
          <li>
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">交换排序-冒泡排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 Fei Qi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>