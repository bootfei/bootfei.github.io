<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-HashMap/" class="post-title-link" itemprop="url">JDK-util-HashMap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-19 09:07:43" itemprop="dateCreated datePublished" datetime="2022-04-19T09:07:43+08:00">2022-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-09 16:55:17" itemprop="dateModified" datetime="2023-03-09T16:55:17+08:00">2023-03-09</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdibMJVazadOLIHm8dB5Us2Nq4WlibbqZL4NMBNIMsRP3NibcOYT3uU7wNrw/640" alt="Image"></p>
<p>这张图囊括了HashMap中最基础的几个点：</p>
<ol>
<li><code>Java</code>中<code>HashMap</code>的实现的基础数据结构是数组，每一对<code>key</code>-&gt;<code>value</code>的键值对组成<code>Entity</code>类以双向链表的形式存放到这个数组中</li>
<li>元素在数组中的位置由<code>key.hashCode()</code>的值决定，如果两个<code>key</code>的哈希值相等，即发生了哈希碰撞，则这两个<code>key</code>对应的<code>Entity</code>将以链表的形式存放在数组中</li>
<li>调用<code>HashMap.get()</code>的时候会首先计算<code>key</code>的值，继而在数组中找到<code>key</code>对应的位置，然后遍历该位置上的链表找相应的值。</li>
</ol>
<p>当然这张图中没有体现出来的有两点：</p>
<ol>
<li>为了提升整个<code>HashMap</code>的读取效率，当<code>HashMap</code>中存储的元素大小等于桶数组大小乘以负载因子的时候整个<code>HashMap</code>就要扩容，以减小哈希碰撞，具体细节我们在后文中讲代码会说到</li>
<li>在<code>Java 8</code>中如果<strong>桶数组</strong>的同一个位置上的链表数量超过一个定值，则整个链表有一定概率会转为一棵红黑树。</li>
</ol>
<p>整体来看，整个<code>HashMap</code>中最重要的点有四个：<strong>初始化</strong>，<strong>数据寻址-<code>hash</code>方法</strong>，<strong>数据存储-<code>put</code>方法</strong>,<strong>扩容-<code>resize</code>方法</strong>，只要理解了这四个点的原理和调用时机，也就理解了整个<code>HashMap</code>的设计。</p>
<p>如果对其中的某几个问题还有疑惑</p>
<ol>
<li><code>HashMap</code>内部的<code>bucket</code>数组长度为什么一直都是2的整数次幂</li>
<li><code>HashMap</code>默认的<code>bucket</code>数组是多大</li>
<li><code>HashMap</code>什么时候开辟<code>bucket</code>数组占用内存</li>
<li><code>HashMap</code>何时扩容？</li>
<li>桶中的元素链表何时转换为红黑树，什么时候转回链表，为什么要这么设计？</li>
<li><code>Java 8</code>中为什么要引进红黑树，是为了解决什么场景的问题？</li>
<li><code>HashMap</code>如何处理<code>key</code>为<code>null</code>的键值对？</li>
</ol>
<h2 id="new-HashMap"><a href="#new-HashMap" class="headerlink" title="new HashMap()"></a><code>new HashMap()</code></h2><p>在<code>JDK 8</code>中，在调用<code>new HashMap()</code>的时候并没有分配数组堆内存，只是做了一些参数校验，初始化了一些常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tableSizeFor</code>的作用是找到大于<code>cap</code>的最小的2的整数幂，我们假设n(注意是n，不是cap哈)对应的二进制为000001xxxxxx，其中x代表的二进制位是0是1我们不关心 <!--我个人看法，使用位运算时，一定要注意最高位，最高位是符号位，不能移动，所以32bit的int，只能用到倒数第2的高位bit，所以HashMap的最大容量是2^30 --></p>
<p><code>n |= n &gt;&gt;&gt; 1;</code>执行后<code>n</code>的值为：</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdibnWhteLvazicGAkd7go3CeiabRjYN0ib1Wb5h1B8TuPOHBT1cr1K0GCaSA/640" style="zoom:33%;" />

<p>可以看到此时<code>n</code>的二进制最高两位已经变成了1（1和0或1异或都是1），再接着执行第二行代码：</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdibibEwy9YFEA0Gy21LJYNColicAxpW11teDQpRZvE0HqcTC1QYJ6Z7fWBQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:33%;" />

<p>可见<code>n</code>的二进制最高四位已经变成了1，等到执行完代码<code>n |= n &gt;&gt;&gt; 16;</code>之后，<code>n</code>的二进制最低位全都变成了1，<!--就是为了创建最低位都是1的整数--> 也就是<code>n = 2^x - 1</code>其中x和n的值有关，如果没有超过<code>MAXIMUM_CAPACITY</code>，最后会返回一个2的正整数次幂，因此<code>tableSizeFor()</code>的作用就是保证返回一个比入参大的最小的2的正整数次幂。<!--说白了，就是把bit是1的最高位以后的低位，全部置为1，这就是“最小的2的正整数次幂”--></p>
<p>在<code>JDK 7</code>中初始化的代码大体一致，在<code>HashMap</code>第一次<code>put</code>的时候会调用<code>inflateTable</code>计算桶数组的长度，但其算法并没有变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一次put时，初始化table</span><br><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">    &#x2F;&#x2F; Find an power of 2 &gt;&#x3D; toSize</span><br><span class="line">    int capacity &#x3D; roundUpToPowerOf2(toSize);</span><br><span class="line">    threshold &#x3D; (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    table &#x3D; new Entry(capacity);</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们也回答了开头提出来的问题：</p>
<p><code>HashMap</code>什么时候开辟<code>bucket</code>数组占用内存？答案是在<code>HashMap</code>第一次<code>put</code>的时候，无论<code>Java 8</code>还是<code>Java 7</code>都是这样实现的 <!--计算机领域，只有对象真正被使用的时候，才被初始化。类似“延迟加载”-->。这里我们可以看到两个版本的实现中，桶数组的大小都是2的正整数幂，至于为什么这么设计，看完后文你就明白了。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a><code>hash</code></h2><p>在<code>HashMap</code>这个特殊的数据结构中，<code>hash</code>函数承担着寻址定址的作用，其性能对整个<code>HashMap</code>的性能影响巨大，那什么才是一个好的<code>hash</code>函数呢？</p>
<ul>
<li>计算出来的哈希值足够散列，能够有效减少哈希碰撞</li>
<li>本身能够快速计算得出，因为<code>HashMap</code>每次调用<code>get</code>和<code>put</code>的时候都会调用<code>hash</code>方法</li>
</ul>
<p>下面是<code>Java 8</code>中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里比较重要的是<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，这个位运算其实是将<code>key.hashCode()</code>计算出来的<code>hash</code>值的高16位与低16位继续异或，为什么要这么做呢？</p>
<p>我们知道<code>hash</code>函数的作用是用来确定<code>key</code>在桶数组中的位置的，在<code>JDK</code>中为了更好的性能，通常会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D;(table.length - 1) &amp; key.hash();</span><br></pre></td></tr></table></figure>

<p>回忆前文中的内容，<code>table.length</code>是一个2的正整数次幂，类似于<code>000100000</code>，这样的值减一就成了<code>000011111</code>，通过位运算可以高效寻址，这也回答了前文中提到的一个问题，<code>HashMap</code>内部的<code>bucket</code>数组长度为什么一直都是2的整数次幂？好处之一就是可以通过构造位运算快速寻址定址。</p>
<p>回到本小节的议题，既然计算出来的哈希值都要与<code>table.length - 1</code>做与运算，那就意味着计算出来的<code>hash</code>值只有低位有效，这样会加大碰撞几率，因此让高16位与低16位做异或，让低位保留部分高位信息，减少哈希碰撞。</p>
<p>我们再看<code>Java 7</code>中对hash的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by </span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded </span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor). </span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Java 7</code>中为了避免<code>hash</code>值的高位信息丢失，做了更加复杂的异或运算，但是基本出发点都是一样的，都是让哈希值的低位保留部分高位信息，减少哈希碰撞。</p>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a><code>put</code></h2><h3 id="Jdk8"><a href="#Jdk8" class="headerlink" title="Jdk8:"></a>Jdk8:</h3><p>在<code>Java 8</code>中<code>put</code>这个方法的思路分为以下几步：</p>
<ol>
<li>调用<code>key</code>的<code>hashCode</code>方法计算哈希值，并据此计算出数组下标index</li>
<li>如果发现当前的桶数组为<code>null</code>，则调用<code>resize()</code>方法进行初始化</li>
<li>如果没有发生哈希碰撞，则直接放到对应的桶中</li>
<li>如果发生哈希碰撞，且节点已经存在，就替换掉相应的<code>value</code></li>
<li>如果发生哈希碰撞，且桶中存放的是树状结构，则挂载到树上</li>
<li>如果碰撞后为链表，添加到链表尾，如果链表长度超过<code>TREEIFY_THRESHOLD</code>默认是8，则将链表转换为树结构</li>
<li>数据<code>put</code>完成后，如果<code>HashMap</code>的总数超过<code>threshold</code>就要<code>resize</code></li>
</ol>
<p>具体代码以及注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用上文我们已经分析过的hash方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 第一次put时，会调用resize进行桶数组初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据数组长度和哈希值相与来寻址，原理上文也分析过</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果没有哈希碰撞，直接放到桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//【关键点1】 哈希碰撞，且节点已存在，直接替换</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 【关键点2】哈希碰撞，树结构</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 【关键点3】哈希碰撞，链表结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表过长，转换为树结构</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 【关键点4】：如果节点已存在，则跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 否则，指向下一个节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 对应着上文中【关键点4】：节点已存在，跳出循环的分支</span></span><br><span class="line">            <span class="comment">// 直接替换</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 如果超过阈值，还需要扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jdk7"><a href="#jdk7" class="headerlink" title="jdk7:"></a>jdk7:</h3><p><code>Java 7</code>中的<code>put</code>方法就简单不少</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，调用 putForNullKey 方法进行处理  </span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key</span><br><span class="line">                || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; e = table[bucketIndex];     <span class="comment">// ①  </span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K, V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);    <span class="comment">// ②  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个小细节，<code>HashMap</code>允许<code>put</code>key为<code>null</code>的键值对，但是这样的键值对都放到了桶数组的第0个桶中。</p>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a><code>resize()</code></h2><h3 id="jdk8"><a href="#jdk8" class="headerlink" title="jdk8:"></a>jdk8:</h3><p><code>resize</code>是整个<code>HashMap</code>中最复杂的一个模块，如果在<code>put</code>数据之后超过了<code>threshold</code>的值，则需要扩容，扩容意味着桶数组大小变化，我们在前文中分析过，<code>HashMap</code>寻址是通过<code>index =(table.length - 1) &amp; key.hash();</code>来计算的，现在<code>table.length</code>发生了变化，势必会导致部分<code>key</code>的位置也发生了变化，<code>HashMap</code>是如何设计的呢？</p>
<p>这里就涉及到桶数组长度为2的正整数幂的第二个优势了：当桶数组长度为2的正整数幂时，如果桶发生扩容（长度翻倍），则桶中的元素大概只有一半需要切换到新的桶中，另一半留在原先的桶中就可以，并且这个概率可以看做是均等的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdiblzYia6ic0unz6yDBBUz9zaYTfnYCdtazFW4ibtEf8bs5F6K2zdNPK7n9w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>通过这个分析可以看到如果在即将扩容的那个位上<code>key.hash()</code>的二进制值为0，则扩容后在桶中的地址不变，否则，扩容后的最高位变为了1，新的地址也可以快速计算出来<code>newIndex = oldCap + oldIndex;</code> <!--对以前的地址完美兼容，这就是size是2的次幂的优势--></p>
<p>下面是<code>Java 8</code>中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果oldCap &gt; 0则对应的是扩容而不是初始化</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有超过最大值，就扩大为原先的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 如果oldCap为0， 但是oldThr不为0，则代表的是table还未进行过初始化</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果到这里newThr还未计算，比如初始化时，则根据容量计算出新的阈值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">// 遍历之前的桶数组，对其值重新散列</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 如果原先的桶中只有一个元素，则直接放置到新的桶中</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 如果原先的桶中是链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// hiHead和hiTail代表元素在新的桶中和旧的桶中的位置不一致</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// loHead和loTail代表元素在新的桶中和旧的桶中的位置一致</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 新的桶中的位置 = 旧的桶中的位置 + oldCap， 详细分析见前文</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jdk7-1"><a href="#jdk7-1" class="headerlink" title="jdk7:"></a>jdk7:</h3><p><code>Java 7</code>中的<code>resize</code>方法相对简单许多：</p>
<ol>
<li>基本的校验之后<code>new</code>一个新的桶数组，大小为指定入参</li>
<li>桶内的元素根据新的桶数组长度确定新的位置，放置到新的桶数组中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable &#x3D; table;</span><br><span class="line">    int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable &#x3D; new Entry[newCapacity];</span><br><span class="line">    boolean oldAltHashing &#x3D; useAltHashing;</span><br><span class="line">    useAltHashing |&#x3D; sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (newCapacity &gt;&#x3D; Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    boolean rehash &#x3D; oldAltHashing ^ useAltHashing;</span><br><span class="line">    transfer(newTable, rehash);</span><br><span class="line">    table &#x3D; newTable;</span><br><span class="line">    threshold &#x3D; (int) Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity &#x3D; newTable.length;</span><br><span class="line">    for (Entry&lt;K, V&gt; e : table) &#123;</span><br><span class="line">        &#x2F;&#x2F;链表跟table[i]断裂遍历，头部往后遍历插入到newTable中</span><br><span class="line">        while (null !&#x3D; e) &#123;</span><br><span class="line">            Entry&lt;K, V&gt; next &#x3D; e.next;</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next &#x3D; newTable[i];</span><br><span class="line">            newTable[i] &#x3D; e;</span><br><span class="line">            e &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在看完了<code>HashMap</code>在<code>Java 8</code>和<code>Java 7</code>的实现之后我们回答一下前文中提出来的那几个问题：</p>
<ol>
<li><p><code>HashMap</code>内部的<code>bucket</code>数组长度为什么一直都是2的整数次幂</p>
<p>答：这样做有两个好处，第一，可以通过<code>(table.length - 1) &amp; key.hash()</code>这样的位运算快速寻址，第二，在<code>HashMap</code>扩容的时候可以保证同一个桶中的元素均匀的散列到新的桶中，具体一点就是同一个桶中的元素在扩容后一般留在原先的桶中，一般放到了新的桶中。</p>
</li>
<li><p><code>HashMap</code>默认的<code>bucket</code>数组是多大</p>
<p>答：默认是16，即时指定的大小不是2的整数次幂，<code>HashMap</code>也会找到一个最近的2的整数次幂来初始化桶数组。<!--长度不超过2^30--></p>
</li>
<li><p><code>HashMap</code>什么时候开辟<code>bucket</code>数组占用内存</p>
<p>答：在第一次<code>put</code>的时候调用<code>resize</code>方法</p>
</li>
<li><p><code>HashMap</code>何时扩容？</p>
<p>答：当<code>HashMap</code>中的元素熟练超过阈值时，阈值计算方式是<code>capacity * loadFactor</code>，在<code>HashMap</code>中<code>loadFactor</code>是0.75</p>
</li>
<li><p>桶中的元素链表何时转换为红黑树，什么时候转回链表，为什么要这么设计？</p>
<p>答：当同一个桶中的元素数量大于等于8的时候元素中的链表转换为红黑树，反之，当桶中的元素数量小于等于6的时候又会转为链表，这样做的原因是避免红黑树和链表之间频繁转换，引起性能损耗</p>
</li>
<li><p><code>Java 8</code>中为什么要引进红黑树，是为了解决什么场景的问题？</p>
<p>答：引入红黑树是为了避免<code>hash</code>性能急剧下降，引起<code>HashMap</code>的读写性能急剧下降的场景，正常情况下，一般是不会用到红黑树的，在一些极端场景下，假如客户端实现了一个性能拙劣的<code>hashCode</code>方法，可以保证<code>HashMap</code>的读写复杂度不会低于O(lgN)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>HashMap</code>如何处理<code>key</code>为<code>null</code>的键值对？</p>
<p>答：放置在桶数组中下标为0的桶中</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/08/database/mysql/mysql-%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/database/mysql/mysql-%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">mysql - 常见事务问题解决方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-08 15:59:03" itemprop="dateCreated datePublished" datetime="2022-03-08T15:59:03+08:00">2022-03-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-05-26 17:19:41" itemprop="dateModified" datetime="2022-05-26T17:19:41+08:00">2022-05-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-数据库如何保证先查询，后插入-更新-原子性？"><a href="#1-数据库如何保证先查询，后插入-更新-原子性？" class="headerlink" title="1 数据库如何保证先查询，后插入/更新 原子性？"></a>1 数据库如何保证先查询，后插入/更新 原子性？</h2><p>ref: <a target="_blank" rel="noopener" href="https://blog.51cto.com/u_7592962/2543362">https://blog.51cto.com/u_7592962/2543362</a></p>
<p>当操作积分用户表时，如果accountId在表中没有数据，那新增一条数据用户积分。如果accountId在表中有数据，更新用户积分。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/08/database/mysql/mysql-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/database/mysql/mysql-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">mysql - 面试问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-08 15:59:03" itemprop="dateCreated datePublished" datetime="2022-03-08T15:59:03+08:00">2022-03-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-05-26 18:10:24" itemprop="dateModified" datetime="2022-05-26T18:10:24+08:00">2022-05-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p>MySQL 脏页刷新到磁盘机制？</p>
<ul>
<li><p>脏页定义：数据存储的最小单元就是数据页，当内存的数据页与磁盘的数据页不一致时，该数据页就是脏页。</p>
</li>
<li><p>脏页生成的时机：由于Write Ahead Log策略，每次事务提交时，innodb先写磁盘，再写内存</p>
</li>
<li><p>脏页落盘（刷新）的时机：</p>
<ul>
<li>MySQL中，刷新的规则叫checkpoint机制，共2种</li>
<li>sharp checkpoint：在数据库关闭时，刷新所有的脏页到磁盘。</li>
<li>fuzzy checkpoint：刷新一部分脏页到磁盘中。<ul>
<li>定时刷新</li>
<li>Flush LRUlist checkpoint ：当LRU中列表中空闲页不足时，强制LRU删除一些末尾的页，如果存在脏页，那么需要checkpoint刷新</li>
<li>async/sync checkpoint ：指重做日志文件不可用时，需要强制将脏页列表中的一些页刷新回磁盘。这可以保证重做日志文件可循环使用</li>
<li>dirty too much checkpoint：关注系统中的整体脏页比例，如果达到一定比例，强制刷新</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>MySQL innodb 引擎的索引结构，B+树一般都多高？ 层高怎么计算？</p>
<ul>
<li><p>不超过3层，因为磁盘的IO查询超过3次会影响性能</p>
</li>
<li><p>影响层高的因素（假设一行数据大小为1kb，非叶子节点的指针是14byte）</p>
<ul>
<li><p>mysql的存储基本单位为数据页，大小=16kb</p>
</li>
<li><p>因为B+树的非叶子节点存储指针，叶子节点存储数据，所以层高与数据行数的关系：<br>*<em>数据量=（非叶子节点的存储指针数量）^ (层高-1) * 一个数据页存储的行数*</em></p>
<ul>
<li>1层的数据行数最大为: (16kb/1kb)^(1-1) = 16条数据</li>
<li>2层的数据行数最大为: (16kb/14byte)^(2-1) * (16kb/1kb) = 18k 条数据</li>
<li>3层的数据行数最大为: (16kb/14byte)^(3-1) * (16kb/1kb) = 20.89w条数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>sql join 驱动表如何选择？</p>
<ul>
<li><p>mysql中的join，底层实现都是用的nested loop</p>
</li>
<li><p>小表驱动大表</p>
<ul>
<li>当使用left join时，左表是驱动表，右表是被驱动表</li>
<li>当使用right join时，右表是驱动表，左表是被驱动表</li>
<li>当使用inner join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>mysql 查询语句执行流程？</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关</li>
<li><strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</li>
</ul>
</li>
</ol>
<ol start="5">
<li>造成慢sql 常见原因有哪些？<ul>
<li>查询条件没有索引，或者索引失效</li>
<li>操作等待锁资源，比如update，select for update</li>
<li>单表数据量过大</li>
</ul>
</li>
</ol>
<ol start="6">
<li>如何分析慢查询，慢查询的分析步骤？ explain 返回的列的含义？<ul>
<li>使用慢查询定位执行慢的SQL：<ul>
<li>慢日志存储路径：show variables like ‘%query%’;</li>
</ul>
</li>
<li>explain 返回的列的含义<ul>
<li>id:SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>
<li>select_type: SELECT 查询的类型.</li>
<li>table: 查询的是哪个表</li>
<li>partitions: 匹配的分区</li>
<li>type: join 类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引. ref: 哪个字段或常数与 key 一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/17/My%20Lord%20Jesus/%E7%A5%9E%E5%AD%A6%E5%AF%BC%E8%AE%BA-%E6%9E%97%E8%80%81%E5%B8%88/44%E8%AF%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/17/My%20Lord%20Jesus/%E7%A5%9E%E5%AD%A6%E5%AF%BC%E8%AE%BA-%E6%9E%97%E8%80%81%E5%B8%88/44%E8%AF%BE/" class="post-title-link" itemprop="url">44课</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-17 22:17:44" itemprop="dateCreated datePublished" datetime="2022-02-17T22:17:44+08:00">2022-02-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-06-18 23:23:45" itemprop="dateModified" datetime="2022-06-18T23:23:45+08:00">2022-06-18</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>人的犯罪</p>
<p>我们领受了不合圣经的教导，通过各种途径达到最终不犯罪的状态</p>
<p>圣洁的重要性：</p>
<ol>
<li>神要求我们圣洁</li>
<li>基督道成肉身的目的</li>
<li>圣洁的生活，是活泼信心的唯一依据</li>
<li>圣洁的生活，是爱zhu的唯一依据</li>
<li>是做神儿女、得救的唯一依据</li>
<li>我们若圣洁，得以圣洁</li>
<li>我们今生的平安，在于圣经</li>
<li>我们若不圣洁，无法进入圣洁的天家</li>
</ol>
<p>称义和成圣</p>
<ol>
<li>都来自神的恩典</li>
<li>都是基督的救恩和约中，成就的</li>
<li>一个被chengyi的人，一定是个圣经的人；一个圣经的人，一定是chengyi</li>
<li>一个人得救，一定要称义和成圣</li>
<li>称义</li>
</ol>
<p>基督徒为什么老是犯罪？</p>
<ol>
<li>耶稣基督称义和圣灵重生的工作<ul>
<li>耶稣的死，使我们从罪的刑法释放了</li>
<li>耶稣的死，使我们从罪和魔鬼的权势释放了</li>
<li>圣灵重生我们的时候，使我们从罪和魔鬼的权势释放了</li>
<li>圣灵要用我们一生，经历到圣灵具体使我们从罪中释放</li>
<li>当我们离开世界，就全然成圣</li>
</ul>
</li>
<li>我们是谁？是那个在泥中的猪吗？还是公主王子呢？<ul>
<li>“我们”不喜欢、不愿意犯罪的，同意神的话，真的是你心中最大的愿望吗？</li>
<li>罗马7, “我”是真我，是被神洁净的，第一号意愿；我们里面有第二号意愿，</li>
<li>战战兢兢的打仗，靠着主耶稣，与第二号意愿打仗</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">交换排序-冒泡排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-20 20:40:04 / Modified: 20:40:46" itemprop="dateCreated datePublished" datetime="2021-11-20T20:40:04+08:00">2021-11-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/Users/qifei/Documents/blog/source/_posts/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="冒泡排序动图"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">insert-sorting</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-20 16:14:02 / Modified: 21:01:08" itemprop="dateCreated datePublished" datetime="2021-11-20T16:14:02+08:00">2021-11-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-quick-sorting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-quick-sorting/" class="post-title-link" itemprop="url">quick sorting</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-20 16:13:39 / Modified: 20:38:38" itemprop="dateCreated datePublished" datetime="2021-11-20T16:13:39+08:00">2021-11-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter05-servlet%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter05-servlet%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">chapter05-servlet容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-07 20:14:36" itemprop="dateCreated datePublished" datetime="2021-10-07T20:14:36+08:00">2021-10-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-14 08:59:41" itemprop="dateModified" datetime="2021-10-14T08:59:41+08:00">2021-10-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lovejavaydj/category_9267782.html">https://blog.csdn.net/lovejavaydj/category_9267782.html</a></p>
<!--socket转化为request和response这项工作已经被httpConnector和httpProcessor解决了，那么如何处理请求交给servlet容器，比如日志、添加请求头、业务..-->

<p>servelet容器是用来处理请求servlet资源，为web client端填充response对象的模块。servlet容器是org.apache.catalina.Container接口的实现。</p>
<!--org.apache.catalina包是接口, -org.apache.catalina.core包是具体实现-->



<h2 id="5-1-Container接口"><a href="#5-1-Container接口" class="headerlink" title="5.1 Container接口"></a>5.1 Container接口</h2><p>一个容器必须实现 org.apache.catalina.Container 接口。如第4章中看到，传递一个 Container 实例给 Connector 对象的 setContainer()方法，然后Connector 就可以调用 container 的 invoke() 方法，重新看第4章中Bootstrap 类的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpConnector connector = <span class="keyword">new</span> HttpConnector();</span><br><span class="line">SimpleContainer container = <span class="keyword">new</span> SimpleContainer();</span><br><span class="line">connector.setContainer(container);</span><br></pre></td></tr></table></figure>

<p>首先需要注意的是，对于 Catalina 容器，在不同的概念上，它一共有4种不同类型的容器：</p>
<p>1》Engine：表示整个 Catalina 的 servlet 引擎<br>2》Host：表示一拥有数个上下文(context)的虚拟主机<br>3》Context：表示一 Web 应用，一个 context 包含一个或多个wrapper<br>4》Wrapper：表示一个独立的 servlet</p>
<p>上面的每个概念级别都由org.apache.catalin包中的接口表示。Engine、Host、Context和 Wrapper 接口都实现了 Container 接口。它们的标准实现是 StandardEngine,StandardHost, StandardContext, StandardWrapper，它们都是org.apache.catalina.core 包的一部分。</p>
<p>图 5.1 表示了 Container 接口和它的子接口的结构图。注意接口都是org.apache.catalina 包的，而所有的类都是 org.apache.catalina.core 包的。<br><img src="https://img-blog.csdn.net/20170115205718774?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>图 5.1: Container相关类图</p>
<blockquote>
<p>注意:</p>
<p>所有的类都扩展自抽象类 ContainerBase。</p>
<p>Catalina 功能部署不一定需要所有的四种类型容器。例如本章第一个应用程序就仅包括一个 wrapper，而第二个应用程序包含 Context 和wrapper 容器模块。在本章附带的应用程序中不需要host和engine。</p>
</blockquote>
<p>一个容器可以有一个或多个低层次上的子容器。例如，一个 Context 有一个或多个 wrapper；一个host有零个或多个context。 然而 wrapper 作为最底层容器，则不能包含子容器。把个容器添加到另一容器中可以使用 Container 接口中定义的 addChild()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加子容器；Host容器下只能添加Context容器。。。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Container child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除子容器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Container child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名称查找子容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Container <span class="title">findChild</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找子容器集合</span></span><br><span class="line">    <span class="keyword">public</span> Container[] findChildren();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它组件的get/set方法，包括：载入器（Loader）、记录器（Logger）、Session管理器（Manager）、领域（Realm）、资源（Resource）</span></span><br><span class="line"></span><br><span class="line">    容器是Tomcat的核心，所以才将所有组件都与容器连接起来，而且通过Lifecyle接口，使我们可以只启动容器组件就可以了（他帮我们启动其它组件）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：这是组合模式的一种使用</p>
</blockquote>
<p>一个容器还包含一系列的部分如 Lodder、Loggee、Manager、Realm 和Resources。我们将会在后边章节中讨论这些组成部分。</p>
<p>更有意思的是Container接口被设计成Tomcat管理员可以通过server.xml文件配置来决定其工作方式的模式。它通过一个 pipeline和容器中一系列的valves来实现，这些内容将会在下一节 “管道流水线任务”中讨论。</p>
<h2 id="5-2-管道任务"><a href="#5-2-管道任务" class="headerlink" title="5.2 管道任务"></a>5.2 管道任务</h2><p>本章节介绍当connector 调用容器(container)的 invoke() 方法会发生什么。后续子章节中讨论org.apache.catalina 中4个相关接口：Pipeline, Valve, ValveContext和Contained。</p>
<p>这里是 Container 接口中 invoke() 方法在org.apache.catalina.core.ContainerBase 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    pipeline.invoke(request, response); <span class="comment">//这里pipeline是容器中 Pipeline 接口的一个实例。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个管道(pipeline)中包含了该容器要调用的所有任务。每一个阀门(valve)表示着一特定任务。一个容器的管道中有一个<font color="red">基本的阀门</font>，但是我们可以添加任意想要添加的阀门。阀门的数目定义为添加的阀门的个数（不包括基本阀门）。有趣的是，阀门可以通过编辑 Tomcat 的配置文件 server.xml 来动态地添加。</p>
<p>一个管道线就像一个过滤链，每一个阀门像一个过滤器。跟过滤器一样，一个阀门可以操作处理传递给它的 request 和 response 对象。一个阀门完成处理后，它则进一步调用管道中的下一个阀门，基本阀门总是在最后才被调用。</p>
<p>一个容器可以有一个管道。当容器的 invoke() 方法被调用时，容器将通过管道处理，且管理调用在其中的第一个阀门，一个接一个阀门的调用处理，直到所有阀门都被处理完毕。可以想象管道的 invoke() 方法的伪代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invoke each valve added to the pipeline</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;valves.length; n++) &#123;</span><br><span class="line">    valve[n].invoke( ... );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then, invoke the basic valve</span></span><br><span class="line">basicValve.invoke( ... );</span><br></pre></td></tr></table></figure>

<p>但是，Tomcat 设计者通过引入org.apache.catalina.ValveContext接口选择了一种不同处理方式。这里将介绍它是如何工作的。</p>
<p><a href="">容器不会硬编码它的invoke()方法被调用时应该做什么。反而，容器调用的是管道的 invoke()方法</a>。管道接口的 invoke() 方法跟容器接口的invoke() 方法签名相同，方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br></pre></td></tr></table></figure>

<p>一个Pipeline的 invoke() 方法可以如下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">   <span class="comment">// Invoke the first Valve in this pipeline for this request</span></span><br><span class="line">   (<span class="keyword">new</span> SimplePipelineValveContext()).invokeNext(request, response);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><a href="">现在，管道必须保证添加给它的阀门必须如基本阀门一样被调用一次。</a><strong>管道通过创建一</strong><br><strong>个 ValveContext 接口的实例来实现</strong>。ValveContext 是管道的内部类，这样 ValveContext 就可以访问管道中所有成员。ValveContext 中最重要的方法是 invokeNext() 方法：</p>
<p>在创建一个 ValveContext 实例之后，管道调用 ValveContext 的 invokeNext()方法。ValveContext 会先唤起管道中的第一个阀门，然后第一个阀门会在完成它的任务之前继续唤起下一个阀门。ValveContext 将它自己传递给每一个阀门，那么该阀门就可以调用 ValveContext 的 invokeNext() 方法。</p>
<p>Valve 接口的 invoke()签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">invoke</span><span class="params">(Request request, Response response,</span></span></span><br><span class="line"><span class="function"><span class="params">    ValveContext ValveContext)</span> <span class="keyword">throws</span> IOException, ServletException</span></span><br></pre></td></tr></table></figure>

<p>一个Valve的 invoke() 方法可以如下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response,</span></span></span><br><span class="line"><span class="function"><span class="params">    ValveContext valveContext)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// Pass the request and response on to the next valve in our pipeline</span></span><br><span class="line">    valveContext.invokeNext(request, response);</span><br><span class="line">    <span class="comment">// now perform what this valve is supposed to do，</span></span><br><span class="line">    ...比如下文的HeaderLoggerValve的逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.apache.catalina.core.StandardPipeline 类是所有容器中Pipeline的实现。在Tomcat4 中，这个类中有一个<a href="">内部类 StandardPipelineValveContext</a> 实现了ValveContext 接口，</p>
<blockquote>
<p>仔细推敲会发现，每个Valve都是先调用ValveContext的invokeNext，然后才做自己的工作，所以“第一个”被 pipeline调用的Valve，实际却是最后一个完成自己工作的，有点类似“压栈”操作，第一个Valve最先被压进去，却是最后一个从堆栈中弹出来 的。如果不信，可以做个试验，眼见为实。</p>
</blockquote>
<p>Listing 5.1: Tomcat 4中的StandardPipelineValveContext 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pipeline的内部类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardPipelineValveContext</span> <span class="keyword">implements</span> <span class="title">ValveContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> stage = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeNext</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> subscript = stage;</span><br><span class="line">        stage = stage + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Invoke the requested Valve for the current request thread</span></span><br><span class="line">        <span class="keyword">if</span> (subscript &lt; valves.length) &#123;</span><br><span class="line">            valves[subscript].invoke(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((subscript == valves.length) &amp;&amp; (basic != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            basic.invoke(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException (sm.getString(<span class="string">&quot;standardPipeline.noValve&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>invokeNext()方法中使用subscript和stage记住哪个阀门被唤醒。当第一次唤醒时，subscript的值是 0，stage的值是 1。所以，第一个阀门(数组下标是0)被唤醒，管道的阀门获得 ValveContext 实例接收到ValveContext实例并调用它的 invokeNext() 方法。这时subscript的值是 1， 所以第二个阀门被唤醒，然后一步步地这样继续进行。<!--疑惑，stage作为类变量，是线程安全的吗--></p>
<p>当invokeNext()在最后一个阀门中调用时，subscript值等于总阀门的个数。因此这时，基本阀门被唤醒调用。</p>
<h3 id="5-2-1-Pipeline接口"><a href="#5-2-1-Pipeline接口" class="headerlink" title="5.2.1 Pipeline接口"></a><strong>5.2.1 Pipeline接口</strong></h3><p>我们提到的Pipeline接口的第一种方法是invoke()方法，容器调用它来开始调用管道中的阀门和基本阀门。Pipeline接口允许我们通过addValve()方法添加一个新的阀门或者通过removeValve()方法删除一个阀门。最后，可以使用 setBasic()方法来分配一个基本阀门给管道，使用getBasic()方法会得到基本阀门。最后调用的基本阀门负责处理请求和相应的响应。</p>
<p>Listing 5.3: Pipeline接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">public interface Pipeline &#123;</span><br><span class="line">    public Valve getBasic();</span><br><span class="line">    public void setBasic(Valve valve);</span><br><span class="line">    public void addValve(Valve valve);</span><br><span class="line">    public Valve[] getValves();</span><br><span class="line">    public void invoke(Request request, Response response)</span><br><span class="line">        throws IOException, ServletException;</span><br><span class="line">    public void removeValve(Valve valve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-Valve接口"><a href="#5-2-2-Valve接口" class="headerlink" title="5.2.2 Valve接口"></a><strong>5.2.2 Valve接口</strong></h3><p>Value接口表示一个阀门，该组件负责处理请求。该接口有两个方法，invoke() 和getInfo()方法。invoke()方法如上面已讨论过，getInfo()方法返回阀门的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">public interface Valve &#123;</span><br><span class="line">    public String getInfo();</span><br><span class="line">    public void invoke(Request request, Response response,</span><br><span class="line">        ValveContext context) throws IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-ValveContext接口"><a href="#5-2-3-ValveContext接口" class="headerlink" title="5.2.3 ValveContext接口"></a><strong>5.2.3 ValveContext接口</strong></h3><p>ValveContext接口有两个方法，invokeNext()方法如上已讨论，getInfo()方法会返回valveContext的实现信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">public interface ValveContext &#123;</span><br><span class="line">    public String getInfo();</span><br><span class="line">    public void invokeNext(Request request, Response response)</span><br><span class="line">        throws IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-Contained接口"><a href="#5-2-4-Contained接口" class="headerlink" title="5.2.4 Contained接口"></a><strong>5.2.4 Contained接口</strong></h3><p>阀门类可以选择性实现org.apache.catalina.Contained接口。此接口指定实现类最多与一个相关联容器实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line"></span><br><span class="line">public interface Contained &#123;</span><br><span class="line">    public Container getContainer();</span><br><span class="line">    public void setContainer(Container container);</span><br><span class="line">&#125;123456</span><br></pre></td></tr></table></figure>



<h2 id="5-3-Wrapper接口"><a href="#5-3-Wrapper接口" class="headerlink" title="5.3 Wrapper接口"></a>5.3 Wrapper接口</h2><p>org.apache.catalina.Wrapper 接口表示一个包装器。包装器是表示单个servlet定义的容器。包装器继承了Container接口，并且添加了几个方法。包装器的实现类负责管理其servlet 的生命中期，包括 servlet 的init()、service()、和 destroy()方法。由于包装器是最底层的容器，所以不可以将子容器添加给它。<a href="">如果 addChild()方法被调用，则会产生IllegalArgumantException 异常。</a></p>
<p>包装器接口中重要方法有 allocate() 和 load() 方法。allocate() 方法负责定位该包装器表示的 servlet 的实例。allocate()方法必须考虑一个 servlet 是否实现了javax.servlet.SingleThreadModel 接口，该部分内容将会在 11 章中进行讨论。load() 方法负责加载和初始化 servlet 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 载入并加载servlet，在它的子类StandardWrapper中直接调用的loadServlet方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法会返回已加载的servlet类，还要考虑它是否实现了SingleThreadModel</span></span><br><span class="line"><span class="function">Servlet <span class="title">allocate</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-Context接口"><a href="#5-4-Context接口" class="headerlink" title="5.4 Context接口"></a><strong>5.4 Context接口</strong></h2><p>一个 context 容器表示一个 web 应用。一个 context 通常含有一个或多个包装器作为其子容器。重要的方法包括 addWrapper(), createWrapper() 等方法。该接口将会在第 12 章中详细介绍。</p>
<h2 id="5-5-Wrapper应用Demo"><a href="#5-5-Wrapper应用Demo" class="headerlink" title="5.5 Wrapper应用Demo"></a><strong>5.5 Wrapper应用Demo</strong></h2><p>这个应用Demo展示了如何写一个简单的容器模型。该应用程序的核心类是ex05.pyrmont.core.SimpleWrapper，它实现了 Wrapper 接口。SimpleWrapper类包括一个 Pipeline（由 ex05.pyrmont.core.SimplePipeline 实现）和一个Loader 类（ex05.pyrmont.core.SimpeLoader）来加载一个 servlet。管道包括一个基本阀门（ex05.pyrmont.core.SimpleWrapperValve）和两个另外的阀门<br>(ex05.pyrmont.core.ClientIPLoggerValve 和ex05.pyrmont.core.HeaderLoggerValve)。该应用的类结构图如图 5.3 所示：</p>
<p><img src="https://img-blog.csdn.net/20170115210024548?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>注意：该容器使用的是Tomcat 4的默认连接器</p>
<p>包装器包装的是前面章节已经使用过的 ModernServlet类。这个应用程序表示一个 servlet 容器可以只有一单一的包装器构成。这些类都没有完整的实现，只是实现了必要方法。接下来看程序的具体实现。</p>
<h4 id="core-SimpleLoader"><a href="#core-SimpleLoader" class="headerlink" title="core.SimpleLoader"></a><strong>core.SimpleLoader</strong></h4><p>容器中加载 servlet 的任务分配给了 Loader 实现。在该程序中 SimpleLoader就是一个 Loader 实现。它知道如何定位一个 servlet，并且通过 getClassLoader()获得一个 java.lang.ClassLoader 实例用来查找 servlet 类位置。</p>
<ul>
<li>SimpleLoader定义了 3 个变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个是 WEB_ROOT 用来指明在哪里查找 servlet 类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEB_ROOT =</span><br><span class="line">        System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + File.separator + <span class="string">&quot;webroot&quot;</span>;</span><br><span class="line"><span class="comment">//另外两个变量是 ClassLoader 和 Container：</span></span><br><span class="line">ClassLoader classLoader = <span class="keyword">null</span>;</span><br><span class="line">Container container = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>SimpleLoader 类的构造器初始化类加载器，以便于准备返回一个 SimpleWrapper实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL[] urls = <span class="keyword">new</span> URL[l];</span><br><span class="line">        URLStreamHandler streamHandler = <span class="keyword">null</span>;</span><br><span class="line">        File classPath = <span class="keyword">new</span> File(WEB_ROOT);</span><br><span class="line">        String repository = (<span class="keyword">new</span> URL(<span class="string">&quot;file&quot;</span>, <span class="keyword">null</span>,</span><br><span class="line">            classPath.getCanonicalPath() + File.separator)).toString() ;</span><br><span class="line">        urls[<span class="number">0</span>] = <span class="keyword">new</span> URL(<span class="keyword">null</span>, repository, streamHandler);</span><br><span class="line">        classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的构造器用于初始化一个类加载器如前面章节所用的一样。container变量表示容器跟该加载器是相关联。</p>
<p>注意：加载器将在第8章详细讨论。</p>
<h4 id="core-SimplePipeline"><a href="#core-SimplePipeline" class="headerlink" title="core.SimplePipeline"></a><strong>core.SimplePipeline</strong></h4><p>SimplePipeline 实现了 org.apache.catalina.Pipeline 接口。该类中最重要的方法是 invoke() 方法，其中包括了一个内部类 SimplePipelineValveContext。SimplePipelineValveContext 实现了 org.apache.catalina.ValveContext 接口如上面章节所介绍。</p>
<h4 id="core-SimpleWrapper"><a href="#core-SimpleWrapper" class="headerlink" title="core. SimpleWrapper"></a><strong>core. SimpleWrapper</strong></h4><p>该类实现了 org.apache.catalina.Wrapper 接口并且实现了 allocate() 方法和load() 方法，并声明了如下变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private Loader loader;</span><br><span class="line">protected Container parent &#x3D; null;</span><br></pre></td></tr></table></figure>

<p>loader 变量用于加载一个 servlet 类。parent 变量表示该包装器的父容器。这意味着，该容器可以是其它容器的子容器，例如 Context。</p>
<p>需要特别注意 getLoader()方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Loader <span class="title">getLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (loader);</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (parent.getLoader());</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getLoader()方法用于返回一个 Loader 对象用于加载一个 servlet 类。如果一个包装器跟一个加载器相关联，会返回该加载器。否则返回其父容器的加载器，如果没有父容器，则返回 null。</p>
<p>SimpleWrapper 类有一个管道和该管道的基本阀门。这些工作在SimpleWrapper 的构造函数中完成。</p>
<p>Listing 5.8:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中，pipeline是 SimplePipeline 类的一个实例：</span></span><br><span class="line"><span class="keyword">private</span> SimplePipeline pipeline = <span class="keyword">new</span> SimplePipeline(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipeline.setBasic(<span class="keyword">new</span> SimpleWrapperValve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="core-SimpleWrapperValve"><a href="#core-SimpleWrapperValve" class="headerlink" title="core. SimpleWrapperValve"></a><strong>core. SimpleWrapperValve</strong></h4><p>SimpleWrapperValve 类是一个给 SimpleWrapper 类专门处理请求的<a href="">基本阀门</a>。它实现了 org.apache.catalina.Valve 接口和org.apache.catalina.Contained接口。最重要的方法是 invoke() 方法，如 Listing5.9 所示：</p>
<p>Listing 5.9: SimpleWrapperValve类的invoke()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    SimpleWrapper wrapper = (SimpleWrapper) getContainer();</span><br><span class="line">    ServletRequest sreq = request.getRequest();</span><br><span class="line">    ServletResponse sres = response.getResponse();</span><br><span class="line">    Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line">    HttpServletRequest hreq = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (sreq <span class="keyword">instanceof</span> HttpServletRequest)</span><br><span class="line">      hreq = (HttpServletRequest) sreq;</span><br><span class="line">    HttpServletResponse hres = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (sres <span class="keyword">instanceof</span> HttpServletResponse)</span><br><span class="line">      hres = (HttpServletResponse) sres;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a servlet instance to process this request</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      servlet = wrapper.allocate();</span><br><span class="line">      <span class="keyword">if</span> (hres!=<span class="keyword">null</span> &amp;&amp; hreq!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        servlet.service(hreq, hres);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        servlet.service(sreq, sres);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">由于 SimpleWrapperValve 被当做一基本阀门来使用，所以它的 invoke() 方法不需要invokeNext()方法。</font></p>
<p>invoke()方法调用SimpleWrapper的allocate()方法获得servlet的实例。然后调用 servlet 的 service() 方法。注意包装器管道的基本阀门唤醒的是 servlet 的 service ()方法，而不是 wrapper自己。</p>
<h4 id="ex05-pyrmont-valves-ClientIPLoggerValve"><a href="#ex05-pyrmont-valves-ClientIPLoggerValve" class="headerlink" title="ex05.pyrmont. valves. ClientIPLoggerValve"></a><strong>ex05.pyrmont. valves. ClientIPLoggerValve</strong></h4><p>ClientIPLoggerValve 是一个阀门，它打印客户端的 IP 地址到控制台。该类如 Listing5.10:</p>
<p>Listing 5.10: ClientIPLoggerValve类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex05.pyrmont.valves;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Valve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.ValveContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Contained;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Container;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientIPLoggerValve</span> <span class="keyword">implements</span> <span class="title">Valve</span>, <span class="title">Contained</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Container container;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass this request on to the next valve in our pipeline</span></span><br><span class="line">    valveContext.invokeNext(request, response);</span><br><span class="line">    System.out.println(<span class="string">&quot;Client IP Logger Valve&quot;</span>);</span><br><span class="line">    ServletRequest sreq = request.getRequest();</span><br><span class="line">    System.out.println(sreq.getRemoteAddr());</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.container = container;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p> invoke() 方法，它的第一件事情是调用阀门上下文 invokeNext ()方法来唤醒下一个阀门，然后它会打印出请求对象的 getRemoteAddr() 方法的输出。</p>
</blockquote>
<h4 id="ex05-pyrmont-valves-HeaderLoggerValve"><a href="#ex05-pyrmont-valves-HeaderLoggerValve" class="headerlink" title="ex05.pyrmont. valves. HeaderLoggerValve"></a><strong>ex05.pyrmont. valves. HeaderLoggerValve</strong></h4><p>该类跟 ClientIPLoggerValve 类非常相似。HeaderLoggerValve 是一个阀门打印请求头部信息到控制台上。该类如 Listing5.11：</p>
<p>Listing 5.11: HeaderLoggerValve 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex05.pyrmont.valves;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Valve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.ValveContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Contained;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Container;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderLoggerValve</span> <span class="keyword">implements</span> <span class="title">Valve</span>, <span class="title">Contained</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Container container;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass this request on to the next valve in our pipeline</span></span><br><span class="line">    valveContext.invokeNext(request, response);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Header Logger Valve&quot;</span>);</span><br><span class="line">    ServletRequest sreq = request.getRequest();</span><br><span class="line">    <span class="keyword">if</span> (sreq <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">      HttpServletRequest hreq = (HttpServletRequest) sreq;</span><br><span class="line">      Enumeration headerNames = hreq.getHeaderNames();</span><br><span class="line">      <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">        String headerName = headerNames.nextElement().toString();</span><br><span class="line">        String headerValue = hreq.getHeader(headerName);</span><br><span class="line">        System.out.println(headerName + <span class="string">&quot;:&quot;</span> + headerValue);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      System.out.println(<span class="string">&quot;Not an HTTP Request&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.container = container;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>其 invoke() 方法，该方法首先调用阀门的 invokeNext()方法唤醒下一个阀门。然后打印出头部的值。</p>
</blockquote>
<h4 id="pyrmont-startup-Bootstrap1"><a href="#pyrmont-startup-Bootstrap1" class="headerlink" title="pyrmont.startup.Bootstrap1"></a><strong>pyrmont.startup.Bootstrap1</strong></h4><p>Bootstrap1 用于启动这个应用程序。</p>
<p>Listing 5.12: Bootstrap1 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex05.pyrmont.startup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.core.SimpleLoader;</span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.core.SimpleWrapper;</span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.valves.ClientIPLoggerValve;</span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.valves.HeaderLoggerValve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Loader;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Pipeline;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Valve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Wrapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.http.HttpConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* call by using http://localhost:8080/ModernServlet,</span></span><br><span class="line"><span class="comment">   but could be invoked by any name */</span></span><br><span class="line"></span><br><span class="line">    HttpConnector connector = <span class="keyword">new</span> HttpConnector();</span><br><span class="line">    Wrapper wrapper = <span class="keyword">new</span> SimpleWrapper();</span><br><span class="line">    <span class="comment">//创建 HttpConnector 和 SimpleWrapper 类的实例后，分配ModernServlet 给 SimpleWrapper 的 setServletClass() 方法，告诉包装器要加载的类的名字以便于加载。</span></span><br><span class="line">    wrapper.setServletClass(<span class="string">&quot;ModernServlet&quot;</span>);</span><br><span class="line">    <span class="comment">//然后创建了加载器和两个阀门，然后将其加载器赋给包装器：</span></span><br><span class="line">    Loader loader = <span class="keyword">new</span> SimpleLoader();</span><br><span class="line">    Valve valve1 = <span class="keyword">new</span> HeaderLoggerValve();</span><br><span class="line">    Valve valve2 = <span class="keyword">new</span> ClientIPLoggerValve();</span><br><span class="line">    wrapper.setLoader(loader);</span><br><span class="line">     <span class="comment">//然后把两个阀门添加到包装器管道中：</span></span><br><span class="line">    ((Pipeline) wrapper).addValve(valve1);</span><br><span class="line">    ((Pipeline) wrapper).addValve(valve2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后，把包装器当做容器添加到连接器中，然后初始化并启动连接器：</span></span><br><span class="line">    connector.setContainer(wrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      connector.initialize();</span><br><span class="line">      connector.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// make the application wait until we press a key.</span></span><br><span class="line">      System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-8-运行Demo"><a href="#5-5-8-运行Demo" class="headerlink" title="5.5.8 运行Demo"></a><strong>5.5.8 运行Demo</strong></h4><p>在 Linux 下，使用冒号分开两个库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .&#x2F;lib&#x2F;servlet.jar:.&#x2F; ex05.pyrmont.startup.Bootstrap11</span><br></pre></td></tr></table></figure>

<p>可以使用下面的 URL 来请求servlet：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:80801</span><br></pre></td></tr></table></figure>

<p>浏览器将会显示从 ModernServlet 得到的响应回复。跟下面相似的内容会显示在控制台上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ModernServlet -- init</span><br><span class="line">Client IP Logger Valve</span><br><span class="line">127.0.0.1</span><br><span class="line">------------------------------------</span><br><span class="line">Header Logger Valve</span><br><span class="line">host:localhost:8080</span><br><span class="line">user-agent:Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko&#x2F;20100101 Firefox&#x2F;50.0</span><br><span class="line">accept:text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">accept-language:zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3</span><br><span class="line">accept-encoding:gzip, deflate</span><br><span class="line">connection:keep-alive</span><br><span class="line">upgrade-insecure-requests:1</span><br><span class="line">------------------------------------</span><br></pre></td></tr></table></figure>

<!--果然最先添加的valve，是最后执行的，递归操作，类似stack-->



<h2 id="5-6-Context应用Demo"><a href="#5-6-Context应用Demo" class="headerlink" title="5.6 Context应用Demo"></a><strong>5.6 Context应用Demo</strong></h2><p>在本章第一个Demo中，介绍了如何部署一个仅仅包括一个包装器(Wrapper)的简单web应用。该程序仅包括一个 servlet。也许会有一些应用仅仅需要一个 servlet，可是大多数的网络应用需要多个 servlet。在这些应用中，我们需要一个跟包装器（wrapper）不同的容器：上下文（context）。</p>
<p>第二个Demo将会示范如何使用一个包含两个包装器的上下文来包装两个servlet 类。当有多于一个包装器时，需要一个 map 来处理这些子容器——本Demo中使用Context容器，对于特殊的请求可以使用特殊的子容器来处理。</p>
<blockquote>
<p>注意 使用 map 方法是在 Tomcat4 中，Tomcat 5 使用了另一种机制来查找子容器。</p>
</blockquote>
<p>在这个程序中，mapper 是 ex05.pyrmont.core.SimpleContextMapper 类的一个实例，它继承Tomcat 4 中org.apache.catalina.Mapper 接口。一个容器也可以有多个 mapper 来支持多协议。例如容器可以用一个 mapper 来支持 HTTP 协议，而使用另一个 mapper 来支持 HTTPS 协议。Listing5.13 提供了 Tomcat4 中的 Mapper 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line"></span><br><span class="line">public interface Mapper &#123;</span><br><span class="line">    public Container getContainer();</span><br><span class="line">    public void setContainer(Container container);</span><br><span class="line">    public String getProtocol();</span><br><span class="line">    ublic void setProtocol(String protocol);</span><br><span class="line">    ublic Container map(Request request, boolean update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getContainer()获取该容器的 mapper，setContainer() 方法用于关联一个容器到mapper。getProtocol() 返回该 mapper 负责处理的协议，setProtocol()用于分配该容器要处理的协议。map()方法返回处理一个特殊请求的子容器。<br><img src="https://img-blog.csdn.net/20170115210322558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>图 5.4 是该Demo结构图。</p>
<p>SimpleContext表示一个上下文，它使用SimpleContextMapper作为它的mapper，SimpleContextValve 作为它的基本阀门。该上下文包括两个阀门ClientIPLoggerValve 和 HeaderLoggerValve。用 SimpleWrapper 表示的两个包装器作为该上下文的子容器被添加到其中。包装器 SimpleWrapperValve 作为它的基阀门，但是没有其它的阀门了。</p>
<p>该Context应用程序使用同一个加载器、两个阀门。<a href="">但是加载器和阀门是跟该Context关联的，而不是跟包装器关联</a>。这样，两个包装器就可以都使用该加载器。该Conetext被当做连接器的容器。因此，连接器每次收到一个 HTTP 请求可以使用上下文的 invoke() 方法。根据前面介绍的内容，其余的不难理解。</p>
<p>1》一个容器有一个管道，容器的 invoke() 方法会调用管道的invoke()方法<br>2》管道的 invoke()方法会调用添加到容器中的阀门的 invoke()方法，然后调用基本阀门的 invoke()方法<br>3》在一包装器中，基本阀门负责加载相关的 servlet 类并对请求作出相应<br>4》在一个有子容器的上下文中，基阀门使用 mapper 来查找负责处理请求的子容器。如果一个子容器被找到，子容器的 invoke() 方法会被调用，然后返回步骤 1</p>
<p>现在让我们看看实现中的处理流程。</p>
<p>SimpleContext 的 invoke() 方法调用管道的 invoke() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line">        pipeline.invoke(request, response);</span><br><span class="line">&#125;1234</span><br></pre></td></tr></table></figure>

<p>pipeline是SimplePipeline 类实例，用来表示管道，它的 invoke()方法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line">    &#x2F;&#x2F; Invoke the first Valve in this pipeline for this request</span><br><span class="line">    (new SimplePipelineValveContext()).invokeNext(request, response);</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure>

<p>如“管道任务”一节中介绍的，该段代码唤醒所有阀门，然后调用基阀门的invoke()方法。在SimpleContext中SimpleContextValve代表着基阀门。在它的invoke()方法中SimpleContextValve使用上下文的mapper是查找一个包装器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Select the Wrapper to be used for this Request</span><br><span class="line">Wrapper wrapper &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    wrapper &#x3D; (Wrapper) context.map(request, true);</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure>

<p>如果一个包装器被找到，它的invoke()方法会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrapper.invoke(request, response);1</span><br></pre></td></tr></table></figure>

<p>本Demo着通过SimpleWrapper表示一个包装器。如下是其invoke()方法，和SimpleContext类的invoke()方法完全一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line">    pipeline.invoke(request, response);</span><br><span class="line">&#125;1234</span><br></pre></td></tr></table></figure>

<p>管道是SimplePipeline的一个实例，其调用方法已在上面列出。本Demo中包装器是SimpleWrapperValve的实例，它除了有基阀门外没其它阀门。包装器的管道调用SimpleWrapperValve类的invoke()方法，它分配一个servlet并调用其service()方法，如上文“Wrapper应用Demo”一节中所述。</p>
<p>注意，包装器不与加载器相关联，而是上下文与其关联。 因此，SimpleWrapper类的getLoader()方法返回父级（Context）的加载器。</p>
<p>有4个类：SimpleContext, SimpleContextValve, SimpleContextMapper和Bootstrap2在前面小节没被提到，在下面将讨论。</p>
<h4 id="5-6-1-core-SimpleContextValve"><a href="#5-6-1-core-SimpleContextValve" class="headerlink" title="5.6.1 core.SimpleContextValve"></a><strong>5.6.1 core.SimpleContextValve</strong></h4><p>此类作为SimpleContext的基阀门。它的最重要的方法invoke()代码如Listing 5.14：</p>
<p>Listing 5.14: SimpleContextValve类的invoke()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// Validate the request and response object types</span></span><br><span class="line">    <span class="keyword">if</span> (!(request.getRequest() <span class="keyword">instanceof</span> HttpServletRequest) ||</span><br><span class="line">      !(response.getResponse() <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;     <span class="comment">// NOTE - Not much else we can do generically</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disallow any direct access to resources under WEB-INF or META-INF</span></span><br><span class="line">    HttpServletRequest hreq = (HttpServletRequest) request.getRequest();</span><br><span class="line">    String contextPath = hreq.getContextPath();</span><br><span class="line">    String requestURI = ((HttpRequest) request).getDecodedRequestURI();</span><br><span class="line">    String relativeURI =</span><br><span class="line">      requestURI.substring(contextPath.length()).toUpperCase();</span><br><span class="line"></span><br><span class="line">    Context context = (Context) getContainer();</span><br><span class="line">    <span class="comment">// Select the Wrapper to be used for this Request</span></span><br><span class="line">    Wrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      wrapper = (Wrapper) context.map(request, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      badRequest(requestURI, (HttpServletResponse) response.getResponse());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">      notFound(requestURI, (HttpServletResponse) response.getResponse());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ask this Wrapper to process this Request</span></span><br><span class="line">    response.setContext(context);</span><br><span class="line">    wrapper.invoke(request, response);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-2-core-SimpleContextMapper"><a href="#5-6-2-core-SimpleContextMapper" class="headerlink" title="5.6.2 core.SimpleContextMapper"></a><strong>5.6.2 core.SimpleContextMapper</strong></h4><p>SimpleContextMapper类实现Tomcat4中的org.apache.catalina.Mapper接口，并被设计成和SimpleContext实例相关联。</p>
<p>Listing 5.15: The SimpleContext 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleContextMapper</span> <span class="keyword">implements</span> <span class="title">Mapper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SimpleContext context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(container <span class="keyword">instanceof</span> SimpleContext))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span><br><span class="line">        (<span class="string">&quot;Illegal type of container&quot;</span>);</span><br><span class="line">    context = (SimpleContext) container;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProtocol</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the child Container that should be used to process this Request,</span></span><br><span class="line"><span class="comment">   * based upon its characteristics.  If no such child Container can be</span></span><br><span class="line"><span class="comment">   * identified, return &lt;code&gt;null&lt;/code&gt; instead.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">map</span><span class="params">(Request request, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Identify the context-relative URI to be mapped</span></span><br><span class="line">    String contextPath =</span><br><span class="line">      ((HttpServletRequest) request.getRequest()).getContextPath();</span><br><span class="line">    String requestURI = ((HttpRequest) request).getDecodedRequestURI();</span><br><span class="line">    String relativeURI = requestURI.substring(contextPath.length());</span><br><span class="line">    <span class="comment">// Apply the standard request URI mapping rules from the specification</span></span><br><span class="line">    Wrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">    String servletPath = relativeURI;</span><br><span class="line">    String pathInfo = <span class="keyword">null</span>;</span><br><span class="line">    String name = context.findServletMapping(relativeURI);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span>)</span><br><span class="line">      wrapper = (Wrapper) context.findChild(name);</span><br><span class="line">    <span class="keyword">return</span> (wrapper);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们传递一个不是SimpleContext实例的容器给setContainer()方法时，它将抛出IllegalArgumentException异常。map()方法返回一个子容器（wrapper），它负责处理请求。map()方法接收二个参数，一个是请求对象，一个是布尔值。这里的方法实现忽略了第二个参数。该方法执行的操作是检索从请求对象中得到上下文路径，并使用context的findServletMapping()方法获取与其路径关联的名称。 如果找到名称，它使用context的findChild()方法来获取Wrapper的实例。</p>
<p><strong>5.6.3 ex05.pyrmont.core.SimpleContext</strong></p>
<p>SimpleContext类是本Demo中Context一个实现。它是分配给连接器的主容器。然而，每个单独的servlet的处理由包装器执行。本应用Demo有2个servlet：PrimitiveServlet和ModernServlet，如此一来就有2个包装器。每个包装器都有名字。名称为Primitive是PrimitiveServlet的包装器，Modern是ModernServlet的包装器。对于每个请求，SimpleContext要决定调用哪个包装器，这个必须使用包装器的名称映射匹配请求URL。在此应用程序中，我们有两个可用于调用2个包装器的URL模式。第一个模式是/ Primitive，它映射到Primitive包装器。 第二个模式是/ Modern，它被映射到Modern包装器。 当然，对于给定的servlet，我们可以使用多个模式。 我们只需要添加这些模式即可。</p>
<p>从Container和Context接口有很多方法，SimpleContext必须实现。 大多数方法是留白，但是这些与映射相关的方法给予了实现代码。 这些方法如下：</p>
<p>1》addServletMapping()方法——添加URL/包装器名称映射对。 添加的每一个，可用于调用具有给定名称的包装器<br>2》findServletMapping()方法——获取和URL对应的包装器名称。这个方法用于为一个指定的URL查找哪个包装器应该被调用。如果给定的模式之前未通过addServletMapping()方法添加过，那么此方法将返回null<br>3》addMapper()方法——添加一个mapper给context。SimpleContext申明mapper和mappers变量。mapper为默认的mapper，mappers包含SimpleContext实例中所有mapper。第一个添加到SimpleContext中的mapper将作为默认mapper<br>4》findMapper()方法——查找当前mapper。在SimpleContext中，返回默认mapper。<br>5》map()方法——返回负责处理此请求的包装器</p>
<p>此外SimpleContext也提供了addChild(),findChild(), 和findChildren()方法实现。addChild()用于添加一个wrapper给context；findChild()用于获取指定名称的wrapper；findChildren()返回SimpleContext实例当中的所有包装器。</p>
<p><strong>5.6.4 ex05.pyrmont.startup.Bootstrap2</strong></p>
<p>Listing 5.16: The Bootstrap2 类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package ex05.pyrmont.startup;</span><br><span class="line"></span><br><span class="line">import ex05.pyrmont.core.SimpleContext;</span><br><span class="line">import ex05.pyrmont.core.SimpleContextMapper;</span><br><span class="line">import ex05.pyrmont.core.SimpleLoader;</span><br><span class="line">import ex05.pyrmont.core.SimpleWrapper;</span><br><span class="line">import ex05.pyrmont.valves.ClientIPLoggerValve;</span><br><span class="line">import ex05.pyrmont.valves.HeaderLoggerValve;</span><br><span class="line">import org.apache.catalina.Context;</span><br><span class="line">import org.apache.catalina.Loader;</span><br><span class="line">import org.apache.catalina.Mapper;</span><br><span class="line">import org.apache.catalina.Pipeline;</span><br><span class="line">import org.apache.catalina.Valve;</span><br><span class="line">import org.apache.catalina.Wrapper;</span><br><span class="line">import org.apache.catalina.connector.http.HttpConnector;</span><br><span class="line"></span><br><span class="line">public final class Bootstrap2 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HttpConnector connector &#x3D; new HttpConnector();</span><br><span class="line">    Wrapper wrapper1 &#x3D; new SimpleWrapper();</span><br><span class="line">    wrapper1.setName(&quot;Primitive&quot;);</span><br><span class="line">    wrapper1.setServletClass(&quot;PrimitiveServlet&quot;);</span><br><span class="line">    Wrapper wrapper2 &#x3D; new SimpleWrapper();</span><br><span class="line">    wrapper2.setName(&quot;Modern&quot;);</span><br><span class="line">    wrapper2.setServletClass(&quot;ModernServlet&quot;);</span><br><span class="line"></span><br><span class="line">    Context context &#x3D; new SimpleContext();</span><br><span class="line">    context.addChild(wrapper1);</span><br><span class="line">    context.addChild(wrapper2);</span><br><span class="line"></span><br><span class="line">    Valve valve1 &#x3D; new HeaderLoggerValve();</span><br><span class="line">    Valve valve2 &#x3D; new ClientIPLoggerValve();</span><br><span class="line"></span><br><span class="line">    ((Pipeline) context).addValve(valve1);</span><br><span class="line">    ((Pipeline) context).addValve(valve2);</span><br><span class="line"></span><br><span class="line">    Mapper mapper &#x3D; new SimpleContextMapper();</span><br><span class="line">    mapper.setProtocol(&quot;http&quot;);</span><br><span class="line">    context.addMapper(mapper);</span><br><span class="line">    Loader loader &#x3D; new SimpleLoader();</span><br><span class="line">    context.setLoader(loader);</span><br><span class="line">    &#x2F;&#x2F; context.addServletMapping(pattern, name);</span><br><span class="line">    context.addServletMapping(&quot;&#x2F;Primitive&quot;, &quot;Primitive&quot;);</span><br><span class="line">    context.addServletMapping(&quot;&#x2F;Modern&quot;, &quot;Modern&quot;);</span><br><span class="line">    connector.setContainer(context);</span><br><span class="line">    try &#123;</span><br><span class="line">      connector.initialize();</span><br><span class="line">      connector.start();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; make the application wait until we press a key.</span><br><span class="line">      System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657</span><br></pre></td></tr></table></figure>

<p>main()方法由实例化Tomcat默认连接器和两个wrappers，wrapper1和wrapper2开始。 这些包装器被命名为Primitive和Modern。 Primitive和Modern的servlet类是PrimitiveServlet和ModernServlet。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpConnector connector &#x3D; new HttpConnector();</span><br><span class="line">Wrapper wrapper1 &#x3D; new SimpleWrapper();</span><br><span class="line">wrapper1.setName(&quot;Primitive&quot;);</span><br><span class="line">wrapper1.setServletClass(&quot;PrimitiveServlet&quot;);</span><br><span class="line">Wrapper wrapper2 &#x3D; new SimpleWrapper();</span><br><span class="line">wrapper2.setName(&quot;Modern&quot;);</span><br><span class="line">wrapper2.setServletClass(&quot;ModernServlet&quot;);1234567</span><br></pre></td></tr></table></figure>

<p>然后，main()方法创建一个SimpleContext实例，并将wrapper1和wrapper2添加为SimpleContext的子容器。它还实例化两个阀门ClientIPLoggerValve和HeaderLoggerValve，并将它们添加到SimpleContext。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Context context &#x3D; new SimpleContext();</span><br><span class="line">context.addChild(wrapper1);</span><br><span class="line">context.addChild(wrapper2);</span><br><span class="line">Valve valve1 &#x3D; new HeaderLoggerValve();</span><br><span class="line">Valve valve2 &#x3D; new ClientIPLoggerValve();</span><br><span class="line">((Pipeline) context).addValve(valve1);</span><br><span class="line">((Pipeline) context).addValve(valve2);1234567</span><br></pre></td></tr></table></figure>

<p>接下来，它从SimpleMapper类构造一个映射器对象并将其添加到SimpleContext。 此映射器负责在上下文中查找子容器来处理HTTP请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mapper mapper &#x3D; new SimpleContextMapper();</span><br><span class="line">mapper.setProtocol(&quot;http&quot;);</span><br><span class="line">context.addMapper(mapper);123</span><br></pre></td></tr></table></figure>

<p>要加载servlet类，则需要一个加载器。 在这里我们使用SimpleLoader类，正如在第一个应用Demo一样。 但是，不是将它添加到两个包装器，而是loader被添加到context中。 包装器将使用它的getLoader()找到加载器，因为context是其父级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loader loader &#x3D; new SimpleLoader();</span><br><span class="line">context.setLoader(loader);12</span><br></pre></td></tr></table></figure>

<p>现在，是时候添加servlet映射了。 我们为2个包装器添加了2个匹配模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; context.addServletMapping(pattern, name);</span><br><span class="line">context.addServletMapping(&quot;&#x2F;Primitive&quot;, &quot;Primitive&quot;);</span><br><span class="line">context.addServletMapping(&quot;&#x2F;Modern&quot;, &quot;Modern&quot;);123</span><br></pre></td></tr></table></figure>

<p>最后，将上下文指定为连接器的容器，并初始化和启动连接器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connector.setContainer(context);</span><br><span class="line">try &#123;</span><br><span class="line">    connector.initialize();</span><br><span class="line">    connector.start();1234</span><br></pre></td></tr></table></figure>

<p><strong>5.6.5 运行Demo</strong></p>
<p>在 Linux 下，使用冒号分开两个库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .&#x2F;lib&#x2F;servlet.jar:.&#x2F; ex05.pyrmont.startup.Bootstrap21</span><br></pre></td></tr></table></figure>

<p>调用PrimitiveServlet，可以使用下面的 URL 来请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;Primitive</span><br></pre></td></tr></table></figure>

<p>调用ModernServlet，可以使用下面的 URL 来请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;Modern</span><br></pre></td></tr></table></figure>

<h2 id="5-7小结"><a href="#5-7小结" class="headerlink" title="5.7小结"></a><strong>5.7小结</strong></h2><p>容器是连接器之后的第二个主模块。 容器使用许多其它模块，如Loader，Logger，Manager等。有4种类型容器：Engine，Host，Context和Wrapper。 Catalina部署没有必需所有4个容器都存在。 本章中的两个应用Demo展现了：部署可以具有单个Wrapper或含有几个wrapper的Context。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%208%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/Chapter-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%208%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/Chapter-1/" class="post-title-link" itemprop="url">CHAPTER 1: SCALE FROM ZERO TO MILLIONS OF USERS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-04 18:24:28" itemprop="dateCreated datePublished" datetime="2021-10-04T18:24:28+08:00">2021-10-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-10 09:42:25" itemprop="dateModified" datetime="2023-02-10T09:42:25+08:00">2023-02-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%208%20%E5%AE%9E%E6%88%98/Chapter-4%20%E5%BC%95%E5%85%A5%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%208%20%E5%AE%9E%E6%88%98/Chapter-4%20%E5%BC%95%E5%85%A5%E6%B5%81/" class="post-title-link" itemprop="url">chapter4-引入流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-04 18:24:28" itemprop="dateCreated datePublished" datetime="2021-10-04T18:24:28+08:00">2021-10-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-10 10:28:27" itemprop="dateModified" datetime="2023-02-10T10:28:27+08:00">2023-02-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h2><ul>
<li><p>以声明的方式（通过查询语句表达，而不是临时写实现）处理数据集合</p>
</li>
<li><p>遍历数据的高级迭代器</p>
</li>
</ul>
<h2 id="集合与流"><a href="#集合与流" class="headerlink" title="集合与流"></a>集合与流</h2><h3 id="集合和流比较"><a href="#集合和流比较" class="headerlink" title="集合和流比较"></a>集合和流比较</h3><ul>
<li>无法并行处理了元素</li>
</ul>
<p>java使用集合处理数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; lowCaloricDishes &#x3D; new ArrayList();</span><br><span class="line">for(Dish : dishes)&#123;</span><br><span class="line">	if(dishes.getCalories() &lt; 400)</span><br><span class="line">		lowCaloricDishes.add(dish)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collections.sort(lowCaloricDishes, (d1, d2) -&gt; return d1.getCalories() - d2.getCaloriest());</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; lowCaloricDishNames &#x3D; new ArrayList();</span><br><span class="line">for(Dish d : lowCaloricDishes)&#123;</span><br><span class="line">  lowCaloricDishNames.add(d.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java使用流处理同样的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lowCaloricDishNames &#x3D;  dishes</span><br><span class="line">.parallelStream()</span><br><span class="line">.filter(d-&gt;d.getCalories() &lt; 400)</span><br><span class="line">.sorted(comparing(Dishes::getCalories))</span><br><span class="line">.map(e-&gt;e.getName())</span><br><span class="line">.collect(toList())</span><br></pre></td></tr></table></figure>

<p>总结stream api的优势：</p>
<ul>
<li>声明性：更简单、更透明</li>
<li>可复合：更灵活</li>
<li>可并行：性能更好</li>
</ul>
<h3 id="流简介"><a href="#流简介" class="headerlink" title="流简介"></a>流简介</h3><p>简短定义：从支持数据处理操作的源生成的元素序列</p>
<ul>
<li>元素序列：就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。但<strong>流的目的在于表达计算</strong>，比如filter、 sorted和map。集合讲的是数据，流讲的是计算。</li>
<li>源：流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li>
<li>数据处理操作：流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、 map、 reduce、 find、 match、 sort等。流操作可以顺序执行，也可并行执行。</li>
<li>流水线：很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线，流水线的操作可以看作对数据源进行数据库式查询。</li>
<li>内部迭代：与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li>
</ul>
<h3 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h3><p>Java现有的集合概念和新的流概念都提供了接口，来配合代表元素型有序值的数据接口。所谓有序，就是说我们一般是按顺序取用值，而不是随机取用的。</p>
<p>粗略地说，集合与流之间的差异就在于什么时候进行计算。</p>
<ul>
<li>集合是一个内存中的数据结构，它包含数据结构中目前所有的值，集合中的每个元素都得先算出来才能添加到集合中。（你可以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素都得先算出来才能成为集合的一部分。）</li>
<li>相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。 这对编程有很大的好处。这个思想就是用户仅仅从流中提取需要的值，而这些值在用户看不见的地方，只会按需生成。这是一种生产者，消费者的关系。从另一个角度来说，流就像是一个延迟创建的集合，只有在消费者要求的时候才会计算值（用管理学的话说这就是需求驱动，甚至是实时制造)。</li>
</ul>
<h4 id="只能遍历一次"><a href="#只能遍历一次" class="headerlink" title="只能遍历一次"></a>只能遍历一次</h4><p>请注意，和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集合之类的可重复的源，如果是I/O通道就没戏了）。</p>
<h4 id="外部迭代与内部迭代"><a href="#外部迭代与内部迭代" class="headerlink" title="外部迭代与内部迭代"></a>外部迭代与内部迭代</h4><p>使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。 相反，Streams库使用内部迭代，它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。</p>
<h3 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h3><h4 id="常用中间操作"><a href="#常用中间操作" class="headerlink" title="常用中间操作"></a>常用中间操作</h4><p>操作    类型    返回类型    操作参数    函数描述符<br>filter    中间    Stream<T>    Predicate<T>    T -&gt; boolean<br>map    中间    Stream<R>    Function&lt;T, R&gt;    T -&gt; R<br>limit    中间    Stream<T><br>sorted    中间    Stream<T>    Comparator<T>    (T, T) -&gt; int<br>distinct    中间    Stream<T>        </p>
<h4 id="常用终端操作"><a href="#常用终端操作" class="headerlink" title="常用终端操作"></a>常用终端操作</h4><p>操作    类型    目的<br>forEach    终端    消费流中的每个元素并对其应用 Lambda。这一操作返回 void<br>count    终端    返回流中元素的个数。这一操作返回 long<br>collect    终端    把流归约成一个集合，比如 List、 Map 甚至是 Integer。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
