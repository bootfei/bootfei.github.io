<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">218</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%B9%82%E7%AD%89%E6%80%A7-02-%E7%8A%B6%E6%80%81%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%B9%82%E7%AD%89%E6%80%A7-02-%E7%8A%B6%E6%80%81%E6%9C%BA/" class="post-title-link" itemprop="url">幂等性-02-状态机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-02 14:51:01" itemprop="dateCreated datePublished" datetime="2021-06-02T14:51:01+08:00">2021-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>状态机幂等</strong></p>
<p>在支付场景中，创建了一个支付订单，发起了一个支付请求，这个订单不论多少次重复请求，都应该保证最多只扣款一次。即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相同支付订单ID（幂等条件） —&gt; 最多一次扣款（期望结果）</span><br></pre></td></tr></table></figure>

<p>为了实现这个目标，可以考虑使用有限状态机。</p>
<p>有限状态机(Finite-state machine FSM)，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。用于处理复杂的状态转换。</p>
<p>在这个支付的例子中，为了化简，不考虑退款、取消订单等复杂的状态，只考虑未支付和已支付两种状态之间的转换。</p>
<p><img src="https://img.toutiao.io/c/f217e1df139ab9e614398a401c624131" alt="img"></p>
<p>由上面的状态转换图可以看到，相同支付订单ID从未支付状态，要不就是支付不成功停留在未支付状态，要不就是支付成功，状态转移为已支付。此状态转移过程不可逆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public enum OrderStateEnum &#123;</span><br><span class="line">    UNPAID &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public OrderStateEnum changeState() &#123;</span><br><span class="line">            if (doPay()) &#123;</span><br><span class="line">                return PAID;</span><br><span class="line">            &#125;</span><br><span class="line">            return UNPAID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    PAID &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public OrderStateEnum changeState() &#123;</span><br><span class="line">            return PAID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    public abstract OrderStateEnum changeState();</span><br><span class="line">    public boolean doPay() &#123;</span><br><span class="line">        &#x2F;&#x2F;这里是逻辑伪代码,可以是发起下游调用请求支付通道等</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个java版本的简单状态机实现。状态机里定义了一个未支付状态和其行为changeState。changeState又定义了一个未支付状态和其行为changeState。</p>
<p>利用状态机来实现这个幂等支付请求的设计流程图如下：</p>
<p><img src="https://img.toutiao.io/c/34edb771f6045f3df4f30baeda3bbd33" alt="img"></p>
<p>参考状态机实现和上图可知，相同支付ID的请求，支付状态只能进行一次从未支付到已支付的转换。从而保证了其幂等性。</p>
<p><strong>按目标幂等</strong></p>
<p>先来回答一个小学生的问题：</p>
<p>定了一个会议，参加人数为10人。发现会议室的椅子只有5把。3个提前来到会议室的同学热心的去其他地方搬椅子进来。问：每人要搬几把椅子？</p>
<p>有人要说这不是把简单的问题复杂了吗？大家看到椅子不够就去搬，看够10把椅子了就不搬就可以了。对了，这其实是一个很好的解题思路，完全可以用在设计当中，就是按目标幂等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相同会议ID（幂等条件） —&gt; 总数10把椅子（期望结果）</span><br></pre></td></tr></table></figure>

<p>利用按目标幂等来实现这个总数10把椅子请求的设计流程图如下：</p>
<p><img src="https://img.toutiao.io/c/0f4b81ab2ae6e759c2403c476ff07a17" alt="img"></p>
<p>采用按目标的设计，相同会议ID，不管多少次请求，请求椅子的总数就是10把。多次请求不改变行为，从而实现了幂等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%8B%93%E5%B1%95%E7%82%B9-BeanPostProcessor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%8B%93%E5%B1%95%E7%82%B9-BeanPostProcessor/" class="post-title-link" itemprop="url">spring-07-BeanPostProcessor</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-02 11:31:13" itemprop="dateCreated datePublished" datetime="2021-06-02T11:31:13+08:00">2021-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-02 14:01:38" itemprop="dateModified" datetime="2023-02-02T14:01:38+08:00">2023-02-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>Spring</strong>的<code>BeanPostProcessor</code>后置处理器承担了很多工作</p>
<ul>
<li>AOP、代理</li>
<li>构造方法注入的构造方法推断，构造方法上使用<code>@Autowired</code>等注解时</li>
<li>循环依赖，提前暴露未完成的Bean</li>
<li>依赖注入，<code>@Resource</code>、<code>@Autowired</code>、<code>@Value</code>等，不同注解依赖不同的后置处理器</li>
<li>动态注入</li>
<li>执行<code>Aware</code>回调</li>
<li><code>@Import</code>注解，通过<code>ImportAwareBeanPostProcessor</code>将<code>@Import</code>修饰的注解注入到<code>@Import</code>指定的类中</li>
<li>初始化和销毁方法，<code>@PostConsturct</code>、<code>@PreDestroy</code>后置处理完成</li>
<li><code>ApplicationListener</code>的监听等</li>
</ul>
<h2 id="相关BeanPostProcessor"><a href="#相关BeanPostProcessor" class="headerlink" title="相关BeanPostProcessor"></a>相关BeanPostProcessor</h2><p><img src="https://images.effiu.cn/blog/spring/BeanPostProcessor.png" alt=" "></p>
<p>在<strong>Spring Boot</strong>中<strong>Spring framework</strong>相关<strong>BeanPostProcesso</strong>如下:</p>
<ol>
<li>ApplicationContextAwareProcessor</li>
<li>ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor</li>
<li>PostProcessorRegistrationDelegate.BeanPostProcessorChecker</li>
<li>CommonAnnotationBeanPostProcessor</li>
<li>AutowiredAnnotationBeanPostProcessor</li>
<li>ApplicationListenerDetector</li>
</ol>
<blockquote>
<p>忽略Spring MVC、Spring Boot、Spring Cloud相关BeanPostProcessor，例如:Spring Boot的<code>ConfigurationPropertiesBindingPostProcessor</code>,Spring Cloud的<code>ConfigurationPropertiesBeans</code>等等。</p>
</blockquote>
<p>上述6个后置处理器相关接口以及发挥作用的方法(标红的):</p>
<p><img src="https://images.effiu.cn/blog/spring/BeanPostProcessor_class.jpg" alt="BeanPostProcessor类图"></p>
<blockquote>
<p>上述标红的为真正执行的类,类中的成员仅仅是一些重要的<strong>field</strong>和方法，即在获取Bean过程中执行后置处理器相关的方法。</p>
</blockquote>
<h2 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h2><blockquote>
<p><strong>BeanPostProcessor</strong>在<code>org.springframework.context.support.AbstractApplicationContext#refresh</code>中的<code>obtainFreshBeanFactory()</code>和<code>registerBeanPostProcessors()</code>方法中注册的</p>
</blockquote>
<p><code>org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory</code>加载了<code>ApplicationContextAwareProcessor</code>和<code>ApplicationListenerDetector</code>两个后置处理器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">    &#x2F;&#x2F; Tell the internal bean factory to use the context&#39;s class loader etc.</span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 第一个BeanPostProcessor:ApplicationContextAwareProcessor</span><br><span class="line">    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line">    &#x2F;&#x2F; 配置自动注入忽略的接口，需要以其他的方式完成相关Bean的引用,例如实现ApplicationContextAware接口完成引用</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 自动装配时指定实现类(一个接口有多个实现类的情况),作用类似于@Primary注解</span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Register early post-processor for detecting inner beans as ApplicationListeners.</span><br><span class="line">    &#x2F;&#x2F; 第二个BeanPostProcessor</span><br><span class="line">	&#x2F;&#x2F; ApplicationListenerDetector用于将ApplicationListener子类Bean放入到&#123;@link applicationListeners&#125; 集合中</span><br><span class="line">    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...省略</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Register default environment beans. 三个Bean，environment、systemProperties、systemEnvironment, 可以直接通过@Autowried等注解使用</span><br><span class="line">    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors</code>通过调用<code>ConfigurationClassPostProcessor#postProcessBeanFactory()</code>方法注册了<code>ImportAwareBeanPostProcessor</code>后置处理器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ConfigurationClassPostProcessor部分源码</span><br><span class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">    int factoryId &#x3D; System.identityHashCode(beanFactory);</span><br><span class="line">    if (this.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">        throw new IllegalStateException(</span><br><span class="line">        &quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    this.factoriesPostProcessed.add(factoryId);</span><br><span class="line">    if (!this.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">        &#x2F;&#x2F; BeanDefinitionRegistryPostProcessor hook apparently not supported...</span><br><span class="line">        &#x2F;&#x2F; Simply call processConfigurationClasses lazily at this point then.</span><br><span class="line">        processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enhanceConfigurationClasses(beanFactory);</span><br><span class="line">    beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#registerBeanPostProcessors&#96;注册了&#96;BeanPostProcessorChecker&#96;、&#96;AutowiredAnnotationBeanPostProcessor&#96;、&#96;CommonAnnotationBeanPostProcessor&#96;、以及重新注册了&#96;ApplicationListenerDetector</span><br><span class="line">public static void registerBeanPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line">    &#x2F;&#x2F; 遍历beanDefinitionNames获取BeanPostProcessorNames</span><br><span class="line">    String[] postProcessorNames &#x3D; beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line">    int beanProcessorTargetCount &#x3D; beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">    &#x2F;&#x2F; BeanPostProcessorChecker用于当在BeanPostProcessor实例化期间创建Bean时，当某个Bean不适合所有BeanPostProcessor时，记录信息. BeanPostProcessorChecker内部会比较beanProcessorTargetCount与beanFactory.getBeanPostProcessorCount()</span><br><span class="line">    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">    &#x2F;&#x2F; Separate between BeanPostProcessors that implement PriorityOrdered,</span><br><span class="line">    &#x2F;&#x2F; Ordered, and the rest.</span><br><span class="line">    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;BeanPostProcessor&gt; internalPostProcessors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (String ppName : postProcessorNames) &#123;</span><br><span class="line">        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            BeanPostProcessor pp &#x3D; beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            &#x2F;&#x2F; CommonAnnotationBeanPostProcessor、AutowiredAnnotationBeanPostProcessor两个BeanPostProcessor</span><br><span class="line">            priorityOrderedPostProcessors.add(pp);</span><br><span class="line">            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; First, register the BeanPostProcessors that implement PriorityOrdered.</span><br><span class="line">    &#x2F;&#x2F; 注册实现PriorityOrdered的BeanPostProcessors</span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Next, register the BeanPostProcessors that implement Ordered.</span><br><span class="line">    &#x2F;&#x2F; 注册实现Ordered的BeanPostProcessors</span><br><span class="line">    List&lt;BeanPostProcessor&gt; orderedPostProcessors &#x3D; new ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    for (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp &#x3D; beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        orderedPostProcessors.add(pp);</span><br><span class="line">        if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Now, register all regular BeanPostProcessors.</span><br><span class="line">    &#x2F;&#x2F; 注册所有常规的BeanPostProcessors</span><br><span class="line">    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors &#x3D; new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    for (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp &#x3D; beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        nonOrderedPostProcessors.add(pp);</span><br><span class="line">        if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Finally, re-register all internal BeanPostProcessors.</span><br><span class="line">    &#x2F;&#x2F; 最后重新注册所有内部BeanPostProcessor</span><br><span class="line">    sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Re-register post-processor for detecting inner beans as ApplicationListeners,</span><br><span class="line">    &#x2F;&#x2F; moving it to the end of the processor chain (for picking up proxies etc).</span><br><span class="line">    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanPostProcessor作用"><a href="#BeanPostProcessor作用" class="headerlink" title="BeanPostProcessor作用"></a>BeanPostProcessor作用</h2><p>排序后的BeanPostProcessor顺序为:</p>
<ol>
<li>ApplicationContextAwareProcessor</li>
<li>ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor</li>
<li>PostProcessorRegistrationDelegate.BeanPostProcessorChecker</li>
<li>CommonAnnotationBeanPostProcessor</li>
<li>AutowiredAnnotationBeanPostProcessor</li>
<li>ApplicationListenerDetector</li>
</ol>
<h3 id="ApplicationContextAwareProcessor"><a href="#ApplicationContextAwareProcessor" class="headerlink" title="ApplicationContextAwareProcessor"></a>ApplicationContextAwareProcessor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||</span><br><span class="line">          bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||</span><br><span class="line">          bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware))&#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AccessControlContext acc &#x3D; null;</span><br><span class="line"></span><br><span class="line">    if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">        acc &#x3D; this.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (acc !&#x3D; null) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareInterfaces(bean);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;, acc);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        invokeAwareInterfaces(bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">    if (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">        ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof EmbeddedValueResolverAware) &#123;</span><br><span class="line">        ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof ResourceLoaderAware) &#123;</span><br><span class="line">        ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">        ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof MessageSourceAware) &#123;</span><br><span class="line">        ((MessageSourceAware) bean).setMessageSource(this.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">        ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationContextAwareProcessor</code>加载的是<code>EnvironmentAware</code>、<code>EmbeddedValueResolverAware</code>、<code>ResourceLoaderAware</code>、<code>ApplicationEventPublisherAware</code>、<code>MessageSourceAware</code>、<code>ApplicationContextAware</code>6个用于回调的Aware。</p>
<h3 id="ImportAwareBeanPostProcessor"><a href="#ImportAwareBeanPostProcessor" class="headerlink" title="ImportAwareBeanPostProcessor"></a>ImportAwareBeanPostProcessor</h3><blockquote>
<p>是<code>ConfigurationClassPostProcessor</code>的子类，在Spring容器启动过程中，由其父类完成注册</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static class ImportAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private final BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    public ImportAwareBeanPostProcessor(BeanFactory beanFactory) &#123;</span><br><span class="line">        this.beanFactory &#x3D; beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PropertyValues postProcessProperties(@Nullable PropertyValues pvs, Object bean, String beanName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在AutowiredAnnotationBeanPostProcessor的postProcessProperties方法注入Bean之前,注入BeanFactory,</span><br><span class="line">        if (bean instanceof EnhancedConfiguration) &#123;</span><br><span class="line">            ((EnhancedConfiguration) bean).setBeanFactory(this.beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        return pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 若该bean是ImportAware, 则将@Import注解的类</span><br><span class="line">        &#x2F;&#x2F; (支持@Configuration、@Component,实现ImportSelector、ImportBeanDefinitionRegistrar接口的实现类)</span><br><span class="line">        &#x2F;&#x2F; 通过ImportAware的setImportMetadata将该注解注入到@Import指定类中</span><br><span class="line">        if (bean instanceof ImportAware) &#123;</span><br><span class="line">            ImportRegistry ir &#x3D; this.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);</span><br><span class="line">            AnnotationMetadata importingClass &#x3D; ir.getImportingClassFor(ClassUtils.getUserClass(bean).getName());</span><br><span class="line">            if (importingClass !&#x3D; null) &#123;</span><br><span class="line">                ((ImportAware) bean).setImportMetadata(importingClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanPostProcessorChecker"><a href="#BeanPostProcessorChecker" class="headerlink" title="BeanPostProcessorChecker"></a>BeanPostProcessorChecker</h3><blockquote>
<p>没有实际逻辑，只是用于在BeanPostProcessor实例化期间创建Bean时记录日志。</p>
</blockquote>
<h3 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p><code>CommonAnnotationBeanPostProcessor</code>支持的注解,<code>@Resource</code>、<code>@EJB</code>、<code>@WebServiceRef</code>，其继承了<code>InitDestroyAnnotationBeanPostProcessor</code>，<code>InitDestroyAnnotationBeanPostProcessor</code>支持<code>@PostConstruct</code>和<code>@PreDestroy</code>注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">private static final Class&lt;? extends Annotation&gt; webServiceRefClass;</span><br><span class="line">@Nullable</span><br><span class="line">private static final Class&lt;? extends Annotation&gt; ejbClass;</span><br><span class="line">private static final Set&lt;Class&lt;? extends Annotation&gt;&gt; resourceAnnotationTypes &#x3D; new LinkedHashSet&lt;&gt;(4);</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    webServiceRefClass &#x3D; loadAnnotationType(&quot;javax.xml.ws.WebServiceRef&quot;);</span><br><span class="line">    ejbClass &#x3D; loadAnnotationType(&quot;javax.ejb.EJB&quot;);</span><br><span class="line">    &#x2F;&#x2F; 配置支持的注解</span><br><span class="line">    resourceAnnotationTypes.add(Resource.class);</span><br><span class="line">    if (webServiceRefClass !&#x3D; null) &#123;</span><br><span class="line">        resourceAnnotationTypes.add(webServiceRefClass);</span><br><span class="line">    &#125;</span><br><span class="line">    if (ejbClass !&#x3D; null) &#123;</span><br><span class="line">        resourceAnnotationTypes.add(ejbClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 将支持的注解解析为InjectionMetadata,放入到injectionMetadataCache</span><br><span class="line">@Override</span><br><span class="line">public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123;</span><br><span class="line">    super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);</span><br><span class="line">    InjectionMetadata metadata &#x3D; findResourceMetadata(beanName, beanType, null);</span><br><span class="line">    metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从injectionMetadataCache中取得InjectionMetadata，然后完成注入</span><br><span class="line">@Override</span><br><span class="line">public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) &#123;</span><br><span class="line">    InjectionMetadata metadata &#x3D; findResourceMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 属性注入</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(beanName, &quot;Injection of resource dependencies failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InjectionMetadata"><a href="#InjectionMetadata" class="headerlink" title="InjectionMetadata"></a>InjectionMetadata</h3><p><code>InjectionMetadata</code>要注入的数据元，<code>InjectElement</code>是其内部类。<code>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition</code>方法会将BeanPostProcessor支持的注解解析为<code>InjectionMetadata</code>，然后由<code>InstantiationAwareBeanPostProcessorAdapter.postProcessProperties</code>方法完成注入。</p>
<p><code>InjectionMetadata</code>部分源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 待注入的元素,field或者method</span><br><span class="line">private final Collection&lt;InjectedElement&gt; injectedElements;</span><br><span class="line"></span><br><span class="line">public abstract static class InjectedElement &#123;</span><br><span class="line">	protected final Member member;</span><br><span class="line">	protected final boolean isField;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; postProcessProperties中会调用该方法</span><br><span class="line">protected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)</span><br><span class="line">				throws Throwable &#123;</span><br><span class="line">    if (this.isField) &#123;</span><br><span class="line">        Field field &#x3D; (Field) this.member;</span><br><span class="line">        ReflectionUtils.makeAccessible(field);</span><br><span class="line">        field.set(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (checkPropertySkipping(pvs)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method &#x3D; (Method) this.member;</span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            method.invoke(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InvocationTargetException ex) &#123;</span><br><span class="line">            throw ex.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p><code>AutowiredAnnotationBeanPostProcessor</code>支持<code>@Autowired</code>、<code>@Value</code>、<code>@Inject</code>、<code>@Lookup</code>等注解</p>
<blockquote>
<p><code>AutowiredAnnotationBeanPostProcessor</code>会将支持的注解的field或者method解析为<code>InjectMetadata</code>，但是<code>AutowiredAnnotationBeanPostProcessor</code>内部自己实现了<code>InjectedElement</code>的子类<code>AutowiredFieldElement</code>和<code>AutowiredMethodElement</code>，分别用于属性注入和方法注入。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">public AutowiredAnnotationBeanPostProcessor() &#123;</span><br><span class="line">    &#x2F;&#x2F; 配置支持@Autowired、@Value以及JSR-330相关注解</span><br><span class="line">    this.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">    this.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">    try &#123;</span><br><span class="line">        this.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">                                          ClassUtils.forName(&quot;javax.inject.Inject&quot;, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException ex) &#123;</span><br><span class="line">        &#x2F;&#x2F; JSR-330 API not available - simply skip.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ··· 省略</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将支持的注解解析为InjectionMetadata(AutowiredFieldElement、AutowiredMethodElement)</span><br><span class="line">@Override</span><br><span class="line">public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123;</span><br><span class="line">    InjectionMetadata metadata &#x3D; findAutowiringMetadata(beanName, beanType, null);</span><br><span class="line">    metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, final String beanName)</span><br><span class="line">    throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Let&#39;s check for lookup methods here...</span><br><span class="line">    if (!this.lookupMethodsChecked.contains(beanName)) &#123;</span><br><span class="line">        if (AnnotationUtils.isCandidateClass(beanClass, Lookup.class)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class&lt;?&gt; targetClass &#x3D; beanClass;</span><br><span class="line">                do &#123;</span><br><span class="line">                    ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">                        Lookup lookup &#x3D; method.getAnnotation(Lookup.class);</span><br><span class="line">                        if (lookup !&#x3D; null) &#123;</span><br><span class="line">                            Assert.state(this.beanFactory !&#x3D; null, &quot;No BeanFactory available&quot;);</span><br><span class="line">                            LookupOverride override &#x3D; new LookupOverride(method, lookup.value());</span><br><span class="line">                            try &#123;</span><br><span class="line">                                RootBeanDefinition mbd &#x3D; (RootBeanDefinition)</span><br><span class="line">                                    this.beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">                                mbd.getMethodOverrides().addOverride(override);</span><br><span class="line">                            &#125;</span><br><span class="line">                            catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                                throw new BeanCreationException(beanName,</span><br><span class="line">                                                                &quot;Cannot apply @Lookup to beans without corresponding bean definition&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    targetClass &#x3D; targetClass.getSuperclass();</span><br><span class="line">                &#125;</span><br><span class="line">                while (targetClass !&#x3D; null &amp;&amp; targetClass !&#x3D; Object.class);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch (IllegalStateException ex) &#123;</span><br><span class="line">                throw new BeanCreationException(beanName, &quot;Lookup method resolution failed&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.lookupMethodsChecked.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Quick check on the concurrent map first, with minimal locking.</span><br><span class="line">    Constructor&lt;?&gt;[] candidateConstructors &#x3D; this.candidateConstructorsCache.get(beanClass);</span><br><span class="line">    if (candidateConstructors &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; Fully synchronized resolution now...</span><br><span class="line">        synchronized (this.candidateConstructorsCache) &#123;</span><br><span class="line">            candidateConstructors &#x3D; this.candidateConstructorsCache.get(beanClass);</span><br><span class="line">            if (candidateConstructors &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Constructor&lt;?&gt;[] rawCandidates;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取所有的构造方法</span><br><span class="line">                    rawCandidates &#x3D; beanClass.getDeclaredConstructors();</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Throwable ex) &#123;</span><br><span class="line">                    throw new BeanCreationException(beanName,</span><br><span class="line">                                                    &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +</span><br><span class="line">                                                    &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;Constructor&lt;?&gt;&gt; candidates &#x3D; new ArrayList&lt;&gt;(rawCandidates.length);</span><br><span class="line">                Constructor&lt;?&gt; requiredConstructor &#x3D; null;</span><br><span class="line">                Constructor&lt;?&gt; defaultConstructor &#x3D; null;</span><br><span class="line">                Constructor&lt;?&gt; primaryConstructor &#x3D; BeanUtils.findPrimaryConstructor(beanClass);</span><br><span class="line">                int nonSyntheticConstructors &#x3D; 0;</span><br><span class="line">                for (Constructor&lt;?&gt; candidate : rawCandidates) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 是否由编译器自己生成的构造方法</span><br><span class="line">                    if (!candidate.isSynthetic()) &#123;</span><br><span class="line">                        nonSyntheticConstructors++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (primaryConstructor !&#x3D; null) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 检查是否存在使用支持注解修饰的类构造方法</span><br><span class="line">                    MergedAnnotation&lt;?&gt; ann &#x3D; findAutowiredAnnotation(candidate);</span><br><span class="line">                    if (ann &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 检查父类构造方法是否存在支持的注解</span><br><span class="line">                        Class&lt;?&gt; userClass &#x3D; ClassUtils.getUserClass(beanClass);</span><br><span class="line">                        if (userClass !&#x3D; beanClass) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                Constructor&lt;?&gt; superCtor &#x3D;</span><br><span class="line">                                    userClass.getDeclaredConstructor(candidate.getParameterTypes());</span><br><span class="line">                                ann &#x3D; findAutowiredAnnotation(superCtor);</span><br><span class="line">                            &#125;</span><br><span class="line">                            catch (NoSuchMethodException ex) &#123;</span><br><span class="line">                                &#x2F;&#x2F; Simply proceed, no equivalent superclass constructor found...</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (ann !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 只能存在一个需要注入的构造方法，否则会抛出异常</span><br><span class="line">                        if (requiredConstructor !&#x3D; null) &#123;</span><br><span class="line">                            throw new BeanCreationException(beanName,</span><br><span class="line">                                                            &quot;Invalid autowire-marked constructor: &quot; + candidate +</span><br><span class="line">                                                            &quot;. Found constructor with &#39;required&#39; Autowired annotation already: &quot; +</span><br><span class="line">                                                            requiredConstructor);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 判断是否需要注入，若需要那么当不存在要注入的bean时会抛出异常</span><br><span class="line">                        boolean required &#x3D; determineRequiredStatus(ann);</span><br><span class="line">                        if (required) &#123;</span><br><span class="line">                            if (!candidates.isEmpty()) &#123;</span><br><span class="line">                                throw new BeanCreationException(beanName,</span><br><span class="line">                                                                &quot;Invalid autowire-marked constructors: &quot; + candidates +</span><br><span class="line">                                                                &quot;. Found constructor with &#39;required&#39; Autowired annotation: &quot; +</span><br><span class="line">                                                                candidate);</span><br><span class="line">                            &#125;</span><br><span class="line">                            requiredConstructor &#x3D; candidate;</span><br><span class="line">                        &#125;</span><br><span class="line">                        candidates.add(candidate);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (candidate.getParameterCount() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        defaultConstructor &#x3D; candidate;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!candidates.isEmpty()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Add default constructor to list of optional constructors, as fallback.</span><br><span class="line">                    if (requiredConstructor &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        if (defaultConstructor !&#x3D; null) &#123;</span><br><span class="line">                            candidates.add(defaultConstructor);</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (candidates.size() &#x3D;&#x3D; 1 &amp;&amp; logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(&quot;Inconsistent constructor declaration on bean with name &#39;&quot; + beanName +</span><br><span class="line">                                        &quot;&#39;: single autowire-marked constructor flagged as optional - &quot; +</span><br><span class="line">                                        &quot;this constructor is effectively required since there is no &quot; +</span><br><span class="line">                                        &quot;default constructor to fall back to: &quot; + candidates.get(0));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    candidateConstructors &#x3D; candidates.toArray(new Constructor&lt;?&gt;[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (rawCandidates.length &#x3D;&#x3D; 1 &amp;&amp; rawCandidates[0].getParameterCount() &gt; 0) &#123;</span><br><span class="line">                    candidateConstructors &#x3D; new Constructor&lt;?&gt;[] &#123;rawCandidates[0]&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (nonSyntheticConstructors &#x3D;&#x3D; 2 &amp;&amp; primaryConstructor !&#x3D; null &amp;&amp;</span><br><span class="line">                         defaultConstructor !&#x3D; null &amp;&amp; !primaryConstructor.equals(defaultConstructor)) &#123;</span><br><span class="line">                    candidateConstructors &#x3D; new Constructor&lt;?&gt;[] &#123;primaryConstructor, defaultConstructor&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (nonSyntheticConstructors &#x3D;&#x3D; 1 &amp;&amp; primaryConstructor !&#x3D; null) &#123;</span><br><span class="line">                    candidateConstructors &#x3D; new Constructor&lt;?&gt;[] &#123;primaryConstructor&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    candidateConstructors &#x3D; new Constructor&lt;?&gt;[0];</span><br><span class="line">                &#125;</span><br><span class="line">                this.candidateConstructorsCache.put(beanClass, candidateConstructors);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (candidateConstructors.length &gt; 0 ? candidateConstructors : null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从injectionMetadataCache中取出需要出入的原始数据完成注入</span><br><span class="line">@Override</span><br><span class="line">public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) &#123;</span><br><span class="line">    InjectionMetadata metadata &#x3D; findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    try &#123;</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (BeanCreationException ex) &#123;</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ApplicationListenerDetector"><a href="#ApplicationListenerDetector" class="headerlink" title="ApplicationListenerDetector"></a>ApplicationListenerDetector</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType,</span><br><span class="line">                                            String beanName) &#123;</span><br><span class="line">    &#x2F;&#x2F; 若Bean是ApplicationListener则将其放入到singletonNames内</span><br><span class="line">    &#x2F;&#x2F; 在postProcessAfterInitialization方法中，将ApplicationListener子类放入到ApplicationListeners集合中</span><br><span class="line">    if (ApplicationListener.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">        this.singletonNames.put(beanName, beanDefinition.isSingleton());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) &#123;</span><br><span class="line">    if (bean instanceof ApplicationListener) &#123;</span><br><span class="line">        &#x2F;&#x2F; potentially not detected as a listener by getBeanNamesForType retrieval</span><br><span class="line">        &#x2F;&#x2F; getBeanNamesForType可能不会将其判断为监听器,所以此处判断是否是ApplicationListener若是则将其加入到ApplicationListeners中</span><br><span class="line">        Boolean flag &#x3D; this.singletonNames.get(beanName);</span><br><span class="line">        if (Boolean.TRUE.equals(flag)) &#123;</span><br><span class="line">            &#x2F;&#x2F; singleton bean (top-level or inner): register on the fly</span><br><span class="line">            this.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">         &#125; else if (Boolean.FALSE.equals(flag)) &#123;</span><br><span class="line">                this.singletonNames.remove(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanPostProcessor的执行顺序"><a href="#BeanPostProcessor的执行顺序" class="headerlink" title="BeanPostProcessor的执行顺序"></a>BeanPostProcessor的执行顺序</h2><blockquote>
<p><code>BeanPostProcessor</code>在<strong>Bean</strong>的实例化过程中每个方法执行的顺序。上文已经指出在<strong>Bean</strong>的实例化过程中8次调用后置处理器的地方。</p>
</blockquote>
<h3 id="postProcessBeforeInstantiation"><a href="#postProcessBeforeInstantiation" class="headerlink" title="postProcessBeforeInstantiation"></a>postProcessBeforeInstantiation</h3><p>第一次调用后置处理器是<code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>，其会在目标对象被实例化之前调用，因为此时目标对象未被实例化，所以可以返回自定义对象，比如代理对象。</p>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code>是<code>InstantiationAwareBeanPostProcessor</code>的一个子类，所有使用<code>@AspectJ</code>注解修饰的类，都会被其自动识别，其实现了<code>BeanFactoryAware</code>接口，所有持有beanFactory对象，会在创建代理类后将<strong>targetClass</strong>赋给代理类。</p>
<blockquote>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code>与AOP相关，待后续研究</p>
</blockquote>
<h3 id="determineCandidateConstructors"><a href="#determineCandidateConstructors" class="headerlink" title="determineCandidateConstructors"></a>determineCandidateConstructors</h3><p>第二次调用后置处理器是<code>SmartInstantiationAwareBeanPostProcessor.determineCandidateConstructors</code>方法，主要是推断创建Bean的构造方法。具体见<a target="_blank" rel="noopener" href="https://www.effiu.cn/blog/2020/10/27/spring/3_beanPostProcessor/#AutowiredAnnotationbeanPostProcessor">AutowiredAnnotationBeanPostProcessor</a>。</p>
<h3 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h3><p>第三次调用后置处理器是<code>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition</code>其主要作用的解析类中要注入的对象然后放入到<code>BeanDefinition</code>中，然后会在``InstantiationAwareBeanPostProcessor.postProcessProperties`中完成属性注入</p>
<h3 id="getEarlyBeanReference"><a href="#getEarlyBeanReference" class="headerlink" title="getEarlyBeanReference"></a>getEarlyBeanReference</h3><p>第四次调用后置处理器是<code>SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference</code>，用于循环依赖中提前暴露Bean</p>
<h3 id="postProcessAfterInstantiation"><a href="#postProcessAfterInstantiation" class="headerlink" title="postProcessAfterInstantiation"></a>postProcessAfterInstantiation</h3><p>第五次调用后置处理器是<code>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</code>主要是在Bean完成实例化后判断是否需要属性注入，返回false则不需要完成属性注入</p>
<h3 id="postProcessProperties"><a href="#postProcessProperties" class="headerlink" title="postProcessProperties"></a>postProcessProperties</h3><p>第六次调用后置处理器是<code>InstantiationAwareBeanPostProcessor.postProcessProperties</code>，主要是完成属性注入。</p>
<ul>
<li>在``ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor.postProcessProperties<code>中指定</code>BeanFactory`</li>
<li>在<code>CommonAnnotationBeanPostProcessor.postProcessProperties</code>中注入<code>@Resurce</code>、<code>@WebServiceRef</code>、<code>@EJB</code>、<code>@PostConstruct</code>、<code>@PreDestory</code>注解相关</li>
<li>在<code>AutowiredAnnotationBeanPostProcessor.postProcessProperties</code>中进行属性注入<code>@Autowired</code>、<code>@Value</code>、<code>@Inject</code>注解相关属性</li>
</ul>
<h3 id="postProcessBeforeInitialization"><a href="#postProcessBeforeInitialization" class="headerlink" title="postProcessBeforeInitialization"></a>postProcessBeforeInitialization</h3><p>第七次调用后置处理器是<code>BeanPostProcessor.postProcessBeforeInitialization</code>，<code>BeanPostProcessor</code>是最顶层接口，所以所有后置处理器都有该方法。存在逻辑的如下:</p>
<ul>
<li><code>ApplicationContextAwareProcessor</code>: 执行<code>EnvironmentAware</code>、<code>EmbeddedValueResolverAware</code>、<code>ResourceLoaderAware</code>、<code>ApplicationEventPublisherAware</code>、<code>MessageSourceAware</code>、<code>ApplicationContextAware</code>相关回调</li>
<li><code>ImportAwareBeanPostProcessor</code>: 实现<code>ImportAware</code>接口的Bean</li>
<li><code>CommonAnnotationBeanPostProcessor</code>其继承了<code>InitDestroyAnnotationBeanPostProcessor</code>类，其会执行<code>@PostConstruct</code>方法</li>
</ul>
<h3 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h3><p>第八次调用后置处理器是<code>BeanPostProcessor.postProcessAfterInitialization</code>，<code>BeanPostProcessor</code>是最顶层接口，所以所有后置处理器都有该方法。</p>
<ul>
<li><code>ApplicationListenerDetector</code>，将符合条件的<strong>Bean</strong>放入到<code>ApplicationContext.applicationListeners</code>中，用于监听<strong>Application</strong>事件</li>
<li><code>AnnotationAwareAspectJAutoProxyCreator</code>，待研究</li>
</ul>
<h3 id="requiresDestruction和postProcessBeforeDestruction"><a href="#requiresDestruction和postProcessBeforeDestruction" class="headerlink" title="requiresDestruction和postProcessBeforeDestruction"></a>requiresDestruction和postProcessBeforeDestruction</h3><p>第9次调用后置处理器，<code>DestructionAwareBeanPostProcessor#requiresDestruction</code>和<code>DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</code>，判断Bean实例是否需要该后置处理器销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public DisposableBeanAdapter(Object bean, String beanName, RootBeanDefinition beanDefinition,</span><br><span class="line">			List&lt;BeanPostProcessor&gt; postProcessors, @Nullable AccessControlContext acc) &#123;</span><br><span class="line">    &#x2F;&#x2F; 构造方法中返回该bean在销毁时需要执行的后置处理器,filterPostProcessors</span><br><span class="line">    this.beanPostProcessors &#x3D; filterPostProcessors(postProcessors, bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; DestructionAwareBeanPostProcessor#requiresDestruction方法</span><br><span class="line">private List&lt;DestructionAwareBeanPostProcessor&gt; filterPostProcessors(List&lt;BeanPostProcessor&gt; processors, Object bean) &#123;</span><br><span class="line">    List&lt;DestructionAwareBeanPostProcessor&gt; filteredPostProcessors &#x3D; null;</span><br><span class="line">    if (!CollectionUtils.isEmpty(processors)) &#123;</span><br><span class="line">        filteredPostProcessors &#x3D; new ArrayList&lt;&gt;(processors.size());</span><br><span class="line">        for (BeanPostProcessor processor : processors) &#123;</span><br><span class="line">            if (processor instanceof DestructionAwareBeanPostProcessor) &#123;</span><br><span class="line">                DestructionAwareBeanPostProcessor dabpp &#x3D; (DestructionAwareBeanPostProcessor) processor;</span><br><span class="line">                if (dabpp.requiresDestruction(bean)) &#123;</span><br><span class="line">                    filteredPostProcessors.add(dabpp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return filteredPostProcessors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 销毁调用方法</span><br><span class="line">public void destroy() &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理@PreDestroy注解</span><br><span class="line">    if (!CollectionUtils.isEmpty(this.beanPostProcessors)) &#123;</span><br><span class="line">        for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) &#123;</span><br><span class="line">            processor.postProcessBeforeDestruction(this.bean, this.beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F; DisposableBean接口</span><br><span class="line">    if (this.invokeDisposableBean) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; ··· 省略</span><br><span class="line">            ((DisposableBean) this.bean).destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            &#x2F;&#x2F; throw ex</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F; 推断的destroyMethod，例如close、shutdown方法,xml中的destroy-method、default-destroy-method属性</span><br><span class="line">    if (this.destroyMethod !&#x3D; null) &#123;</span><br><span class="line">        invokeCustomDestroyMethod(this.destroyMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (this.destroyMethodName !&#x3D; null) &#123;</span><br><span class="line">        Method methodToInvoke &#x3D; determineDestroyMethod(this.destroyMethodName);</span><br><span class="line">        if (methodToInvoke !&#x3D; null) &#123;</span><br><span class="line">            invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当销毁Bean时:</p>
<ol>
<li><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#destroySingletons</code></li>
<li><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#destroySingleton</code></li>
<li><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#destroyBean</code></li>
</ol>
<blockquote>
<p>destroyBean的源码如下:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">protected void destroyBean(String beanName, @Nullable DisposableBean bean) &#123;</span><br><span class="line">    &#x2F;&#x2F; Trigger destruction of dependent beans first...</span><br><span class="line">    Set&lt;String&gt; dependencies;</span><br><span class="line">    synchronized (this.dependentBeanMap) &#123;</span><br><span class="line">        &#x2F;&#x2F; Within full synchronization in order to guarantee a disconnected Set</span><br><span class="line">        dependencies &#x3D; this.dependentBeanMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 销毁依赖的bean</span><br><span class="line">    if (dependencies !&#x3D; null) &#123;</span><br><span class="line">        for (String dependentBeanName : dependencies) &#123;</span><br><span class="line">            destroySingleton(dependentBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Actually destroy the bean now...</span><br><span class="line">    if (bean !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 此处调用的是DisposableBeanAdapter.destroy()方法。</span><br><span class="line">            bean.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(&quot;Destruction of bean with name &#39;&quot; + beanName + &quot;&#39; threw an exception&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Trigger destruction of contained beans...</span><br><span class="line">    Set&lt;String&gt; containedBeans;</span><br><span class="line">    synchronized (this.containedBeanMap) &#123;</span><br><span class="line">        &#x2F;&#x2F; Within full synchronization in order to guarantee a disconnected Set</span><br><span class="line">        containedBeans &#x3D; this.containedBeanMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    if (containedBeans !&#x3D; null) &#123;</span><br><span class="line">        for (String containedBeanName : containedBeans) &#123;</span><br><span class="line">            destroySingleton(containedBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Remove destroyed bean from other beans&#39; dependencies.</span><br><span class="line">    synchronized (this.dependentBeanMap) &#123;</span><br><span class="line">        for (Iterator&lt;Map.Entry&lt;String, Set&lt;String&gt;&gt;&gt; it &#x3D; this.dependentBeanMap.entrySet().iterator(); it.hasNext();) &#123;</span><br><span class="line">            Map.Entry&lt;String, Set&lt;String&gt;&gt; entry &#x3D; it.next();</span><br><span class="line">            Set&lt;String&gt; dependenciesToClean &#x3D; entry.getValue();</span><br><span class="line">            dependenciesToClean.remove(beanName);</span><br><span class="line">            if (dependenciesToClean.isEmpty()) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Remove destroyed bean&#39;s prepared dependency information.</span><br><span class="line">    this.dependenciesForBeanMap.remove(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-01-%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-01-%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">分布式事务-01-一致性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-01 17:52:09" itemprop="dateCreated datePublished" datetime="2021-06-01T17:52:09+08:00">2021-06-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在微服务架构盛行的情况下，在分布式的多个服务中保证业务的一致性，即分布式事务就显得尤为重要。本文将讲述分布式事务及其解决方案，有XA协议、TCC和Saga事务模型、本地消息表、事务消息和阿里开源的Seata。</p>
<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">概要</a></h1><p>在微服务架构盛行的情况下，在分布式的多个服务中保证业务的一致性，即分布式事务就显得尤为重要。本文将讲述分布式事务及其解决方案，有XA协议、TCC和Saga事务模型、本地消息表、事务消息和阿里开源的Seata。</p>
<h1 id="分布式事务特性"><a href="#分布式事务特性" class="headerlink" title="分布式事务特性"></a>分布式事务特性</h1><p>单机事务是相对分布式事务来说的，即数据库事务。</p>
<ul>
<li>A（Atomicity）：指单个事务中的操作要不都执行，要不都不执行</li>
<li>C（Consistency）：指事务前后数据的完整性必须保持一致</li>
<li>I（Isolation）：指多个事务对数据可见性的规则</li>
<li>D（Durability）：指事务提交后，就会被永久存储下来</li>
</ul>
<p>既然数据库事务有这四个特性的，那么分布式事务也不例外，应该具备这四个特性。</p>
<p>在微服务架构下，服务之间通过RPC远程调用，相对单机事务来说，多了“网络通信”这一不确定因素，使得本来服务的调用只有“成功”和“失败”这两种返回结果，变为“成功”、“失败”和“未知”三种返回结果。系统之间的通信可靠性从单一系统中的可靠变成了微服务架构之间的不可靠，分布式事务其实就是在不可靠的通信下实现事务的特性。一般因为网络导致的异常可能有机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的TCP、存储数据丢失、其他异常等等。</p>
<h1 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h1><h2 id="2PC-3PC"><a href="#2PC-3PC" class="headerlink" title="2PC/3PC"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">2PC/3PC</a></h2><p>2PC即二阶段提交 :</p>
<blockquote>
<p>二阶段提交（Two-phase Commit）是指在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法。通常，二阶段提交也被称为是一种协议（Protocol）。</p>
</blockquote>
<p>2PC是一种协议，它的作用保证在分布式系统中每个节点要不都提交事务，要么都取消事务。这个跟ACID中的A原子性的定义很像。</p>
<p>2PC引入一个第三方的节点协调者，即Coordinator，其他参与事务的节点为参与者，即Participants。协调者统筹整个事务行为，负责通知参与者进行Commit还是Rollback操作。</p>
<p>2PC的过程比较简单，分为两个阶段：</p>
<ol>
<li><p>准备阶段</p>
<p>协调者分别给每个参与者发送Prepare消息，每个参与者收到消息后，进行“预提交”操作（不是实际的提交操作），把操作的结果（成功或失败）返回给协调者。</p>
</li>
<li><p>提交阶段</p>
<p>协调者根据准备阶段收到的参与者的返回结果进行判断，如果所有的参与者都返回成功，那么分别给每个参与者发送Commit消息，否则发送Rollback消息。</p>
</li>
</ol>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">upload successful</p>
<p>2PC是一个强一致性协议，同时它在实际应用中还存在几个问题</p>
<ul>
<li>同步阻塞，2PC的两个阶段中，协调者和参与者的通信都是同步的，这会导致整个事务的长时间阻塞</li>
<li>Coordinator的单点问题</li>
<li>数据不一致，在Commit阶段，可能存在只有部分参与者收到Commit消息（或处理成功）的情况</li>
</ul>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">3PC</a></h3><p>3PC即三阶段提交，它比2PC多了一个阶段，即把原来2PC的准备阶段拆分成CanCommit和PreCommit两个阶段，同时</p>
<p>引入超时机制来解决2PC的同步阻塞问题。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">upload successful</p>
<p>但是在我看来3PC并没有解决2PC的根本问题，它只是在2PC的基础上做了一些优化，它增加了一个阶段（也增加了1个RTT）来提高对方可用性的概率，这本质跟TCP的三次握手一样，同样也改为四次握手，五次握手等等。</p>
<h3 id="XA"><a href="#XA" class="headerlink" title="XA"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">XA</a></h3><p>XA是一种基于2PC协议实现的规范。在2PC中没有明确资源是什么，以及资源是怎么提交的等等，而XA就是数据库实现2PC的规范，已知常用的支持XA的关系型数据库有Mysql、Oracle等。</p>
<h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">本地消息表</a></h2><p>本地消息表方案应该是业界内使用最为广泛的，因为它使用简单，成本比较低。</p>
<p>本地消息表的方案最初是由 eBay 提出（完整方案），核心思路是将分布式事务拆分成本地事务进行处理。</p>
<p>它的处理流程如下：</p>
<ul>
<li>事务发起方把<a href="">要处理的业务事务</a>和<a href="">写消息表</a>这两个操作放在同一个本地事务里</li>
<li>事务发起方有一个定时任务轮询消息表，把<a href="">未成功的消息</a>发送到消息中间件，做补偿</li>
<li>事务被动方从消息中间件获取消息后，返回成功</li>
<li>事务发起方更新消息状态为已成功</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcqFjwkXDAcOWzt5b707kH6CuLmfstpk8fmrHq7licApVRSKhkxKcGVMfsaLK0IGqOQ9uAiaTqN6J6g/640" alt="图片"></p>
<p>从处理流程来看，本地消息表方案是一个基于消息中间件的可靠性来达到事务的最终一致性的方案。</p>
<p>一些分析：</p>
<ul>
<li><p>把业务处理和写消息表放在同一个事务是为了失败/异常后可以同时回滚</p>
</li>
<li><p>为什么不直接发消息，而是先写消息表？</p>
<p>试想，如果发送消息超时了，即不确定消息中间件收到消息没，那么你是重试还是抛异常回滚事务呢？回滚是不行的，因为可能消息中间件已经收到消息，接收方收到消息后做处理，导致双方数据不一致了；重试也是不行的，因为有可能会一直重试失败，导致事务阻塞。</p>
</li>
<li><p>基于上述分析，消息的接收方是需要做幂等操作的</p>
</li>
</ul>
<p>本地消息表方案整体来说还是比较简单、可用的，但是也有以下缺点：</p>
<ul>
<li>消息数据和业务数据耦合，消息表需要根据具体的业务场景制定，不能公用。就算可以公用消息表，对于分库的业务来说每个库都是需要消息表的。</li>
<li>只适用于最终一致的业务场景。例如在 A -&gt; B场景下，在不考虑网络异常、宕机等非业务异常的情况下，A成功的话，B肯定也会成功的。</li>
</ul>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">事务消息</a></h2><p>事务消息是通过消息中间件来解耦本地消息表和业务数据表，适用于所有对数据最终一致性需求的场景。现在支持事务消息的消息中间件只有RocketMQ，这个概念最早也是RocketMQ提出的。</p>
<p>通过事务消息实现分布式事务的流程如下：</p>
<ol>
<li>发起方发送半事务消息会给RocketMQ ，此时消息的状态prepare，接受方还不能拉取到此消息</li>
<li>发起方进行本地事务操作</li>
<li>发起方给RocketMQ确认提交消息，此时接受方可以消费到此消息了</li>
</ol>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">upload successful</p>
<p>步骤1和3失败/异常该如何处理：</p>
<p>RocketMQ会定期扫描还没确认的消息，回调给发送方，询问此次事务的状态，根据发送方的返回结果把这条消息进行取消还是提交确认。</p>
<p>可以看出事务消息的本质的借鉴了二阶段提交的思想，它跟本地消息表的做法也很像，事务消息做的事情其实就是把消息表的存储和扫描消息表这两个事情放到消息中间件来做，使得消息表和业务表解耦。</p>
<h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">TCC</a></h2><p>TCC （Try-Confirm-Cancel）事务模型采用的是补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿操作。</p>
<p>相当于XA来说，TCC可以不依赖于资源管理器，即数据库，它是通过业务逻辑来控制确认和补偿操作的，所以它用了’Cancel’而非’Rollback’的字眼。它是一个应用层面的2PC。</p>
<p>TCC分为三个阶段：</p>
<ul>
<li>Try阶段，对业务资源进行检测和预留</li>
<li>Confirm阶段，对Try阶段预留的资源进行确认提交，Try阶段执行成功是Confirm阶段执行成功的前提</li>
<li>Cancel阶段，对Try阶段预留的资源进行撤销或释放</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">upload successful</p>
<p>看上去TCC跟2PC/3PC可能有点像，但是TCC强调的是补偿，而且对于对资源的“预留”，“确认”，“释放”，TCC并没有明确说要如何做，这个具体是要业务来定义的。</p>
<p>例如在转账的场景，“预留”操作可能就是对账号里的部分资金进行冻结，这样这个资金只能是当前事务才能用，别的事务用不了。</p>
<p>另外，对于异常的场景，TCC也没有说要怎么做，因为Try、Confirm、Cancel都是业务定义的，这三个阶段中发生了异常，那么就由业务来做相应的处理。一般都有以下几种处理：</p>
<ul>
<li>如果Try成功了，那么Confirm阶段异常了就一直重试，直到成功</li>
<li>Try、Confirm、Cancel三个阶段都有相应的资源及事务日志，应用根据日志（异步）来做重试或补偿</li>
<li>TCC的实现依赖底层数据库，异常后直接利用数据库的事务机制回滚</li>
</ul>
<p>其中现在使用比较多的TCC框架ByteTCC、tcc-transaction的原理都是基于第三点</p>
<p>同时，在实现TCC时要注意以下三个问题</p>
<ul>
<li><p>允许空回滚</p>
<p>在Try没有真正执行的情况下，触发了Cancel操作，这时要允许Cancel成功</p>
</li>
<li><p>防悬挂控制</p>
<p>Cancel操作比Try操作先执行（网络延迟原因），后面的Try操作不能执行成功</p>
</li>
<li><p>幂等控制</p>
</li>
</ul>
<p>TCC其实是把控制事务的逻辑放在业务应用层面，而非资源管理器，这样实现起来就会相对灵活很多，但相对对数据一致性的保证可能没那么强（具体看怎么实现Try），整体来说TCC还有以下缺点：</p>
<ul>
<li>对于Confirm和Cancel阶段失败后要完全靠业务应用自己去处理</li>
<li>每个业务都需要实现Try、Confirm、Cancel三个接口，代码量比较多</li>
<li>如果是基于现有的业务想使用TCC会比较困难。一是对于原来的接口要拆分为三个接口，入侵性比较大；二是因为要做“预留”资源的操作，有可能需要对原来的业务模型进行改造。</li>
</ul>
<h2 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">Saga</a></h2><p>Saga事务模型又叫做长时间运行的事务（Long-running-transaction）, 它是由普林斯顿大学的H.Garcia-Molina等人提出，它描述的是另外一种在没有两阶段提交的的情况下解决分布式系统中复杂的业务事务问题。Saga的论文。</p>
<p>该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Saga工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Saga工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。</p>
<p>Saga也是一种补偿协议，在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcqFjwkXDAcOWzt5b707kH6QE2MdM6ZVZzMnNFHqUZeMwnUWMmvKPJxb3zeP6boKGvk1gmbTribfSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">overwrote existing file</p>
<p>你可以看到Saga跟TCC很像，但是Saga更加宽松，一致性更弱，在Saga看来，在一阶段直接做提交/确认操作就好了，有问题再做补偿。这样的话，Saga可以拥有比XA和TCC更好的性能（XA、TCC需要锁定资源或预留资源），而且Saga强调通过事件驱动异步处理，实现高吞吐。</p>
<p>可以看出Saga是对TCC的一种“妥协”，从TCC的三个接口变为两个接口，一阶段直接提交缺少对资源的隔离（如果一阶段提交后，后面发现需要做补偿，但是补偿操作执行前有另外的事务更改了数据，这时数据已经变“脏”了，那么这时该如何处理是一个问题。在TCC没有这个问题，因为资源已经被hold住了），因此对使用者也是比较宽松的，对于现有业务的改造也会比较简单。</p>
<p>Saga实现分两种，一种是Saga状态机实现，一种是Saga AOP Proxy实现。Saga状态机实现，在关于参与者服务编排实现又有集中式和协同式两种分支。这点就不展开了。</p>
<h3 id="TCC-vs-Saga"><a href="#TCC-vs-Saga" class="headerlink" title="TCC vs Saga"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">TCC vs Saga</a></h3><p>TCC和Saga都属于补偿型事务模型，Saga没有Try，直接Commit，所有会产生实际的事务痕迹，而补偿做的是反向操作。TCC是二阶段的广义实现，利用了数据的中间态，Cancel是中间状态的数据进行撤销，从而不存在数据污染问题。</p>
<p>使用场景对比：</p>
<ul>
<li>TCC 适用于执行时间确定且较短、对一致性要求比较高、数据隔离强的业务</li>
<li>Saga 适用于业务流程长、业务流程多的业务，在银行业金融机构使用广泛</li>
<li>TCC 对现有业务改造较大，Saga则相对少点</li>
</ul>
<h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">Seata</a></h2><p>Seata是一个由阿里做背书的分布式事务框架，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">AT模式</a></h3><p>AT模式是Seata通过拦截、解释用户的SQL，对业务数据进行加锁、回滚等操作的基于二阶段协议的一个实现。</p>
<p>它的特点是对业务无入侵，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。</p>
<p>在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</p>
<p>二阶段如果是提交的话，因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">upload successful</p>
<h3 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">TCC模式</a></h3><p>Seata的TCC模式跟上面讲的TCC事务模型差不多</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">overwrote existing file</p>
<h3 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">Saga模式</a></h3><p>Saga模式也是上面讲的Saga事务模型差不多。在Seata中对服务的编排引入了状态机引擎， 使得对业务流程的定义更加标准化，提高可读性，不过相对来说配置会比较复杂繁琐。同时支持注解的方式，这个在开发上会简单一点，但功能可能少一点。</p>
<h1 id="分布式事务一致性与Paxos一致性的思考"><a href="#分布式事务一致性与Paxos一致性的思考" class="headerlink" title="分布式事务一致性与Paxos一致性的思考"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">分布式事务一致性与Paxos一致性的思考</a></h1><p>首先要明确一点的就是对于上述提到的分布式事务解决方案，如TCC、Saga、本地消息表等，其本质都是2PC。</p>
<p>Paxos算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。</p>
<p>咋看起来2PC和Paxos都是解决关于“一致性”的问题，其实细想它们解决的问题不在一个层面。</p>
<p>2PC要求分布式系统中的每个节点要不全部成功，要不全部失败，强调的是原子性。</p>
<p>Paxos要求多个副本之间的数据一致性，其实这里用“一致性”并不准确，应该用“共识（Consensus）”才对。</p>
<p>例如2PC中的协调者单点的问题可以用Paxos算法通过选举出新的协调者来解决。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">总结</a></h1><p>总得看来，分布式事务的解决方案都很难做到有高一致性的同时，也有高性能，同时在实现上也有一定的难度。在业务允许的情况下，我们通常处理分布式事务的一般原则应是：业务规避 &gt; 最终一致 &gt; 强一致。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/31/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ-04-%E5%BC%80%E6%BA%90%E8%B4%A1%E7%8C%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/31/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ-04-%E5%BC%80%E6%BA%90%E8%B4%A1%E7%8C%AE/" class="post-title-link" itemprop="url">RocketMQ-04-开源贡献</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-31 09:10:13" itemprop="dateCreated datePublished" datetime="2021-05-31T09:10:13+08:00">2021-05-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/o917lCT1kHPYpAD63bvv7w">https://mp.weixin.qq.com/s/o917lCT1kHPYpAD63bvv7w</a></p>
<p><strong>我们希望能够有一个运维命令，能够获取当前集群中所有的客户端连接信息。</strong></p>
<p>那我们能否定制化一个运维命令实现获取所有生产者的连接信息，既然官方提供了producerConnection命令获取单个生产者组信息，服务端应该是会存储所有生产者组的连接信息，只是官方没有提供相关的命令而已，为了验证，我们可以去看一下producerConnection命令在服务端的处理逻辑。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFsujHP5KXGTMibVaYCfRrxjY0rLzcpmfQFqLt3qrcG8ib8TLYuuURDAss2YIdKsiaryAcgxMSgxooBaA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>从服务端代码可知，在服务端会使用一个Map存储所有的生产者客户端连接，其键为生产者组名称，其值为Map键值对(通道对象(Channel),客户端信息(ClientChannelInfo))，其中客户端信息就包含了客户端ID，客户端使用的语言以及版本等信息。</p>
<p>经过上面分析，实现一个获取全部生产者连接信息将变得非常简单。</p>
<p>本文由于篇幅问题，不展示全部代码，主要总结一下开发一个RocketMQ的几个核心步骤，代码已提交到github仓库：</p>
<p>链接：<a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/pull/2940">https://github.com/apache/rocketmq/pull/2940</a></p>
<p>首先我们看一下该命令在IDEA中的测试效果，运行命令如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFsujHP5KXGTMibVaYCfRrxjYD6ILnKgAVhW3zTdiaeUCp34fMLRtCIvZhh3GReZIpbgzCxngMouCJ8w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>命令运行输出为：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFsujHP5KXGTMibVaYCfRrxjYzDaIoJLJtCibP3D6agiaNNRfm51IMRGXGTqXjMtk9liadibdbp3iaxNyK0g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>打包部署后命令的使用说明如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFsujHP5KXGTMibVaYCfRrxjY3GvNu1nSZjccZ8tekt01O0cOhD6GxEmwt5jmbADJw9lQGUYqagkTlA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>其中-b broker地址与-c cluster集群名称两个参数二选一，主用用于路由。</p>
<p>编写一个RocketMQ运维命令通常具备如下几个要点：</p>
<ul>
<li>创建自己的命令处理类，并在MQAdminStartup中调用initCommand初始化命令。</li>
<li>定义命令请求CODE,RocketMQ为每一个请求定义了对应的RequestCode。</li>
<li>在Broker端的AdminBrokerProcessor中添加对该请求Code的处理逻辑</li>
</ul>
<p>为了更加形象完整的展示开发一个运维命令，我将本次提交记录截图展示给大家：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFsujHP5KXGTMibVaYCfRrxjYeQkUFTqXWDs5kJNyqib9xWAaibibpBcxHdV3VbW8o08WO0A9EFFics8JQQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springMVC/springMVC-03-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springMVC/springMVC-03-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">springMVC-03-拦截器和过滤器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-31 08:55:22 / Modified: 09:01:26" itemprop="dateCreated datePublished" datetime="2021-05-31T08:55:22+08:00">2021-05-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="HandlerInterceptor实现登录拦截的原理"><a href="#HandlerInterceptor实现登录拦截的原理" class="headerlink" title="HandlerInterceptor实现登录拦截的原理"></a>HandlerInterceptor实现登录拦截的原理</h3><p>SpringBoot通过实现HandlerInterceptor接口实现拦截器，通过实现WebMvcConfigurer接口实现一个配置类，在配置类中注入拦截器，最后再通过@Configuration注解注入配置.</p>
<h4 id="实现HandlerInterceptor接口"><a href="#实现HandlerInterceptor接口" class="headerlink" title="实现HandlerInterceptor接口"></a>实现HandlerInterceptor接口</h4><p>实现HandlerInterceptor接口需要实现3个方法：<code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code>.</p>
<p>3个方法各自的功能如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> blog.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 在请求处理之前进行调用(Controller方法调用之前)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了拦截器的preHandle方法&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpSession session = request.getSession();</span><br><span class="line">            <span class="comment">//统一拦截（查询当前session是否存在user）(这里user会在每次登录成功后，写入session)</span></span><br><span class="line">            User user = (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            response.sendRedirect(request.getContextPath() + <span class="string">&quot;login&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果设置为false时，被请求时，拦截器执行到此处将不会继续操作</span></span><br><span class="line">        <span class="comment">//如果设置为true时，拦截器将会继续执行后面的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了拦截器的postHandle方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 整个请求结束之后被调用，也就是在DispatchServlet渲染了对应的视图之后执行（主要用于进行资源清理工作）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了拦截器的afterCompletion方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>preHandle在Controller之前执行，因此拦截器的功能主要就是在这个部分实现：</p>
<ul>
<li>检查session中是否有user对象存在；</li>
<li>如果存在，就返回true，那么Controller就会继续后面的操作；</li>
<li>如果不存在，就会重定向到登录界面。就是通过这个拦截器，使得Controller在执行之前，都执行一遍preHandle.</li>
</ul>
<h4 id="实现WebMvcConfigurer接口，注册拦截器"><a href="#实现WebMvcConfigurer接口，注册拦截器" class="headerlink" title="实现WebMvcConfigurer接口，注册拦截器"></a>实现WebMvcConfigurer接口，注册拦截器</h4><p>实现WebMvcConfigurer接口来实现一个配置类，将上面实现的拦截器的一个对象注册到这个配置类中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> blog.interceptor.UserLoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注册TestInterceptor拦截器</span></span><br><span class="line">        InterceptorRegistration registration = registry.addInterceptor(<span class="keyword">new</span> UserLoginInterceptor());</span><br><span class="line">        registration.addPathPatterns(<span class="string">&quot;/**&quot;</span>); <span class="comment">//所有路径都被拦截</span></span><br><span class="line">        registration.excludePathPatterns(    <span class="comment">//添加不拦截路径</span></span><br><span class="line">                <span class="string">&quot;/login&quot;</span>,                    <span class="comment">//登录路径</span></span><br><span class="line">                <span class="string">&quot;/**/*.html&quot;</span>,                <span class="comment">//html静态资源</span></span><br><span class="line">                <span class="string">&quot;/**/*.js&quot;</span>,                  <span class="comment">//js静态资源</span></span><br><span class="line">                <span class="string">&quot;/**/*.css&quot;</span>                  <span class="comment">//css静态资源</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将拦截器注册到了拦截器列表中，并且指明了拦截哪些访问路径，不拦截哪些访问路径，不拦截哪些资源文件；最后再以@Configuration注解将配置注入。</p>
<h4 id="保持登录状态"><a href="#保持登录状态" class="headerlink" title="保持登录状态"></a>保持登录状态</h4><p>只需一次登录，如果登录过，下一次再访问的时候就无需再次进行登录拦截，可以直接访问网站里面的内容了。</p>
<p>在正确登录之后，就将user保存到session中，再次访问页面的时候，登录拦截器就可以找到这个user对象，就不需要再次拦截到登录界面了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &#123;&quot;/login&quot;&#125;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">loginIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;users/login&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &#123;&quot;/login&quot;&#125;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestParam(name = &quot;username&quot;)</span>String username, <span class="meta">@RequestParam(name = &quot;password&quot;)</span>String password, Model model, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    User user = userService.getPwdByUsername(username);</span><br><span class="line">    String pwd = user.getPassword();</span><br><span class="line">    <span class="keyword">if</span> (pwd.equals(password2)) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        request.getSession().setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;users/failed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring-03-DI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring-03-DI/" class="post-title-link" itemprop="url">spring-03-DI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-29 21:40:10" itemprop="dateCreated datePublished" datetime="2021-05-29T21:40:10+08:00">2021-05-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-02 11:20:40" itemprop="dateModified" datetime="2021-06-02T11:20:40+08:00">2021-06-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="beanFactory-createBean和doCreateBean"><a href="#beanFactory-createBean和doCreateBean" class="headerlink" title="beanFactory.createBean和doCreateBean"></a>beanFactory.createBean和doCreateBean</h3><p>创建Bean的过程如下(省略部分代码，只保留主要逻辑)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">	RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">    <span class="comment">// 从BeanDefinition Map中得到要创建的bean的类型</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">    	mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次调用后置处理器，判断是否加代理，Spring Boot中没有任何处理</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Bean的真正过程</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    	<span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第二次调用后置处理器</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建实例对象</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 第三次调用后置处理器，通过后置处理器合并BeanDefinition,拿到所有需要注入的属性</span></span><br><span class="line">                <span class="comment">// ApplicationListenerDetector: 将属于ApplicationListener的Bean放入到ApplicationContext上下文的applicationListener集合中</span></span><br><span class="line">                <span class="comment">// CommonAnnotationBeanPostProcessor: 将@Resource、@webServiceRef、@EJB修饰的属性放入到RootBeanDefinition中</span></span><br><span class="line">                <span class="comment">// AutowiredAnnotationBeanPostProcessor: 将@Autowired、@Value、JSR-330相关注解放入到RootBeanDefinition中</span></span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环依赖相关</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">      <span class="comment">// 当支持循环依赖时，就会提前暴露自己(为了其他对象可以注入自己)，第四次调用后置处理器,实际在Spring Boot中没有处理任何事情</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要属性注入,若需要则注入则完成注入,第五、六次调用后置处理器</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化Spring，进行第七、八次后置处理器的调用</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">//异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第9次调用后置处理器</span></span><br><span class="line">      <span class="comment">// DestructionAwareBeanPostProcessor的requiresDestruction方法和postProcessBeforeDestruction方法，具体destroy过程见:</span></span><br><span class="line">      <span class="comment">// org.springframework.beans.factory.support.DisposableBeanAdapter.destroy()方法</span></span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="beanFactory-populateBean"><a href="#beanFactory-populateBean" class="headerlink" title="beanFactory.populateBean"></a>beanFactory.populateBean</h3><p><code>populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</code>方法完成属性注入(省略部分代码，只保留主要逻辑):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任何实现postProcessAfterInstantiation的BeanPostProcessor都可以修改postProcessAfterInstantiation的返回值,例如:动态注入</span></span><br><span class="line">    <span class="comment">// 第五次调用后置处理器，判断是否需要属性注入,CommonAnnotationBeanPostProcessor、AutowiredAnnotationBeanPostProcessor、ImportAwareBeanPostProcessor都默认为true</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                <span class="comment">// 调用后置处理器 判断是否需要属性注入，实现InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation就不会进行属性注入</span></span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始属性注入</span></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 自动注入的方式。。。省略</span></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第六次调用后置处理器</span></span><br><span class="line">        <span class="comment">// 1.在ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor.postProcessProperties中指定BeanFactory</span></span><br><span class="line">        <span class="comment">// 2.在CommonAnnotationBeanPostProcessor.postProcessProperties中注入@Resurce、@WebServiceRef、@EJB相关</span></span><br><span class="line">        <span class="comment">// 3.其会在AutowiredAnnotationBeanPostProcessor.postProcessProperties中进行属性注入@Autowired、@Value、@Inject注解</span></span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="comment">// 完成属性注入</span></span><br><span class="line">                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">                pvs = pvsToUse;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="beanFactory-initializeBean"><a href="#beanFactory-initializeBean" class="headerlink" title="beanFactory.initializeBean"></a>beanFactory.initializeBean</h3><p><code>initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd)</code>方法会执行工厂相关回调方法、init方法等BeanPostProcessor后置处理器，具体如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行或者回调Aware相关接口:BeanNameAware、BeanClassLoaderAware、BeanFactoryAware，只有这三个</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 第七次调用后置处理器</span></span><br><span class="line">		<span class="comment">// 1.ApplicationContextAwareProcessor: 执行EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware相关回调</span></span><br><span class="line">		<span class="comment">// 2.ImportAwareBeanPostProcessor: 实现ImportAware接口的Bean</span></span><br><span class="line">		<span class="comment">// 3.BeanPostProcessorChecker:没有做任何事情</span></span><br><span class="line">		<span class="comment">// 4.CommonAnnotationBeanPostProcessor继承自CommonAnnotationBeanPostProcessor, 执行带@PostConstract注解的方法</span></span><br><span class="line">		<span class="comment">// 5.AutowiredAnnotationBeanPostProcessor:没有做任何事情</span></span><br><span class="line">		<span class="comment">// 6.ApplicationListenerDetector:将ApplicationListener添加到applicationContext中</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先处理实现InitializingBean,然后处理xml的init-method方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 第8次调用后置处理器</span></span><br><span class="line">		<span class="comment">// 1.ApplicationContextAwareProcessor、ImportAwareBeanPostProcessor、: 没有做任何事情</span></span><br><span class="line">		<span class="comment">// 2.BeanPostProcessorChecker: 一些日志</span></span><br><span class="line">		<span class="comment">// 3.CommonAnnotationBeanPostProcessor、AutowiredAnnotationBeanPostProcessor:没有做任何事情</span></span><br><span class="line">		<span class="comment">// 4.ApplicationListenerDetector: 将符合条件的Bean放入到ApplicationContext.applicationListeners中</span></span><br><span class="line">		<span class="comment">// AOP代理 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述过程不仅仅是Bean的创建过程，还包括了创建Bean过程中相关的后置处理器逻辑，<strong>Spring framework</strong>相关的共6个后置处理器，具体见下文。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-IO-Serializable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-IO-Serializable/" class="post-title-link" itemprop="url">JDK-IO-Serializable</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-28 16:43:54" itemprop="dateCreated datePublished" datetime="2021-05-28T16:43:54+08:00">2021-05-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-18 13:24:15" itemprop="dateModified" datetime="2021-06-18T13:24:15+08:00">2021-06-18</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java序列化与反序列化"><a href="#Java序列化与反序列化" class="headerlink" title="Java序列化与反序列化"></a>Java序列化与反序列化</h2><ul>
<li>序列化：将对象写入到IO流中</li>
<li>反序列化：从IO流中恢复对象</li>
</ul>
<p>序列化机制允许将实现序列化的Java对象转换为字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。</p>
<p>要想有序列化的能力，得实现<code>Serializable</code>接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class SerializableTest implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -3751255153289772365L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM会在运行时判断类的<code>serialVersionUID</code>来验证版本一致性，如果传来的字节流中的serialVersionUID与本地相应类的serialVersionUID相同则认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException:com.taobao.query.TestSerializable;</span><br><span class="line"> local class incompatible: stream classdesc serialVersionUID = -7165097063094245447,local class    serialVersionUID = 6678378625230229450</span><br></pre></td></tr></table></figure>

<h2 id="Jackson序列化"><a href="#Jackson序列化" class="headerlink" title="Jackson序列化"></a>Jackson序列化</h2><h2 id="Dubbo与序列化"><a href="#Dubbo与序列化" class="headerlink" title="Dubbo与序列化"></a>Dubbo与序列化</h2><img src="https://mmbiz.qpic.cn/mmbiz_jpg/R7PtjL3tdAickVUF9IZmibFdmF1FlgL2NuBu5TXia3HmibyicxYfMkYv7YzoGKy4ISEs8MEs3CjMw28JdxibnibFHCPfA/640" alt="Image" style="zoom:67%;" />

<p>图片来源：<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/dev/design/">https://dubbo.apache.org/zh/docs/v2.7/dev/design/</a></p>
<p>从Dubbo的调用链可以发现是有一个序列化节点的，其支持的序列化协议一共有四种：</p>
<ol>
<li>dubbo序列化：阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它</li>
<li>hessian2序列化：hessian是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的hessian lite，它是dubbo RPC默认启用的序列化方式</li>
<li>json序列化：目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。</li>
<li>java序列化：主要是采用JDK自带的Java序列化实现，性能很不理想。</li>
</ol>
<p>如果在RPC中使用了Java序列化，那下面的这三个坑一定注意不要踩</p>
<h3 id="类实现Serializable接口但没有指定serialVersionUID"><a href="#类实现Serializable接口但没有指定serialVersionUID" class="headerlink" title="类实现Serializable接口但没有指定serialVersionUID"></a>类实现<code>Serializable</code>接口但没有指定<code>serialVersionUID</code></h3><p>如果实现了<code>Serializable</code>的类没有指定<code>serialVersionUID</code>，编译器编译的时候会根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，这就决定了这个类在序列化上一定不是向前兼容的</p>
<p>假如我们先有<code>Student</code>这样的一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static int startId &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">        id &#x3D; startId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将其序列化到磁盘：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        FileOutputStream fileOut =</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/student.ser&quot;</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">        out.writeObject(student);</span><br><span class="line">        out.close();</span><br><span class="line">        fileOut.close();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Serialized data is saved in /tmp/student.ser&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (</span><br><span class="line">            IOException i) &#123;</span><br><span class="line">        i.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后给<code>Student</code>类加一个字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> startId = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="comment">// 注意这里我们已经加了一个属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = startId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再去解码，发现程序会抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.idealism.base.Student; local class incompatible: stream classdesc serialVersionUID &#x3D; -1534228028811562580, local class serialVersionUID &#x3D; 630353564791955009</span><br><span class="line"> at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699)</span><br><span class="line"> at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2001)</span><br><span class="line"> at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1848)</span><br><span class="line"> at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2158)</span><br><span class="line"> at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459)</span><br><span class="line"> at com.idealism.base.SerializableTest.deserialize(SerializableTest.java:34)</span><br><span class="line"> at com.idealism.base.SerializableTest.main(SerializableTest.java:9)</span><br></pre></td></tr></table></figure>

<p>根因是RPC的参数实现了<code>Serializable</code>接口，但是没有指定<code>serialVersionUID</code>，编译器会根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，当服务端类升级之后导致了服务端发送给客户端的字节流中的<code>serialVersionUID</code>发生了改变，因此当客户端反序列化去检查<code>serialVersionUID</code>字段的时候发现发生了变化被判定了异常。</p>
<h3 id="父类实现Serializable接口，并且指定了serialVersionUID但是子类没有指定serialVersionUID"><a href="#父类实现Serializable接口，并且指定了serialVersionUID但是子类没有指定serialVersionUID" class="headerlink" title="父类实现Serializable接口，并且指定了serialVersionUID但是子类没有指定serialVersionUID"></a>父类实现<code>Serializable</code>接口，并且指定了<code>serialVersionUID</code>但是子类没有指定<code>serialVersionUID</code></h3><p>我们对前面的例子中的<code>Student</code>类稍微改一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Base&#123;</span><br><span class="line"></span><br><span class="line">    private static int startId &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">        id &#x3D; startId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中父类长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Base implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 218886242758597651L;</span><br><span class="line"></span><br><span class="line">    private Date gmtCreate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们按照之前的讨论在本地进行一次序列化和反序列化，程序依然抛异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.idealism.base.Student; local class incompatible: stream classdesc serialVersionUID &#x3D; 1049562984784675762, local class serialVersionUID &#x3D; 7566357243685852874</span><br><span class="line"> at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699)</span><br><span class="line"> at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2001)</span><br><span class="line"> at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1848)</span><br><span class="line"> at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2158)</span><br><span class="line"> at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459)</span><br><span class="line"> at com.idealism.base.SerializableTest.deserialize(SerializableTest.java:34)</span><br><span class="line"> at com.idealism.base.SerializableTest.main(SerializableTest.java:9)</span><br></pre></td></tr></table></figure>

<p>我们在设计类的时候公共属性要放到基类，这条经验指导放到这个case中仍然不太正确，而且这个case比上一个还要隐蔽，问题是子类中的<code>serialVersionUID</code>仍然是编译器自动生成的。当然可以把父类中<code>serialVersionUID</code>的改为非<code>private</code>来解这个问题，不过我仍然建议每个有序列化需求的类都显式指定<code>serialVersionUID</code>的值。</p>
<p>如果序列化遇到类之间的组合或者继承关系，则Java按照下面的规则处理：</p>
<ul>
<li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化，而不管其是否实现了<code>Serializable</code>接口</li>
<li>如果子类实现了<code>Serializable</code>，则序列化时只序列化子类，不会序列化父类中的属性</li>
<li>如果父类实现了<code>Serializable</code>，则序列化时子类和父类都会被序列化，异常场景如本例所指</li>
</ul>
<p>还有一点要注意：如果类的实例中有静态变量，改属性不会被序列化和反序列化</p>
<h3 id="类中有枚举值"><a href="#类中有枚举值" class="headerlink" title="类中有枚举值"></a>类中有枚举值</h3><p>《阿里巴巴开发规约》中有这么一条：</p>
<blockquote>
<p>【强制】二方库例可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象。</p>
<p>说明：由于升级原因，导致双方的枚举类不尽相同，在接口解析，类反序列化时出现异常</p>
</blockquote>
<p>这里会出现这样一个限制的原因是Java对枚举的序列化和反序列化采用完全不同的策略。序列化的结果中仅包含枚举的名字，而不包含枚举的具体定义，反序列化的时候客户端从序列化结果中读取枚举的name，然后调用<code>java.lang.Enum#valueOf</code>根据本地的枚举定义获取具体的枚举值。</p>
<p>我们仍然用之前的代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 2528736437985230667L;</span><br><span class="line">    </span><br><span class="line">    private static int startId &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    &#x2F;&#x2F; 新增字段，校服尺码，其类型是一个枚举</span><br><span class="line">    private SchoolUniformSizeEnum schoolUniformSize;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">        id &#x3D; startId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如学生这个类中新增了一个校服尺码的枚举值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum SchoolUniformSizeEnum &#123;</span><br><span class="line">    SMALL,</span><br><span class="line">    MEDIUM,</span><br><span class="line">    LARGE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如服务端此时对这个枚举进行了升级，但是客户端的二方包中仍然只有三个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum SchoolUniformSizeEnum &#123;</span><br><span class="line">    SMALL,</span><br><span class="line">    MEDIUM,</span><br><span class="line">    LARGE,</span><br><span class="line">    OVERSIZED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果服务端有逻辑给客户端返回了这个新增的枚举值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static void serialize() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Student student &#x3D; new Student();</span><br><span class="line">        &#x2F;&#x2F; 服务端升级了枚举</span><br><span class="line">        student.setSchoolUniformSize(SchoolUniformSizeEnum.OVERSIZED);</span><br><span class="line">        FileOutputStream fileOut &#x3D;</span><br><span class="line">                new FileOutputStream(&quot;&#x2F;tmp&#x2F;student.ser&quot;);</span><br><span class="line">        ObjectOutputStream out &#x3D; new ObjectOutputStream(fileOut);</span><br><span class="line">        out.writeObject(student);</span><br><span class="line">        out.close();</span><br><span class="line">        fileOut.close();</span><br><span class="line">        System.out.printf(&quot;Serialized data is saved in &#x2F;tmp&#x2F;student.ser&quot;);</span><br><span class="line">    &#125; catch (</span><br><span class="line">            IOException i) &#123;</span><br><span class="line">        i.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为客户端的包还没有升级，所以当客户端读到这个新的字节流并序列化的时候会因为找不到对应的枚举值而抛异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidObjectException: enum constant OVERSIZED does not exist in class com.idealism.base.SchoolUniformSizeEnum</span><br><span class="line"> at java.io.ObjectInputStream.readEnum(ObjectInputStream.java:2130)</span><br><span class="line"> at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1659)</span><br><span class="line"> at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2403)</span><br><span class="line"> at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2327)</span><br><span class="line"> at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2185)</span><br><span class="line"> at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501)</span><br><span class="line"> at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459)</span><br><span class="line"> at com.idealism.base.SerializableTest.deserialize(SerializableTest.java:36)</span><br><span class="line"> at com.idealism.base.SerializableTest.main(SerializableTest.java:9)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-lang-Object-wait-notify/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-lang-Object-wait-notify/" class="post-title-link" itemprop="url">JDK-lang-Thread</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-28 15:09:45" itemprop="dateCreated datePublished" datetime="2021-05-28T15:09:45+08:00">2021-05-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-16 00:09:01" itemprop="dateModified" datetime="2023-03-16T00:09:01+08:00">2023-03-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="JVM线程状态与锁的关系"><a href="#JVM线程状态与锁的关系" class="headerlink" title="JVM线程状态与锁的关系"></a>JVM线程状态与锁的关系</h2><p>sleep、wait、join都会使线程进入阻塞状态(waiting/timed_waiting状态)，同时也都会释放cpu资源</p>
<blockquote>
<p>yield是释放cpu资源，然后又抢夺cpu资源，目的是为了让其它线程有机会获取cpu资源进行处理，但是线程状态还是runnable。</p>
</blockquote>
<p>sleep如果是在锁方法内执行，比如同步代码块或者重入锁方法内执行，是不会释放锁。而wait会释放锁。</p>
<ul>
<li>wait用于锁机制，sleep不是，这也是为什么sleep不释放锁，wait释放锁的原因，</li>
<li>sleep是线程的方法，跟锁没关系，</li>
<li>wait，notify，notifyall 都是Object对象的方法，是一起使用的，用于锁机制。</li>
</ul>
<p>有个特殊的Thread.sleep(0)，操作这个动作是让出cpu，让其它线程又机会获取cpu资源执行</p>
<h2 id="wait-官方说明"><a href="#wait-官方说明" class="headerlink" title="wait()官方说明"></a>wait()官方说明</h2><p>The recommended approach to waiting is to check the condition being awaited in a while loop around the call to wait, as shown in the example below. Among other things, this approach avoids problems that can be caused by spurious wakeups.<br> synchronized (obj) {      while (<condition does not hold> and <timeout not exceeded>) {          long timeoutMillis = … ; // recompute timeout values          int nanos = … ;          obj.wait(timeoutMillis, nanos);      }      … // Perform action appropriate to condition or timeout  }</p>
<h2 id="notify-官方说明"><a href="#notify-官方说明" class="headerlink" title="notify()官方说明"></a>notify()官方说明</h2><p>Wakes up all threads that are waiting on this object’s monitor. A thread waits on an object’s monitor by calling one of the wait methods.<br>The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object. The awakened threads will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable privilege or disadvantage in being the next thread to lock this object.<br>This method should only be called by a thread that is the owner of this object’s monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.<br>Throws:<br>IllegalMonitorStateException – if the current thread is not the owner of this object’s monitor.</p>
<p><img src="https://2.bp.blogspot.com/-7yTGxlOBfu4/VvUdKBO3RhI/AAAAAAAAFYE/tSNS9y3Gb2sGPE4nrnTvllraf0lYOt-SA/w615-h461/Wait%2Band%2BNotify%2BJava%2BConcurrency.jpg" alt="&quot;wait notify and notifyall in java synchronized"></p>
<blockquote>
<p>Since the wait() method in Java also releases the lock prior to waiting and reacquires the lock prior to returning from the <a target="_blank" rel="noopener" href="http://javarevisited.blogspot.com/2011/12/difference-between-wait-sleep-yield.html">wait() method</a>, we must use this lock to ensure that checking the condition (buffer is full or not) and setting the condition (taking element from the buffer) is atomic which can be achieved by using synchronized method or block in Java.</p>
<p>Read more: <a target="_blank" rel="noopener" href="https://javarevisited.blogspot.com/2011/05/wait-notify-and-notifyall-in-java.html#ixzz7w2kARh54">https://javarevisited.blogspot.com/2011/05/wait-notify-and-notifyall-in-java.html#ixzz7w2kARh54</a></p>
</blockquote>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>无论是wait()还是notify()，其执行的前提条件都是：该线程首先持有资源对象object的锁。否则的话，就会抛出IllegalMonitorStateException异常。<br> <code>wait(long timeout)</code>：和wait()方法类似的还有一个wait(long timeout)，如果线程一直没有被唤醒，当超时时间到了，就会自动被唤醒。<br> <code>notifyAll()</code>：notify()方法，也对应有一个notifyAll()方法，该方法会将等待队列里的所有线程都唤醒，唤醒后的线程行为和notify()保持一致。</p>
<p>事实上一个线程被唤醒的方式包括以下几种：</p>
<ul>
<li>其他线程调用object的notify()方法， 而该线程刚好被从等待队列中选中.</li>
<li>其他线程调用了notifyAll()方法。</li>
<li>其他线程通过interrupt中断了该线程。</li>
<li>等待超时时间到达，线程被自动唤醒。</li>
</ul>
<p>刚刚上文也提到了执行notify和wait，必须先获取到资源对象的锁，获取锁的方式有三种：</p>
<ul>
<li>执行对象的同步方法。</li>
<li>执行对象的同步代码块。</li>
<li>对于类对象，执行类的静态同步方法。</li>
</ul>
<h3 id="wait-和sleep"><a href="#wait-和sleep" class="headerlink" title="wait()和sleep()"></a>wait()和sleep()</h3><p>首先，wait必须要在获得了当前对象的对象锁代码块中执行（可以理解为调用哪个对象的wait方法，调用的时候就要处于哪个对象的同步代码块中），而sleep则没有这个限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wait(); <span class="comment">//可以 没问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wait(); <span class="comment">//不可以，没有处于this的同步代码块中，抛出IllegalMonitorStateException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(其他对象) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait() <span class="comment">// 不可以，这里只获得了其他对象的锁，但是却调用了this的wait，抛出IllegalMonitorStateException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(其他对象) &#123;</span><br><span class="line">        其他对象.wait() <span class="comment">// 可以，没问题，不一定非得是this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也许你注意到了，wait()必须配合synchronized使用？为什么呢？那就是wait()有个很有意思的特性，<strong>执行wait()后的睡眠期间，会释放掉通过synchronized获得的锁，直到被唤醒的时候会重新获得锁</strong>，而sleep()会在线程睡眠期间依然持有这个锁，也就是说，在同步代码块中用wait()睡眠后，其他线程也能够获得对象的锁。</p>
<p>wait()的睡眠状态被notity()或notifyAll()唤醒时，不会抛出异常，sleep()导致的睡眠只能被interrupt()方法唤醒，同时sleep()会抛出异常，若interrupt()唤醒的是由wait()导致的睡眠，wait()同样会抛出异常。</p>
<p>同时，由于wait()会释放掉锁，因此一个对象中可能会同时存在多个线程由于wait()导致的睡眠</p>
<h3 id="notify-与notifyAll"><a href="#notify-与notifyAll" class="headerlink" title="notify()与notifyAll()"></a>notify()与notifyAll()</h3><p>notify()会将对象的一个线程从wait()导致的睡眠状态中唤醒，至于是哪个线程，则是随机的。</p>
<p>而notifyAll()则是唤醒对象所有由于wait()导致的睡眠。由于wait()被唤醒后会对对象加锁，如果没能拿到锁会暂时先阻塞着直到有机会拿到锁，因此依然是线程安全的。</p>
<h3 id="简易消息队列的实现"><a href="#简易消息队列的实现" class="headerlink" title="简易消息队列的实现"></a>简易消息队列的实现</h3><p>现在就利用上面的特性，实现一个简单的阻塞型消息队列吧。</p>
<p>消息队列是一个典型的消费者-生产者模型，当消费者消费时，若消息队列为空，则一直等待（阻塞执行），直到生产者生产了一个消息，此时消费者阻塞消除并获得一个消息</p>
<p>这里阻塞的关键是队列空时等待，非空时唤醒</p>
<p>消息队列类完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用锁实现的消息队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列关闭标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 使用链表作为消息容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg   消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取链表的锁之后，向链表添加消息，最后尝试唤醒链表对象（如果在等待的话）</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;消息队列已关闭&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(msg);</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭消息队列，并唤醒消费者的等待（如果在等待的话）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            stop = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费消息，若无消息将会一直阻塞，直到有消息或队列关闭，若消息队列已关闭则不再阻塞且返回null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 拿到的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取对象的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> queue.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stop &amp;&amp; queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 由于关闭队列也有可能退出上面的循环，所以要再判断一次长度</span></span><br><span class="line">                <span class="keyword">if</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> queue.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MessageQueue mq = <span class="keyword">new</span> MessageQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开1个线程消费消息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               String msg = mq.consume();</span><br><span class="line">               System.out.println(<span class="string">&quot;消费消息：&quot;</span> + msg);</span><br><span class="line">               <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;队列关闭&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            mq.product(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产消息：&quot;</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mq.stop();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行可以观察到每0.1秒生产一个消息，紧接着就被消费，最后程序退出 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-lang-Thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-lang-Thread/" class="post-title-link" itemprop="url">JDK-lang-Thread</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-28 15:09:45" itemprop="dateCreated datePublished" datetime="2021-05-28T15:09:45+08:00">2021-05-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-15 17:59:31" itemprop="dateModified" datetime="2023-03-15T17:59:31+08:00">2023-03-15</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="操作系统中线程状态"><a href="#操作系统中线程状态" class="headerlink" title="操作系统中线程状态"></a>操作系统中线程状态</h3><p>传统的进（线）程状态一般划分如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfednyicQRNkh1ibicsEjORXmQPvuebO2CAvYA39TwmEx3t5agr9HlYDO9wxvRoW8eGut9tzZUGvvJyNg/640" alt="图片"></p>
<h3 id="jdk中线程状态"><a href="#jdk中线程状态" class="headerlink" title="jdk中线程状态"></a>jdk中线程状态</h3><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><h5 id="包含OS的ready和running状态"><a href="#包含OS的ready和running状态" class="headerlink" title="包含OS的ready和running状态"></a>包含OS的ready和running状态</h5><p>runnable 状态实质上是包括了 ready 状态和running 状态。</p>
<blockquote>
<p>A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</p>
</blockquote>
<p>通常，Java的线程状态是服务于监控的，如果线程切换得是如此之快，那么区分 ready 与 running 就没什么太大意义了。</p>
<p>现今主流的 JVM 实现都把 Java 线程一一映射到操作系统底层的线程上，把调度委托给了操作系统，我们在虚拟机层面看到的状态实质是对底层状态的映射及包装。JVM 本身没有做什么实质的调度，把底层的 ready 及 running 状态映射上来也没多大意义，因此，统一成为runnable 状态是不错的选择。</p>
<h5 id="包含OS中由于IO引起的wait状态"><a href="#包含OS中由于IO引起的wait状态" class="headerlink" title="包含OS中由于IO引起的wait状态"></a>包含OS中由于IO引起的wait状态</h5><p>一旦线程中执行到 I/O 有关的代码，相应线程立马被切走，然后调度 ready 队列中另一个线程来运行。这时执行了 I/O 的线程就不再运行，处于上图中的 waiting 状态。</p>
<p>而当 I/O 完成时，则用一种叫中断 （interrupt）的机制来通知 cpu：</p>
<p>cpu 会收到一个比如说来自硬盘的Interrput信号，并进入中断处理例程，CPU正在执行的线程因此被Interrput，回到 ready 队列。而先前因 I/O 而waiting 的线程随着 I/O 的完成也再次回到 ready 队列，这时 cpu 可能会选择它来执行。</p>
<blockquote>
<p>进行阻塞式 I/O 操作时，Java 的线程状态究竟是什么？是 BLOCKED？还是 WAITING？</p>
</blockquote>
<p>其实状态还是 RUNNABLE。</p>
<p>网络阻塞时同理，比如socket.accept，我们说这是一个“阻塞式(blocked)”式方法，但线程状态还是 RUNNABLE。</p>
<blockquote>
<p>至少我们看到了，进行传统上的 IO 操作时，口语上我们也会说“阻塞”，但这个“阻塞”与线程的 BLOCKED 状态是两码事！</p>
</blockquote>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>首先还是前面说的，注意分清两个层面：</p>
<ul>
<li><p>JVM层面：当进行阻塞式的 IO 操作时，或许底层的操作系统线程确实处在阻塞状态，但我们关心的是 JVM 的线程状态。JVM 把那些都视作资源，cpu 也好，硬盘，网卡也罢，有东西在为线程服务，它就认为线程在“执行”。</p>
</li>
<li><p>操作系统：操作系统的线程状态是围绕着 cpu 这一核心去述说的，这与 JVM 的侧重点是有所不同的。</p>
</li>
</ul>
<p>前面我们也强调了“Java 线程状态的改变通常只与自身显式引入的机制有关”，如果 JVM 中的线程状态发生改变了，通常是自身机制引发的。</p>
<blockquote>
<p>比如 synchronize 机制有可能让线程进入BLOCKED 状态，sleep，wait等方法则可能让其进入 WATING 之类的状态。</p>
</blockquote>
<p>它与传统的线程状态的对应可以如下来看：</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfednyicQRNkh1ibicsEjORXmQPEQSACKpCTzaaLPDxT4MNqw0KgSqLFX6LxM8qFbf61zybHibUGM8n3Cw/640" alt="图片" style="zoom: 50%;" />

<p>RUNNABLE 状态对应了传统的 ready， running 以及部分的 waiting 状态。</p>
<h4 id="BLOCKED-阻塞状态"><a href="#BLOCKED-阻塞状态" class="headerlink" title="BLOCKED: 阻塞状态"></a>BLOCKED: 阻塞状态</h4><p>等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态</p>
<h4 id="WAITING-等待状态"><a href="#WAITING-等待状态" class="headerlink" title="WAITING: 等待状态"></a>WAITING: 等待状态</h4><p>处于等待状态的线程是由于执行了3个方法中的任意方法。 </p>
<ol>
<li>Object.wait() with no timeout</li>
<li>Thread.join() with no timeout</li>
<li>LockSupport.park()</li>
</ol>
<p>处于waiting状态的线程会等待另外一个线程处理特殊的行为。 </p>
<p>再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态</p>
<blockquote>
<p>比如线程处于WAITING状态，这个时候可以分析一下notifyAll或者signalAll方法的调用时机是否不对。</p>
</blockquote>
<h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING:"></a>TIMED_WAITING:</h4><p>有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。  </p>
<ol>
<li><p>Thread.sleep(long millis)</p>
</li>
<li><p>Object.wait(long) with timeout </p>
</li>
<li><p>Thread.join(long) with timeout</p>
</li>
<li><p>LockSupport.parkNanos(Object blocker, long deadline)</p>
</li>
<li><p>LockSupport.parkUntil(long deadline)</p>
</li>
</ol>
<h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>线程中止的状态，这个线程已经完整地执行了它的任务</p>
<h3 id="java线程不同状态之间的转换"><a href="#java线程不同状态之间的转换" class="headerlink" title="java线程不同状态之间的转换"></a>java线程不同状态之间的转换</h3><p><img src="http://f1.babyitellyou.com/sp1/img/20201206/1ed0ebb5d7a15469d852e640d8daa0dd.png" alt="img"></p>
<h4 id="RUNNABLE-gt-BLOCKED状态"><a href="#RUNNABLE-gt-BLOCKED状态" class="headerlink" title="RUNNABLE -&gt; BLOCKED状态"></a>RUNNABLE -&gt; BLOCKED状态</h4><p>代码执行到synchronized代码块和synchronized方法 时候要获取到锁，就变成BLOCKED状态。</p>
<blockquote>
<p><strong>我们平时所谓的 Java 在调用阻塞式 API 时，线程会阻塞，指的是操作系统线程的状态，并不是 Java 线程的状态。</strong></p>
</blockquote>
<h4 id="RUNNABLE-gt-WAITING状态"><a href="#RUNNABLE-gt-WAITING状态" class="headerlink" title="RUNNABLE -&gt; WAITING状态"></a>RUNNABLE -&gt; WAITING状态</h4><p>根据官方文档，线程执行到代码Object#wait()，Thread.join，LockSupport#park()时候线程会转移到该前状态。</p>
<h4 id="RUNNABLE-gt-TIMED-WAITING状态"><a href="#RUNNABLE-gt-TIMED-WAITING状态" class="headerlink" title="RUNNABLE -&gt; TIMED_WAITING状态"></a>RUNNABLE -&gt; TIMED_WAITING状态</h4><p>根据定义线程执行到Thread.sleep(long millis)，Object.wait(long timeout)，Thread.join(long millis)，LockSupport.parkNanos(Object blocker, long deadline)，LockSupport.parkUntil(long deadline)，和waitting相比主要是有个等待时间，且比waiting多了个sleep操作。</p>
<h4 id="BLOCKED-gt-RUNNABLE状态"><a href="#BLOCKED-gt-RUNNABLE状态" class="headerlink" title="BLOCKED -&gt; RUNNABLE状态"></a>BLOCKED -&gt; RUNNABLE状态</h4><p>线程获得 监视器锁(synchronized 隐式锁)时，就又会从 BLOCKED 转换到 RUNNABLE 状态</p>
<h4 id="WAITING-gt-RUNNABLE状态"><a href="#WAITING-gt-RUNNABLE状态" class="headerlink" title="WAITING -&gt; RUNNABLE状态"></a>WAITING -&gt; RUNNABLE状态</h4><p>对于Object.wait()，其它线程执行了同一个对象的Object#notify()或者nofityAll()时候唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<p>对于Thread.join()，其它线程执行完毕或者抛出异常后唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<p>对于LockSupport#park，在别处执行了此Thread的LockSuport#unPark时候唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<h4 id="TIMED-WAITING-gt-RUNNABLE状态"><a href="#TIMED-WAITING-gt-RUNNABLE状态" class="headerlink" title="TIMED_WAITING -&gt; RUNNABLE状态"></a>TIMED_WAITING -&gt; RUNNABLE状态</h4><p>对于Object.wait(long timeout)，线程阻塞timeout时间后，或者在timeout时间内其它线程执行了同一个对象的Object#notify()或者nofityAll()时候唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<p>对于Thread.join(long millis)，线程阻塞millis时间后，或者millis时间内其它线程执行完毕或者抛出异常后唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<p>对于LockSupport.parkNanos(Object blocker, long deadline)和LockSupport.parkUntil(long deadline)，线程阻塞deadline时间后，或者在别处执行了此Thread的LockSuport#unPark时候唤醒线程，线程由WAITING -&gt; RUNNABLE。</p>
<p>Thread.sleep(long millis)，休眠millis时间后线程自动唤醒，或者线程被打断休眠，也会被唤醒。线程由WAITING -&gt; RUNNABLE。</p>
<h2 id="jstack显示的java线程状态"><a href="#jstack显示的java线程状态" class="headerlink" title="jstack显示的java线程状态"></a>jstack显示的java线程状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack PID(10进制)</span><br></pre></td></tr></table></figure>

<p>生成线程堆栈文件</p>
<blockquote>
<p>java.lang.Thread.State: BLOCKED 线程处于阻塞状态，遇到了synchronized处于阻塞状态</p>
<p>java.lang.Thread.State: RUNNABLE 线程处于正运行状态，或者阻塞在IO状态 </p>
<p>java.lang.Thread.State: TIMED_WAITING (on object monitor) Object.wait(long)加超时时间操作 java.lang.Thread.State: TIMED_WAITING (parking) 通过LockSupport.parkXXX加超时时间操作 java.lang.Thread.State: TIMED_WAITING (sleeping) 通过Thread.sleep加休眠时间操作 </p>
<p>java.lang.Thread.State: WAITING (on object monitor) Object.wait()无超时时间操作 </p>
<p>java.lang.Thread.State: WAITING (parking) 通过LockSupport.park())操作</p>
</blockquote>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>除了Object.nofity()，nofityAll()，LockSupport.unPark(Thread)操作唤醒线程或者超时自动唤醒线程，工作中也经常使用到interrupt() 方法对阻塞中的线程(WAITING、TIMED_WAITING 状态)进行中断，以便使线程从阻塞(WAITING、TIMED_WAITING 状态)中被唤醒。interrupt()操作是给正在处于阻塞状态的线程发个中断通知，以便线程从阻塞中唤醒过来。</p>
<p>线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的 interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态(中间可能存在BLOCKED状态)，同时线程 A 的代码会触发 InterruptedException 异常。通过查看Object.wait()，Thread.join()方法上都有throws InterruptedException。这个异常的触发条件就是：其他线程调用了该线程的 interrupt() 方法。</p>
<p>当RUNNABLE状态线程在阻塞到IO操作时候，此时线程状态还是RUNNABLE ，但是实际在linux线程模型中是阻塞状态，比如线程A阻塞在 java.nio.channels.Selector.select() 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 的 java.nio.channels.Selector 会立即返回。</p>
<h2 id="线程池内线程的状态"><a href="#线程池内线程的状态" class="headerlink" title="线程池内线程的状态"></a>线程池内线程的状态</h2><ul>
<li><p>预热阶段，线程状态也是从NEW-&gt;RUNNABLE-BLOCKED/WAITING/TIMED_WAITING状态</p>
</li>
<li><p>线程池活动达到core线程后，接入的请求都会存放到队列内，如果队列内任务为空，那么Worker线程getTask()阻塞，处于waiting状态</p>
</li>
</ul>
<p><img src="http://f1.babyitellyou.com/sp1/img/20201206/87d263be12c962900f8a33fa6b68e264.png" alt="img"></p>
<p>其中代码@1和@2底层都是使用的LockSupport.park()挂起线程 <!--ReentrantLock锁--> ，因此，线程池内的线程空闲时候，线程状态是waiting状态。</p>
<p>验证如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocateServiceImpl</span> <span class="keyword">implements</span> <span class="title">AllocateService</span>, <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor pool;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().</span><br><span class="line">                setNameFormat(<span class="string">&quot;my-pool-%d&quot;</span>).build();</span><br><span class="line">        pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">60L</span>, TimeUnit.MINUTES, </span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">1024</span>), threadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        pool.prestartAllCoreThreads();<span class="comment">//启动所有线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动后使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack pid</span><br></pre></td></tr></table></figure>

<p>验证截图如下</p>
<p><img src="http://f1.babyitellyou.com/sp1/img/20201206/8484f37a0899c7617f7fc4e9db310e82.png" alt="img"></p>
<h2 id="JVM线程状态与cpu关系"><a href="#JVM线程状态与cpu关系" class="headerlink" title="JVM线程状态与cpu关系"></a>JVM线程状态与cpu关系</h2><blockquote>
<p>NEW 这线程刚创建，还未执行, CPU=0%</p>
<p>RUNNABLE 线程处于可运行状态，但是实际可能是正在运行或者等待io资源，因此不能完全确定是否在使用cpu资源。 </p>
<p>BLOCKED 线程阻塞状态，肯定不会使用cpu资源 </p>
<p>WAITING 线程休眠状态，肯定不会使用cpu资源 </p>
<p>TIMED_WAITING 线程休眠状态，肯定不会使用cpu资源</p>
</blockquote>
<p>通过上面分析，在分析cpu100%问题时候，<code>jstack PID</code> 后，只需要查看dump结果中处于RUNNABLE状态的线程即可，但是处于RUNNABLE状态的线程，不代表就一定正在使用cpu资源，因此要特定分析（通过代码分析）。通常是通过top -Hp PID确定使用cpu资源高的线程后，再通过多次jstack操作，查看哪些线程堆栈一直处于RUNNABLE。</p>
<p>举例如下：</p>
<p>1.处于waiting，timed_waiting，blocked状态肯定不消化cpu，如下图，分析cpu时候忽略这些线程</p>
<p><img src="http://f1.babyitellyou.com/sp1/img/20201206/7cbd9e0e3d0429f3457a83cc93986736.png" alt="img"></p>
<p>2.比如下面这个，虽然处于RUNNABLE状态，实际上是阻塞在监听接入连接上（阻塞在网络IO上），因此实际是不使用cpu资源</p>
<p><img src="http://f1.babyitellyou.com/sp1/img/20201206/aac05a22a9f161e09ff13ccd498d4e3c.png" alt="img"></p>
<p>3.如下图这个，线程状态是RUNNABLE，这里是使用正则表达式解析，正在使用cpu资源</p>
<p><img src="http://f1.babyitellyou.com/sp1/img/20201206/ce38281f97a1a12abb4811f2b11f94d6.png" alt="img"></p>
<h2 id="JVM线程状态与锁的关系"><a href="#JVM线程状态与锁的关系" class="headerlink" title="JVM线程状态与锁的关系"></a>JVM线程状态与锁的关系</h2><p>sleep、wait、join都会使线程进入阻塞状态(waiting/timed_waiting状态)，同时也都会释放cpu资源</p>
<blockquote>
<p>yield是释放cpu资源，然后又抢夺cpu资源，目的是为了让其它线程有机会获取cpu资源进行处理，但是线程状态还是runnable。</p>
</blockquote>
<p>sleep如果是在锁方法内执行，比如同步代码块或者重入锁方法内执行，是不会释放锁。而wait会释放锁。</p>
<ul>
<li>wait用于锁机制，sleep不是，这也是为什么sleep不释放锁，wait释放锁的原因，</li>
<li>sleep是线程的方法，跟锁没关系，</li>
<li>wait，notify，notifyall 都是Object对象的方法，是一起使用的，用于锁机制。</li>
</ul>
<p>有个特殊的Thread.sleep(0)，操作这个动作是让出cpu，让其它线程又机会获取cpu资源执行</p>
<h3 id="wait-和sleep"><a href="#wait-和sleep" class="headerlink" title="wait()和sleep()"></a>wait()和sleep()</h3><p>前面synchronized关键字的用法讲完了，该轮到wait和sleep了。可能会有点好奇，为什么wait和sleep要一块讲？因为我一开始也搞不懂他们的区别，只知道wait()是Object类的实例方法，sleep()是Thread类的实例方法。作用都是使让代码停下来。</p>
<p>但后来研究了下，两者使用起来还是有一定的差别的。</p>
<p>首先，wait必须要在获得了当前对象的对象锁代码块中执行（可以理解为调用哪个对象的wait方法，调用的时候就要处于哪个对象的同步代码块中），而sleep则没有这个限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wait(); <span class="comment">//可以 没问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wait(); <span class="comment">//不可以，没有处于this的同步代码块中，抛出IllegalMonitorStateException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(其他对象) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait() <span class="comment">// 不可以，这里只获得了其他对象的锁，但是却调用了this的wait，抛出IllegalMonitorStateException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(其他对象) &#123;</span><br><span class="line">        其他对象.wait() <span class="comment">// 可以，没问题，不一定非得是this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也许你注意到了，wait()必须配合synchronized使用？为什么呢？那就是wait()有个很有意思的特性，<strong>执行wait()后的睡眠期间，会释放掉通过synchronized获得的锁，直到被唤醒的时候会重新获得锁</strong>，而sleep()会在线程睡眠期间依然持有这个锁，也就是说，在同步代码块中用wait()睡眠后，其他线程也能够获得对象的锁。</p>
<p>wait()的睡眠状态被notity()或notifyAll()唤醒时，不会抛出异常，sleep()导致的睡眠只能被interrupt()方法唤醒，同时sleep()会抛出异常，若interrupt()唤醒的是由wait()导致的睡眠，wait()同样会抛出异常。</p>
<p>同时，由于wait()会释放掉锁，因此一个对象中可能会同时存在多个线程由于wait()导致的睡眠</p>
<h3 id="notify-与notifyAll"><a href="#notify-与notifyAll" class="headerlink" title="notify()与notifyAll()"></a>notify()与notifyAll()</h3><p>notify()会将对象的一个线程从wait()导致的睡眠状态中唤醒，至于是哪个线程，则是随机的。</p>
<p>而notifyAll()则是唤醒对象所有由于wait()导致的睡眠。由于wait()被唤醒后会对对象加锁，如果没能拿到锁会暂时先阻塞着直到有机会拿到锁，因此依然是线程安全的。</p>
<h3 id="简易消息队列的实现"><a href="#简易消息队列的实现" class="headerlink" title="简易消息队列的实现"></a>简易消息队列的实现</h3><p>现在就利用上面的特性，实现一个简单的阻塞型消息队列吧。</p>
<p>消息队列是一个典型的消费者-生产者模型，当消费者消费时，若消息队列为空，则一直等待（阻塞执行），直到生产者生产了一个消息，此时消费者阻塞消除并获得一个消息</p>
<p>这里阻塞的关键是队列空时等待，非空时唤醒</p>
<p>消息队列类完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用锁实现的消息队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列关闭标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 使用链表作为消息容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg   消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取链表的锁之后，向链表添加消息，最后尝试唤醒链表对象（如果在等待的话）</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;消息队列已关闭&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(msg);</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭消息队列，并唤醒消费者的等待（如果在等待的话）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            stop = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费消息，若无消息将会一直阻塞，直到有消息或队列关闭，若消息队列已关闭则不再阻塞且返回null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 拿到的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取对象的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> queue.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stop &amp;&amp; queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 由于关闭队列也有可能退出上面的循环，所以要再判断一次长度</span></span><br><span class="line">                <span class="keyword">if</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> queue.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MessageQueue mq = <span class="keyword">new</span> MessageQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开1个线程消费消息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               String msg = mq.consume();</span><br><span class="line">               System.out.println(<span class="string">&quot;消费消息：&quot;</span> + msg);</span><br><span class="line">               <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;队列关闭&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            mq.product(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产消息：&quot;</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mq.stop();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行可以观察到每0.1秒生产一个消息，紧接着就被消费，最后程序退出 </p>
<h2 id="线程中断-1"><a href="#线程中断-1" class="headerlink" title="线程中断"></a>线程中断</h2><h3 id="3个中断相关的方法"><a href="#3个中断相关的方法" class="headerlink" title="3个中断相关的方法"></a>3个中断相关的方法</h3><p> 停止一个线程意味着在任务处理完任务之前停掉正在做的操作，也就是放弃当前的操作。</p>
<p>在java中有以下3种方法可以终止正在运行的线程：</p>
<ol>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li>
<li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</li>
<li>使用interrupt方法中断线程。</li>
</ol>
<h4 id="Method1-interrupt-中断线程-软中断"><a href="#Method1-interrupt-中断线程-软中断" class="headerlink" title="Method1: interrupt()中断线程(软中断)"></a>Method1: interrupt()中断线程(软中断)</h4><blockquote>
<p>Interrupts this thread.<br>Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.</p>
<p>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</p>
</blockquote>
<p>调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程，无法硬中断线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span>+(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：可以看到线程继续运行，并没有中断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">i&#x3D;499998</span><br><span class="line">i&#x3D;499999</span><br><span class="line">i&#x3D;500000</span><br></pre></td></tr></table></figure>

<h4 id="Method2-静态方法interrupted-判断当前线程是否中断状态"><a href="#Method2-静态方法interrupted-判断当前线程是否中断状态" class="headerlink" title="Method2: 静态方法interrupted()判断当前线程是否中断状态"></a>Method2: 静态方法interrupted()判断当前线程是否中断状态</h4><blockquote>
<p>Tests whether the current thread has been interrupted. <font color='red'>The interrupted status of the thread is cleared by this method. In other words, if this method were to be called twice in succession, the second call would return false</font>&gt; (unless the current thread were interrupted again, after the first call had cleared its interrupted status and before the second call had examined it).<br>A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.<br>Returns:<br>true if the current thread has been interrupted; false otherwise.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> interrupted&#123;</span><br><span class="line">	<span class="keyword">return</span> currentThread().isInterrputed(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interrupted(): 测试<font color='red'>当前线程</font>是否已经中断，线程的中断状态由该方法清除。 换句话说，如果连续两次调用该方法，则第二次调用返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;stop 1??&quot;</span> + thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">&quot;stop 2??&quot;</span> + thread.interrupted());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop 1??false</span><br><span class="line">stop 2??false</span><br></pre></td></tr></table></figure>

<p>类Run.java中虽然是在thread对象上调用以下代码：thread.interrupt(), 后面又使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;stop 1??&quot; + thread.interrupted());</span><br><span class="line">System.out.println(&quot;stop 2??&quot; + thread.interrupted());</span><br></pre></td></tr></table></figure>

<p>来判断thread对象所代表的线程是否停止，但从控制台打印的结果来看，线程并未停止，这也证明了interrupted()方法的解释，测试<a href="">当前线程</a>是否已经中断。这个当前线程是main主线程，它从未中断过，而是子线程thread中断了，所以打印的结果是两个false.</p>
<p>如何使main线程产生中断效果呢？就是把thread.interrupt改为main线程interrupt <!--Thread.currentThread()获取当前main线程--></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;stop 1??&quot;</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;stop 2??&quot;</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop 1??true</span><br><span class="line">stop 2??false</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p>方法interrupted()的确判断出当前线程是否是停止状态。</p>
<h4 id="Method3-isInterrupted-判断线程是否中断状态"><a href="#Method3-isInterrupted-判断线程是否中断状态" class="headerlink" title="Method3: isInterrupted()判断线程是否中断状态"></a>Method3: isInterrupted()判断线程是否中断状态</h4><blockquote>
<p>Tests whether this thread has been interrupted. <font color='red'>The interrupted status of the thread is unaffected by this method.</font><br>A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.<br>Returns:<br>true if this thread has been interrupted; false otherwise.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isInterrupted&#123;</span><br><span class="line">	<span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span></span><br></pre></td></tr></table></figure>

<p>isInterrupted()并<font color='red'>不清除中断状态</font>,所有连续2次调用并不清除中断状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;stop 1??&quot;</span> + thread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;stop 2??&quot;</span> + thread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop 1??true</span><br><span class="line">stop 2??true</span><br></pre></td></tr></table></figure>

<h3 id="捕获中断状态"><a href="#捕获中断状态" class="headerlink" title="捕获中断状态"></a>捕获中断状态</h3><h4 id="通过判断中断状态，抛出异常，停止线程"><a href="#通过判断中断状态，抛出异常，停止线程" class="headerlink" title="通过判断中断状态，抛出异常，停止线程"></a>通过判断中断状态，抛出异常，停止线程</h4><p>在线程中用for语句来判断一下线程是否是停止状态，如果是停止状态，则后面的代码不再运行即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程已经终止， for循环不再执行&quot;</span>);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span>+(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;这是for循环外面的语句，也会被执行&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入MyThread.java类中的catch了。。。&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>建议使用“抛异常”的方法来实现线程的停止，因为在catch块中还可以将异常向上抛，使线程停止事件得以传播。</p>
</blockquote>
<h4 id="通过捕获InterruptedException停止"><a href="#通过捕获InterruptedException停止" class="headerlink" title="通过捕获InterruptedException停止"></a>通过捕获InterruptedException停止</h4><p>如果线程在sleep()状态下停止线程，会是什么效果呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程开始。。。&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在沉睡中被停止, 进入catch， 调用isInterrupted()方法的结果是：&quot;</span> + <span class="keyword">this</span>.isInterrupted());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Run.java运行的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程开始。。。</span><br><span class="line">在沉睡中被停止, 进入catch， 调用isInterrupted()方法的结果是：false</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native Method)</span><br><span class="line"> at thread.MyThread.run(MyThread.java:12)</span><br></pre></td></tr></table></figure>

<p>从打印的结果来看， 如果在sleep状态下停止某一线程，会进入catch语句，并且清除停止状态值，使之变为false。</p>
<p>前一个实验是先sleep然后再用interrupt()停止，与之相反的操作在学习过程中也要注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程开始。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;先停止，再遇到sleep，进入catch异常&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i&#x3D;9998</span><br><span class="line">i&#x3D;9999</span><br><span class="line">先停止，再遇到sleep，进入catch异常</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native Method)</span><br><span class="line"> at thread.MyThread.run(MyThread.java:15)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/28/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F(stack-sorting)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/28/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F(stack-sorting)/" class="post-title-link" itemprop="url">堆排序(stack-sorting)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-28 10:59:50" itemprop="dateCreated datePublished" datetime="2021-05-28T10:59:50+08:00">2021-05-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-13 20:48:05" itemprop="dateModified" datetime="2021-06-13T20:48:05+08:00">2021-06-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
