<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/19/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/19/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">246</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/28/%E7%AE%97%E6%B3%95/leetcode/leetcode-%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/%E7%AE%97%E6%B3%95/leetcode/leetcode-%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">leetcode:如何规划刷题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-28 10:59:50" itemprop="dateCreated datePublished" datetime="2020-12-28T10:59:50+08:00">2020-12-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-03-26 01:25:06" itemprop="dateModified" datetime="2024-03-26T01:25:06+08:00">2024-03-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Sequence-or-substring"><a href="#Sequence-or-substring" class="headerlink" title="Sequence or substring"></a>Sequence or substring</h2><table>
<thead>
<tr>
<th>题目</th>
<th>相似题目</th>
<th>difficulty</th>
<th>space and time complexity</th>
</tr>
</thead>
<tbody><tr>
<td><del>5. Longest Palindromic Substring<br /></del></td>
<td></td>
<td>2</td>
<td>Palindromic pivot with expand</td>
</tr>
<tr>
<td>128.Longest Consecutive Sequence</td>
<td></td>
<td>2.5</td>
<td></td>
</tr>
<tr>
<td>300. Longest Increasing Subsequence(刷了3次)</td>
<td>516(刷了3次)、673（刷了2次）</td>
<td>2</td>
<td>dp, subproblem by sub-length<br />O(n^2)</td>
</tr>
<tr>
<td><del>647. Palindromic Substrings</del></td>
<td></td>
<td>2</td>
<td>Palindromic pivot with expand</td>
</tr>
<tr>
<td>1143. Longest Common Subsequence(刷了2次)</td>
<td></td>
<td>3.5</td>
<td>dp</td>
</tr>
<tr>
<td>1048. Longest String Chain</td>
<td></td>
<td>3</td>
<td>dp: S(n),  O(n^2)</td>
</tr>
<tr>
<td>1898. Maximum Number of Removable Characters</td>
<td></td>
<td>4.5</td>
<td>Binary search + 2pointers</td>
</tr>
<tr>
<td><del>1930. Unique Length-3 Palindromic Subsequences</del></td>
<td></td>
<td>2.5</td>
<td>Greedy</td>
</tr>
<tr>
<td>2207. Maximize Number of Subsequences in a String</td>
<td></td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>2407. Longest Increasing Subsequence II</td>
<td>307、315、406、699、1649、2179、2213、2407</td>
<td>5</td>
<td><strong><em>Segment Tree problem</em></strong>，O(n)</td>
</tr>
</tbody></table>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><table>
<thead>
<tr>
<th>题目</th>
<th>difficulty</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>3. Longest Substring Without Repeating Characters</td>
<td>3.5</td>
<td>Sliding Window</td>
</tr>
<tr>
<td>2401. Longest Nice Subarray</td>
<td>3.5</td>
<td>Sliding Window + bitwise</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><table>
<thead>
<tr>
<th>题目</th>
<th>相似题目</th>
<th>difficulty</th>
<th>Language</th>
<th>space and time complexity</th>
</tr>
</thead>
<tbody><tr>
<td>144. Binary Tree Preorder Traversal</td>
<td>145、589、590</td>
<td>3/5</td>
<td>Java</td>
<td>traversal by recursing</td>
</tr>
<tr>
<td>987</td>
<td><del>429</del>、1302</td>
<td>3/5</td>
<td>java</td>
<td>collect nodes</td>
</tr>
<tr>
<td>669. Trim a Binary Search Tree</td>
<td>1325</td>
<td>3.5/5</td>
<td></td>
<td>prune tree</td>
</tr>
<tr>
<td>112. Path Sum</td>
<td>437</td>
<td>3.5/5</td>
<td>Java</td>
<td>Path</td>
</tr>
<tr>
<td>236. Lowest Common Ancestor of a Binary Tree</td>
<td>235</td>
<td></td>
<td></td>
<td>postOrder</td>
</tr>
<tr>
<td>297</td>
<td>499</td>
<td>4/5</td>
<td>Java</td>
<td>constrcut tree</td>
</tr>
<tr>
<td>337</td>
<td>968,979</td>
<td>4.5/5</td>
<td>Java</td>
<td>Dp/memization</td>
</tr>
</tbody></table>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><table>
<thead>
<tr>
<th>题目</th>
<th>相似题目</th>
<th>difficulty</th>
<th>Language</th>
<th>space and time complexity</th>
</tr>
</thead>
<tbody><tr>
<td>133</td>
<td>138</td>
<td>3</td>
<td>Java</td>
<td>DFS: O(n + m)、T(n + m)、visitedMap/visitedSet<br />BFS: Queue+visitedMap</td>
</tr>
<tr>
<td>200</td>
<td>695、827</td>
<td>2</td>
<td></td>
<td>DFS + visitedMap</td>
</tr>
</tbody></table>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><table>
<thead>
<tr>
<th>题目</th>
<th>相似题目</th>
<th>difficulty</th>
<th>Language</th>
<th>space and time complexity</th>
</tr>
</thead>
<tbody><tr>
<td>4. Median of Two Sorted Arrays</td>
<td></td>
<td>3.5</td>
<td>Java\</td>
<td>binary search</td>
</tr>
<tr>
<td>433. Minimum Genetic Mutation</td>
<td></td>
<td>3</td>
<td></td>
<td>BFS</td>
</tr>
<tr>
<td>456. 132 Pattern</td>
<td></td>
<td></td>
<td></td>
<td>Balanced BFS<br /></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><table>
<thead>
<tr>
<th>题目</th>
<th>相似题目</th>
<th>difficulty</th>
<th>Language</th>
<th>space and time complexity</th>
</tr>
</thead>
<tbody><tr>
<td>133</td>
<td>138</td>
<td>3</td>
<td>Java</td>
<td>DFS: O(n + m)、T(n + m)、visitedMap/visitedSet<br />BFS: Queue+visitedMap</td>
</tr>
<tr>
<td>200</td>
<td>695、827</td>
<td>2</td>
<td></td>
<td>DFS + visitedMap</td>
</tr>
<tr>
<td><del>1061. Lexicographically Smallest Equivalent String</del></td>
<td>2477</td>
<td>3.5</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h2><table>
<thead>
<tr>
<th>题目</th>
<th>相似题目</th>
<th>difficulty</th>
<th>space and time complexity</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://zxi.mytechroad.com/blog/sliding-window/leetcode-2653-sliding-subarray-beauty/">2653. Sliding Subarray Beauty</a></td>
<td><a target="_blank" rel="noopener" href="https://zxi.mytechroad.com/blog/sliding-window/leetcode-2156-find-substring-with-given-hash-value/">LeetCode 2156. Find Substring With Given Hash Value</a></td>
<td>2.5</td>
<td></td>
</tr>
<tr>
<td>3090.  Maximum Length Substring With Two Occurrences</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/" class="post-title-link" itemprop="url">chapter6任务执行</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-25 14:35:00" itemprop="dateCreated datePublished" datetime="2020-12-25T14:35:00+08:00">2020-12-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-12-28 13:42:49" itemprop="dateModified" datetime="2021-12-28T13:42:49+08:00">2021-12-28</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>大多数并发应用程序都是围绕 <strong>任务执行（Task Execution）</strong>来进行构造的，<strong>任务</strong>通常是一些抽象的且离散的工作单元。<!--我们一直在说并发，但是巨人们已经总结了并发的使用场景和构造方法--></p>
<p>通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种<strong>「自然的事务边界」</strong>来优化错误的恢复过程，以及提供一种自然的<strong>「并行工作结构」</strong>来提升并发性。<!--有了使用场景和构造方法，如何解决构造过程中出现的问题，这里巨人们也给出了方案--></p>
<h3 id="在线程中执行任务"><a href="#在线程中执行任务" class="headerlink" title="在线程中执行任务"></a>在线程中执行任务</h3><p>当围绕 <strong>「任务执行」</strong> 来设计应用程序结构时，第一部就是要找出<strong>清晰</strong>的<strong>「任务边界」</strong>。在理想的情况下，各个任务之间是独立的：任务并不依赖于其他任务的状态，结果或边界效应。</p>
<p><strong>「独立性」</strong>有助于实现并发，如果存在足够多的「资源」，那么这些独立的任务都可以并行执行。为了在<strong>「调度」</strong>与<strong>「负载均衡」</strong>等过程中实现更高的<strong>「灵活性」</strong>,每项任务还表示应用程序的一小部分处理能力。</p>
<p>在<strong>「正常的负载」</strong>下，服务器应用程序应该同时表现出良好<strong>「吞吐量」</strong> 和 快速的 <strong>「响应性」</strong>。 应用程序提供商希望支持尽可能多的用户，而用户希望得到尽可能快的响应。当「负荷过载」时，应用程序的性能应该是逐渐降低，而不是直接失败。</p>
<p>要实现上述目标，应该选择清晰的<strong>「任务边界」</strong>以及明确的任务执行策略（<a target="_blank" rel="noopener" href="https://github.com/funnycoding/blog/issues/31">参见6.2.2 节</a>。）</p>
<p>大多数服务器应用程序都提供了一种自然的任务边界选择方式：以<strong>「独立的客户请求」</strong>为边界。</p>
<p>Web 服务器，邮件服务器，文件服务器，EJB 容器以及数据库服务器等，这些服务器都通过网络接受远程客户的连接请求。将<strong>「独立的请求」</strong>作为<strong>「任务边界」</strong>，既可以实现「任务的独立性」，又可以实现合理的「任务规模」。<!--非常巧妙的设计，即满足了并行工作结构的前提条件（任务边界），又尽量使用独立性有助于实现并发--></p>
<p>例如：在向邮件服务器提交一个消息后得到的结果，并不受其他正在处理的消息的影响，而且在处理单个消息时通常只需要服务器总处理能力的很小一部分。</p>
<h4 id="串行地执行任务"><a href="#串行地执行任务" class="headerlink" title="串行地执行任务"></a>串行地执行任务</h4><p>在应用程序中可以通过多种策略来调度任务，而其中一些策略能够更好地利用潜在的并发性。最简单的策略就是在单个线程中<strong>「串行」</strong>地执行各项任务。 <!--- 也就是不使用多线程技术，所有业务逻辑都在一个线程中完成 --></p>
<p><strong>程序清单 6-1</strong> 中的 <code>SingleThreadWebServer</code> 将串行地处理它的任务（通过 80 端口接收到的 HTTP 请求）。 至于如何处理任务的细节问题，在这里并不重要，我们感兴趣的是<strong>「如何表征不同调度策略的同步特性」</strong>。</p>
<blockquote>
<p>程序清单 6-1 串行的 Web 服务器：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 接收客户端的请求</span></span><br><span class="line">            Socket connection = socket.accept();</span><br><span class="line">            <span class="comment">// 以串行的形式处理请求,具体对请求做处理的逻辑，在这里我们不需要关心</span></span><br><span class="line">            handleRequest(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的，但执行性能却很糟糕，因为它「每次只能处理一个请求」。</p>
<p>主线程在「接受连接 <code>accept</code>」与处理相关请求 <code>handleRequest</code> 等操作之间不断地交替运行。当服务器正在处理请求时，新到来的连接必须等待直到服务器处理完成上一次的请求，然后服务器再次调用 <code>accpt</code>，来接受这一次请求。如果处理请求的速度很快，并且 <code>handleRequest</code> 可以立即返回，那么这种方法是可行的，但是现实世界中的 Web 服务器的情况却并非如此。</p>
<p>在 <strong>「Web请求的处理」</strong> 中包含了一组不同的运算与 I/O 操作。 服务器必须处理 套接字 I/O 以读取请求和写回响应，这些操作通常会由于 <strong>「网络拥塞」</strong> 或 <strong>「连接性问题」</strong>而被<strong>「阻塞」</strong>。 此外，服务器还可能处理 文件I/O 或者 数据库请求，这些操作同样会阻塞。 在单线程的服务器中，阻塞不仅会推迟当前请求的完成时间，而且还将彻底阻塞等待中的请求被处理。</p>
<ul>
<li><p>如果请求<strong>「阻塞」</strong>的时间过长，用户将任务服务器是不可用的，因为服务器看似失去了响应。</p>
</li>
<li><p>同时，服务器的<strong>「资源利用率」</strong> 非常低，因为当单线程在等待 I/O 操作完成时， CPU 将处于空闲状态。</p>
</li>
</ul>
<p>在服务器应用程序中，<strong>「串行处理机制」</strong>通常都无法提供「高吞吐率」<strong>或</strong>「快速响应性」。</p>
<!--【在某些情况中，串行处理方式能带来「简单性」和 「安全性」。大多数 GUI 框架都通过单一的线程来串行地处理任务。 第9章 将再次减少串行模型】-->

<h4 id="显示地为任务创建线程"><a href="#显示地为任务创建线程" class="headerlink" title="显示地为任务创建线程"></a>显示地为任务创建线程</h4><h5 id="a-通过无限制创建线程的方式"><a href="#a-通过无限制创建线程的方式" class="headerlink" title="a. 通过无限制创建线程的方式"></a>a. 通过无限制创建线程的方式</h5><p>通过为每个请求创建一个新的线程来提供服务，从而实现更高的响应性。</p>
<blockquote>
<p>程序清单6-2 在 Web服务器中为每个请求都启动一个新的线程<strong>（不要这么做）</strong>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = serverSocket.accept();</span><br><span class="line">            Runnable task = () -&gt; handleRequest(connection);</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadPerTaskWebServer</code> 在结构上类似之前的单线程版本 —— 主线程仍然不断地 交替执行 「接受外部链接」与 「分发请求」 这两个操作。 区别在于，对于每个连接，主循环都将创建一个新线程来处理请求，而不是在 「主循环」 中进行处理，由此可得到<strong>3个主要结论</strong>：</p>
<ul>
<li>任务处理过程从主线程中分离出来，到每个新创建的子线程中去，使得主循环能更快地重新等待下一个到来的连接，使得不必等待上一个连接处理完成就可以接受新的请求，提高了<strong>「响应性」</strong>。</li>
<li>任务可以<strong>「并行处理」</strong>，从而能同时服务多个请求。如果有「多个处理器」，或者由于某种原因被「阻塞」，例如 「等待I/O完成」，获取锁资源 或者资源可用性等，程序的吞吐量将得到提高。【也就是同时可以处理更多的任务】</li>
<li><strong><u>任务处理代码</u>，即handleRequest(connection), 必须是「线程安全」</strong>的，因为当有多个任务时，会并发地调用这段代码。<!--这块和前面4章的线程安全联系起来了--></li>
</ul>
<p>在「正常负载情况下」，「为每个任务分配一个线程」的方法能提升「串行执行」的性能。只要请求到达速率不超出服务器的请求处理能力，那么这种方法可以同时带来 <strong>「更快的响应性」</strong> 和 <strong>「更高的吞吐率」</strong>。</p>
<h5 id="b-无限制创建线程的不足"><a href="#b-无限制创建线程的不足" class="headerlink" title="b. 无限制创建线程的不足"></a>b. 无限制创建线程的不足</h5><p>可以想到，这样为每个请求都创建一个线程的方法肯定有诸多不妥，尤其是有大量请求时，那就需要创建大量的线程：</p>
<ul>
<li><strong>线程生命周期的开销非常高。</strong> 线程的创建与销毁并非没有代价，线程的创建过程都会需要「时间」，「延迟处理的请求」，并且需要 「JVM」 和 「操作系统」提供一些辅助操作。如果请求的到达率非常高且请求的处理过程是轻量级的，大多数服务器应用程序就是这种情况，那么为每个请求创建一个线程这种操作将消耗大量的计算资源。<!--极端情况，请求的处理速度handleRquest()比线程的创建销毁的速度都快，哈哈--></li>
<li><strong>资源消耗。</strong> 「活跃的线程」会消耗「系统资源」，尤其是内存。如果可运行的线程数量多于可用处理的数量，那么有些线程将「闲置」。大量的空余线程会占用许多「内存」，给「垃圾回收器」带来压力， 而且大量线程在竞争 CPU 资源时还将产生 「其他性能开销」。所以如果已经有足够多的线程使 CPU 保持忙碌状态，那么此时创建「更多的线程」反而会「降低」性能。<!--这里就用到了JVM的运行时数据区的知识了，虚拟机栈是线程私有的，不管线程是否运行，只要线程被创建了而且存在着，线程都会占着茅坑不拉屎，消耗内存--></li>
<li><strong>稳定性</strong>。 在「可创建线程」的数量上存在着一个限制。这个限制随着「平台」不同而不同，并且受多个因素制约，包括「JVM 的启动参数」，「<code>Thread</code>构造函数中请求的「栈」大小」，以及「底层系统」 对线程的限制等①。 如果破坏了这些限制，那么很可能抛出 <code>OutOfMemoryError</code>异常，要想从这种错误中恢复过来很危险，更好的方法是通过「构造程序」 避免超过这些限制。</li>
</ul>
<p>①【在 32位的机器上，其中一个主要的 <strong>「限制因素」</strong> 是 <strong>线程栈的 地址空间</strong>。 每个线程都维护 <strong>「两个」</strong> 线程栈，一个用于 <strong>「Java 代码」</strong>，另一个用于 <strong>「原生代码」</strong>。通常 JVM 在「默认情况」下会生成一个 <strong>「复合的栈」</strong>，大小约为 0.5MB (可以通过 JVM 标志 <code>-Xss</code> 或者通过 <code>Thread</code> 的构造函数来修改这个值。)如果将 2^32（32位系统下内存的最大值） 除以每个栈的大小<strong>，那么线程数量将被限制为 「几千」 到 「几万」</strong>。其他的一些因素，例如操作系统的限制等，则可能施加更加严格的约束。】</p>
<p><strong>在一定范围内，增加线程可以提高系统的吞吐率，当超过这个阈值，再创建更多的线程只会降低程序的执行速度，过多的创建线程，则会使整个应用程序崩溃。</strong></p>
<p>要想避免这种危险，就需要对程序可以创建的线程数量进行「限制」，并且全面地测试应用程序，从而确保达到线程最大限制数量时，程序也不会因「耗尽资源」而崩溃。</p>
<p>「为每个任务分配一个线程」 这种方法的问题在于”没有限制可创建线程的数量，只限制了远程用户提交 HTTP 请求的速率。”<!--划重点，这是主要原因，没有限制是多么可怕的事情，所以管理资源是多么重要的事情--> 与其他 「并发危险」 一样，在原型设计和开发阶段，无限制的创建线程或许还能正常运行，当到了应用程序部署后并处于高负载下运行时，才会有问题不断地暴露出来。某个恶意用户或者过多的用户同时访问，都会使 Web 服务器的负载达到阈值，从而崩溃。</p>
<p>如果服务器需要提供 高可用性，并且在<strong>「高负载」</strong>情况下<strong>「平缓地降低」</strong>性能，那么这将是一个严重的故障。</p>
<h3 id="任务执行框架：Executor-框架"><a href="#任务执行框架：Executor-框架" class="headerlink" title="任务执行框架：Executor 框架"></a>任务执行框架：Executor 框架</h3><p><strong>「任务」</strong>是一组<strong>「逻辑工作」</strong>单元，而线程则是使「任务」<strong>异步执行</strong>的机制。<!--看看巨人们总结的，任务和线程之间的关系--></p>
<p>之前已经分析过「两种」 通过线程来执行任务的策略：</p>
<ul>
<li>把所有任务在单个线程中串行执行。</li>
<li>将每个任务放在各自的线程中执行。</li>
</ul>
<p>上面这两种方式都存在一些严格的限制：<strong>「串行执行」</strong>的问题在于及其糟糕的响应性和吞吐量，而<strong>「为每个任务分配一个线程」</strong>的问题在于<strong>「资源管理的复杂性」</strong>。</p>
<p>第五章中，我们通过「有界队列」来防止高负荷的应用程序耗尽内存。 「线程池」简化了线程的管理工作，并且 <code>java.util.concurrent</code> 提供了一种灵活的线程池作为 <code>Executor</code>框架的一部分。</p>
<p>在 Java 类库中，<strong>任务执行</strong>的主要抽象不是 <code>Thread</code>，而是 <code>Executor</code>，如下面的程序所示：<!--小伙伴们，这里有个新概念，任务执行，千万要搞清楚 任务、线程、任务执行 这3者之间的关系--></p>
<blockquote>
<p>程序清单6-3 <code>Executor</code> 接口：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">  void execute (Runnable commoand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Executor</code>为灵活且强大的<strong>「异步任务执行框架」</strong>提供了基础，该框架能支持多种不同类型的任务<strong>「执行策略」</strong>。它提供了一种标准的方法将任务的<strong>「提交」</strong>与<strong>「执行」</strong>过程解耦，使用 <code>Runnbale</code>来表示任务。<!--提交与执行的解耦，为能够方便地修改执行策略打下了基础--></p>
<p><code>Executor</code>的实现还提供了对<strong>「生命周期」</strong>的支持，以及<strong>「统计信息收集」</strong>、<strong>「应用程序管理机制」</strong>和<strong>「性能监视」</strong>等机制。</p>
<p><code>Executor</code>基于<strong>「生产者—消费者」</strong>模式，<strong>提交任务的操作</strong>相当于<strong>「生产者」</strong>（生产待完成的工作单元），<strong>执行任务的线程</strong>则相当于 「消费者」（执行完这些工作单元）。</p>
<h4 id="6-2-1-示例：基于-Executor的Web服务器"><a href="#6-2-1-示例：基于-Executor的Web服务器" class="headerlink" title="6.2.1 示例：基于 Executor的Web服务器"></a>6.2.1 示例：基于 Executor的Web服务器</h4><p>基于 <code>Executor</code>构建 Web服务器 非常容易。</p>
<blockquote>
<p>程序清单 6-4 基于线程池的 <strong>Web服务器</strong>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutionWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N_THREADS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec = Executors.newFixedThreadPool(N_THREADS);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line">            Runnable task = () -&gt; handleRequest(connection);</span><br><span class="line">            exec.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>TaskExecutionWebServer</code>中，通过使用 <code>Executor</code> 将请求处理任务的「提交」 与任务的实际 「执行」 解耦开，并且只需要采用另一种不同的 <code>Executor</code> 实现，就可以改变服务器的行为。 改变 <code>Executor</code> 实现或配置所带来的影响要远远小于改变「任务提交方式」所带来的影响。</p>
<p>通常，<code>Executor</code>的配置是一次性的，因此在部署阶段可以完成，而提交任务的代码却会不断地「扩散」到整个程序，增加了修改的难度。</p>
<p>我们可以很容易地将 <code>TaskExecutionWebServer</code>修改为类似 <code>ThreadPerTaskWebServer</code> 的行为，只需要使用为每个请求都创建新线程的线程池，编写这样的 <code>Executor</code>也很简单，如下所示：</p>
<blockquote>
<p>程序清单6-5 为每个请求启动一个新线程的 <code>Executor</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为每个请求都创建一个线程的 Executor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，还可以编写一个 <code>Executor</code>使 <code>TaskExecutionWebServer</code>的行为类似于单线程程序的行为 —— 以「同步」 的方式执行每个任务，然后再返回，如下所示：</p>
<blockquote>
<p>程序清单6-6 在调用线程中以同步方式执行所有任务的 <code>Executor</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让线程池以单线程的串行形式执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithinThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-执行策略"><a href="#6-2-2-执行策略" class="headerlink" title="6.2.2 执行策略"></a>6.2.2 执行策略</h4><p>通过将任务的「提交」与 「执行」 解耦，从而无需太大的困难就可以为某种类型的任务指定和修改执行策略。<!--这就是把提交与执行解耦的一个原因--></p>
<p>在执行策略中定义了任务执行的<strong>「What」</strong>、<strong>「Where」</strong>、<strong>「When」</strong>、<strong>「How」</strong>等方面，具体意义如下：</p>
<ul>
<li>在什么（What）线程中执行任务？</li>
<li>任务按照什么（What）顺序执行（FIFO、LIFO、优先级）？</li>
<li>有多少个（How Many）任务能「并发」执行？</li>
<li>在队列中有多少个（How Many）任务在等待执行？</li>
<li>如果系统由于「过载」而需要拒绝一个任务，那么应该选择哪一个（Which）任务？另外，如何（How）通知应用程序有任务被拒绝？</li>
<li>在执行一个任务之前或之后，应该进行哪些（What）动作？</li>
</ul>
<p>各种<strong>「执行策略」</strong>都是一种<strong>「资源管理工具」</strong>，最佳策略取决于<strong>「可用的计算资源」</strong>以及<strong>「服务质量的需求」</strong>。</p>
<p>通过<strong>「限制并发任务的数量」</strong>，可以确保应用程序不会由于<strong>「资源耗尽」</strong>而失败，或者由于在稀缺资源上发生竞争而严重影响性能。</p>
<p>通过将任务的提交与执行的策略分离开，有助于在<strong>「部署阶段」</strong>选择与「<strong>可用硬件资源」</strong>最匹配的执行策略。</p>
<blockquote>
<p>每当看到下面这种形式的代码时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Thread(runnable).start()</span><br></pre></td></tr></table></figure>

<p>如果你希望获得一种更灵活的执行策略时，请考虑使用 <code>Executor</code>来代替直接使用 <code>Thread</code>。</p>
</blockquote>
<!--看看大师们的开发经验，非常实际的应用-->

<h4 id="6-2-3-线程池"><a href="#6-2-3-线程池" class="headerlink" title="6.2.3 线程池"></a>6.2.3 线程池</h4><p><strong>「线程池」</strong>指管理一组<strong>「同构」</strong>工作线程的资源池。线程池与<strong>「工作队列（Work Queue)」</strong>关系密切。<!--大意了啊，不要忘记线程池和工作队列可是息息相关的--></p>
<p>在「工作队列」中保存了所有等待执行的任务。<strong>「工作者线程（Work Thread）」</strong>的任务很简单：从<strong>「工作队列」</strong>中获取一个任务，执行任务，然后返回线程池并等待下一个任务。</p>
<p>“在线程池中执行任务”与比”为每个任务分配一个线程”有众多优势。首先重用线程而不是创建新线程，可以在处理多个请求时「分摊」线程创建和销毁过程中的巨大开销。另外当用户请求到达时，线程已经被创建好，因此省去了等待线程创建的时间，提高了「响应性」。</p>
<p>通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌姿态，同时还可以「防止过多」线程相互竞争资源而使应用程序「耗尽内存」或「失败」。</p>
<p>类库提供了一个灵活的线程池以及一些有用的「默认配置」。可以通过 Executors 中的静态工厂方法之一来创建一个线程池，下面是不同的线程池类型：</p>
<ul>
<li><code>newFixedThreadPool</code>，创建一个固定长度的线程池，每提交一个任务该线程池中就创建一个线程，直到达到线程池「最大数量」。这时线程池的规模将不再变化（如果有线程在执行时遇到「未预期」的 <code>Exception</code>而结束，那么线程池会补充一个新的线程） &lt;—【也就是对于意外减员的应对情况】</li>
<li><code>newCachedThreadPool</code>，创建了一个「可缓存」的线程池，如果线程池的当前规模超过了处理器的需求，那么将「回收」空闲的线程，而当需求增加时，则可以添加新的线程，该线程池的规模不存在任何限制。</li>
<li><code>newSingleThreadExecutor</code>，一个单线程的线程池，它创建单个工作线程来执行任务，如果这个线程「异常结束」，会创建另一个线程进行代替。<code>newSingleThreadExecutor</code>能确保依照任务在队列中的顺序来「串行」执行（例如FIFO，LIFO，优先级） <!--单线程的 `Executor`提供了大量的「内部」同步机制，从而确保了任务执行的任何内存写入操作对于后续任务来说都是「可见」的。这意味着，即使这个线程会时不时被「另一个线程替代」，但对象总是可以「安全」地「封闭」在「任务线程」 中。--></li>
<li><code>newScheduledThreadPool</code>，创建了一个固定长度的线程池，而且以「延迟」或定时的方式来执行任务，类似于 <code>Timer</code>。</li>
</ul>
<p><code>newFixedThreadPool</code> 和 <code>newCachedThreadPool</code> 这两个工厂方法返回「通用」 的 <code>ThreadPoolExecutor</code> 实例，这些实例可以直接用来构造专门用途的 <code>executor</code>。 将在 第8章 中深入讨论「线程池的各个配置选项」。</p>
<p><code>TaskExecutionWebService</code> 中的 Web服务器使用了一个带有 有界线程池 的 <code>Executor</code>。通过 <code>execute</code> 方法将任务提交到工作队列中，工作线程反复地从工作队列汇总取出并执行它们。</p>
<h4 id="6-2-4-Executor-的生命周期"><a href="#6-2-4-Executor-的生命周期" class="headerlink" title="6.2.4 Executor 的生命周期"></a>6.2.4 Executor 的生命周期</h4><p>之前已经说了如何「创建」一个 <code>Executor</code>，但是没有讨论如何关闭它。 <code>Executor</code> 的实现通常会创建线程来执行任务，但 <code>JVM</code> 只有在所有（非守护）线程全部终止之后才会退出。</p>
<p><strong>「因此，如果无法正确地关闭 <code>Executor</code>，那么 <code>JVM</code> 将无法结束。」</strong> <!--所以关闭任务执行框架非常的重要--></p>
<p>由于 <code>Executor</code>以 「异步」 方式来执行任务，因此在任何时刻，之前提交任务的状态不是「立即可见」的。有些任务可能已经完成，有些可能正在运行，而其他的任务可能在队列中等待执行。</p>
<p>当关闭应用程序时，可能使用的是「最平缓」的关闭形式（完成所有已经启动的任务，并且不再接受「任何形式」 的新任务），也可能采用的是「最粗暴」的关闭形式 —— 直接关掉机房的电源，以及其他各种可能的形式。</p>
<p>既然 <code>Executor</code>是为应用程序提供服务的，所以它们也是可关闭的（无论是采用平缓的还是粗暴的方式），并将在关闭操作中「受影响的任务」的状态反馈给「应用程序」。</p>
<p>为了解决 任务执行框架 <code>Executor</code> 的生命周期问题，<code>ExecutorService</code>扩展了 <code>Executor</code> 接口，添加了一些用于「管理」 生命周期的方法（还有一些用于提交任务的便利方法），具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line">    void shutdown();</span><br><span class="line">    List&lt;Runnable&gt; shutdownNow();</span><br><span class="line">    boolean isShutdown();</span><br><span class="line">    boolean isTerminated();</span><br><span class="line">    boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">		</span><br><span class="line">  &#x2F;&#x2F; ... 其他用于任务提交的便利方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Executor</code> 的<strong>「生命周期」</strong> 有3种状态：运行、关闭和已终止。</p>
<p><code>ExecutorService</code>在初始创建时处于「运行」状态。</p>
<p><code>shutdown</code>方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括那些「还未开始执行」的任务。</p>
<p><code>shutdownNow</code>方法则是粗暴的关闭过程：它将尝试「取消」所有「运行中的」任务，并且不再启动队列中尚未开始执行的任务。</p>
<p>在 <code>ExecutorService</code> 关闭后提交的任务将由 “拒绝执行处理器”（Rejected Execution Handler）处理，它会「抛弃」任务，或者使得 <code>execute</code>方法抛出一个未检查的 <code>RejectedExcutionException</code> 。等所有任务都完成后，<code>ExecutorService</code>将转入终止状态。可以调用 <code>awaitTermination</code> 来等待 <code>ExecutorService</code>到达终止状态，或者调用 <code>isTerminated</code> 来 「轮询」 <code>ExecutorService</code> 是否已经终止。</p>
<p>通常在调用 <code>awaitTermination</code> 之后会立即调用 <code>shutdown</code>，从而产生「同步地关闭」 <code>ExecutorService</code> 的效果。（第7章 将进一步介绍 Executor 的关闭和任务取消方面的内容）</p>
<p>程序清单 6-8 的 <code>LifecycleWebServer</code> 通过增加生命周期支持来 「扩展」 Web服务器的功能。 可以通过两种方法来关闭 Web 服务器：</p>
<ul>
<li>在程序中调用 <code>stop</code></li>
<li>以客户端请求的形式向 Web服务器 发送一个特定格式的 HTTP 请求</li>
</ul>
<blockquote>
<p>程序清单 6-8 支持关闭操作的 Web 服务器：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持关闭操作的 Web 服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="comment">// 只要任务执行框架没有被通知关闭，则一直执行主循环，同时可能因为 ExecutorService 被关闭抛出 拒绝异常，此时需要对异常进行处理</span></span><br><span class="line">        <span class="keyword">while</span> (!exec.isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Socket conn = socket.accept();</span><br><span class="line">                exec.execute(() -&gt; handleRequest(conn));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!exec.isShutdown()) &#123;</span><br><span class="line">                    log(<span class="string">&quot;task submission reject&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对连接进行业务处理，首先判断封装的程序是否处于关闭状态，如果是，则调用 ExecutorService 的shutdown() 方法，否则进行任务分发</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span> </span>&#123;</span><br><span class="line">        Request req = readRequest(connection);</span><br><span class="line">        <span class="keyword">if</span> (isShutdownRequest(req)) &#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dispatchRequest(req);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isShutdownRequest</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-5-示例：延迟任务与周期任务"><a href="#6-2-5-示例：延迟任务与周期任务" class="headerlink" title="6.2.5 示例：延迟任务与周期任务"></a>6.2.5 示例：延迟任务与周期任务</h4><p><code>Timer</code> 类负责管理延迟任务（例如在 100ms 后执行的任务）以及周期任务（”以每 10ms 执行一次的任务”）。</p>
<p>然而 <code>Timer</code> 存在一些缺陷，因此应该考虑使用 <code>ScheduledThreadPoolExecutor</code> 来代替它。（<code>Timer</code>支持的是基于「绝对时间」的调度机制，因此任务的执行对「系统时钟」的变化很敏感，而 <code>ScheduledThreadPool</code> 只支持基于相对时间的调度）。</p>
<p>可以通过 <code>ScheduledThreadPoolExecutor</code> 的构造函数或 <code>newScheduledThreadPool</code> 工厂方法来创建该类的对象。</p>
<p><code>Timer</code> 在执行「所有定时任务」时只会创建一个线程。如果某个线程执行时间过长，那么将<strong>「破坏」</strong>其他 <code>TimerTask</code> 的<strong>「定时精确性」</strong>。<!--单线程。。。。Timer的设计师怎么想的。。。--></p>
<p>例如某个周期 TimerTask 需要 每 10ms 执行一次，而另一个 TimerTask 需要执行 40ms，那么这个周期任务或者在 40ms 任务执行完成后快速连续地调用 4次，或者彻底「丢失」4次调用（取决于它是基于<strong>「固定速率」</strong>还是基于<strong>「固定延迟」来</strong>进行调度）。线程池能弥补这个缺陷，它可以提供「多个线程」来执行 延时任务 和 周期任务。</p>
<p><code>Timer</code> 的另一个问题是：如果 <code>TimerTask</code> 抛出了一个「未检查的异常」，那么 <code>Timer</code> 将表现出糟糕的行为。</p>
<p><code>Timer</code>线程并不捕获异常，因此当 <code>TimerTask</code> 抛出未检查异常时将 「终止」 定时线程。 这种情况下 <code>Timer</code> 不会恢复线程的执行，而是会「错误地」 认为整个 Timer 都被取消了。<!--坑爹，抛出未受检查的异常。。。。，找事情啊--></p>
<p>因此「已经调度」但「尚未执行」的 <code>TimerTask</code> 将不会再执行，而新的任务也不能被调度（这个问题称为「线程泄漏」）</p>
<p>在 <strong>程序清单6-9</strong> 的 <code>OutOfTime</code> 中给出了 <code>Timer</code> 为什么出现这种问题的原因，以及如何使得试图提交 <code>TimerTask</code> 的调用者也出现问题。 你可能认为程序会运行6秒后退出，但实际情况是运行1秒就结束了，并抛出一个异常消息 —— “Timer already cancelled”。</p>
<p><code>ScheduledThreadPoolExector</code> 能正确处理这些表现出错误的行为的任务，在 <code>Java5.0</code> 或更高的 <code>JDK</code>中，很少使用 <code>Timer</code>。</p>
<p>如果要构建自己的「调度服务」，可以使用 <code>DelayQueue</code>，它实现了 <code>BlockingQueue</code> 并为 <code>SCheduledThreadPoolExecutor</code> 提供 「调度」 功能。</p>
<p><code>DelayQueue</code> 管理着一组 <code>Delayed</code> 对象。每个 <code>Delayed</code> 对象都有一个相应的延迟时间：在 <code>DelayQueue</code> 中，只有某个元素「逾期」后，才能从 <code>DelayQueue</code> 中执行 <code>take</code> 操作，从 <code>DelayQueue</code> 中返回的对象将根据它们的 「延迟时间」 进行排序。</p>
<h3 id="找出可利用的并行性"><a href="#找出可利用的并行性" class="headerlink" title="找出可利用的并行性"></a>找出可利用的并行性</h3><p><code>Executor</code> 框架使确定执行策略更加容易，但如果要使用 <code>Executor</code>，必须将任务表述为一个 <code>Runnable</code>。在大多数服务器应用程序中都存在一个「明显的任务边界」：单个用户请求。</p>
<p>但有时候，任务边界并非是显而易见的，例如在很多「桌面应用程序中」。即使是 「服务器应用程序」，在单个客户请求中可能存在可发掘的「并行性」，例如 「数据库服务器」。</p>
<blockquote>
<p>程序清单 6-9 错误的 <code>Timer</code> 行为：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Timer 因抛出异常错误结束的情景</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfTime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">// 执行到这里时 Timer因为抛出了 未预料的异常，之后的代码也无法继续进行了</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> ThrowTask(),<span class="number">1</span>);</span><br><span class="line">        SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> ThrowTask(),<span class="number">1</span>);</span><br><span class="line">        SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这一节中将开发一些「不同版本」 的组件，并且每个版本都实现了「不同程度」的并发性。</p>
<p>该示例组件实现浏览器程序中的 页面渲染（Page-Rendering）功能，它的作用是将 HTML 页面绘制到图像缓存中。为了简便，假设 HTML 页面只包含「标签文本」，以及预定义大小的「图片」和 URL。</p>
<h4 id="示例1：渲染文本、下载、渲染页面都是串行"><a href="#示例1：渲染文本、下载、渲染页面都是串行" class="headerlink" title="示例1：渲染文本、下载、渲染页面都是串行"></a>示例1：渲染文本、下载、渲染页面都是串行</h4><p>最简单的方法就是对 <code>HTML</code> 文档进行「串行处理」。当遇到文本标签时，将其绘制到「图像缓存」中。 当遇到图像引用时，先通过网络获取它，然后再将其绘制到图像缓存中。</p>
<p>优点是这种方法非常简单：程序只需要将输入中的每个元素处理一次（甚至不需要缓存文档），<strong>但这种方法会让用户等待很长的时间</strong>，因为获取图片可能需要的时间很久，他们必须一直等待，直到显示所有文本。</p>
<p>另一种「串行」执行的方法更好一些，它先绘制文本元素，同时为图像预留出矩形的占位空间，在处理完了第一遍文本后，程序再开始下载图像，并将他们绘制到相应的占位空间中。</p>
<blockquote>
<p>—&gt;renderText(source)   —&gt; 下载图片1 —&gt; 下载图片2  …….—&gt; 下载图片n —&gt; renderImage(图片)</p>
</blockquote>
<p>在 <strong>程序清单 6-10</strong> 的 <code>SingleThreadRenderer</code>中给出了上述这种方法的实现。<br>程序清单 6-10 串行地渲染页面元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行渲染页面元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadRenderer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先渲染文字</span></span><br><span class="line">        renderText(source);</span><br><span class="line">        <span class="comment">// 定义页面图像引用</span></span><br><span class="line">        List&lt;ImageData&gt; imageData = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 通过source分析出其包含的图像信息 并将其添加到之前定义的 imageData 中</span></span><br><span class="line">        <span class="keyword">for</span> (ImageInfo imageInfo : scanForImageInfo(source)) &#123;</span><br><span class="line">            imageData.add(imageInfo.downloadImage() <span class="comment">//网络IO阻塞);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 渲染页面图片</span></span><br><span class="line">        <span class="keyword">for</span> (ImageData data : imageData) &#123;</span><br><span class="line">            renderImage(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点：</strong></p>
<blockquote>
<p>图像下载过程的大部分时间都是在 「等待 I/O」 操作执行完成。 在这期间 CPU 几乎没有任何工作。</p>
<p>因此，这种串行执行方法没有充分地利用 CPU，使得用户看到最终页面之前要等待过长的时间。</p>
<p>通过将问题「分解」为多个独立的任务「并发执行」，能够获得更高的 「CPU 利用率」和「响应灵敏度」。</p>
</blockquote>
<h4 id="携带结果的任务-Callable-与Future"><a href="#携带结果的任务-Callable-与Future" class="headerlink" title="携带结果的任务 Callable 与Future"></a>携带结果的任务 Callable 与Future</h4><p><code>Executor</code> 框架使用 <code>Runnable</code> 作为其「基本的任务表示形式」。 <code>Runnable</code> 是一种有很大局限性的抽象，虽然 <code>run</code> 能写入到日志文件或者将结果放入某个 「共享的数据结构」，但它<strong>不能</strong> 「返回一个值」 或 「抛出一个受检查的异常」。</p>
<p>许多任务实际上都是存在「延迟计算」这种情况的，例如「执行数据库查询」，「从网络上获取资源」，或者计算某个复杂的功能。</p>
<p>对于上述类型的任务 <code>Callable</code>是一种更好的抽象：它认为主入口点 <code>call</code> 方法将返回一个值，并可能「抛出一个异常」。（要使用 <code>Callable</code> 来表示一个无返回值的任务，可使用 <code>Callable&lt;Void&gt;</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent/Callable.java</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Executor</code> 中包含了一些「辅助方法」能将其他类型的任务「封装」为一个<code>Callable</code>，例如 <code>Runnable</code> 和 <code>java.security.PrivilegedAction</code>。</p>
<p><code>Runnable</code> 和 <code>Callable</code> 描述的都是「抽象的计算任务」。 这些任务通常是「有范围」的 —— 都有一个明确的起始点，并且最终会结束。</p>
<p><code>Executor</code> 执行的任务有 4 个生命周期阶段：<strong>「创建、提交、开始、完成」</strong>。</p>
<p>由于有些任务可能执行时间很长，因此通常希望能够取消这些任务。 在 <code>Executor</code> 框架中，已提交但尚未开始的任务可以取消，但是对于那些<strong>「已经开始」</strong>的任务，只有当它们能<strong>「响应」</strong>中断操作时，才能取消。取消一个已经「完成」的任务不会有任何影响（第7章将进一步介绍取消操作）。</p>
<p><code>Future</code> 表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及「获取任务的结果」和「取消任务」等。 在 <strong>程序清单 6-11</strong> 中给出了 <code>Callable</code> 和 <code>Future</code>。<!--Callable与Future各自的作用一定要清楚，Callable是被提交给Executor的任务单元；Future是Executor获取Callable以后，Callable对应的生命周期--></p>
<p><code>Future</code> 规范中包含的<strong>「隐含意义」</strong> 是：任务的生命周期「只能前进」，不能后退，就像 <code>ExecutorService</code> 的生命周期一样，当某个任务完成后，它就只能永远停留在「完成」状态上。<!--生命周期只能前进，合理！！！--></p>
<p><code>get</code>方法的行为「取决于任务的状态」（尚未开始、正在运行、已完成）。 </p>
<ul>
<li>如果任务已经完成，那么 <code>get</code> 会立即返回或者抛出一个 <code>Exception</code> ，</li>
<li>如果任务没有完成，那么 <code>get</code> 将阻塞并直到任务完成。</li>
<li>如果任务抛出了异常，那么 <code>get</code> 将该异常封装为 <code>ExecutionException</code>并重新抛出。 </li>
<li>如果任务被取消，那么 <code>get</code> 将抛出 <code>CancellationException</code>。如果 <code>get</code> 抛出了 <code>ExecutionException</code>，那么可以通过 <code>getCause</code> 来获得被封装的「初始异常」。</li>
</ul>
<blockquote>
<p><strong>程序清单 6-11</strong> <code>Callable</code> 与 <code>Future</code> 接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过许多方法创建一个 <code>Future</code> 来 「描述」 任务。 <code>ExecutorService</code> 中的所有 <code>submit</code> 方法都将返回一个 <code>Future</code>，从而将一个 <code>Runnable</code> 或 <code>Callable</code> 提交给 <code>Executor</code>，并得到一个 <code>Future</code> 用来获得任务的执行结果或者取消任务。</p>
<p>还可以显式地位某个指定的 <code>Runnable</code> 或 <code>Callable</code> 实例化一个 <code>FutureTask</code>。（由于 <code>FutureTask</code> 实现了<code>Runnable</code> ，因此可以将它提交给 <code>Executor</code> 来执行，或者直接调用它的 <code>run</code> 方法）</p>
<p>从 <code>Java6</code> 开始，<code>ExecutorService</code> 的实现可以改写为 <code>AbstractExecutorService</code> 中的 <code>newTaskFor</code>方法，从而根据已提交的 <code>Runnable</code> 或 <code>Callable</code> 来控制 <code>Future</code>的「实例化过程」。</p>
<p>在默认实现中仅创建了一个新的 <code>FutureTask</code> 如下所示：</p>
<blockquote>
<p>程序清单 6-12 <code>ThreadPoolExecutor</code> 中的 <code>newTaskFor</code> <strong>的默认实现</strong>：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;</span><br><span class="line">    return new FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--实际上 `newTaskFor` 这个方法不再 `ThreadPoolExecutor.java` 中，而是在 ``AbstractExecutorService.java`中，但是 `ThreadPoolExecutor` 继承 该类，说是默认实现也没问题。-->

<p>将 <code>Runnable</code> 或 <code>Callbale</code> 提交到 <code>Executor</code> 的过程中，包含了一个 「安全发布」的过程（参见3.5） —— 将 <code>Runnable</code> 或 <code>Callable</code> 从「提交线程」 发布到最终 「执行任务的线程」。 类似地，在设置 <code>Future</code> 结果的过程中也包含了一个安全发布，将这个结果从计算它的线程发布到任何通过 <code>get</code> 获得它的线程。</p>
<h4 id="示例2：-使用-Future-实现下载图片和渲染文本并行"><a href="#示例2：-使用-Future-实现下载图片和渲染文本并行" class="headerlink" title="示例2： 使用 Future 实现下载图片和渲染文本并行"></a>示例2： 使用 Future 实现下载图片和渲染文本并行</h4><p>为了使页面渲染器实现更高的「并发性」，我们将渲染过程分解为「两个任务」：</p>
<ul>
<li>渲染所有文本 （CPU密集型）</li>
<li>下载所有的图像 （I/O 密集型）</li>
</ul>
<p>这样将 CPU密集型 和 I/O 密集型的任务分解开，即使在单 CPU 系统上也能提升性能。</p>
<p><code>Callable</code> 和 <code>Future</code> 有助于表示这些协同任务之间的交互，在 <strong>程序清单 6-13</strong> 的 <code>Future Renderer</code> 中创建了一个 <code>Callable</code> 来下载所有的图像，并将其提交到一个 <code>ExecutorService</code>。 这将返回一个 「描述任务执行情况」的 <code>Future</code>。 当主任务需要图像时，它会等待 <code>Future.get</code> 的调用结果。</p>
<p>如果幸运的话，当开始请求时所有图像就已经下载完成了，即使没有，下载图像的任务也已经提前开始了。</p>
<blockquote>
<p>—&gt; renderText(source)   </p>
<p>—&gt; 下载图片1 —&gt; 下载图片2 … —&gt; 下载图片n   —&gt; renderImage(图片)</p>
</blockquote>
<blockquote>
<p>程序清单 6-13 使用 <code>Future</code> 等待图像下载：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Future 等待下载图像任务的完成</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureRenderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class="line">        <span class="comment">// 创建一个 Callable 开启一个线程专门下载图片；直到所有图片IO下载完成，这个任务结束</span></span><br><span class="line">        Callable&lt;List&lt;ImageData&gt;&gt; task = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;ImageData&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ImageInfo imageInfo : imageInfos) &#123;</span><br><span class="line">                result.add(imageInfo.downloadImage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 提交这个 Callable 到 Executor 中，获得一个返回的 Future</span></span><br><span class="line">        <span class="keyword">final</span> Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染文字</span></span><br><span class="line">        renderText(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始获取下载图片的结果</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;ImageData&gt; imageData = future.get();</span><br><span class="line">            <span class="comment">// 渲染图片</span></span><br><span class="line">            imageData.forEach(<span class="keyword">this</span>::renderImage);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 重新声明线程的中断状态</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="comment">// 此时这个 Future 的结果已经不需要了，所以关闭这个任务</span></span><br><span class="line">            future.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> LaunderThrowable.launderThrowable(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get</code> 方法拥有 「状态依赖」 的内在特性，因而调用者不需要知道任务的状态，此外在任务 「提交」 和 「获得结果」 中包含的安全发布属性也确保了这个方法是 「线程安全」的。</p>
<p><code>Future.get</code> 的异常处理代码将处理两个可能的问题：</p>
<ul>
<li>任务遇到了一个 Exception</li>
<li>或者调用 <code>get</code> 的线程在获得结果之前被中断（参见 5.5.2 和 5.4 节）</li>
</ul>
<p><code>FutureRenderer</code> 使得渲染文本任务与下载图像数据的任务「并发」 地执行。 当所有图像下载完成后，会显示到页面上。 这将提升「用户体验」，不仅使用户更快地看到结果，还有效地利用了「并行性」，但我们还可以做的更好：<strong>「用户不必等待所有图像都下载完成，而是希望每下载完成一个就显示出一个」</strong>。</p>
<h4 id="讨论：在异构任务并行化中存在的局限"><a href="#讨论：在异构任务并行化中存在的局限" class="headerlink" title="讨论：在异构任务并行化中存在的局限"></a>讨论：在异构任务并行化中存在的局限</h4><p>上个例子中，我们尝试并行地执行两个<strong>「不同类型」</strong>的任务 —— 「下载图像」与 「渲染页面」。然而，通过对 <strong>「异构任务」</strong> 进行并行化来获得重大的性能提升是很困难的。<!--异构，这个词语，记住了啊--></p>
<p>如果工作类型相同，比如都是洗完，那么两个人可以很好地分摊工作，一个负责清洗，一个负责烘干，增加人手可以直接提升工作效率。然而，如果将「不同类型的任务」 平均分配给每个工人却并不容易。</p>
<p>当人数增加时，如果没有在「相似」 的任务之间找出细粒度的「并行性」，那么这种方法带来的好处将减少。</p>
<p>当在多个工人之间分配「异构」 任务时，还有一个问题就是各个任务的「大小」可能完全不同。</p>
<p>如果将两个任务 A 和 B 分配给两个工人，但是「 A 的执行时间是 B 的10倍。」，那么整个过程也只能加速 <strong>9%</strong></p>
<p>当在多个工人之间分解任务时，还需要一定的任务协调开销：「为了使任务分解能提高性能，这种开销不能高于并行性实现的提升。」</p>
<p><code>FutureRenderer</code> 使用了两个任务，其中一个负责<strong>「渲染文本」</strong>，另一个负责<strong>「下载图像」</strong>。 如果渲染文本的速度远高于下载图像的速度（这个可能性很大），那么程序的最终性能与串行执行时的性能差别不大（因为需要等待 下载图像，而渲染文本的耗时可以忽略不计，所以和串行执行几乎差不多），而并行执行任务的代码却更复杂了。因此，虽然做了许多工作来并发执行「异构任务」 以提高并发度，但从中获得的 「并发性」 却十分有限。 （在 11.4.2 节 和 11.4.3节） 中的示例说明了同一个问题。</p>
<p>只有当大量「相互独立」 且 「同构」（相同类型工作）的任务可以进行并发处理时，才能体现出将程序的工作负载分配到「多个任务」 中带来的真正性能提升。</p>
<h4 id="任务完成框架：CompletionService：Executor-与-BlockingQueue"><a href="#任务完成框架：CompletionService：Executor-与-BlockingQueue" class="headerlink" title="任务完成框架：CompletionService：Executor 与 BlockingQueue"></a>任务完成框架：CompletionService：Executor 与 BlockingQueue</h4><p>如果向 <code>Executor</code> 提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与任务关联的 <code>Future</code>，然后反复使用 <code>get</code>方法，同时将参数 <code>timeout</code> 指定为 0 <!--立即查看任务状态-->，从而通过轮询来判断任务是否完成，从而仅仅获得已完成的结果。</p>
<p>这种方法虽然可行，却有些「繁琐」。还有一种更好的方法：<strong>「完成服务」</strong>（<code>CompletionService</code>）</p>
<p><code>CompletionService</code> 将 <code>Executor</code> 和 <code>BlockingQueue</code> 的功能融合在一起。 你可以将 <code>Callable</code> 任务提交给它来执行，然后使用类似于队列操作的 <code>take</code> 和 <code>poll</code> 等方法来获得已完成的结果，而这些结果会在完成时被封装为 <code>Future</code>。</p>
<p><code>ExecutorCompletionService</code> 实现了 <code>CompletionService</code>，并将<strong>「计算部分」</strong>委托给了一个 <code>Executor</code>。<!--其实这块的设计，需要仔细想一下设计模式的概念，如果你想为一个类开发一个全新的功能，你会怎么做呢？JAVA的设计师使用了组合方法，计算部分仍然交给Executor，全新的功能交给CompletionService,那么CompletionService持有一个Exectuor对象即可--></p>
<p><code>ExecutorCompletionService</code> 的实现非常简单。 在构造函数中创建一个 <code>BlockingQueue</code> 来保存计算完成的结果。<!--Executor有任务队列，ExcutorCompletionService比Exectutor多了一个结果队列--></p>
<p>当计算完成时，调用 <code>FutureTask</code> 中的 <code>done</code> 方法。</p>
<p>当提交某个任务时，该任务将首先包装为一个 <code>QueueingFuture</code> ，这是 <code>FutureTask</code> 的一个子类，然后再改写子类的 <code>done</code> 方法，并将结果放入 <code>BlockingQueue</code> 中，如 <strong>程序清单 6-14</strong> 所示 —— <code>take</code> 和 <code>pool</code> 方法委托于 <code>BlockingQueue</code> ，这些方法在得到结果之前将被「阻塞」。</p>
<blockquote>
<p>程序清单 6-14 由 <code>ExecutorCompletionService</code> 使用的 <code>QueueingFuture</code> 类：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 8 的 QueueingFuture</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">            <span class="keyword">super</span>(task, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// JDK 6的 QueueingFuture ，书中给的例子</span></span><br><span class="line">     <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        QueueingFuture(Callable&lt;V&gt; c) &#123;<span class="keyword">super</span>(c);&#125;</span><br><span class="line">        QueueingFuture(RunnableFuture t,V r) &#123;</span><br><span class="line">            <span class="keyword">super</span>(t r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; completionQueue.add(<span class="keyword">this</span>); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到随着 <code>JDK</code> 的演化，底层的实现还是有些许不同的地方的。</p>
<h4 id="示例3：使用-CompletionService-实现页面渲染器"><a href="#示例3：使用-CompletionService-实现页面渲染器" class="headerlink" title="示例3：使用 CompletionService 实现页面渲染器"></a>示例3：使用 CompletionService 实现页面渲染器</h4><p>可以通过 <code>CompletionService</code> 从两个方面来提高页面渲染器的性能：</p>
<ul>
<li>缩短总运行时间</li>
<li>提高响应性</li>
</ul>
<p>为每一个图像的「下载」都创建一个「独立任务」，并在线程中执行它们，从而将「串行」的下载过程转变为「并行」过程。</p>
<p>此外，通过从 <code>CompletionService</code> 中获取结果以及使每张图片在下载完成后「立刻」 显示出来，能使用户获得一个更加「动态」和「更高响应性」 的用户界面，如下面的代码所示：</p>
<blockquote>
<p>—&gt; renderText(source)   </p>
<p>—&gt; 下载图片1  —&gt; renderImage(图片)</p>
<p>———&gt; 下载图片2  —&gt; renderImage(图片)</p>
<p>… </p>
<p>————————————&gt; 下载图片n   —&gt; renderImage(图片)</p>
</blockquote>
<blockquote>
<p><strong>程序清单 6-15</strong> 使用 <code>CompletionService</code> 使页面元素在下载完成后立即显示出来：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为每个图片分配一个线程进行下载，并且当其下载完成后立即进行渲染</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过传入 ExecutorService 获得不同的特性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Renderer</span><span class="params">(ExecutorService executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; info = scanForImageInfo(source);</span><br><span class="line">        <span class="comment">// 初始化 ExecutorCompletionService</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorCompletionService&lt;ImageData&gt; completionService =</span><br><span class="line">                <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executor);</span><br><span class="line">        <span class="comment">// 为每个图片分配一个Callable线程进行下载</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ImageInfo imageInfo : info) &#123;</span><br><span class="line">            completionService.submit(imageInfo::downloadIamge); <span class="comment">//不会阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 渲染页面文字</span></span><br><span class="line">        renderText(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; info.size(); t++) &#123;</span><br><span class="line">                <span class="comment">// 获取下载任务关联的 Future</span></span><br><span class="line">                <span class="keyword">final</span> Future&lt;ImageData&gt; f = completionService.take();</span><br><span class="line">                <span class="comment">// 获取下载任务的结果 ——&gt; ImageData</span></span><br><span class="line">                <span class="keyword">final</span> ImageData imageData = f.get();</span><br><span class="line">                <span class="comment">// 渲染页面图片</span></span><br><span class="line">                renderImage(imageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> LaunderThrowable.launderThrowable(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		<span class="class"><span class="keyword">interface</span> <span class="title">ImageInfo</span> </span>&#123;</span><br><span class="line">        <span class="function">ImageData <span class="title">downloadIamge</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个 <code>ExecutorCompletionService</code> 可以 「共享」 一个 <code>Executor</code>。 因此可以创建一个对于「特定计算」私有，又能「共享」一个公共 <code>Executor</code> 的 <code>ExecutorCompletionService</code> 。因此，<code>CompletionService</code> 的作用就相当于一组<strong>「计算句柄」</strong>，这与 <code>Future</code> 作为单个计算句柄是非常类似的。 通过记录提交给 <code>CompletionService</code> 的任务数量，并计算出已经获得的已完成结果的数量，即使使用一个 「共享的」 <code>Executor</code>，也能知道已经获得了所有任务结果的「时间」。</p>
<h4 id="为任务设置超时时间"><a href="#为任务设置超时时间" class="headerlink" title="为任务设置超时时间"></a>为任务设置超时时间</h4><p>有时候，如果某个任务无法在指定时间内完成，那么将不再需要它结果，此时可以放弃这个任务。<!--非常常见的业务场景，具有强时效性的任务--></p>
<p>例如：某个 Web 应用程序从外部的广告服务器上获取广告信息，但如果该应用程序在两秒内得不到响应，那么将显示一个默认的广告，这样即使不能获得广告信息，也不会「降低」 网站的响应性能。 类似地，一个门户网站可以从多个数据源「并行地」获取数据，但可能值会在「指定的时间」内等待数据，一旦超出了等待时间，那么将只显示已经获得的数据。</p>
<p>在有限的时间内执行任务的主要困难在于：<strong>「确保得到答案的时间不会超过限定的时间」</strong>，或者在限定的时间内无法获得答案时做出对应的处理。</p>
<p>在支持「时间限制」的 <code>Future.get</code> 中支持这种需求： 当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，将抛出 <code>TimeoutException</code>。</p>
<p>在使用时限任务时需要注意，当这些任务超时后应该 「立即停止」，从而避免为无效的任务浪费计算资源。 要实现这个功能，可以由 「任务本身」 来管理它自己的限定时间，并且在超时后 「中止」 或 「取消」 任务。<!--这里，用"中止"和"取消"，比"放弃"任务更加准确，因为"中止"是java线程的一种状态--></p>
<p>此时可再次使用 <code>Future</code> ,如果一个限时的 <code>get</code> 方法抛出了 <code>TimeoutException</code> ,那么可以通过 <code>Future</code> 来取消任务。</p>
<p>如果编写的任务是「可取消」的（参见第7章），那么可以提前中止它，以免消耗过多的资源。 在程序清单 6-13 和 6-16 的代码中使用了这项技术。【提前中止】</p>
<p>程序清单 6-16 给出了限时 <code>Future.get</code> 的一种 「典型应用」 —— 在生成的页面中包括「响应用户请求的内容」以及从广告服务器上获得的「广告」。 它将获取广告的「任务」 提交给一个 Executor，然后计算剩余的文本页面内容，最后等待广告信息，直到超出指定的时间。（传递给 <code>get</code> 的 <code>timeout</code> 参数的计算方法是： 将指定时间 - 当前时间。 这样可能得到 「负数」，但 <code>java.util.concurrent</code> 中所有与「时限」 相关的方法都将负数视为零，因此不需要额外的代码来处理这种情况）。</p>
<p>如果 <code>get</code> 超时，那么将取消获取广告的任务，并转而使用默认的广告信息。（<code>Future.cancel</code> 的参数为 <code>true</code> 表示任务线程可以在运行中中断，详见 第7章）</p>
<blockquote>
<p><strong>程序清单 6-16</strong> 在指定时间内获取广告信息：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用有时限的任务来放弃超时的失效 Task</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RederWithTimeBudget</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 广告信息，初始化时使用默认广告信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Ad DEFAULT_AD = <span class="keyword">new</span> Ad();</span><br><span class="line">    <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_BUDGET = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 初始化任务执行框架</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里没有处理被中断的异常，而是将其抛给了调用者进行处理</span></span><br><span class="line">    <span class="function">Page <span class="title">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> endNanos = System.nanoTime() + TIME_BUDGET;</span><br><span class="line">        <span class="comment">// 提交一个获取广告的任务到任务执行框架中</span></span><br><span class="line">        <span class="keyword">final</span> Future&lt;Ad&gt; f = exec.submit(<span class="keyword">new</span> FetchAdTask());</span><br><span class="line">        <span class="comment">// Render the page while waiting for the ad 在等待获取广告的同事，渲染这个页面</span></span><br><span class="line">        <span class="keyword">final</span> Page page = renderPageBody();</span><br><span class="line">        Ad ad;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Only wait for the remaining time budget</span></span><br><span class="line">            <span class="comment">// 获取任务执行时间，如果超时则直接抛弃任务 ，如果获取成功则将其赋值给之前定义的广告引用</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> timeLeft = endNanos - System.nanoTime();</span><br><span class="line">            ad = f.get(timeLeft, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">// 发生异常时，将广告信息设置为默认信息</span></span><br><span class="line">            ad = DEFAULT_AD;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="comment">// 如果获取广告的任务超时，不仅将广告设置为默认信息，同时关闭这个获取广告的任务</span></span><br><span class="line">            ad = DEFAULT_AD;</span><br><span class="line">            f.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        page.setAd(ad);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="示例4：旅行预订门户网站"><a href="#示例4：旅行预订门户网站" class="headerlink" title="示例4：旅行预订门户网站"></a>示例4：旅行预订门户网站</h4><p>「预定时间」 方法可以很容易地 「扩展」 到任意数量的任务上。</p>
<p>例如这样一个旅行预定门户网站：用户输入旅行的「日期」 和其他要求，门户网站获取并显示来自多条航线，旅店或汽车租赁公司的报价。</p>
<p>在获取不同公司报价的过程中，可能会调用「Web服务」，「访问」 数据库，执行一个 EDI 事务或其他机制。在这种情况下，不应该让页面的响应时间 受限于 「最慢服务」的响应时间，而应该只显示在 「指定时间」内接收到的信息。 对于没有及时响应的服务提供者，页面可以忽略它们，或者显示一个提示信息，例如”未在指定时间内获取到 xxx 信息”。<!--一组任务分解为多个任务上，并且抛弃超时的任务--></p>
<p>从一个公司获得报价的过程 与 从其他公司获得报价的过程无关。因此可以将获取报价的过程当成「一个任务」，从而使获得报价的过程能「并发执行」。</p>
<p>创建 n 个任务，将其提交到一个线程池，保留 n 个 <code>Future</code>，并使用限时的 <code>get</code> 方法通过 <code>Future</code> 串行地获取每一个结果 ，这一切都很简单，但还有个更简单的方法 ——&gt; <code>invokeAll</code>。</p>
<p>下面的示例代码中使用了支持限时的 <code>invokeAll</code> ，将多个任务提交到 「一个」 <code>ExecutorService</code> 并获得结果。</p>
<p><code>InvokeAll</code> 方法的参数为 「一组任务」，并返回一组 <code>Future</code>。 这两个集合有着相同的结构，<code>invokeAll</code> 按照任务集合中迭代器的顺序将所有的 <code>Future</code> 添加到返回的集合中，从而使调用者能降各个 <code>Future</code> 与其表示的 <code>Callable</code> 关联起来。<!--太好了，而且集合能将Callable任务单元 与 Future任务结果状态一一对应--></p>
<p>当所有任务都执行完毕时，或者调用线程被中断时，又或者超过指定时限时， <code>invokeAll</code> 将返回。</p>
<p>当超过 「指定时限」后，任务还未完成的任务都会「取消」。 当 <code>invokeAll</code> 返回后，每个任务要么正常地完成，要么被取消。 而客户端代码可以调用 <code>get</code> 或 <code>isCancelled</code> 来判断具体是什么情况。</p>
<blockquote>
<p>程序清单 6-17 在预定时间内请求旅游报价：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requesting travel quotes under a time budget</span></span><br><span class="line"><span class="comment">// 使用 invokeAll 来获取一组报价，这个类的设计非常严谨</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeBudget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取报价的方法 在这里调用 QuoteTask 中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TravelQuote&gt; <span class="title">getRankedTravelQuotes</span><span class="params">(TravelInfo travelInfo, Set&lt;TravelCompany&gt; companies,</span></span></span><br><span class="line"><span class="function"><span class="params">            Comparator&lt;TravelQuote&gt; ranking, <span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 轮询调用每个旅行社指定 TravelInfo 的报价</span></span><br><span class="line">        <span class="keyword">for</span> (TravelCompany company : companies) &#123;</span><br><span class="line">            tasks.add(<span class="keyword">new</span> QuoteTask(company, travelInfo));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知任务执行框架开始这一组任务，并获取其 Future</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;Future&lt;TravelQuote&gt;&gt; futures = exec.invokeAll(tasks, time, unit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来保存真正获取到的报价信息 其数量与获取报价任务的数量相等</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;TravelQuote&gt; quotes = <span class="keyword">new</span> ArrayList&lt;&gt;(tasks.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取任务的迭代器</span></span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;QuoteTask&gt; taskIter = tasks.iterator();</span><br><span class="line">        <span class="comment">// 遍历 Future 获取其任务执行完成的信息</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;TravelQuote&gt; f : futures) &#123;</span><br><span class="line">            <span class="keyword">final</span> QuoteTask task = taskIter.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                quotes.add(f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="comment">// 发生异常时 ，在 task列表中 增加一个 获取失败的报价类</span></span><br><span class="line">                quotes.add(task.getFailureQuote(e.getCause()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                <span class="comment">// 收集因任务关闭导致获取报价失败的类</span></span><br><span class="line">                quotes.add(task.getTimeoutQuote(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(quotes, ranking);</span><br><span class="line">        <span class="keyword">return</span> quotes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取报价类的具体实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuoteTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">TravelQuote</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 旅行社</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelCompany company;</span><br><span class="line">    <span class="comment">// 不同航线</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuoteTask</span><span class="params">(TravelCompany company, TravelInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.company = company;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取失败的报价信息</span></span><br><span class="line">    <span class="function">TravelQuote <span class="title">getFailureQuote</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取超时的报价信息</span></span><br><span class="line">    <span class="function">TravelQuote <span class="title">getTimeoutQuote</span><span class="params">(CancellationException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TravelQuote <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 调用旅行社的获取具体航线信息报价的方法</span></span><br><span class="line">        <span class="keyword">return</span> company.solicitQuote(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表不同旅行社的类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TravelCompany</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回具体报价信息</span></span><br><span class="line">    <span class="function">TravelQuote <span class="title">solicitQuote</span><span class="params">(TravelInfo travelInfo)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报价</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TravelQuote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同航线的信息</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TravelInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">chapter7:虚拟机类加载机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-23 18:42:39" itemprop="dateCreated datePublished" datetime="2020-12-23T18:42:39+08:00">2020-12-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-09 14:14:56" itemprop="dateModified" datetime="2023-02-09T14:14:56+08:00">2023-02-09</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <img src="https://mmbiz.qpic.cn/mmbiz_png/1TAcib2scKMT9n0lSVtWic7tmb0WgrrbBkicnpaWJNscP6888C0Bqd6zSsWTBicbWx5aW7KY9EkXGl63hAtRBlARfQ/640" alt="图片" style="zoom: 80%;" />

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步</p>
<p><strong>在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。</strong></p>
<p>虚拟机把描述类的数据从<strong>Class文件加载到内存</strong>，并<strong>对数据进行校验</strong>、<strong>转换解析</strong>和<strong>初始化</strong>，最终形成可以被虚拟机<strong>直接使用的Java类型</strong>，这就是虚拟机的<code>类加载机制</code>。</p>
<p>与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的<code>加载</code>和<code>连接</code>过程都是在<code>程序运行期间</code>完成的，这样会在类加载时稍微增加一些性能开销，但是却能为Java应用程序提供高度的灵活性，</p>
<p>Java中天生可以动态扩展的语言特性就是依赖<code>运行期动态加载</code>和<code>动态连接</code>这个特点实现的。例如，如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现。</p>
<!--“Class文件”并非指Class必须是存在于具体磁盘中的某个文件，这里说的Class文件指的是一串二进制的字节流，无论以何种形式存在都可以。-->



<h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：</p>
<blockquote>
<p>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、</p>
<p>初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。</p>
</blockquote>
<p><img src="https://zoctan.github.io/2018/07/25/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.png" alt="类加载机制"></p>
<p><code>加载</code>、<code>验证</code>、<code>准备</code>、<code>初始化</code>和<code>卸载</code>这五个阶段的顺序是确定的，<code>类的加载</code>过程必须按照这种顺序按部就班地开始，</p>
<h2 id="加载开始的时机"><a href="#加载开始的时机" class="headerlink" title="加载开始的时机"></a>加载开始的时机</h2><p>对于**<code>加载</code>**阶段开始的时间，虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。</p>
<h2 id="解析开始的时机"><a href="#解析开始的时机" class="headerlink" title="解析开始的时机"></a>解析开始的时机</h2><p><code>解析</code>在某些情况下可以在<code>初始化</code>阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。<!--请注意这里写的是按部就班地“开始”，而不是按部就班地“进行”或“完成”，因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。--></p>
<h2 id="初始化开始的时机"><a href="#初始化开始的时机" class="headerlink" title="初始化开始的时机"></a>初始化开始的时机</h2><p>对于**<code>初始化</code>**阶段，虚拟机规范则是严格规定了有且只有4种情况必须立即对类进行<code>初始化</code> </p>
<blockquote>
<p><code>加载</code>、<code>验证</code>、<code>准备</code>自然需要在此之前开始</p>
</blockquote>
<ol>
<li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这4条字节码指令时，如果类没有进行过<code>初始化</code>，则需要先触发其<code>初始化</code>。生成这4条指令的最常见的Java代码场景是：<ul>
<li>使用<code>new</code>关键字实例化对象的时候</li>
<li>读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li>
<li>调用一个类的静态方法的时候</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类进行<a href="">反射</a>调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，<a href="">如果发现其父类还没有进行过初始化</a>，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含<a href="">main()方法的那个类</a>），虚拟机会先初始化这个主类。</li>
</ol>
<p>对于这四种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“<strong>有且只有</strong>”，这四种场景中的行为称为对一个类进行<code>主动引用</code>。</p>
<p>除此之外所有引用类的方式，都不会触发初始化，称为<code>被动引用</code>。</p>
<p>下面举三个例子来说明被动引用，分别见代码清单7-1、代码清单7-2和代码清单7-3。</p>
<p>代码清单7-1　被动引用的例子之一</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示一：</span></span><br><span class="line"><span class="comment"> * 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">  　　 System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(SubClass.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>上述代码运行之后，只会输出“SuperClass init！”，而不会输出“SubClass init！”。对于静态字段，只有直接定义这个字段的类才会被<code>初始化</code>，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的<code>初始化</code>。至于是否要触发子类的<code>加载</code>和<code>验证</code>，在虚拟机规范中并未明确规定。</p>
<p>代码清单7-2　被动引用的例子之二</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示二：</span></span><br><span class="line"><span class="comment"> * 通过数组定义来引用类，不会触发此类的初始化</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>这段代码为了节省版面，复用了代码清单7-1中的SuperClass，运行之后发现没有输出“SuperClass init！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。</p>
<p>代码清单7-3　被动引用的例子之三</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示三：</span></span><br><span class="line"><span class="comment"> * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类</span></span><br><span class="line"><span class="comment">的初始化。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>上述代码运行之后，也没有输出“ConstClass init！”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但是在编译阶段将此常量的值“hello world”存储到了NotInitialization类的常量池中，对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。</p>
<blockquote>
<p>也就是说<strong>实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口</strong>，这两个类在编译成Class之后就不存在任何联系了。</p>
</blockquote>
<p>接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器 [<a target="_blank" rel="noopener" href="http://reader.epubee.com/books/mobile/11/110629db113c9cb59f62032f449dd46c/text00045.html#ch2-back">2]</a> ，用于初始化接口中所定义的成员变量。</p>
<p>接口与类真正有所区别的是前面讲述的四种“<strong>有且仅有</strong>”需要开始初始化场景中的第三种：</p>
<ul>
<li>当一个类在<code>初始化</code>时，要求其父类全部都已经<code>初始化</code>过了，但是一个接口在<code>初始化</code>时，并不要求其父接口全部都完成了<code>初始化</code>，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li>
</ul>
<p>[<a target="_blank" rel="noopener" href="http://reader.epubee.com/books/mobile/11/110629db113c9cb59f62032f449dd46c/text00045.html#ch2">2]</a> 关于类构造器<clinit> 和方法构造器<init> 的生成过程和作用，可参见第10章的相关内容。</p>
<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>接下来我们详细讲解一下类加载的全过程，也就是加载、验证、准备、解析和初始化这五个阶段的过程。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p><strong><code>加载</code>**（Loading）阶段是“</strong><code>类加载</code>**”（Class Loading）过程的一个阶段</p>
<p>在**<code>加载</code>**阶段，虚拟机需要完成以下三件事情：</p>
<p>1）通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>2）将这个字节流所代表的静态存储结构转化为<a href="">方法区的运行时数据</a>结构。</p>
<p>3）在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</p>
<p>虚拟机规范的这三点要求实际上并不具体，因此虚拟机实现与具体应用的灵活度相当大。例如“通过一个类的全限定名来获取定义此类的二进制字节流”，并没有指明二进制字节流要从一个Class文件中获取，准确地说是根本没有指明要从哪里获取及怎样获取。例如：</p>
<ul>
<li>从ZIP包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用就是Applet。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成$Proxy的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景：JSP应用。</li>
<li>从数据库中读取，这种场景相对少见些，有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ul>
<p>相对于**<code>类加载</code><strong>过程的其他阶段，</strong><code>加载</code><strong>阶段（准确地说，是</strong><code>加载</code><strong>阶段中获取类的二进制字节流的动作）是开发期可控性最强的阶段，因为加载阶段既可以使用系统提供的</strong><code>Class Loader</code>**来完成，也可以由用户自定义的类加载器去完成，开发人员们可以通过定义自己的类加载器去控制字节流的获取方式。</p>
<p>**<code>加载</code>**阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在Java堆中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口。加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="1-文件格式验证"><a href="#1-文件格式验证" class="headerlink" title="1.文件格式验证"></a><strong>1.文件格式验证</strong></h3><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头。</li>
<li>主、次版本号是否在当前虚拟机处理范围之内。</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>
</ul>
<p>实际上第一阶段的验证点还远不止这些，上面这些只是从HotSpot虚拟机源码 [<a target="_blank" rel="noopener" href="http://reader.epubee.com/books/mobile/11/110629db113c9cb59f62032f449dd46c/text00046.html#ch1-back">1]</a> 中摘抄的一小部分，该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</p>
<p>这阶段的验证是基于<code>字节流</code>进行的。</p>
<p>经过了这个阶段的验证之后，字节流才会进入内存的**<code>方法区</code><strong>中进行存储，所以后面的三个验证阶段全部是基于</strong><code>方法区</code>**的存储结构进行的。</p>
<h3 id="2-元数据验证"><a href="#2-元数据验证" class="headerlink" title="2.元数据验证"></a><strong>2.元数据验证</strong></h3><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>·这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li>
<li>·这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>
<li>·如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>·类中的字段、方法是否与父类产生了矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li>
</ul>
<p>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p>
<h3 id="3-字节码验证"><a href="#3-字节码验证" class="headerlink" title="3.字节码验证"></a><strong>3.字节码验证</strong></h3><p>第三阶段是整个验证过程中最复杂的一个阶段，主要工作是进行数据流和控制流分析。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析。这阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：</p>
<ul>
<li>·保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈中放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。</li>
<li>·保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li>·保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li>
</ul>
<p>如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。这里涉及了离散数学中一个很著名的问题“Halting Problem” [<a target="_blank" rel="noopener" href="http://reader.epubee.com/books/mobile/11/110629db113c9cb59f62032f449dd46c/text00046.html#ch2-back">2]</a> ：通俗一点的说法就是，通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p>
<h3 id="4-符号引用验证"><a href="#4-符号引用验证" class="headerlink" title="4.符号引用验证"></a><strong>4.符号引用验证</strong></h3><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验，通常需要校验以下内容：</p>
<ul>
<li>·符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>·在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>·符号引用中的类、字段和方法的访问性（private、protected、public、default）是否可被当前类访问。</li>
</ul>
<p>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p>
<p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但不一定是必要的阶段。</p>
<h2 id="准备-根据类变量的初始值-0值-初始化"><a href="#准备-根据类变量的初始值-0值-初始化" class="headerlink" title="准备(根据类变量的初始值(0值), 初始化)"></a>准备(根据类变量的初始值(0值), 初始化)</h2><p><strong><code>准备</code>**阶段是正式为<a href="">类变量</a>**分配内存</strong>并设置<strong>类变量初始值</strong>的阶段，<a href="">这些内存都将在**<code>方法区</code>**中进行分配</a>。</p>
<p>这个阶段中有两个容易产生混淆的概念需要强调一下，</p>
<ul>
<li>这时候进行内存分配的仅包括<code>类变量</code>（被static修饰的变量），而不包括<code>实例变量</code>，<code>实例变量</code>将会在对象实例化时(猜测作者的意思是【初始化阶段】)随着对象一起分配在Java堆中。</li>
<li>这里所说的初始值“通常情况”下是<strong>数据类型的零值</strong>，假设一个类变量的定义为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value &#x3D; 123;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么<a href="">变量value在【准备阶段】过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法</a>，而把value赋值为123的<a href="">putstatic</a>指令是程序被编译后，存放于<a href="">类构造器<clinit>()方法</a>之中，所以把value赋值为123的动作将在<a href="">【初始化阶段】</a>才会被执行。</p>
</blockquote>
<p>注意这里所说的初始值概念，比如一个类变量定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量 v 在【准备阶段】过后的初始值为 0 而不是 8080</span></span><br><span class="line"><span class="comment">// 将 v 赋值为 8080 的 putstatic 指令是程序被编译后，存在类构造器&lt;clinit&gt;方法中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure>

<p>但如果声明为final所修饰时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在【编译阶段】会为变量 v 生成 ConstantValue 属性</span></span><br><span class="line"><span class="comment">// 在【准备阶段】，虚拟机会根据 ConstantValue 属性将 v 赋值为 8080</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure>



<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><code>解析</code>阶段是虚拟机将<code>常量池</code>内的符号引用替换为直接引用的过程，符号引用在前一章讲解Class文件格式的时候就已经出现过多次，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？</p>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</li>
<li>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</li>
</ul>
<p>虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokeinterface、invokespecial、invokestatic、invokevirtual、multianewarray、new、putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
<p>对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的都是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样地，如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info及CONSTANT_InterfaceMethodref_info四种常量类型 [<a target="_blank" rel="noopener" href="http://reader.epubee.com/books/mobile/11/110629db113c9cb59f62032f449dd46c/text00046.html#ch3-back">3]</a> 。下面将讲解这四种引用的解析过程。</p>
<h3 id="1-类或接口的解析"><a href="#1-类或接口的解析" class="headerlink" title="1.类或接口的解析"></a>1.类或接口的解析</h3><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p>
<p>1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于无数据验证、字节码验证的需要，又将可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。</p>
<p>2）如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava.lang.Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</p>
<p>3）如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认C是否具备对D的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<h3 id="2-字段解析"><a href="#2-字段解析" class="headerlink" title="2.字段解析"></a>2.字段解析</h3><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index [<a target="_blank" rel="noopener" href="http://reader.epubee.com/books/mobile/11/110629db113c9cb59f62032f449dd46c/text00046.html#ch4-back">4]</a> 项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：</p>
<p>1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>2）否则，如果在C中实现了接口，将会按照继承关系从上往下递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>3）否则，如果C不是java.lang.Object的话，将会按照继承关系从上往下递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>4）否则，查找失败，抛出java.lang.NoSuchFieldError异常。</p>
<p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<p>在实际应用中，虚拟机的编译器实现可能会比上述规范要求得更加严格一些，如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。在代码清单7-4中，如果注释了Sub类中的“public static int A=4；”，接口与父类同时存在字段A，那编译器将提示“The field Sub.A is ambiguous”，并且会拒绝编译这段代码。</p>
<p>代码清单7-4　字段解析</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package org.fenixsoft.classloading;</span><br><span class="line">public class FieldResolution &#123;</span><br><span class="line">　interface Interface0 &#123;</span><br><span class="line">　　int A &#x3D; 0;</span><br><span class="line">　&#125;</span><br><span class="line">　interface Interface1 extends Interface0 &#123;</span><br><span class="line">　　int A &#x3D; 1;</span><br><span class="line">　&#125;</span><br><span class="line">　interface Interface2 &#123;</span><br><span class="line">　　int A &#x3D; 2;</span><br><span class="line">　&#125;</span><br><span class="line">　static class Parent implements Interface1 &#123;</span><br><span class="line">　　public static int A &#x3D; 3;</span><br><span class="line">　&#125;</span><br><span class="line">　static class Sub extends Parent implements Interface2 &#123;</span><br><span class="line">　　public static int A &#x3D; 4;</span><br><span class="line">　&#125;</span><br><span class="line">　public static void main(String[] args) &#123;</span><br><span class="line">　　System.out.println(Sub.A);</span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-类方法解析"><a href="#3-类方法解析" class="headerlink" title="3.类方法解析"></a>3.类方法解析</h3><p>类方法解析的第一个步骤与字段解析一样，也是需要先解析出类方法表的class_index [<a target="_blank" rel="noopener" href="http://reader.epubee.com/books/mobile/11/110629db113c9cb59f62032f449dd46c/text00046.html#ch5-back">5]</a> 项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索：</p>
<p>1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</p>
<p>2）如果通过了第（1）步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>4）否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。</p>
<p>5）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</p>
<p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证；如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<h3 id="4-接口方法解析"><a href="#4-接口方法解析" class="headerlink" title="4.接口方法解析"></a>4.接口方法解析</h3><p>接口方法也是需要先解析出接口方法表的class_index [<a target="_blank" rel="noopener" href="http://reader.epubee.com/books/mobile/11/110629db113c9cb59f62032f449dd46c/text00046.html#ch6-back">6]</a> 项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p>
<p>1）与类方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</p>
<p>2）否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>3）否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>4）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</p>
<p>由于接口中的所有方法都默认是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。</p>
<h2 id="初始化-根据程序员，进行初始化"><a href="#初始化-根据程序员，进行初始化" class="headerlink" title="初始化(根据程序员，进行初始化)"></a>初始化(根据程序员，进行初始化)</h2><p><code>初始化</code>是<code>类加载</code>过程的最后一步，前面的<code>类加载</code>过程中，除了在<code>加载</code>阶段用户应用程序可以通过<code>自定义类加载器</code>参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行<strong>类中定义的Java程序代码</strong>（或者说是字节码）。</p>
<p>在<code>准备</code>阶段，变量已经赋过一次<strong>系统要求的初始值</strong>。</p>
<p>在<code>初始化</code>阶段，则是<strong>根据程序员通过程序制定的主观计划去初始化类变量</strong>和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行<code>类构造器</code><clinit>()方法的过程。</p>
<h3 id="JVM初始化类的步骤"><a href="#JVM初始化类的步骤" class="headerlink" title="JVM初始化类的步骤"></a>JVM初始化类的步骤</h3><ol>
<li>若该类还没有被加载和连接，则程序先加载并连接该类</li>
<li>若该类的父类还没有初始化，则先初始化该类的父类</li>
<li>若该类种有静态代码块，则系统依次执行这些代码块</li>
</ol>
<h3 id="执行类构造器-方法"><a href="#执行类构造器-方法" class="headerlink" title="执行类构造器()方法"></a>执行<code>类构造器</code><clinit>()方法</h3><p>我们先看一下<clinit>()方法执行过程中可能会影响程序运行行为的一些特点和细节[<a target="_blank" rel="noopener" href="http://reader.epubee.com/books/mobile/11/110629db113c9cb59f62032f449dd46c/text00046.html#ch7-back">7]</a> ：</p>
<ul>
<li><p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，<strong>编译器收集的顺序是由语句在源文件中出现的顺序所决定的</strong>，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。</p>
</li>
<li><p><clinit>()方法与<u>类的构造函数</u>，或者说<u>实例构造器</u><init>()方法，不同<!--非常重要，也是非常容易混淆的点--><br>它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。</p>
</li>
<li><p>由于父类的<clinit>()方法先执行，也就意味着<strong>父类中定义的<code>静态语句块</code>要优先于子类的变量赋值操作</strong>，如代码清单7-5中，字段B的值将会是2而不是1。</p>
</li>
</ul>
<p>代码清单7-5　<clinit>()方法执行顺序</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Sub.B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p><clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</p>
</li>
<li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。代码清单7-6演示了这种场景。</p>
</li>
</ul>
<p>代码清单7-6　字段解析</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不加上这个if语句，编译器将提示&quot;Initializer does not complete normally&quot;并拒绝编译</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;init DeadLoopClass&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Runnable script = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">            DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; run over&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>运行结果如下，一条线程正在死循环以模拟长时间操作，另外一条线程在阻塞等待：</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]init DeadLoopClass</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。</p>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等情况。</p>
<p>如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果。</p>
<p>代码清单7-7　不同的类加载器对instanceof关键字运算结果的影响</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载器与instanceof关键字演示</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + </span><br><span class="line">　　<span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">&quot;org.fenixsoft.classloading.</span></span><br><span class="line"><span class="string">　ClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> org.fenixsoft.classloading.</span><br><span class="line">　ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>运行结果：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class org.fenixsoft.classloading.ClassLoaderTest</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<hr>
<p>代码清单7-7中构造了一个简单的类加载器。</p>
<p>它可以加载与自己在同一路径下的Class文件。</p>
<p>两行输出结果中，从第一句可以看到这个对象确实是类org.fenixsoft.classloading.ClassLoaderTest实例化出来的对象，但从第二句可以发现这个对象与类org.fenixsoft.classloading.ClassLoaderTest做所属类型检查的时候却返回了false，这是因为虚拟机中存在了两个ClassLoaderTest类，一个是由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然为false。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>站在Java虚拟机的角度讲，只存在两种不同的类加载器：</p>
<ul>
<li>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现  ，是虚拟机自身的一部分；</li>
<li>另外一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</li>
</ul>
<p>从Java开发人员的角度来看，类加载器就还可以划分得更细致一些：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader）：前面已经介绍过，这个类加载器负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<p>我们的应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般会如图7-2所示。</p>
<img src="https://zoctan.github.io/2018/07/25/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.jpg" alt="类加载器的双亲委派模型" style="zoom:75%;" />

<p>图7-2　类加载器双亲委派模型</p>
<p>图7-2中所展示的类加载器之间的这种层次关系，就称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</p>
<p>这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p>
<p>类加载器的双亲委派模型在JDK 1.2期间被引入并被广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者们的一种类加载器实现方式。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。<!--说白了就是不属于java的基础类，java不加载--></p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，</p>
<ul>
<li>无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</li>
<li>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序也将会变得一片混乱。<!--如果您有兴趣的话，可以尝试去写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编译，但永远无法被加载运行--></li>
</ul>
<p>双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法之中，如代码清单7-8所示，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，则在抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p>
<p>代码清单7-8　双亲委派模型的实现</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 首先，检查请求的类是否已经被加载过了</span><br><span class="line">    Class c &#x3D; findLoadedClass(name);</span><br><span class="line">    if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        if (parent !&#x3D; null) &#123;</span><br><span class="line">            c &#x3D; parent.loadClass(name, false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果父类加载器抛出ClassNotFoundException</span><br><span class="line">            &#x2F;&#x2F; 则说明父类加载器无法完成加载请求</span><br><span class="line">        &#125;</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 在父类加载器无法加载的时候</span><br><span class="line">            &#x2F;&#x2F; 再调用本身的findClass方法来进行类加载</span><br><span class="line">            c &#x3D; findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>到现在为止，双亲委派模型主要出现过三次较大规模的“被破坏”情况。</p>
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2发布之前。由于双亲委派模型在JDK 1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则在JDK 1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者们引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK 1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。</p>
<p>上一节我们已经看过loadClass()方法的代码，双亲委派的具体逻辑就实现在这个方法之中，JDK 1.2之后已不提倡用户再去覆盖loadClass()方法，而应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以被称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办了？</p>
<p>这并非是不可能的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK 1.3时代放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能“认识”这些代码啊！那该怎么办？</p>
<!--解决方法-->

<p>为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoaser()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热”门的名词：代码热替换（HotSwap）、模块热部署（Hot Deployment）等，对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。</p>
<p>在JSR-297 [<a target="_blank" rel="noopener" href="http://reader.epubee.com/books/mobile/11/110629db113c9cb59f62032f449dd46c/text00047.html#ch4-back">4]</a> 、JSR-277 [<a target="_blank" rel="noopener" href="http://reader.epubee.com/books/mobile/11/110629db113c9cb59f62032f449dd46c/text00047.html#ch5-back">5]</a> 规范从纸上标准变成真正可运行的程序之前，OSGi是当前业界“事实上”的Java模块化标准，而OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p>
<p>在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<p>（1）将以java.*开头的类，委派给父类加载器加载。</p>
<p>（2）否则，将委派列表名单内的类，委派给父类加载器加载。</p>
<p>（3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p>
<p>（4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p>
<p>（5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p>
<p>（6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</p>
<p>（7）否则，类查找失败。</p>
<p>上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。</p>
<p>笔者虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可算作一种创新。正如OSGi中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但在Java程序员中基本有一个共识：OSGi中对类加载器的使用是很值得学习的，弄懂了OSGi的实现，自然就明白了类加载器的精粹。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">chapter3:垃圾收集器与内存分配策略</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-23 12:15:53" itemprop="dateCreated datePublished" datetime="2020-12-23T12:15:53+08:00">2020-12-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-12-07 14:05:06" itemprop="dateModified" datetime="2022-12-07T14:05:06+08:00">2022-12-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>垃圾收集需要完成的三件事情:</p>
<ul>
<li>哪些内存需要回收?</li>
<li>什么时候回收?</li>
<li>如何回收?</li>
</ul>
<p><code>程序计数器</code>、<code>虚拟机栈</code>、<code>本地方法栈</code> 3个区域随线程而生,随线程而灭,栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。</p>
<blockquote>
<p>每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的。<!--尽管在运行期间JIT可能会优化，但大体上认为是编译期间是可知的--></p>
</blockquote>
<p>因此这几个区域的内存分配和回收都具备确定性,在这几个区域内就不需要过多考虑如何回收的问题,当方法结束或者线程结束时,内存自然就跟随着回收了。</p>
<p>而Java堆和方法区这两个区域则有着很显著的不确定性：</p>
<blockquote>
<p>一个接口的多个实现类需要的内存可能会不一样,一个方法所执行的不同条件分支所需要的内存也可能不一样,只有处于运行期间,我们才能知道程序究竟会创建哪些对象,创建多少个对象,这部分内存的分配和回收是动态的。</p>
</blockquote>
<h2 id="对象已死"><a href="#对象已死" class="headerlink" title="对象已死"></a>对象已死</h2><p>在垃圾收集器在对堆进行回收前，第一件事就是确定这些对象之中哪些还“存活”着，哪些已经“死去”。</p>
<h3 id="判断依据1：引用计数算法"><a href="#判断依据1：引用计数算法" class="headerlink" title="判断依据1：引用计数算法"></a>判断依据1：引用计数算法</h3><p>引用计数算法(Reference Counting)：</p>
<blockquote>
<p>在对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加一;当引用失效时,计数器值就减一;任何时刻计数器为0的对象就是不可能再被使用的。</p>
</blockquote>
<p>引用计数算法虽然占用了一些额外的内存空间来进行计数,但它的原理简单,判定效率也很高,在大多数情况下它都是一个不错的算法。但是,在Java领域,至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存,主要原因是,这个看似简单的算法有很多例外情况要考虑,必须要配合大量额外处理才能保证正确地工作,譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p>
<h3 id="判断依据2：可达性分析算法"><a href="#判断依据2：可达性分析算法" class="headerlink" title="判断依据2：可达性分析算法"></a>判断依据2：可达性分析算法</h3><p>当前主流的商用程序语言的内存管理子系统,都是通过<strong>可达性分析</strong>(Reachability Analysis)算法来判定对象是否存活的。</p>
<p>这个算法的基本思路</p>
<ul>
<li>通过一系列称为<strong>GC Roots</strong>的根对象作为起始节点集,</li>
<li>从这些节点开始,根据引用关系向下搜索,搜索过程所走过的路径称为<strong>引用链</strong>(Reference Chain),</li>
<li>如果某个对象到<strong>GC Roots</strong>间没有任何引用链相连,即从<strong>GC Roots</strong>到这个对象不可达时,则证明此对象是不可能再被使用的。</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/1839532/202003/1839532-20200304165840671-711345216.png"></p>
<p>可作为GC Roots的对象：</p>
<ul>
<li>在虚拟机栈(栈帧中的本地变量表)中引用的对象,譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象,譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象,譬如字符串常量池里的引用。</li>
<li>在本地方法栈中JNI(即通常所说的Native方法)引用的对象。</li>
<li>Java虚拟机内部的引用,如基本数据类型对应的Class对象,一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等,还有系统类加载器。</li>
<li>所有被同步锁(synchronized关键字)持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
<li>除此以外,根据用户所选用的垃圾收集器以及当前回收的内存区域不同,还可以有其他对象”临时性”地加入,共同构成完整GC Roots集合。</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>无论是<code>引用计数算法</code>还是<code>可达性分析算法</code>，判断对象是否存活都与**<code>引用</code>**相关。</p>
<p>在JDK 1.2版之前，如果reference类型的数据中存储的数据，表示的是另一块内存的起始地址，就称这块内存代表着一个引用。</p>
<blockquote>
<p>这种定义方法太过简单，我们希望：</p>
<p>如果内存足够，则保留一些“食之无味，弃之可惜”的对象；</p>
<p>如果内存紧张，则抛弃保留一些“食之无味，弃之可惜”的对象。</p>
</blockquote>
<p>在JDK 1.2版之后，Java对引用的概念进行了扩充</p>
<ul>
<li>强引用：指在程序代码之中普遍存在的引用赋值,即类似”Object obj=new Object()”这种引用关系。只要强引用关系还存在,垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用：用来描述一些还有用,但非必须的对象。只被软引用关联的对象,在系统将要发生内存溢出异常前,会把这些对象列进回收范围之中进行第二次回收,如果这次回收还没有足够的内存,才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用：与软引用类似,但是它的强度更弱些,被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作,无论当前内存是否足够,都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
<li>虚引用：或”幽灵引用”,”幻影引用”,最弱的一种引用关系。一个对象是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使经过可达性分析后，处于不可达状态的对象，也并非处于“非死不可”的。这时他们处于“缓刑”阶段。</p>
<p><strong>真正宣告一个对象死亡，至少要经历2次标记过程：</strong></p>
<ul>
<li><p>如果对象经过可达性分析后，没有与GC Root相连接的引用链，那么对象 **1st次 **被标记</p>
</li>
<li><p>随后进行一次筛选，筛选的条件为<code>此对象是否有必要执行finalize()方法</code></p>
<ul>
<li><p>对象没有覆盖finalize()方法 或者 finalize()方法已经被虚拟机调用过一次了<!--这个很重要，防止对象使用finalize()一直逃避gc-->，则<code>没必要执行</code>；</p>
</li>
<li><p><code>有必要执行</code>：那么对象会被放置在一个名为F-Queue的队列之中,并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法[1]，稍后收集器将对F-Queue中的对象进行第二次小规模的标记：</p>
</li>
</ul>
</li>
<li><p>在finalize()方法中重新与引用链上的任一对象建立管理：被移出队列[2]</p>
<ul>
<li>否则，基本真的要被回收</li>
</ul>
</li>
</ul>
<p>[1]注：这里所说的”执行”是指虚拟机会触发这个方法开始运行,但并不承诺一定会等待它运行结束。这样做的原因是,如果某个对象的finalize()方法执行缓慢,或者更极端地发生了死循环,将很可能导致F-Queue队列中的其他对象永久处于等待,甚至导致整个内存回收子系统的崩溃。<br>[2]注：finalize()方法是对象逃脱死亡命运的最后一次机会。且这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统调用一次。</p>
<!--注意：尽量避免使用finalize(),因为它并不能等同于C和C++语言中的析构函数,运行代价高昂,不确定性大,无法保证各个对象的调用顺序,如今已被官方明确声明为不推荐使用的语法。-->

<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区垃圾收集的”性价比”通常比较低:在Java堆中,尤其是在新生代中,对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间,相比之下,方法区回收囿于苛刻的判定条件,其区域垃圾收集的回收成果往往远低于此。</p>
<p>方法区的垃圾收集主要回收2部分内容:</p>
<ul>
<li><p><strong>废弃的常量</strong></p>
<p>回收废弃常量与回收Java堆中的对象非常类似。<br>举个常量池中字面量回收的例子,假如一个字符串”java”曾经进入常量池中,但是当前系统又没有任何字符串对象引用常量池中的”java”常量,且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收,而且垃圾收集器判断确有必要的话,这个”java”常量就将会被系统清理出常量池。常量池中其他类(接口)、方法、字段的符号引用也与此类似。</p>
</li>
<li><p><strong>不再使用的类</strong>：<br>需同时满足以下3个条件</p>
<ul>
<li>该类所有的实例都已经被回收,也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收,这个条件除非是经过精心设计的可替换类加载器的场景,如OSGi、JSP的重加载等,否则通常是很难达成的。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收,而不是必然被回收。<br>HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制,还可以使用<code>-verbose:class</code>以及<code>-XX:+TraceClass-Loading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息。</p>
</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>从如何判定对象消亡的角度出发,垃圾收集算法可以划分为</p>
<p>“引用计数式垃圾收集”(Reference Counting GC)和”追踪式垃圾收集”(Tracing GC)</p>
<p>这两类也常被称作”直接垃圾收集”和”间接垃圾收集”。</p>
<!--由于引用计数式垃圾收集算法在主流Java虚拟机中未涉及,以下介绍的所有算法均属于追踪式垃圾收集的范畴。-->

<p>基本概念：</p>
<ul>
<li>部分收集(Partial GC)：目标不是完整收集整个Java堆的垃圾收集<ul>
<li>新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集。</li>
<li>老年代收集(Major GC/Old GC):指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。</li>
<li>混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ul>
</li>
<li>整堆收集(Full GC)：收集整个Java堆和方法区的垃圾收集。</li>
</ul>
<p>注：”Major GC”这个说法现在有点混淆,需按上下文区分到底是指老年代的收集还是整堆收集。</p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集器,大多数都遵循了”分代收集”(Generational Collection)。</p>
<p>分代收集名为理论,实质是一套符合大多数程序运行实际情况的经验法则,它建立在两个分代假说之上:</p>
<ul>
<li>弱分代假说(Weak Generational Hypothesis):绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说(Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ul>
<p>设计原则：收集器应将Java堆划分出不同的区域,并将回收对象依据其年龄(熬过垃圾收集过程的次数)分配到不同的区域之中存储。</p>
<ul>
<li><p>如果一个区域中大多数对象都是朝生夕灭、难以熬过垃圾收集过程的话,那么把它们集中放在一起,每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象,就能以较低代价回收到大量的空间;</p>
</li>
<li><p>如果剩下的都是难以消亡的对象,那把它们集中放在一块,虚拟机便可以使用较低的频率来回收这个区域。</p>
</li>
</ul>
<blockquote>
<p>这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://img2020.cnblogs.com/blog/1839532/202003/1839532-20200304165840671-711345216.png">现在的商用Java虚拟机里,设计者一般至少会把Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域。</a></p>
<p>在新生代中,每次垃圾收集时都发现有大批对象死去,而每次回收后存活的少量对象,将会逐步晋升到老年代中存放。</p>
<p><strong>问题</strong>：对象不是孤立的,对象之间会存在跨代引用。</p>
<p>假如要现在进行一次只局限于新生代区域内的收集(Minor GC),但新生代中的对象是完全有可能被老年代所引用的,为了找出该区域中的存活对象,不得不在固定的GC Roots之外,再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性。这会为内存回收带来很大的性能负担。</p>
<p>为了解决这个问题,就需要对分代收集理论添加第三条经验法则：</p>
<ul>
<li>跨代引用假说(Intergenerational Reference Hypothesis):跨代引用相对于同代引用来说仅占极少数。<br>存在互相引用关系的两个对象,是应该倾向于同时生存或者同时消亡的。如果某个新生代对象存在跨代引用,由于老年代对象难以消亡,该引用会使得新生代对象在收集时同样得以存活,进而在年龄增长之后晋升到老年代中,这时跨代引用也随即被消除了。</li>
</ul>
<p><strong>解决</strong>：依据这条假说,我们只需在新生代上建立一个全局的数据结构(记忆集,Remembered Set),这个结构把老年代划分成若干小块,标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时,只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。<br>虽然这种方法需要在对象改变引用关系(如将自己或者某个属性赋值)时维护记录数据的正确性,会增加一些运行时的开销,但比起收集时扫描整个老年代来说仍然是划算的。</p>
<h3 id="标记——清除算法"><a href="#标记——清除算法" class="headerlink" title="标记——清除算法"></a>标记——清除算法</h3><p>最早出现也是最基础的垃圾收集算法是”标记-清除”(Mark-Sweep)算法。算法分为”标记”和”清除”两个阶段:</p>
<ul>
<li>首先标记出所有需要回收的对象</li>
<li>在标记完成后,统一回收掉所有被标记的对象</li>
</ul>
<p>缺点：</p>
<ul>
<li>执行效率不稳定：如果Java堆中包含大量对象,而且其中大部分是需要被回收的,这时必须进行大量标记和清除的动作,导致标记和清除两个过程的执行效率都随对象数量增长而降低</li>
<li>内存空间的碎片化：标记、清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<!--需要空闲列表，不需要指针碰撞--></li>
</ul>
<img src="https://img2020.cnblogs.com/blog/1839532/202003/1839532-20200304165903094-181946271.png" style="zoom:50%;" />

<h3 id="标记——复制算法"><a href="#标记——复制算法" class="headerlink" title="标记——复制算法"></a>标记——复制算法</h3><p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题将可用内存按容量划分为大小相等的两块,每次只使用其中的一块。当这一块的内存用完了,就将还存活着的对象复制到另外一块上面,然后再把已使用过的内存空间一次清理掉。</p>
<ul>
<li>如果内存中多数对象都是存活的,这种算法将会产生大量的内存间复制的开销,</li>
<li>但如果内存中多数对象都是可回收的,算法需要复制的就是占少数的存活对象,</li>
</ul>
<p>而且每次都是针对整个半区进行内存回收,分配内存时也就不用考虑有空间碎片的复杂情况,<a href="">只要移动堆顶指针,按顺序分配即可</a>。<!--指针碰撞，不需要空闲列表--></p>
<ul>
<li>优点：实现简单,运行高效</li>
<li>缺点：将可用内存缩小为了原来的一半,空间浪费大</li>
</ul>
<img src="https://img2020.cnblogs.com/blog/1839532/202003/1839532-20200304165915283-1742434176.png" alt="img" style="zoom:50%;" />

<p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代,IBM公司曾有一项专门研究表明：新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。</p>
<p><strong>优化</strong><br>Andrew Appel针对具备”朝生夕灭”特点的对象,提出了一种更优化的半区复制分代策略,HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。</p>
<ul>
<li>把<a href="">新生代</a>分为一块较大的<a href="">Eden空间</a>和两块较小的<a href="">Survivor</a>空间,每次分配内存只使用Eden和其中一块Survivor。</li>
<li>发生垃圾搜集时,将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上,然后直接清理掉Eden和已用过的那块Survivor空间。</li>
<li>当Survivor空间不足以容纳一次Minor GC之后存活的对象时,就需要依赖其他内存区域(大多是老年代)进行分配担保(Handle Promotion)(Suvivor无法容纳的对象直接送入老年代)。<!--分配担保：见3.6.5章节--></li>
</ul>
<p>注：HotSpot虚拟机默认新生代中的Eden和Survivor的大小比例是8∶1,也即每次新生代中可用内存空间为整个新生代容量的90%。</p>
<h3 id="标记——整理算法"><a href="#标记——整理算法" class="headerlink" title="标记——整理算法"></a>标记——整理算法</h3><p>针对老年代对象的存亡特征,1974年Edward Lueders提出了另外一种有针对性的”标记-整理”(Mark-Compact)算法,其中的标记过程仍然与”标记-清除”算法一样,但后续步骤不是直接对可回收对象进行清理,而是<a href="">让所有存活的对象都向内存空间一端移动,然后直接清理掉边界以外的内存</a>。<!--指针碰撞--></p>
<img src="https://img2020.cnblogs.com/blog/1839532/202003/1839532-20200304165928553-2130045856.png" alt="img" style="zoom:50%;" />

<p><strong>问题</strong><br>在老年代这种每次回收都有大量对象存活区域,移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作,而且这种对象移动操作必须全程暂停用户应用程序才能进行(Stop The World)。但若不移动整理存货对象，面对碎片化的空间，内存分配会更加复杂。</p>
<p><strong>解决</strong><br>让虚拟机平时多数时间都采用标记-清除算法,暂时容忍内存碎片的存在,直到内存空间的碎片化程度已经大到影响对象分配时,再采用标记-整理算法收集一次,以获得规整的内存空间。</p>
<h2 id="HotSpot-算法细节实现"><a href="#HotSpot-算法细节实现" class="headerlink" title="HotSpot 算法细节实现"></a>HotSpot 算法细节实现<!--好难，我不准备看--></h2><h3 id="1-根节点枚举"><a href="#1-根节点枚举" class="headerlink" title="1. 根节点枚举"></a>1. 根节点枚举</h3><p>迄今为止,所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。由于目前主流Java虚拟机使用的都是准确式垃圾收集(虚拟机可以知道内存中某个位置的数据具体是什么类型),所以当用户线程停顿下来之后,虚拟机应当是有办法直接得到哪些地方存放着对象引用的。</p>
<p>在HotSpot的解决方案里,使用一组称为OopMap的数据结构。一旦类加载动作完成的时候,HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来,在即时编译过程中,也会在特定的位置(安全点)记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息,并不需要真正一个不漏地从方法区等GC Roots开始查找。</p>
<p>下面代码清单是HotSpot虚拟机客户端模式下生成的一段String.hashCode()方法的本地代码,可以看到在0x026eb7a9处的call指令有OopMap记录,它指明了EBX寄存器和栈中偏移量为16的内存区域中各有一个普通对象指针(Ordinary Object Pointer,OOP)的引用,有效范围为从call指令开始直到0x026eb730(指令流的起始位置)+142(OopMap记录<br>的偏移量)=0x026eb7be,即hlt指令为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Verified Entry Point]</span><br><span class="line">0x026eb730: mov %eax,-0x8000(%esp)</span><br><span class="line">............</span><br><span class="line">;; ImplicitNullCheckStub slow case</span><br><span class="line">0x026eb7a9: call 0x026e83e0 ; OopMap&#123;ebx&#x3D;Oop [16]&#x3D;Oop off&#x3D;142&#125;</span><br><span class="line">							; *caload</span><br><span class="line">							; - java.lang.String::hashCode@48 (line 1489)</span><br><span class="line">							; &#123;runtime_call&#125;</span><br><span class="line">0x026eb7ae: push $0x83c5c18 ; &#123;external_word&#125;</span><br><span class="line">0x026eb7b3: call 0x026eb7b8</span><br><span class="line">0x026eb7b8: pusha</span><br><span class="line">0x026eb7b9: call 0x0822bec0 ; &#123;runtime_call&#125;</span><br><span class="line">0x026eb7be: hlt</span><br></pre></td></tr></table></figure>

<h3 id="2-安全点"><a href="#2-安全点" class="headerlink" title="2. 安全点"></a>2. 安全点</h3><p>通过OopMap,HotSpot可以快速准确地完成GC Roots枚举。但若为每一条指令都生成对应的OopMap,那将会需要大量的额外存储空间。因此HotSpot只在安全点(Safepoint)记录信息。</p>
<p>有了安全点的设定,也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集,而是强制要求必须执行到达安全点后才能够暂停。</p>
<p>因此,安全点的选定既不能太少以至于让收集器等待时间过长,也不能太过频繁以至于过分增大运行时的内存负荷。<br>安全点位置的选取基本上是以”是否具有让程序长时间执行的特征”为标准进行选定的,而每条指令执行的时间都非常短暂,所以”长时间执行”的最明显特征就是指令序列的复用,例如方法调用、循环跳转、异常跳转等,只有具有这些功能的指令才会产生安全点。</p>
<p><strong>问题</strong>：如何在垃圾收集发生时让所有线程(这里其实不包括执行JNI调用的线程)都跑到最近的安全点,然后停顿下来。</p>
<p><strong>解决</strong></p>
<ul>
<li>抢先式中断(Preemptive Suspension)：系统把所有用户线程全部中断,如果发现有用户线程中断的地方不在安全点上,就恢复这条线程执行,直到跑到安全点上再次中断。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。</li>
<li>主动式中断(Voluntary Suspension)：当垃圾收集需要中断线程的时候,不直接对线程操作,而是设置一个标志位,各个线程执行过程时会不停地主动去轮询这个标志,一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。</li>
</ul>
<h3 id="3-安全区域"><a href="#3-安全区域" class="headerlink" title="3. 安全区域"></a>3. 安全区域</h3><p>安全点机制保证了程序执行时,在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但程序不执行时(没有分配处理器,如用户线程处于Sleep状态或者Blocked状态),线程无法响应虚拟机的中断请求,不能再走到安全的地方去中断挂起自己。对于这种情况,就必须引入安全区域(Safe Region)来解决。</p>
<p>安全区域：能够确保引用关系不会发生变化的区域,可以看作被扩展拉伸了的安全点。</p>
<ul>
<li>当用户线程执行到安全区域里面的代码时,会标识自己进入了安全区域,虚拟机要发起垃圾收集时不必去管这些已声明的线程。</li>
<li>当线程要离开安全区域时,它要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段)<ul>
<li>完成,线程继续执行</li>
<li>否则,一直等待,直到收到可以离开安全区域的信号</li>
</ul>
</li>
</ul>
<h3 id="4-记忆集与卡表"><a href="#4-记忆集与卡表" class="headerlink" title="4. 记忆集与卡表"></a>4. 记忆集与卡表</h3><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。<br>最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构,空间占用和维护成本都相当高昂。而在垃圾收集的场景中,收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了,并不需要了解这些跨代指针的全部细节。因此记录粒度可以更为粗犷：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长,该字包含跨代指针。</li>
<li>对象精度：每个记录精确到一个对象,该对象里有字段含有跨代指针。</li>
<li>卡精度：每个记录精确到一块内存区域,该区域内有对象含有跨代指针。<br>“卡精度”所指的是用一种称为”卡表”(Card Table)的方式去实现记忆集,这也是目前最常用的一种记忆集实现形式。<br>卡表最简单的形式可以只是一个字节数组。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CARD_TABLE [this address &gt;&gt; 9] &#x3D; 0; &#x2F;&#x2F; 卡页大小512字节</span><br></pre></td></tr></table></figure>

<p>字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块(卡页,Card Page)。<br>一个卡页的内存中通常包含不止一个对象,只要卡页内有一个对象的字段存在着跨代指针,那就将对应卡表的数组元素的值标识为1,称为这个元素变脏(Dirty),没有则标识为0。在垃圾收集发生时,只要筛选出卡表中变脏的元素,就能轻易得出哪些卡页内存块中包含跨代指针,把它们加入GC Roots中一并扫描。</p>
<h3 id="5-写屏障"><a href="#5-写屏障" class="headerlink" title="5. 写屏障"></a>5. 写屏障</h3><p><strong>问题</strong>：卡表如何维护<br>假如是解释执行的字节码,那相对好处理,虚拟机负责每条字节码指令的执行,有充分的介入空间;但在编译执行的场景中呢?经过即时编译后的代码已经是纯粹的机器指令流了,这就必须找到一个在机器码层面的手段,把维护卡表的动作放到每一个赋值操作之中。</p>
<p><strong>解决</strong>：写屏障(Write Barrier)<br>写屏障可以看作在虚拟机层面对”引用类型字段赋值”这个动作的AOP切面,在引用对象赋值时会产生一个环形(Around)通知,供程序执行额外的动作,也就是说赋值的前后都在写屏障的覆盖范畴内。可以利用写后屏障更新卡表。</p>
<p>缺点：</p>
<ul>
<li>额外开销：应用写屏障后,虚拟机会为所有赋值操作生成相应的指令,不区分是否跨区,每次只要对引用进行更新,就会产生额外的开销,不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。</li>
<li>伪共享：现代中央处理器的缓存系统中是以缓存行(Cache Line)为单位存储的,当多线程修改互相独立的变量时,如果这些变量恰好共享同一个缓存行,就会彼此影响(写回、无效化或者同步)而导致性能降低。<br>假设处理器的缓存行大小为64字节,由于一个卡表元素占1个字节,64个卡表元素将共享同一个缓存行。对应的卡页总内存为32KB(64×512字节)。如果不同线程更新的对象正好处于这32KB的内存区域内,就会导致更新卡表时正好写入同一个缓存行而影响性能。<br>为了避免伪共享问题,一种简单的解决方案是不采用无条件的写屏障,而是先检查卡表标记,只有当该卡表元素未被标记过时才将其标记为变脏。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] != <span class="number">0</span>)</span><br><span class="line">	CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>注：写屏障并非解决并发乱序执行问题的内存屏障</p>
<h3 id="6-并发的可达性问题"><a href="#6-并发的可达性问题" class="headerlink" title="6. 并发的可达性问题"></a>6. 并发的可达性问题</h3><p><strong>问题</strong>：为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？<br>分析：把遍历对象图过程中遇到的对象,按照”是否访问过”这个条件标记成以下三种颜色:</p>
<ul>
<li>白色:表示对象尚未被垃圾收集器访问过。若在分析结束的阶段,仍然是白色的对象,即代表不可达。</li>
<li>黑色:表示对象已经被垃圾收集器访问过,且这个对象的所有引用都已经扫描过,代表安全存活的对象。</li>
<li>灰色:表示对象已经被垃圾收集器访问过,但这个对象上至少存在一个引用还没有被扫描过。</li>
</ul>
<p>可达性分析的扫描过程,可以看作对象图上一股以灰色为波峰的波纹从黑向白推进的过程。</p>
<p>如果用户线程与收集器并发工作,收集器在对象图上标记颜色,同时用户线程在修改引用关系,这样可能出现两种后果：</p>
<ul>
<li>把原本消亡的对象错误标记为存活：这可以容忍,只不过产生了逃过本次收集的浮动垃圾而已。</li>
<li>是把原本存活的对象错误标记为已消亡：这就是非常致命的后果了,程序肯定会因此发生错误。<br><img src="https://img2020.cnblogs.com/blog/1839532/202003/1839532-20200304165948953-1096266345.png" alt="img"></li>
</ul>
<p>Wilson于1994年在理论上证明了,当且仅当以下两个条件同时满足时,会产生”对象消失”的问题,即原本应该是黑色的对象被误标为白色:</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用;</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<p><strong>解决</strong></p>
<ul>
<li>增量更新(Incremental Update)：破坏第一个条件,当黑色对象插入新的指向白色对象的引用关系时,将这个新插入的引用记录下来,等并发扫描结束之后,再将这些记录过的引用关系中的黑色对象为根,重新扫描一次。这可以理解为,黑色对象一旦新插入了指向白色对象的引用之后,它就变回灰色对象了。</li>
<li>原始快照(Snapshot At The Beginning,SATB)：破坏第二个条件,当灰色对象要删除指向白色对象的引用关系时,就将这个要删除的引用记录下来,在并发扫描结束之后,再将这些记录过的引用关系中的灰色对象为根,重新扫描一次。这可以理解为,无论引用关系删除与否,都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>如果说收集算法是内存回收的方法论,那垃圾收集器就是内存回收的实践者。《Java虚拟机规范》中并没有规定垃圾收集器应如何实现,因此不同厂商、版本的虚拟机所包含的垃圾收集器可能会有很大差别,不同的虚拟机一般会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。</p>
<h3 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h3><p>经典垃圾收集器指的是在JDK 7 Update 4之后、JDK 11正式发布之前,OracleJDK中的HotSpot虚拟机所包含的全部可用的垃圾收集器。<br>与几款目前仍处于实验状态,但执行效果上有革命性改进的高性能低延迟收集器区分开来,这些经典的收集器尽管已经算不上是最先进的技术,但它们曾在实践中千锤百炼,足够成熟,基本上可认为是现在到未来两、三年内,能够在商用生产环境上放心使用的全部垃圾收集器了。<br><img src="https://i.loli.net/2019/11/22/MlIqFtL8GvVWZah.png" style="zoom:50%;" /></p>
<h3 id="新生代收集器（都是标记复制）"><a href="#新生代收集器（都是标记复制）" class="headerlink" title="新生代收集器（都是标记复制）"></a>新生代收集器（都是标记复制）</h3><h4 id="Serial：标记复制"><a href="#Serial：标记复制" class="headerlink" title="Serial：标记复制"></a>Serial：标记复制</h4><p>Serial是一个单线程工作的收集器,即使用一个处理器或一条收集线程去完成垃圾收集工作,且垃圾收集时,必须暂停其他所有工作线程,直到收集结束(Stop The World)。<br><img src="https://i.loli.net/2019/11/22/9rERYcx5Jh3tMeV.png" style="zoom: 67%;" /></p>
<p>优点：简单高效</p>
<ul>
<li>对于内存资源受限的环境,是所有收集器里额外内存消耗最小的</li>
<li>对于单核处理器或处理器核心数较少的环境来说,由于没有线程交互的开销,专心垃圾收集可以获得最高的单线程收集效率</li>
</ul>
<p>缺点: stop the world……不能忍</p>
<blockquote>
<p>此外，可以通过设置虚拟机参数 <code>-XX:+UseSeralGC</code> 来使用 Serial 收集器进行垃圾回收。</p>
</blockquote>
<h4 id="ParNew：标记复制（淘汰了）"><a href="#ParNew：标记复制（淘汰了）" class="headerlink" title="ParNew：标记复制（淘汰了）"></a>ParNew：标记复制（淘汰了）</h4><p>ParNew收集器实质上是Serial收集器的多线程并行版本,除了同时使用多条线程进行垃圾收集之外,其余的行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致。</p>
<p>然而随着更先进的作为CMS继承者的G1收集器的出现,ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案。官方甚至直接取消了<code>-XX:+/-UseParNewGC</code>参数,这意味着ParNew和CMS从此只能互相搭配使用。</p>
<p>ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。</p>
<h4 id="Parallel-Scavenge：标记复制-吞吐量"><a href="#Parallel-Scavenge：标记复制-吞吐量" class="headerlink" title="Parallel Scavenge：标记复制 + 吞吐量"></a>Parallel Scavenge：标记复制 + 吞吐量</h4><p>Parallel Scavenge收集器也是一款新生代收集器,同样是基于标记-复制算法实现的收集器,也是能够并行收集的多线程收集器。</p>
<p>特点：Parallel Scavenge的目标是达到一个可控制的吞吐量,而其他收集器关注缩短垃圾收集时用户线程的停顿时间。</p>
<p>$$<br>吞吐量(Throughput)=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}=\frac{1}{1+GCTimeRatio}<br>$$</p>
<ul>
<li>停顿时间短：适合需要与用户交互或需要保证服务响应质量的程序</li>
<li>吞吐量高：最高效率地利用处理器资源,尽快完成程序的运算任务,主要适合在后台运算而不需要太多交互的分析任务。</li>
</ul>
<p>Parallel Scavenge参数：</p>
<ul>
<li><code>-XX:MaxGCPauseMillis</code>：控制最大垃圾收集停顿时间<br>参数允许的值是一个大于0的毫秒数,收集器将尽力保证内存回收花费的时间不超过用户设定值。<br>垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的:系统把新生代调得小一些,但这也直接导致垃圾收集发生得更频繁。<br>原来10秒收集一次、每次停顿100毫秒。<br>现在变成5秒收集一次、每次停顿70毫秒。<br>停顿时间的确在下降,但吞吐量也降下来了。</li>
<li><code>-XX:GCTimeRatio</code>：直接设置吞吐量大小<br>参数的值是一个大于0小于100的整数,即垃圾收集时间占总时间的比率,近似于吞吐量的倒数。</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：自适应调节<br>当这个参数被激活之后,虚拟机会根据当前系统的运行情况收集性能监控信息,动态调整参数(新生代大小,Eden与Survivor比例等)以提供最合适的停顿时间或者最大的吞吐量。</li>
</ul>
<p>如果手工优化收集器存在困难的话,可以使用Parallel Scavenge收集器配合自适应调节策略：只需要把基本的内存数据设置好(如-Xmx设置最大堆),然后使用-XX:MaxGCPauseMillis参数(更关注最大停顿时间)或XX:GCTimeRatio(更关注吞吐量)参数给虚拟机设立一个优化目标,那具体细节参数的调节工作就由虚拟机完成了。</p>
<p>自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。</p>
<h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><h4 id="Serial-Old-标记整理"><a href="#Serial-Old-标记整理" class="headerlink" title="Serial Old: 标记整理"></a>Serial Old: 标记整理</h4><p>Serial Old是Serial收集器的老年代版本,它同样是一个单线程收集器,使用标记-整理算法。<br>这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下,它也可能有两种用途:</p>
<ul>
<li>一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用,</li>
<li>另外一种就是作为CMS收集器发生失败时的后备预案,在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
<h4 id="Parallel-Old：标记整理-吞吐量"><a href="#Parallel-Old：标记整理-吞吐量" class="headerlink" title="Parallel Old：标记整理 + 吞吐量"></a>Parallel Old：标记整理 + 吞吐量</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本,支持多线程并发收集,基于标记-整理算法实现。<br>在注重吞吐量或者处理器资源较为稀缺的场合,都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。<br><img src="https://img2020.cnblogs.com/blog/1839532/202003/1839532-20200304170046369-407129469.png" alt="img"></p>
<h4 id="CMS：标记清除-最短回收停顿时间"><a href="#CMS：标记清除-最短回收停顿时间" class="headerlink" title="CMS：标记清除 + 最短回收停顿时间"></a>CMS：标记清除 + 最短回收停顿时间</h4><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上,这类应用通常都会较为关注服务的响应速度,希望系统停顿时间尽可能短,以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。</p>
<p>步骤：</p>
<ul>
<li>初始标记(CMS initial mark)：标记GC Roots直接关联的对象，速度很快，需要停顿用户线程</li>
<li>并发标记(CMS concurrent mark)：从直接关联对象开始遍历整个对象图,过程耗时较长但是不需要停顿用户线程,可以与垃圾收集线程一起并发运行</li>
<li>重新标记(CMS remark)：为了修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,停顿时间通常会比初始标记阶段稍长一些,需要停顿用户线程</li>
<li>并发清除(CMS concurrent sweep)：清理删除掉标记阶段判断的已经死亡的对象,由于不需要移动存活对象,所以这个阶段可以与用户线程同时并发</li>
</ul>
<p>由于在整个过程中耗时最长的并发标记和并发清除阶段中,垃圾收集器线程都可以与用户线程一起工作,所以从总体上来说,CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><img src="https://img2020.cnblogs.com/blog/1839532/202003/1839532-20200304170102048-1666929154.png" alt="img"></p>
<p>优点：并发收集,低停顿</p>
<p>缺点：</p>
<ul>
<li>对处理器资源非常敏感<br>在并发阶段,它不会导致用户线程停顿,但会因为占用了一部分线程(即处理器的计算能力)而导致应用程序变慢,降低总吞吐量。<br>CMS默认启动的回收线程数是(处理器核心数量+3)/4,如果处理器核心数在四个或以上,并发回收时垃圾收集线程占用不超过25%的处理器运算资源。当处理器核心数量不足四个时,CMS对用户程序的影响就可能变得很大,可能导致用户程序的执行速度忽然大幅降低。</li>
<li>无法处理浮动垃圾,导致并发失败从而进行Stop The Wold的Full GC<br>浮动垃圾(Floating Garbage)：在CMS的并发标记和并发清理阶段,用户线程还在运行,程序还会伴随有新的垃圾对象不断产生,但这一部分垃圾对象是出现在标记过程结束以后,CMS无法在当次收集中处理掉它们,只好留待下一次垃圾收集时再清理掉。<br>同样也是由于在垃圾收集阶段用户线程还需要持续运行,所以需要预留足够内存空间提供给用户线程使用。<ul>
<li>在JDK 5的默认设置下,CMS收集器当老年代使用了68%的空间后就会被激活,这是一个偏保守的设置,可以适当调高参数<code>-XX:CMSInitiatingOccu-pancyFraction</code>的值来提高CMS的触发百分比,降低内存回收频率,获取更好的性能。</li>
<li>到了JDK 6时,CMS收集器的启动阈值默认提升至92%。若CMS运行期间预留的内存无法满足程序分配新对象的需要,就会出现一次”并发失败”(Concurrent Mode Failure),这时候虚拟机将不得不启动后备预案:冻结用户线程的执行,临时启用Serial Old收集器来重新进行老年代的垃圾收集,但这样停顿时间就很长了。</li>
</ul>
</li>
<li>收集结束时会有大量空间碎片产生<br>空间碎片过多时,将会给大对象分配带来很大麻烦,往往会出现老年代还有很多剩余空间,但就是无法找到足够大的连续空间来分配当前对象,而不得不提前触发一次Full GC的情况。</li>
</ul>
<h3 id="Garbage-First：全功能-延迟可控的情况下获得尽可能高的吞吐量"><a href="#Garbage-First：全功能-延迟可控的情况下获得尽可能高的吞吐量" class="headerlink" title="Garbage First：全功能 延迟可控的情况下获得尽可能高的吞吐量"></a>Garbage First：全功能 延迟可控的情况下获得尽可能高的吞吐量</h3><p>Garbage First(简称G1)收集器是垃圾收集器技术发展历史上的里程碑式的成果,开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p>
<p><strong>设计目标</strong><br>主要面向服务端应用,替换掉JDK 5中发布的CMS收集器。<br>建立”停顿时间模型”(Pause Prediction Model)：指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间大概率不超过N毫秒。</p>
<p><strong>设计思想</strong><br>在G1收集器出现之前的所有其他收集器,垃圾收集的目标范围要么是整个新生代(Minor GC),要么就是整个老年代(Major GC),再要么就是整个Java堆(Full GC)。<br>而G1可以面向堆内存任何部分来组成回收集(Collection Set,CSet)进行回收,衡量标准不再是它属于哪个分代,而是哪块内存中存放的垃圾数量最多,回收收益最大,这就是G1收集器的Mixed GC模式。</p>
<p><strong>内存布局</strong><br>G1不再坚持固定大小以及固定数量的分代区域划分,而是把连续的Java堆划分为多个大小相等的独立区域(Region),每一个Region都可以根据需要,扮演新生代的Eden空间、Survivor空间,或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。</p>
<p>Region中还有一类特殊的Humongous区域,专门用来存储大对象。大小超过Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数<code>-XX:G1HeapRegionSize</code>设定,取值范围为1MB-32MB,且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象,将会被存放在N个连续的Humongous Region之中,G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。</p>
<p>虽然G1仍然保留新生代和老年代的概念,但新生代和老年代不再固定,它们都是一系列区域(不需要连续)的动态集合。G1收集器之所以能建立可预测的停顿时间模型,是因为它将Region作为单次回收的最小单元,即每次收集到的内存空间都是Region大小的整数倍,这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p>
<p>更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的”价值”大小,价值即回收所获得的空间大小以及回收所需时间的经验值,然后在后台维护一个优先级列表,每次根据用户设定允许的收集停顿时间(-XX:MaxGCPauseMillis指定,默认值200毫秒),优先处理回收价值收益最大的那些Region,这也就是”Garbage First”名字的由来。这种使用Region划分内存空间,以及具有优先级的区域回收方式,保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>
<p><code>G1</code> 收集器之所以能够建立 <code>可预测的停顿时间模型</code>，是因为其跟踪各个 Region 里面的垃圾堆积的价值大小，维护了一个 <code>优先列表</code>，保证在允许的收集时间优先回收价值最大的 Region。</p>
<p>为了避免全堆扫描，在 <code>G1</code> 收集器的 Region 之间的对象引用以及其它收集器的新生代和老年代之间的对象引用，都使用的是 <code>Remembered Set</code>。对每个 Region 维护一个引用缓存 <code>Rememberd Set</code> 来提高 <code>GC Root Tracing</code> 的效率。</p>
<p>如果没有 <code>Rememberd Set</code> 操作的话，<code>G1</code> 收集器的运作步骤如下：</p>
<ul>
<li><p>初始标记（Initial Marking），标记一下 GC Root 关联的对象，并且修改 <code>Next top at Mark Start</code> 的值。</p>
</li>
<li><p>并发标记（Concurrent Marking），进行 <code>GC Roots Tracing</code>，即可达性分析。</p>
</li>
<li><p>最终标记（Final Marking），修正并发标记期间因用户程序继续运作而导致标记的变动，更新记录在 <code>Remembered Set Logs</code> 中，需要合并到 <code>Remembered Set</code> 中。</p>
</li>
<li><p>筛选回收（Live Data Counting and Evacuation），对 Region 进行回收价值和成本排序，根据用户制定的 GC 停顿时间来制定计划。</p>
</li>
</ul>
<p>  <a target="_blank" rel="noopener" href="https://i.loli.net/2019/11/25/7kvL1X9HYEbDeAS.png"><img src="https://i.loli.net/2019/11/25/7kvL1X9HYEbDeAS.png" alt="image.png"></a></p>
<img src="https://img2020.cnblogs.com/blog/1839532/202003/1839532-20200304170117335-1515287700.png" alt="img" style="zoom:50%;" />

<p>从整体来看基于”标记-整理”算法<br>从局部(两个Region之间)来看基于”标记-复制”算法</p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象的内存分配，粗略地讲，就是在堆中分配。<!--但也可能经过JIT优化被拆为标量类型并间接地在虚拟机栈中分配，详细见11章--></p>
<ul>
<li>对象主要分配在新生代的Eden区</li>
<li>如果启动了本地线程分配缓冲，将按照线程优先在TLAB上分配</li>
<li>如果是大对象，直接分配在老年代中</li>
</ul>
<p>分配的规则不是100%固定，细节取决于哪一种垃圾收集器组合，还有虚拟机参数。</p>
<h3 id="对象优先在新生代中的-Eden-分配"><a href="#对象优先在新生代中的-Eden-分配" class="headerlink" title="对象优先在新生代中的 Eden 分配"></a>对象优先在新生代中的 Eden 分配</h3><p>当 Eden 区域没有足够的空间进行分配的时候，虚拟机将进行一次 <code>Minor GC</code>，即进行一次发生在新生代的垃圾收集动作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-Xms20M -Xmx20M -Xmn10m //限制了堆的大小20M，新生代10M，老年代10M</span><br><span class="line">-XX:SurvivorRatio=8 //Eden与一个Survivor比例8：1，正好对应前文所说的的堆的可用性是80%</span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-大对象直接进入老年代"><a href="#3-6-2-大对象直接进入老年代" class="headerlink" title="3.6.2 大对象直接进入老年代"></a>3.6.2 大对象直接进入老年代</h3><p>即 <strong>大量连续空间内存的 Java 对象</strong> 直接进入老年代，常见的大对象有很长的字符串和数组。</p>
<p>虚拟机提供了 <code>-XX:PretenureSizeThreshold</code> 参数，大于这个参数的对象直接进入老年代，避免在 Eden 和两个 Survivor 之间发生大量的内存复制。</p>
<h3 id="3-6-3-长期存活的对象将进入老年代"><a href="#3-6-3-长期存活的对象将进入老年代" class="headerlink" title="3.6.3 长期存活的对象将进入老年代"></a>3.6.3 长期存活的对象将进入老年代</h3><p>分代收集的思想就是能够分别哪些对象应该放在新生代，哪些对象应该放在老年代。可以通过个每个对象定义一个 <code>对象年龄计数器</code>。如果对象在 Eden 区域出生并经过一次 Minor GC 后仍然存活，并能被 Survivor 容纳的话，则将被移动到 Survivor 空间中，同时 <code>对象年龄</code> 置为 1。默认经过15次 Minor GC 就能进入老年代。</p>
<p>可通过 <code>-XX:MaxTenuringThreshold</code> 参数设置晋升老年代的年龄阈值</p>
<h3 id="3-6-4-动态对象年龄判断"><a href="#3-6-4-动态对象年龄判断" class="headerlink" title="3.6.4 动态对象年龄判断"></a>3.6.4 动态对象年龄判断</h3><p>分代收集的思想就是能够分别哪些对象应该放在新生代，哪些对象应该放在老年代。可以通过个每个对象定义一个 <code>对象年龄计数器</code>。</p>
<p>如果对象在 Eden 区域出生并经过一次 Minor GC 后仍然存活，并能被 Survivor 容纳的话，则将被移动到 Survivor 空间中，同时 <code>对象年龄</code> 置为 1。默认经过15次 Minor GC 就能进入老年代。</p>
<p>可通过 <code>-XX:MaxTenuringThreshold</code> 参数设置晋升老年代的年龄阈值。</p>
<p>如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p>
<h3 id="3-6-5-空间分配担保"><a href="#3-6-5-空间分配担保" class="headerlink" title="3.6.5 空间分配担保"></a>3.6.5 空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有的空间：</p>
<ul>
<li>如果大于，则 Minor GC 是安全的。</li>
<li>如果不大于，则虚拟机会查看<code>HandlePromotionFailure</code>设置的值是否允许担保失败：<ul>
<li>如果允许，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小：<ul>
<li>如果大于，则尝试进行 Minor GC；</li>
<li>如果小于或 <code>HandlePromotionFailure</code> 设置的值不允许冒这个险的话，则进行 Full GC。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>但是，JDK6 Update 24 以后取消了该设置，即只要老年代连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则进行 Full GC。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter5%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter5%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">chapter5基础构建模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-19 21:07:28" itemprop="dateCreated datePublished" datetime="2020-12-19T21:07:28+08:00">2020-12-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-05-04 20:01:48" itemprop="dateModified" datetime="2022-05-04T20:01:48+08:00">2022-05-04</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>第四章介绍了构造线程安全类时采用的一些技术，例如将线程安全性委托给现有的线程安全类。委托是创建线程安全类的一个最有效的策略，只需让现有的线程安全类管理所有的状态即可。<br>JAVA平台类库中包含了一个并发构建块的丰富集合，如线程安全的容器与同步工具。</p>
<h2 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h2><p>同步容器类包括Vector和HashTable，此外还包括JDK1.2中才被加入的类。同步包装类Collections.synchronizedXxx工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。<!--哎，这些同步，即阻塞，实际上是避免了并发访问，降低了性能--></p>
<h3 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h3><p>同步容器类都是线程安全的，但在某些情况下，可能需要额外的客户端加锁来保护复合操作。</p>
<p>容器上常见的复合操作包括：</p>
<ul>
<li>迭代<ul>
<li><strong>反复访问元素，直到遍历完容器中的所有元素</strong>。</li>
</ul>
</li>
<li>跳转<ul>
<li><strong>根据指定顺序找到当前元素的下一个元素</strong>。</li>
</ul>
</li>
<li>条件运算，例如<strong>「”若没有，则添加”」</strong><ul>
<li><strong>检查在 Map 中是否存在键值 K，如果没有，就加入一个二元组 (K,V)。</strong></li>
</ul>
</li>
</ul>
<p>在同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但当其他线程并发地修改容器时，它们可能会出现意料之外的行为。</p>
<!--同步容器的这些复合操作，本身是没有线程问题的，但是如果有多个线程对同步容器同时进行操作，那么就会造成这些复合操作互相影响对方的情况， 即并发问题。-->

<p>操作Vector（同步容器）的复合操作可能导致混乱的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">	list.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些方法看似没有任何问题，无论多少个线程同时调用它们，也不破坏Vector。如果线程A在包含10个元素的Vector 上调用getLast，同时线程B在同一个Vector 上调用deleteLast，getLast 将抛出ArrayIndexOutOfBoundsException异常。在调用 size与调用getLast这两个操作之间，Vector变小了，因此在调用size时得到的索引值将不再有效。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/63543475d08cb404311697b63efe6a76.png" alt="img"></p>
<p>由于同步容器要遵守同步策略，即支持客户端加锁，因此可能会创建一些新的操作，只要我们知道应该使用哪一个锁，那么这些新操作就与容器的其他操作一样都是原子操作。同步容器类通过其自身的锁来保护它的每个方法。通过给得容器类的锁，我们可以使getLast和deleteLast成为原子操作，并确保Vector的大小在调用size和get之间不会发生变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">		<span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">		<span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">		list.remove(lastIndex); </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在调用size和相应的get之间，Vector的长度可能会发生变化，这种风险在对Vector中的元素进行迭代时仍然会出现，多线程环境下迭代过程中也可能抛出ArrayIndexOutOfBoundsException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)</span><br><span class="line">    doSomething(vector.get(i));</span><br></pre></td></tr></table></figure>

<!--迭代过程中可能抛出异常，但并不意味着Vector就不是线程安全-->。Vector的状态仍然是有效的，事实上异常恰好使它保持规范的一致性。然而，在正常或迭代读过程中抛出异常的确不是人们所期望的。

<p>造成迭代不可靠的问题同样可以通过在客户端加锁来完成，通过在迭代期间持有Vector的锁，防止其他线程在迭代期间修改Vector，这样完全阻止了其他线程在这期间访问它，如果集合很大或者对每个元素执行的任务耗时比较长，<strong>这会削弱并发性</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)</span><br><span class="line">        doSomething(vector.get(i));<span class="comment">//还要持有另一个锁，这是一个产生死锁风险的因素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器与ConcurrentModificationException"><a href="#迭代器与ConcurrentModificationException" class="headerlink" title="迭代器与ConcurrentModificationException"></a>迭代器与ConcurrentModificationException</h3><p>尽管上面讨论的Vector是“遗留”下来的容器类，这只是说明同步容器有这样的问题。其实，“现代”的容器类也并没有消除复合操作产生的问题，比如迭代复合操作，当其他线程并发修改容器时，使用迭代器仍然避免不了在使用的地方加锁，在设计同步容器返回迭代器时，并没有使用同步（注，这里讲的是说返回的迭代器不是线程安全，而不是指返回迭代器的方法iterator() 没有使用同步，它本身就是经过同步了的。），因为他们是“及时失败”——只要有其他线程修改容器结果，立马就会抛出未检查性异常ConcurrentModificationException。</p>
<p>这种”及时失败“的迭代器并不是一种完备的处理机制，而只是”善意地“捕获并发错误，因此只能作为并发问题的预警指示器。它们采用的实现方式是，将计算器的变化与容器关联起来：如果在迭代期间计数器被修改，那么hasNext或next将抛出ConcurrentModificationException。然而，这种检查是在没有同步的情况下进行的，因此可能会看到失效的计数值，而迭代器可能并没有意识到已经发生了修改。这是设计上得权衡，从而降低并发修改并发操作的检测代码对程序性能带来的影响。</p>
<p>注：ConcurrentModificationException也可能出现在单线程的代码中，如果对象不是调用Iterator.remove，而是直接从容器中删除就会出现这种情况。</p>
<p>for-each循环语法对容器进行迭代时，也是隐式地用到了Iterator，从内部来看，javac将生成使用Iterator的代码，反复调用hasNext和next来迭代List对象，与迭代Vector一样，想要避免ConcurrentModificationException，就必须在迭代过程持有容器的锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Widget&gt; widgetList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Widget&gt;());</span><br><span class="line">...</span><br><span class="line"><span class="comment">// May throw ConcurrentModificationException</span></span><br><span class="line"><span class="keyword">for</span> (Widget w : widgetList)</span><br><span class="line">    doSomething(w);</span><br></pre></td></tr></table></figure>

<p>有时候开发人员并不希望在迭代期间对容器加锁，例如，某些线程在可以访问容器之前，必须等待迭代过程结束，如果容器规模很大，或者在每个元素上执行操作的时间很长，那么这些线程将长时间等待。即使不存在饥饿或者死锁等风险，长时间地对容器加锁也会降低程序的可伸缩性。持有锁的时间越长，那么在锁上的竞争就可能越激烈，如果许多线程在等待锁被释放，那么将极大地降低吞吐量和CPU的利用率。<!--这一点如同mysql的Update操作，导致数据被加上行锁（排他），其他读写操作就会一直等待甚至超时报错--></p>
<p><strong>如果不希望在迭代期间对容器加锁，那么一种替代方法就是”克隆“容器，并在副本上进行迭代。</strong>由于副本被封闭在线程内，因此其他线程不会在迭代期间对其进行修改，这样就避免了抛出ConcurrentModificationException（在克隆过程中仍然需要对容器加锁）。在克隆容器时存在显著地性能开销。这种方式的好坏取决于多个因素，包括容器的大小，在每个元素上执行的工作，迭代操作相对于容器其他操作的调用频率，以及在响应时间和吞吐量等方面的需求。</p>
<h3 id="隐藏迭代器"><a href="#隐藏迭代器" class="headerlink" title="隐藏迭代器"></a>隐藏迭代器</h3><p>你必须要记住，所有需要对共享容器进行迭代的地方都需要加锁。实际情况更加复杂，因为迭代器有时是隐藏的，就像下面代码一样，容器的toString方法的实现是通过迭代容器中的每个元素。编译器将字符串的连接操作转换为调用StringBuilder.append(Object),而这个方法又会调用容器的toString方法，标准容器的toString方法将迭代容器，并在每个元素上调用toString来生成容器内容的格式化表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer i)</span> </span>&#123; set.add(i); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTenThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            add(r.nextInt());</span><br><span class="line">        System.out.println(<span class="string">&quot;DEBUG: added ten elements to &quot;</span> + set);<span class="comment">//这里会隐式地使用迭代</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toString对容器进行迭代。当然真正的问题是HiddenIterator不是线程安全的。在使用println的set之前必须首先获取HiddenIterator的锁，但在调试代码和日志代码中通常会忽视这个要求。</p>
<p>如果状态与保护它的同步代码之间相隔越远，那么开发人员就越容易忘记在访问状态时使用正确的同步。如果将HashSet包装为synchronizedSet，并且对同步代码进行封装，就不会出现ConcurrentModificationException异常了。</p>
<blockquote>
<p>正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。</p>
</blockquote>
<p>容器的hashCode和equals等方法也会间接地执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。同样，containsAll、removeAll和retainAll等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接地迭代操作都可能抛出ConcurrentModificationException。</p>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>Java5.0提供了多种并发容器类来改进同步容器的性能。同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。<strong>代价是降低并发性，当多个线程竞争容器的锁时，吞吐量将严重减低</strong>。<!--就是就是，锁这种依靠同步，来排斥和阻塞其他线程的设计，分明是搞串行化设计，多核系统还有什么用--></p>
<p>另一方面，并发容器是针对多个线程并发访问设计的。在JAVA5.0中，增加了<code>ConcurrentHashMap</code>用来替代同步且基于散列的Map。增加了<code>CopyOnWriteArrayList</code>，用于在遍历操作为主要操作情况下代替同步的<code>List</code>。</p>
<p>在新的ConcurrentMap接口中增加了对一些常见复合操作的支持，例如”若没有刚添加”、替换以及有条件删除等。</p>
<blockquote>
<p>通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。</p>
</blockquote>
<p>Java5.0增加了两种新的容器类型：<code>Queue</code>和<code>BlockingQueue</code>。</p>
<p><code>Queue</code>用来保存一组等待处理的元素。它提供了几组实现：</p>
<ul>
<li><p><code>ConcurrentLinkedQueue</code>，先进先出队列。</p>
</li>
<li><p><code>PriorityQueue</code>，非并发的优先队列。</p>
</li>
</ul>
<p><code>Queue</code>上的操作<strong>不会阻塞</strong>，如果队列为空，返回空。虽然可以用List来模拟Queue的行为 — 事实上Queue是用LinkedList来实现Queue，但是<strong>还是需要一个Queue类，因为Queue能去掉List的随机访问需求，从而实现更高效的并发</strong>。</p>
<p><code>BlockingQueue</code><strong>扩展了</strong>Queue，<strong>增加了可阻塞的插入和获取等操作</strong>。队列为空，阻塞获取直到出现一个可用元素。如果队列满了（对于有界队列），那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。<!--在生产者----消费者设计模式中，阻塞队列是非常有用的。--></p>
<p>Java6引入了<code>ConcurrentListMap</code>和<code>ConcurrentSkipListSet</code>，分别作为同步的<code>SortedMap</code>和<code>SortedSet</code>的并发替代品。例如用synchronizedMap包装的TreeMap或TreeSet。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><strong>同步容器类在执行每个操作期间都持有一个锁。</strong><!--先给出了一个重要的结论--></p>
<p>在一些操作中，例如HashMap.get或List.contains, 可能包含大最的工作： 当遍历散列桶或链表来查找某个特定的对象时，必须在许多元素上调用equals (而equals本身还包含一定的计算量）。在基于散列的容器中， 如果<code>hashCode</code><strong>不能很均匀地分布散列值，那么容器中的元素就不会均匀地分布在整个容器中</strong>。</p>
<blockquote>
<p>某些情况下，某个糟糕的散列函数还会把一个<strong>散列表变成线性链表</strong>。当遍历很长的链表并且在某些或者全部元素上调用equals方法时，会花费很长的时间，而其他线程在这段时间内都不能访问该容器。</p>
</blockquote>
<!--【使用同步容器类在并发环境下的窘境，所以 JDK5的时候引入了并发包，引入了并发容器，这是并发容器为什么出现的技术背景】-->

<p>与HashMap 一样，ConcurrentHashMap也是一个基于散列的Map, 但它使用了一种完全不同的加锁策略来提供更高的并发性和伸缩性。</p>
<p><strong>ConcurrentHashMap 并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器， 而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁(Lock Striping, 请参考11.4.3节）。</strong><!--分段锁的优势，就是支持并发，而不是同步--></p>
<p>在这种机制中，任意数量的读取线程可以并发地访问Map, 执行读取操作的线程和执行写入操作的线程可以并发地访问Map, 并且一定数量的写入线程可以并发地修改Map。ConcurrentHashMap带来的结果是，<strong>在并发访问环境下将实现更高的吞吐， 而在单线程环境中只损失非常小的性能。</strong></p>
<p>ConcurrentHashMap与其他并发容器一起增强了同步容器类：</p>
<ul>
<li>它们提供的迭代器不会抛出ConcurrentModificationException, 因此<strong>不需要在迭代过程中对容器加锁</strong>。<!--提高了伸缩性--></li>
<li>ConcurrentHashMap返回的迭代器具有<strong>弱一致性</strong>(Weakly Consistent), 而并非“ 及时失败”。<strong>弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素， 并可以（但是不保证） 在迭代器被构造后将修改操作反映给容器。</strong></li>
</ul>
<p>尽管有这些改进，但仍然需要一些权衡的因素。 对于一些需要在整个 Map 上进行计算的方法，例如 <code>size</code> 和 <code>isEmpty</code> ，<strong>这些方法的语义被略微减弱了，以反映容器的并发特性</strong>。</p>
<p>由于 <code>size</code>返回的结果在计算时可能已经过期了，它实际上只是一个估计值，因此允许 <code>size</code> 返回一个近似值而不是 精确值。 虽然这看上去令人有些不安，但事实上， <code>size</code> 和 <code>isEmpty</code>这样的方法在并发环境下的用处很小，因为它们的返回值总在不断地变化。因此，这些操作的需求被弱化了，以换取对其他更重要操作的性能优化：比如 get、put、containsKey 和 remove 等。</p>
<!--这就是典型的根据场景，决定需求，舍弃相对不重要的东西，这种思想对于一个工科的工程师来说，都是非常重要的。-->

<p><strong>在ConcurrentHashMap 中没有实现对Map 加锁以提供独占访问</strong>。在Hashtable 和synchronizedMap中， 获得Map 的锁能防止其他线程访问这个Map。在一些不常见的情况中需要这种功能，例如通过原子方式添加一些映射， 或者对Map 迭代若干次并在此期间保持元素顺序相同。然而， 总体来说这种权衡还是合理的， <strong>因为并发容器的内容会持续变化</strong>。<!--【这是并发容器要面对的场景的核心特性】--></p>
<h3 id="额外的原子Map操作"><a href="#额外的原子Map操作" class="headerlink" title="额外的原子Map操作"></a>额外的原子Map操作</h3><p><strong>ConcurrentHashMap不能被加锁 来执行独占访问，因此我们无法使用客户端加锁来创建新的原子操作。</strong><!--惨兮兮，但是可以用第二种方式 -- 组合的方式对ConcurrentHashMap进行自定义拓展了-->但是一些常见的复合操作，例如”若没有则添加”，”若相等则移除”，”若相等则替换”等，都已经实现为原子操作并且在ConcurrentMap接口中声明。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList 用于替代同步List, 在某些情况下它提供了更好的并发性能，<strong>并且在迭代期间不需要对容器进行加锁或复制。</strong>（类似地， CopyOnWriteArraySet 的作用是替代同步Set。)</p>
<p>“ 写入时复制(Copy-On-Write)” 容器的线程安全性在于， <strong>只要正确地发布一个事实不可变的对象， 那么</strong></p>
<ul>
<li>在访问该对象时，就不再需要进一步的同步。</li>
<li>在每次修改时， 都会创建并重新发布一个新的容器副本， 从而实现可变性。</li>
</ul>
<p>“ 写入时复制 ” 容器的迭代器<strong>保留一个指向底层基础数组的引用</strong>， 这个数组当前位于迭代器的起始位置， 由于它不会被修改， 因此在对其进行同步时只需确保数组内容的可见性。因此， 多个线程可以同时对这个容器进行迭代， 而不会彼此干扰或者与修改容器的线程相互干扰。 “ 写入时复制 ” 容器返回的迭代器不会抛出ConcurrentModificationException, 并且返回的元素与迭代器创建时的元素完全一致， 而不必考虑之后修改操作所带来的影响。</p>
<p>显然， 每当修改容器时都会复制底层数组， 这需要一定的开销， 特别是当容器的规模较大时。 <strong>仅当迭代操作远远多于修改操作时， 才应该使用 “ 写入时复制” 容器</strong>。 这个准则很好地描述了许多事件通知系统：在分发通知时需要迭代已注册监听器链表， 并调用每一个监听器， 在 大多数情况下， 注册和注销事件监听器的操作远少于接收事件通知的操作。<!--给我的感觉是，像InnoDB事务中的MVCC和写锁，多个线程写的时候，不仅加上写锁，而且在MVCC中添加一个版本号--></p>
<h2 id="阻塞队列和生产者—消费者模式"><a href="#阻塞队列和生产者—消费者模式" class="headerlink" title="阻塞队列和生产者—消费者模式"></a>阻塞队列和生产者—消费者模式</h2><p>阻塞队列提供了<strong>可阻塞的put和take方法</strong>，以及<strong>支持实时的offer和poll方法</strong>。</p>
<ul>
<li>如果队列满了，那么put方法将阻塞直到有空间可用；</li>
<li>如果队列为空，那么take方法会阻塞到直到有元素可用。</li>
<li>队列可以是有界的也可以是无界的，无界队列永远都不会充满 ，因此put永远不会阻塞。</li>
</ul>
<p>阻塞队列支持生产者—消费者这种设计模式，该模式把找出需要完成的工作与执行工作这两个过程分离开来，并把工作项放到一个”待完成”列表中以便随后处理，而不是找出后立即处理。它能简化开发过程，因为它消除了生产者类和消费者类之间的代码依赖性，此外，该模式还将生产数据的过程与使用数据的过程解耦开来以简化工作负载的管理，因为这两个过程在处理数据的速率上有所不同。</p>
<p>在基于阻塞队列构建的生产者—消费者设计中，当数据生成时，生产者把数据放入队列，而当消费者准备处理数据时，将从队列中获取数据。生产者不需要知道消费者的标识和数量，只需要将数据放队列即可，同样，消费者也不需要知道生着者是谁。BlockingQueue简化了生产者—消费者设计的实现过程，它支持任意数量的生产者和消费者。一种最常见的生产者—消费者设计模式就是线程池与工作队列的组合，在Executor任务执行框架中就体现了这种模式。这也是第6章和第8章的主题。</p>
<p>阻塞队列简化了消费者程序的编码，因为take操作会一直阻塞直到有可用的数据。如果生产者不能尽快地产生工作项使消费者保持忙碌，那么消费者就只能一直等待，直到有工作可做。<!--在某些情况下，例如服务器应用程序中，没有任何客户请求服务-->，而在其他一些情况下，这也表示需要调整生产者线程数量和消费者线程数量之间的比率，从而实现更高的资源利用率。（比如，在“网页爬虫”中，有无穷的工作需要完成）。</p>
<p>同样，put方法的阻塞特性也极大地简化了生产者的编码。如果使用有界队列，那么当队列充满时，生产者将阻塞并且不能继续生成工作，而消费者就有时间来赶上工作处理进度。</p>
<blockquote>
<p>在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抵制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。</p>
</blockquote>
<p>虽然生产者-消费者模式能够将生产者和消费者的代码彼此解耦开来，但它们的行为仍然会通过共享工作队列间接地耦合在一起。</p>
<p>开发人员总会假设消费者处理工作的速率能赶上生产者生成工作项的速率，因此通常不会为工作队列的大小设置边界，但这将导致在之后需要重新设计系统架构。因此，应该尽早地通过阻塞队列在设计中构建资源管理机制—这件事情做得越早，就越容易。<!--在许多情况下，阻塞队列能使这项工作更加简单，如果阻塞队列并不完全符合设计需求，那么还可以通过信号量（Semaphore）来创建其他的阻塞数据结构（请参见5.5.3节）。在类库中包含了BlockingQueue的多种实现。--></p>
<p>在类库中包含了BlockingQueue的多种实现</p>
<ul>
<li>LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，二者分别与LinkedList和ArrayList类似，但比同步List拥有更好的并发性能。</li>
<li>PriorityBlockingQueue是一个按优先级排序的队列，当你希望按照某种顺序而不是FIFO来处理元素时，这个队列将非常有用。正如其他有序的容器一样，PriorityBlockingQueue既可以根据元素的自然顺序来比较元素（如果它们实现了Comparable方法），也可以使用Comparator来比较。</li>
<li>SynchronousQueue实际上不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。如果以洗盘子的比喻为例，那么这就相当于没有盘架，而是将洗好的盘子直接放入下一个空闲的烘干机中。这种实现队列的方式看似很奇怪，但由于可以直接交付工作，<strong>从而降低了将数据从生产者移动到消费者的延迟</strong>。（在传统的队列中，在一个工作单元可以交付之前，必须通过串行方式首先完成入列[Enqueue]或者出列[Dequeue]等操作。）直接交付方式还会将更多关于任务状态的信息反馈给生产者。当交付被接受时，它就知道消费者已经得到了任务，而不是简单地把任务放入一个队列——这种区别就好比将文件直接交给同事，还是将文件放到她的邮箱中并希望她能尽快拿到文件<!--一个是及时的，一个是异步的-->。因为SynchronousQueue没有存储功能，因此put和take会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。</li>
</ul>
<h3 id="示例：桌面搜索"><a href="#示例：桌面搜索" class="headerlink" title="示例：桌面搜索"></a>示例：桌面搜索</h3><p>有一种类型的程序适合被分解为 生产者 和 消费者，例如 代理程序，它将扫描本地驱动器上的文件并建立索引以便随后进行搜索，类似于某些桌面搜索程序或者 Windows 索引服务。</p>
<p>在 **程序清单 5-8 ** 的 <code>DiskCrawler</code> 中给出了一个生产者任务，即在某个文件层次结构中搜索 符合索引标准的文件，并将它们的文件名 放入 「工作队列」。而且 <code>Indexer</code> 中还给出了一个消费者任务，从队列中取出文件名称并对它们建立索引。</p>
<blockquote>
<p><strong>程序清单 5-8</strong> 桌面搜索应用程序中的生产者任务和消费者任务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个关于 桌面搜索程序的对生产者和消费者的应用实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来抓取桌面文件内容的生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCrawler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 阻塞队列，用于存储要索引的文件</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; fileQueue;</span><br><span class="line">        <span class="comment">// 文件的过滤器，判断是否要将文件放入队列</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> FileFilter fileFilter;</span><br><span class="line">        <span class="comment">// 具体的被处理的队列中的生产资源，在这个例子中是file</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> File root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FileCrawler</span><span class="params">(BlockingQueue&lt;File&gt; fileQueue, FileFilter fileFilter, File root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fileQueue = fileQueue;</span><br><span class="line">            <span class="keyword">this</span>.root = root;</span><br><span class="line">            <span class="comment">// 重写了 accept 方法</span></span><br><span class="line">            <span class="keyword">this</span>.fileFilter = f -&gt; f.isDirectory() || fileFilter.accept(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回是否已经对文件进行索引，但是这里没有进行判断，直接返回的就是 false</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">alreadyIndexed</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                crawl(root);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将桌面中的所有 文件放入 fileQueue 中</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">crawl</span><span class="params">(File root)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            File[] entries = root.listFiles(fileFilter);</span><br><span class="line">            <span class="keyword">if</span> (entries != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (File entry : entries) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">                        crawl(entry);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 但是这里 返回的肯定是 false 然后 变成 true 进入 put 逻辑</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!alreadyIndexed(entry)) &#123;</span><br><span class="line">                        fileQueue.put(entry);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者，获取队列中的元素，这里是文件，然后对其进行索引（方法逻辑未实现，只是列出其逻辑）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Indexer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Indexer</span><span class="params">(BlockingQueue&lt;File&gt; queue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    indexFile(queue.take());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 发生异常就使线程停止</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 对文件进行索引编号的方法，这里书中并没有实现具体逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产者 — 消费者 模式提供了一种 适合线程的方法将 桌面搜索问题分解为 更简单的组件</strong>。 将 「文件遍历」 与建立索引等功能分解为独立的操作，比将所有功能都放到一个操作中实现有着更高的 「代码可读性」 和 「可重用」性：每个操作只需要完成一个任务，并且阻塞队列将负责所有的控制流，因此每个功能的代码都更加简单清晰。</p>
<!--【也就是将逻辑控制完全交给了阻塞队列，从而使 生产 和 消费 2个动作独立，各自逻辑自己处理，分解成2个独立的块，更加清晰，这部分设计的意图我弄明白了，这是 生产者--消费者模式在代码设计上带来的好处】-->

<p>生产者 — 消费者 模式同样能带来许多<strong>「性能优势」</strong>。 生产者 — 消费者 可以并发地执行。如果一个是 I/O 密集型，另一个是 CPU 密集型，那么并发执行的吞吐率要高于 串行执行的吞吐率。</p>
<p>如果生产者和消费者的「并行度」不同，那么将它们紧密耦合在一起会把整体并行度降低为二者中更小的并行度。</p>
<!--【也就是木桶理论，性能最差的部分决定整个程序的性能】-->

<p>在<strong>程序清单 5-9</strong> 中启动了多个爬虫程序和索引建立程序，每个程序都在各自的线程中运行。前面提到过，消费者线程永远不会退出，因而程序无法终止， <a target="_blank" rel="noopener" href="https://github.com/funnycoding/blog/issues/27">第7章</a> 将介绍多种技术来解决这个问题。<!--【并发中的终止问题】--></p>
<p>虽然这个示例使用了 显示管理 的线程，<strong>但许多 生产者—消费者 的设计也可以通过 <code>Executor</code> 任务执行框架来实现，其本身使用的也是 生产者 — 消费者模式。</strong> <strong>【 使用线程池 Executor 也间接的使用了 生产者 — 消费者 模式】</strong></p>
<blockquote>
<p>程序清单 5-9 启动桌面搜索</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设定队列的界限</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOUND = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置消费者的数量，这里是获取当前运行环境的CPU核心数并将其设置为消费者数量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N_CONSUMERS = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startIndexing</span><span class="params">(File[] roots)</span> </span>&#123;</span><br><span class="line">       BlockingQueue&lt;File&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(BOUND);</span><br><span class="line"></span><br><span class="line">       FileFilter filter = pathname -&gt; <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 生产者,将文件放入 queue 中，填充要标记的文件队列</span></span><br><span class="line">       <span class="keyword">for</span> (File root : roots) &#123;</span><br><span class="line">           <span class="comment">// 每个 roots 分配一个线程用来填充要进行标记的文件队列</span></span><br><span class="line">           <span class="keyword">new</span> Thread(<span class="keyword">new</span> FileCrawler(queue, filter, root)).start();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 消费者,消费队列中的文件，对其进行 indexFile() 标记方法</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N_CONSUMERS; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> Thread(<span class="keyword">new</span> Indexer(queue)).start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="串行线程封闭"><a href="#串行线程封闭" class="headerlink" title="串行线程封闭"></a>串行线程封闭</h3><p>在 <code>java.util.concurrent</code> Java 并发包中实现的各种阻塞队列 都包含了足够的 内部同步机制，从而安全地将对象从 「生产者线程」 发布到 「消费者线程」。</p>
<p>对于可变对象， 生产者—消费者 这种设计与阻塞队列一起，促进了<strong>线程封闭</strong>，从而将对象所有权从生产者交付给消费者。</p>
<p>线程封闭对象只能被单个线程持有，但可以通过安全地 「发布」 该对象来 “转移” 对象的所有权。 在转移所有权之后也只有另一个线程能获得这个对象的访问权限，并且发布对象的线程不会再访问它。</p>
<p>这种安全的发布确保了对象状态对于 新的所有者 来说是可见的，并且由于最初的所有者不会再访问它，因此对象被封闭在新的 线程中。</p>
<p>新的所有者线程可以任意对该对象进行修改，因为它具有 独占 的访问权。</p>
<p>「对象池」 利用了 串行线程封闭，将对象 “借给” 一个请求线程。 只要对象池内包含足够的 内部同步 来安全地发布池中的对象，并且只要客户代码本身不会发布池中对象，或者在将对象返回给对象池之后就不再使用它，那么就可以安全地在线程之间传递所有权。</p>
<!-- 串行体现在流程上： 比如 生产者线程持有对象 -> 生产者线程放弃对象，交给Queue-> 消费者获取对象；又比如, 客户端持有对象 -> 客户端放弃对象，交给对象池 -> 对象池中某个线程获取对象。 看到没，这些流程都是串行进行的  -->

<p>我们也可以使用其他发布机制来传递 可变对象 的所有权，<strong>但必须确保只有一个线程能接受被转移的对象。</strong>【基本条件】 阻塞队列简化了这项工作，除此之外，还可以通过 <code>ConcurrentMap</code> 的原子方法 <code>remove</code> 或者 <code>AtomicReference</code> 的原子方法 <code>compareAndSet</code> 来完成这项工作。</p>
<h3 id="双端队列与工作密取"><a href="#双端队列与工作密取" class="headerlink" title="双端队列与工作密取"></a>双端队列与工作密取</h3><p>Java 6 增加了两种容器类型 ，<code>Deque</code>（发音为 “deck”）和 <code>BlockingDeque</code> ，它们分别对 <code>Queue</code> 和 <code>BlockingQueue</code> 进行了扩展。</p>
<p>Deque 是一个 「双端队列」，实现了在队列头和队列尾的<strong>高效插入和移除</strong><!--也就是高效修改操作-->，具体实现包括 <code>ArrayDeque</code> 和 <code>LinkedBlockingDeque</code>。</p>
<p>正如阻塞队列适用于 “生产者—消费者” 模式，所有消费者有一个共享的工作队列，而在 「工作密取」设计中，每个消费者都有各自的双端队列。<!--从共享变为了独享--></p>
<p>如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾 「秘密地获取工作」。<!--说明消费者可以获取其他消费者队列的末尾的数据--></p>
<p>这种工作模式有优势的原因：</p>
<ul>
<li>在 「大多数时候」，消费者只访问自己的双端队列，从而极大地减少了竞争。</li>
<li>当消费者线程需要访问另一个队列时，它会从队列的「尾部」 而不是 「头部」获取工作，因此进一步降低了队列上的竞争程度。</li>
</ul>
<p>「工作密取」非常适用于既是消费者，也是生产者的问题 —— 当执行某个工作时可能导致出现更多的工作。</p>
<p>例如： 在网页爬虫程序中处理一个页面时，通常会发现有更多的页面需要处理。类似的还有很多 图 搜索的算法，例如在 垃圾回收阶段对 堆进行标记，都可以通过 工作密取 机制来实现 「高效并行」。 当一个工作线程找到新的任务单元时，它会将其放到自己队列的末尾（或者在<strong>工作共享设计模式</strong>中，放入其他工作者线程队列中）。</p>
<p>当「双端队列」 为空时，它会在另一个线程的队列队伍查找新的任务，从而确保每个线程都保持忙碌状态。<strong>【这个设计可以很好的提高线程的利用率】</strong></p>
<h2 id="阻塞方法与中断方法"><a href="#阻塞方法与中断方法" class="headerlink" title="阻塞方法与中断方法"></a>阻塞方法与中断方法</h2><p>线程可能会阻塞或暂停执行，原因有多种：</p>
<ul>
<li><strong>等待 I/O 操作结束</strong></li>
<li><strong>等待获取一个锁</strong></li>
<li><strong>等待从 Thread.sleep 方法中醒来</strong></li>
<li><strong>等待另一个线程的计算结果</strong></li>
</ul>
<p>当<strong>线程阻塞</strong>时，它通常被<strong>「挂起」</strong>，并处于某种<strong>『阻塞状态』</strong>（BLOCK、WAITING 或 TIMED_WAITING）。阻塞操作与执行时间很长的普通操作的差别在于 ： 被阻塞的线程必须等待某个不受它控制 的事件发生后 才能继续执行，例如「等待 I/O 操作完成」，「等待某个锁可用」，或者「等待外部计算的结束」。</p>
<p>当某个外部事件发生时，线程被置回 <strong>RUNABLE</strong> 可运行状态，并可以再次被调度执行。</p>
<p><code>BlockingQueue</code> 的 <code>put</code> 和 <code>take</code> 等方法会抛出 <strong>受检查异常</strong>（<strong>Checked Exception</strong>） <code>InterruptedException</code>，这与类库中其他一些方法的做法相同，例如 <code>Thread.sleep</code>。</p>
<p>当某方法抛出 <code>InterruptedException</code> 时，表示该方法是一个<strong>阻塞方法</strong>，如果这个方法被中断，那么它将努力提前结束 「阻塞状态」。&lt;—【阻塞方法的定义，比如 <code>Thread.sleep</code>】</p>
<p><code>Thread</code> 提供了 <code>interrupt</code> 方法，用于中断线程或者查询线程是否已经被中断。 每个线程都有一个布尔类型的属性，表示线程的中断状态，当中断线程时，将设置这个状态。</p>
<p>中断是一种<strong>「协作机制」</strong>，一个线程不能强制其他线程停止正在执行的操作而去执行其他的操作。&lt;—【也就是只能建议，而不能强制停止】</p>
<p>当 「线程A」 中断 「线程B」 时，A 仅仅是要求 B 在执行到某个可以暂停的地方停止正在执行的操作 —— 前提是 「线程B」 <strong>愿意</strong>停止下。虽然在 API 或者 语言规范中并没有为中断定义任何特定应用级别的语义，但最常使用中断的情况就是 「<strong>取消某个操作</strong>」。</p>
<p>方法对中断请求的响应度越高，就越容易及时取消那些执行时间很长的操作。&lt;—【那么方法的响应度是可以设置的吗？ 总是把话说一半。。。】</p>
<p>当在代码中调用了一个将抛出 InterruptedException 异常的方法时，你自己的方法也就变成了一个阻塞方法，并且必须要处理对中断的响应，对于库代码来说，有两种基本选择：</p>
<ul>
<li><p>传递<code>InterruptedException</code>。避开这个异常通常是最明智的策略 —— 只需要把 InterruptedException 抛出给方法的调用者。</p>
<ul>
<li>根本不捕获该异常。</li>
</ul>
</li>
<li><p>捕获该异常，在执行某种简单的清理工作后再次抛出该异常。</p>
</li>
<li><p>恢复中断。 当不能抛出 <code>InterruptedException</code> 时，例如 当代码是 <code>Runnable</code> 的一部分时，这种情况下必须捕获 <code>InterruptedException</code>，并通过调用当前线程上的 <code>interrupt</code> 方法恢复中断状态，这样在调用栈中的更高层代码将看到引发了一个中断： 如<strong>程序清单 5-10</strong></p>
</li>
</ul>
<blockquote>
<p>程序清单 5-10 恢复中断状态以屏蔽中断：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Restoring the interrupted status so as not to swallow the interrupt</span></span><br><span class="line"><span class="comment">// 恢复中断状态以避免中断被屏蔽</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Task&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processTask(queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 恢复被中断的状态 将调用者线程的中断状态设为true。</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对Task进行处理的业务逻辑代码</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processTask</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理 task</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以采用一些更复杂的终端处理方法，但是上述两种方法已经可以应付大多数情况了。 然而在出现 <code>InterruptedException</code> 时<strong>不应该</strong>做的事情是：<strong>捕获它但是不做出任何响应</strong>。【也就是异常的侵吞，这种操作在任何时候应该都是不推荐的】。这将使调用栈更上层的代码无法对中断采取处理措施，因为线程被中断的证据已经丢失。</p>
<p>只有在一种特殊的情况下才能屏蔽中断 —— 对 Thread 进行扩展，并且能够调用栈上更高层的代码。 <a target="_blank" rel="noopener" href="https://github.com/funnycoding/blog/issues/28">第7章</a> 将进一步介绍 <strong>「取消」 和 「中断」</strong> 等操作。</p>
<h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><p>在容器类中，「<strong>阻塞队列」是一种独特的类</strong>：它们不仅作为保存对象的<strong>容器</strong>，还能协调生产者和消费者等线程之间的<strong>控制流</strong>。【也就是除了容器功能还带有逻辑控制功能】，因为 take 和 put 方法将阻塞，直到队列到达期望的状态。（队列既非空，也非满）。</p>
<p>同步工具类可以是任何一个对象，只要它根据自身的状态来协调线程的控制流。&lt;—【这里任何一个对象 怎么理解？不是就那几个容器类吗？】</p>
<p>阻塞队列可以作为同步工具类，其他类型的同步工具类还包括：</p>
<ul>
<li><strong>信号量</strong>（Semaphore）</li>
<li><strong>栅栏</strong>（Barrier）</li>
<li><strong>闭锁</strong>（Latch)。</li>
</ul>
<p>在 JDK 中还包含其他一些同步工具类的类，如果这些类无法满足需要，那么可以按照 <a target="_blank" rel="noopener" href="https://github.com/funnycoding/blog/issues/29">第14章</a> 中给出的机制来创建自己的同步工具类。</p>
<p>所有的同步工具类都包含一些特定的「结构化属性」：它们封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对「状态」进行操作，以及另一些方法用于高效地等待同步工具类进入到 「预期状态。」</p>
<h3 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h3><p>「闭锁」是一种「同步工具类」，可以延迟线程的进度直到其到达终止状态。</p>
<p>闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能够通过，当到达结束状态时，这扇门会打开并允许所有线程通过。</p>
<p>当闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态。<!--所以说这是一次性的--></p>
<p>闭锁可以用来确保某些活动直到其他活动都完成才继续执行 ，例如：</p>
<blockquote>
<ul>
<li>确保某个计算在其需要的所有资源都初始化之后才继续执行。 二元闭锁（包括两个状态） 可以用来表示 “资源 R 已经被初始化”，而所有需要 R 的操作都必须先在这个闭锁上等待。</li>
<li>确保某个服务在其依赖的所有其他服务都启动之后才会启动。每个服务都有一个相关的 「二元闭锁」。 当启动服务 <code>S</code> 时，将首先在 <code>S</code> 依赖的其他服务的闭锁上等待，在所有依赖的服务都启动后会 释放闭锁<code>S</code>，这样其他依赖 <code>S</code> 的服务才能继续执行。</li>
<li>等待直到某个操作的所有参与者（例如，在多玩家游戏中的所有玩家）都就绪再执行操作。在这种情况中，当所有玩家准备就绪时，闭锁达到结束状态。【也有种情况是，在等待时间到达预定时间后，比如吃鸡准备1分钟，则闭锁到达结束状态，游戏开始。</li>
</ul>
</blockquote>
<p><code>CountDownLatch</code> 是一种灵活的 「闭锁实现」，可以在上述情况中使用，它可以使一个或多个线程等待一组事件发生。</p>
<p>闭锁状态包括一个「计数器」，该计数器被初始化为一个正数，表示需要等待的事件数量。 <code>countDown</code> 方法递减计数器，表示有一个事件已经发生了，而 <code>await</code> 方法等待计数器到达零，这表示所有需要等待的事件都已经发生。</p>
<p>如果计数器的值非零，<strong>那么 <code>await</code> 会一直阻塞直到计数器为零</strong>，或者<strong>等待中的线程中断</strong>，或者<strong>等待超时</strong>。</p>
<p>在程序清单 5-11 的 <code>TestHarness</code> 中给出了 闭锁的<strong>两种常见用法</strong> 。 <code>TestHarness</code> 创建一定数量的线程，利用它们并发地执行指定的任务。它使用两个闭锁，分别表示 “<strong>起始门（Starting Gate）”</strong> 和 **”结束门(Ending Gate)”**。</p>
<p><strong>起始门计数器的初始值为1</strong>，而<strong>结束门计数器的初始值为 「工作线程」 的数量</strong>。 每个工作线程首先要做的事情就是在起始门上等待，从而确保所有线程都就绪后才开始执行。</p>
<p>而每个线程要做的最后一件事情就是调用 结束门 的 <code>countDown</code> 方法使计数器 -1 ，这能使主线程高效地等待直到所有工作线程都执行完成，因此可以统计所消耗的时间。</p>
<blockquote>
<p>程序清单 5-11 在计时测试中使用 CountDownLatch 来启动和停止线程：</p>
</blockquote>
<!--与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。CountDownLatch提供了await()方法来使当前线程一直等待，直到计数器的值减为0，或者线程被中断-->

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using CountDownLatch for starting and stopping threads in timing tests</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTask</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        startGate.await();<span class="comment">//重点！！！</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            task.run();<span class="comment">//执行指定的任务task</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            endGate.countDown();<span class="comment">//重点！！！</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 使线程开始执行</span></span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        startGate.countDown();<span class="comment">//重点！！！</span></span><br><span class="line">        endGate.await();<span class="comment">//重点！！！</span></span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要在 <code>TestHarness</code> 中使用闭锁而不是在线程创建后就立即启动？ 或许我们希望测试 N 个线程并发执行某个任务需要的时间。</p>
<p>如果在创建线程后立即启动它们，那么先启动的线程将 “领先” 后启动的线程，并且活跃线程数量会随着时间的推移而增加或减少，竞争程度也在不断发生变化。</p>
<p>「启动门 」 <code>startGate</code> 将使得 主线程能够同时释放所有工作线程，而 「结束门」 <code>endGate</code> 则使主线程能够等待最后一个线程执行完成，而不是顺序地等待每个线程执行完成。</p>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p><code>FutureTask</code> 也可以用做闭锁（<code>FutureTask</code> 实现了 <strong>Future</strong>语义，<strong>表示一种抽象的可生成结果的计算</strong> )。</p>
<p><code>FutureTask</code> 表示的计算是通过 <code>Callable</code> 来实现的，相当于一种可生成结果的 <code>Runnable</code>，并且可以处于以下 3种状态：</p>
<ul>
<li><strong>等待运行（Wating to run）</strong></li>
<li><strong>正在运行(Running)</strong></li>
<li><strong>运行完成(Completed)</strong></li>
</ul>
<p>“执行完成” 表示计算的所有可能结束方式，包括正常结束、由于取消而结束和由于异常而结束等。</p>
<p><strong>当 FutureTask 进入完成状态后，它会永远停止在这个状态上。</strong></p>
<p><code>Future.get</code> 的行为取决于任务的状态。如果任务已经完成，那么 get 会立即返回结果，否则 get 将阻塞直到任务进入完成状态，然后返回结果或者抛出异常。</p>
<p><code>FutureTask</code> 将计算结果从「执行计算的线程」传递到「获取这个结果的线程」，而 <code>FutureTask</code> 的规范确保了这种传递过程能实现结果的安全发布。 <strong>&lt;— 【那么 FutureTask 的规范是什么？】</strong></p>
<p><code>FutureTask</code> 在 <code>Executor</code> 框架中表示<strong>异步任务</strong>，此外还可以用来表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。</p>
<p><strong>程序清单 5-12</strong> 中的 Preloader 就使用了 FutureTask 来执行一个高开销的计算，并且计算结果将在稍后使用。</p>
<p>通过<strong>提前启动计算</strong>，可以减少等待结果时需要的时间：</p>
<blockquote>
<p><strong>程序清单 5-12 使用 FutureTask 来提前加载稍后需要的数据</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreLoader</span> </span>&#123;</span><br><span class="line">    <span class="function">ProductInfo <span class="title">loadProductInfo</span><span class="params">()</span> <span class="keyword">throws</span> DataLoadException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Future 提前调用 长耗时的方法 loadProductInfo()</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;ProductInfo&gt; future = </span><br><span class="line">      <span class="keyword">new</span> FutureTask&lt;ProductInfo&gt;(<span class="keyword">new</span> Callable&lt;ProductInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> loadProductInfo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FutureTask 继承于 Runnable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(future);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;thread.start();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, DataLoadException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            Throwable cause = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> DataLoadException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (DataLoadException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> LaunderThrowable.launderThrowable(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ProductInfo</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataLoadException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PreLoader</code> 创建了一个 <code>FutureTask</code>，其中包含从数据库加载产品信息的任务，以及一个执行运算的线程。</p>
<p>由于在构造函数或静态初始化方法中启动线程并不是一个好方法，因此提供了一个 <code>start</code> 方法来启动线程。</p>
<p>当程序随后需要 <code>ProductInfo</code> 时，可以调用 <code>get</code> 方法，如果数据已经加载，那么将返回这些数据，否则将等待加载完成后再返回。</p>
<p><code>Callable</code> 表示的任务可以抛出 受检查的或未受检查 的异常，并且任何代码都可能抛出一个 <code>Error</code>。无论任务代码抛出什么异常，都会被封装到一个 <code>ExecutionException</code> 中，并在 <code>Future.get</code> 中被<strong>重新抛出</strong>。</p>
<p>这将使调用 <code>get</code> 的代码变得复杂，因为它不仅需要处理可能出现的 <code>ExecutionException</code>（以及未检查的 <code>CancellationException</code>） 而且还由于 <code>ExecutionException</code> 是作为一个 <code>Throwable</code> 类返回的，因此处理起来并不容易。 <strong>【怎么理解？】</strong></p>
<p>在 <code>Preloader</code> 中，当 <code>get</code> 方法抛出 <code>ExecutionException</code>时，可能是以下三种情况之一：</p>
<ul>
<li><strong>Callable 抛出的受检查异常</strong></li>
<li><strong>RuntimeException 运行时异常</strong></li>
<li><strong>以及 Error</strong></li>
</ul>
<p>我们必须对每种情况进行单独处理，但我们将使用 <strong>程序清单 5-13</strong> 中的 <code>launderThrowable</code> 辅助方法来封装一些 复杂的异常处理逻辑。</p>
<p>在调用 <code>launderThrowable</code> 之前， <code>Preloader</code> 会首先检查已知的受检查异常，并重新抛出它们。剩下的是未检查异常，<code>Preloader</code> 将调用 <code>launderThrowable</code> 并抛出结果。</p>
<p>如果 <code>Throwable</code> 传递给 <code>launderThrowable</code> 的是一个 <code>Error</code>，那么 <code>launderThrowable</code> 将直接再次抛出它；如果不是，<code>RuntimeException</code>，那么将抛出一个 <code>IllegalStateException</code> 表示这是一个逻辑错误。 剩下的 <code>RuntimeException</code>， <code>launderThrowable</code> 将把它们返回给调用者，而调用者通常会重新抛出它们。</p>
<p><strong>【这一大段都是对这个异常处理逻辑的描述，其实就是分情况就行了3个if判断然后进行处理】</strong></p>
<blockquote>
<p><strong>程序清单 5-13 强制将未检查的Throwable 转为 RuntimeException</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaunderThrowable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Coerce an unchecked Throwable to a RuntimeException</span></span><br><span class="line"><span class="comment">     * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">     * If the Throwable is an Error, throw it; if it is a</span></span><br><span class="line"><span class="comment">     * RuntimeException return it, otherwise throw IllegalStateException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title">launderThrowable</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException)</span><br><span class="line">            <span class="keyword">return</span> (RuntimeException) t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error)</span><br><span class="line">            <span class="keyword">throw</span> (Error) t;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Not unchecked&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><strong>计数信号量</strong>（<strong>Counting Semaphore</strong>） 用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。<strong>计数信号量还可以用来实现某种资源池，或者对容器施加边界。</strong></p>
<p><code>Semaphore</code> 中管理一组虚拟的许可（<code>permit</code>），许可的初始数量可以通过构造函数来指定。在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。</p>
<ul>
<li><p>如果没有许可<code>permit</code>，那么 <strong><code>acquire</code> 将阻塞直到有许可</strong>（或者直到被中断或者操作超时）。</p>
</li>
<li><p><strong><code>release</code> 将返回一个许可给信号量。</strong>在这种实现中不包含真正的许可对象，并且 <code>Semaphore</code> 也不会将许可与线程关联起来，因此在一个线程中获得的许可可以在另一个线程中释放。 可以将 <code>acquire</code> 操作视为消费一个许可，而 <code>release</code> 操作是创建一个许可，<code>Semaphore</code> 并不受限于它在创建时的初始许可数量。</p>
</li>
</ul>
<p>计算信号量的一种简化形式是 「二值信号量」，即<strong>初始值为 1 的<code>Semaphore</code>**。 二值信号量可以用作互斥体（</strong>mutex<strong>），并具备</strong>不可重入锁**<!--不要大意啊，和Synchronized不一样，是不可重入的-->的语义：谁拥有这个<strong>唯一的许可</strong>，谁就拥有了<strong>「互斥锁」</strong>。</p>
<blockquote>
<p><code>Semaphore</code> <strong>可以用于实现资源池，例如数据库连接池。</strong></p>
</blockquote>
<p>我们可以构造一个<strong>固定长度的资源池</strong>，当池为空时，请求资源将会失败，但你真正希望看到的行为是阻塞而不是失败，并且当池变为非空状态时解除阻塞。</p>
<p>如果将 <code>Semaphore</code> 的计数值初始化为池的大小，并且从池中获取一个资源之前先调用 <code>acquire</code> 方法获取一个许可，在将资源返回给池之后调用 <code>release</code> 释放许可，那么 <code>acquire</code> 将一直阻塞直到资源池不为空。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/funnycoding/blog/issues/29">第12章</a> 有界缓冲类中将使用<code>Semaphore</code> （在构造阻塞对象池时，一种更简单的方法是使用 <code>BlockingQueue</code> 来保存池的资源）</p>
</li>
<li><p>也可以使用 <code>Semaphore</code> 将任何一种容器变成 「有界阻塞容器」， 如 <strong>程序清单 5-14</strong> 中的 <code>BoundedHashSet</code> 所示，信号量的计数值会初始化为容器容量的最大值。 <code>add</code> 操作在向底层容器中添加一个元素之前，首先要获取一个许可。如果 <code>add</code> 操作没有添加任何元素，那么会立刻释放许可。同样 <code>remove</code> 操作释放一个许可，使更多的元素能够添加到容器中。底层的 <code>Set</code> 实现并不知道关于边界的任何信息，这是由 <code>BoundedHashSet</code> 来处理的。</p>
</li>
</ul>
<blockquote>
<p><strong>程序清单 5-14 使用 Semaphore 为容器设置边界：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用信号量 Semaphore 给 容器设置边界</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        <span class="comment">// 设置边界</span></span><br><span class="line">        sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sem.acquire();<span class="comment">// 信号量 +1</span></span><br><span class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wasAdded = set.add(o);</span><br><span class="line">            <span class="keyword">return</span> wasAdded;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wasAdded) &#123;</span><br><span class="line">                sem.release(); <span class="comment">// 如果没有成功保存元素，则信号量 -1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> wasRemoved = set.remove(o);</span><br><span class="line">        <span class="keyword">if</span> (wasRemoved) &#123;</span><br><span class="line">            sem.release(); <span class="comment">// 信号量 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wasRemoved;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BoundedHashSet&lt;String&gt; strSet = <span class="keyword">new</span> BoundedHashSet&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        strSet.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        strSet.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        strSet.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(strSet.set);</span><br><span class="line">        System.out.println(strSet.sem.toString());</span><br><span class="line">        strSet.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">[1, 2, 3]</span></span><br><span class="line"><span class="comment">java.util.concurrent.Semaphore@6f94fa3e[Permits = 0]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h3><ul>
<li><p>闭锁是<strong>一次性对象</strong>，一旦进入终止状态，就不能被重置。</p>
</li>
<li><p><strong>栅栏（Barrier) 类似于闭锁，它能阻塞一组线程直到某个事件发生。</strong></p>
</li>
<li><p>栅栏与闭锁的<strong>关键区别</strong>在于：所有线程都必须「同时」到达栅栏位置，才能继续执行。 <strong>「闭锁用于等待事件，而栅栏用于等待其他线程。」</strong></p>
</li>
</ul>
<p>栅栏用于实现一些协议，例如：几个家庭决定在某个地方集合”所有人决定6:00 在 麦当劳碰头到了以后要等其他人，等所有人到齐之后再讨论下一步要做的事情”。</p>
<p><code>CyclicBarrier</code> 可以使一定数量的参与方 反复地在栅栏位置汇集，它在<strong>并行迭代算法</strong>中非常有用：这种算法通常将一个问题拆分成一系列相互独立的 子问题。当有线程都到达了栅栏位置时将调用 await 方法，这个方法将阻塞直到 所有线程都到达栅栏位置。</p>
<ul>
<li><p>如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被<strong>重置</strong>以便下次使用。</p>
</li>
<li><p>如果对 await 的调用超时，那么 await 阻塞的线程被中断，那么栅栏就认为被打破，所有阻塞的 await 调用都将终止并抛出 <code>BrokenBarrierException</code>。</p>
</li>
<li><p>如果成功地通过栅栏，那么 await 将为每个线程返回一个唯一的到达索引号，我们可以利用这些索引来 “选举” 产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。</p>
</li>
</ul>
<p>CyclicBarrier 还可以让你将一个栅栏操作传递给构造函数，这是一个 Runnable ，</p>
<ul>
<li>当成功通过栅栏时会在一个子任务线程中执行它，</li>
<li>但在阻塞线程被释放之前，该任务是不能执行的。</li>
</ul>
<p>在模拟程序中通常需要使用栅栏，例如某个步骤中的计算可以 「并行执行」 但必须等到该步骤中的所有计算都执行完毕才能进入下一个步骤。</p>
<p>例如，在 n-body 粒子模拟系统中，每个步骤都根据其他粒子的位置和属性来计算各个粒子的新位置。通过在每两次更新之间等待栅栏，能够确保在 第 k 步中的所有更新操作都已经计算完毕，才进入 第 k+1 步。</p>
<p>在程序清单 5-15 的 <code>CelluarAutomata</code> 中给出了如何通过栅栏来计算细胞的自动化模拟，在对模拟过程并行化时，为每个元素（在这个示例中相当于一个细胞）分配一个独立的线程是不现实的，因为这将产生过多的线程，而在协调这些线程上导致的开销将降低计算性能。</p>
<p><strong>合理的做法是：「将问题分解成一定数量的 子问题，为每个子问题分配一个线程来进行求解，之后再将所有的结果合并起来。」</strong></p>
<p><code>CellularAutomate</code> 将问题分解为 <strong>Ncpu</strong> 个子问题，其中 <strong>Ncpu</strong> 等于当前环境下的可用 <strong>CPU</strong> 数量，并将给<strong>每个子问题分配一个线程。</strong></p>
<blockquote>
<p>在这种不涉及 I/O 操作 或共享数据访问的计算问题中，当线程数量为 CPU数量 或者 CPU + 1 的数量时将获得最优的吞吐量。 更多的线程不会带来任何帮助，甚至在某种程度上降低性能，因为多个线程会在 CPU 和 内存等资源上发生竞争</p>
</blockquote>
<p>在每个步骤中，工作线程都为各自子问题中的所有细胞计算新值。当所有工作线程都到达栅栏时，栅栏会把这些新值提交给数据模型。</p>
<p>在栅栏的操作执行完以后，工作线程将开始下一步的计算，包括调用 <code>isDone</code> 方法来判断是否需要进行下一次迭代。</p>
<blockquote>
<p><strong>程序清单 5-15</strong> 通过 <strong>CyclicBarrier</strong> 协调细胞自动衍生系统中的计算：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用栅栏协调计算细胞衍生系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CellularAutomate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Board mainBoard;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker[] workers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CellularAutomate</span><span class="params">(Board board)</span> </span>&#123; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">this</span>.mainBoard = board;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> count = Runtime.getRuntime().availableProcessors();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">this</span>.barrier = <span class="keyword">new</span> CyclicBarrier(count, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mainBoard.commitNewValues();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.workers = <span class="keyword">new</span> Worker[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">        		workers[i] = <span class="keyword">new</span> Worker(mainBoard.getSubBoard(count, i));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Board board;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Board board)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.board = board;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!board.hasConverged()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; board.getMaxX(); x++) </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; board.getMaxY(); y++) </span><br><span class="line">                        board.setNewValue(x, y, computeValue(x, y));</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    barrier.await();<span class="comment">//计数器加1，等待其他线程执行到同样的地方</span></span><br><span class="line">                &#125; <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">                  ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="comment">//启动部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(workers[i]).start();</span><br><span class="line">        &#125;</span><br><span class="line">        mainBoard.waitForConvergence();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种形式的栅栏是 Exchanger，它是一种两方（Two-Party）栅栏，各方在栅栏位置上交换数据。当两方执行不对称操作时， Exchanger 会非常有用。</p>
<p>例如当一个线程向缓冲区写入数据，而另一个线程从缓冲区读取数据。这些线程可以使用 Exchanger 来汇合，并将写满的缓冲区与空的缓冲区交换。当两个线程通过 Exchanger 交换对象时，这种交换就把这两个对象安全地发布给另一方。</p>
<p>数据交换的时机取决于应用程序的响应需求。最简单的方案是：当缓冲区被填满时，由填充任务进行交换，当缓冲区为空时，由清空任务进行交换。</p>
<p><strong>这样会把需要交换的次数降至最低。</strong></p>
<p>但如果新数据的到达率不可预测，那么一些数据的处理过程就将延迟。另一个方法是：不仅当缓冲区被填满时进行交换，并且当缓冲区被填充到一定程度并保持一定的时间后，也进行交换。</p>
<h2 id="构建高效且可伸缩的结果缓存"><a href="#构建高效且可伸缩的结果缓存" class="headerlink" title="构建高效且可伸缩的结果缓存"></a>构建高效且可伸缩的结果缓存</h2><p>几乎所有的服务器应用程序都会使用 「某种形式的缓存」。重用之前的计算结果能降低延迟，提高吞吐量，但却需要消耗更多的内存。【空间与时间之间的转换】</p>
<p>像许多”重复发明的轮子”一样，缓存看上去非常简单。然而，简单的缓存可能会将 「性能瓶颈」 转换成 「可伸缩瓶颈」，即使缓存是用于提升单线程的性能，本节我们将开发一个 「高效」 且 「可伸缩」 的缓存，用于改进一个<strong>高计算开销</strong>的函数。</p>
<p>我们首先从简单的 <code>HashMap</code> 开始，然后分析它的<strong>「并发性缺陷」</strong>，并讨论如何修复它们。</p>
<p>在程序清单 5-16 的 <code>Computable&lt;A,V&gt;</code> 接口中声明了一个 函数 <code>Computable</code>，其输入类型为A，输出类型为V。</p>
<p>在 <code>ExpensiveFunction</code> 中实现的 <code>Computable</code>，需要很长时间来计算结果，我们将创建一个 Computable 包装器，帮助记住之前的计算结果，并将缓存过程封装起来。（这项技术被称为 <code>Memorization</code>）</p>
<blockquote>
<p><strong>程序清单 5-16</strong> 使用 <code>HashMap</code> 和<strong>「同步机制」</strong>来初始化缓存</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">String</span>, <span class="title">BigInteger</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigInteger <span class="title">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 经过了长时间的计算之后</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer1</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer1</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">          	result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 是非线程安全的，</p>
<ul>
<li>因此要确保两个线程不会同时对 HashMap 进行访问 ，Memoizer1 采用了一种保守的方法： 「对整个 <code>compute</code> 进行同步」。 </li>
<li>这种方法能确保线程安全性，但会带来一种明显的 「可伸缩性」 问题：每次只有一个线程能执行 <code>compute</code>方法，并且其可能是一个长耗时的方法，那么其他调用 <code>compute</code> 的线程可能被阻塞很长时间。并且这种长时间的阻塞没法通过提升硬件数目来解决，因为就算核心或线程再多，也只有一个线程能访问该方法。</li>
</ul>
<p>如果有多个线程在排队等待还未计算出的结果，那么 <code>compute</code> 方法的计算时间可能比没有 “记忆” 操作的计算时间更长。</p>
<img src="https://chengfeng96.com/blog/2018/10/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E4%B8%94%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%9A%84%E7%BB%93%E6%9E%9C%E7%BC%93%E5%AD%98/1.png" style="zoom:33%;" />

<p><strong>程序清单 5-17</strong> 中的 <code>Memoizer2</code> 用 <code>ConcurrentHashMap</code> 代替了 <code>HashMap</code> 来改进 <code>Memoizer1</code> 中糟糕的并发行为。由于 <code>ConcurrentHashMap</code> 是线程安全的，因此在访问底层 <code>Map</code> 时就不需要进行同步，因而避免了 <code>Memoizer1</code> 中的 <code>compute</code>方法上使用内置锁导致的串行性。</p>
<p><code>Memoizer2</code> 比 <code>Memoizer1</code> 有更好的并发行为：多线程可以并发地使用它。但它在作为缓存时仍然有一些不足 —— 当<strong>「两个线程同时调用 <code>compute</code> 时存在一个漏洞」</strong>：<strong>可能会导致计算得到相同的值。</strong></p>
<p>在使用 memoization 的情况下，这只会带来低效，因为缓存的作用是避免相同的数据被计算多次。但对于更通用的缓存机制来说，这种情况（在某种情况下导致计算得到的值相同的情况）将更为糟糕。</p>
<p>对于只提供单次初始化的缓存来说，这个漏洞就会带来安全风险。</p>
<blockquote>
<p><strong>程序清单 5-17</strong> 用 <code>ConcurrentHashMap</code> 替换 <code>HashMap</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer2</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer2</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        V resul = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (resul == <span class="keyword">null</span>) &#123;</span><br><span class="line">            resul = c.compute(arg);</span><br><span class="line">            cache.put(arg, resul);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resul;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Memoizer2</code> 的问题在于，如果某个线程启动了一个 「开销很大」 的计算，而其他线程并不知道这个计算正在进行，那么很可能会重复这个计算。</p>
<img src="https://chengfeng96.com/blog/2018/10/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E4%B8%94%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%9A%84%E7%BB%93%E6%9E%9C%E7%BC%93%E5%AD%98/2.png" style="zoom:50%;" />

<p>我们希望通过某种方法来表达”线程X 正在计算 f(1)” 这种情况，这样当另一个线程查找 f(1) 时，它能够知道「最高效」 的方法是等待 「线程X」 计算结束，然后再去查询缓存获取 f(1) 的值。</p>
<p><strong>已经有一个类能够基本实现这个功能：<code>FutureTask</code>。</strong></p>
<p><code>FutureTask</code> 表示一个 <strong>「计算的过程」</strong>，这个过程可能已经计算完成，也可能正在进行。 如果有结果可用，那么 <code>FutureTask.get</code> 将立即返回结果，否则它会一直阻塞，直到结果计算出来再次将其返回。</p>
<p>程序清单 5-18 中的 <code>Memoizer3</code> 将用于缓存值的 Map 重新定义为 <code>ConcurrentHashMap&lt;A,Future&lt;V&gt;&gt;</code> ，替换原来的 <code>ConcurrentHashMap&lt;A,V&gt;</code> 。</p>
<p><code>Memoizer3</code> 首先检查某个相应的计算是否已经开始（ <code>Memoizer2</code> 与之相反，它首先判断某个计算是否已经完成）。</p>
<p>如果对应的值在缓存中不存在，并且对其进行的计算还没有启动，那么就创建一个 <code>FutureTask</code>，并注册到 <code>Map</code> 中，然后启动计算，如果针对该值的计算已经启动，那么等待现有计算的结果，结果可能会很快得到，也可能还在运算过程中，但这堆 <code>Future.get</code> 的调用者来说是「透明」的【也就是不需要对其进行显式的处理，就调用 <code>Future.get</code> 就完事了】。</p>
<blockquote>
<p><strong>程序清单 5-18</strong> 基于 <code>FutureTask</code> 的 <code>Memoizing</code> 封装器：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer3</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer3</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Callable&lt;V&gt; eval = () -&gt; c.compute(arg);</span><br><span class="line"></span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(eval);</span><br><span class="line">            f = ft;</span><br><span class="line">            cache.put(arg, ft);</span><br><span class="line">            ft.run(); <span class="comment">//这里调用 c.compute 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取 FutureTask 的计算的值，如果正在计算中，则阻塞，直到其值返回</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> LaunderThrowable.launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Memoizer3</code> 的实现几乎是完美的：它表现出非常好的并发性（源于 <code>ConcurrentHashMap</code> 高效的并发性）。</p>
<ul>
<li><p>同时若结果已经被计算出来，那么将立即返回。</p>
</li>
<li><p>如果其他线程正在计算该结果，那么新到的线程将一直等待这个结果被计算出来。</p>
</li>
<li><p>它只有一个「缺陷」：仍然存在两个线程计算出相同值的漏洞。 这个漏洞的发生概率要远小于 <code>Memoizer2</code> 中发生的概率，但由于 <code>compute</code> 方法 中的 if 代码块仍然**是非原子的（nonatomic) 的”先检查，再执行的操作”**，因此两个线程仍然有可能在同一时间内调用 compute 来计算相同的值，即「二者都没有在缓存中找到期望的值，因此都开始计算」。</p>
</li>
</ul>
<p>这个错误的执行时序如 <strong>图5-4</strong> 所示：</p>
<img src="https://chengfeng96.com/blog/2018/10/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E4%B8%94%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%9A%84%E7%BB%93%E6%9E%9C%E7%BC%93%E5%AD%98/3.png" style="zoom:50%;" />



<p><code>Memoizer3</code> 中存在这个问题的原因是，复合操作「若没有则添加」 是在底层的 <code>Map</code> 对象上执行的，而这个对象无法通过加锁来确保原子性。</p>
<p>程序清单 <code>5-19</code> 中的 <code>Memoizer</code> 使用了 <code>ConcurrentMap</code> 中的原子方法 <code>putIfAbsent</code>，避免了 <code>Memoizer3</code> 中两个线程计算相同值的漏洞：</p>
<blockquote>
<p><strong>程序清单 5-19</strong> <code>MeMoizer</code> 的最终实现：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Callable&lt;V&gt; eval = () -&gt; c.compute(arg);</span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(eval);</span><br><span class="line"></span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    ft.run(); <span class="comment">// 执行 c.compute 具体计算逻辑</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                cache.remove(arg, f);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> LaunderThrowable.launderThrowable(e.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当缓存的是 <code>Future</code> 而不是<strong>具体的值</strong>时，将导致<strong>缓存污染（Cache Pollution）</strong>问题：如果某个计算被取消或者计算过程中失败，那么在计算这个结果时将指明计算过程被取消或者失败。</p>
<p>为了避免这种情况，如果 Memoizer 发现计算被取消，那么将把 Future 从缓存中移除。如果检测到 RuntimeException，那么也会移除 Future，这样将来的计算才可能成功。</p>
<p><code>Memoizer</code> 同样没有解决</p>
<ul>
<li><strong>「缓存逾期」</strong> 问题，但它可以通过 <code>FutureTask</code> 的子类来解决，<strong>「在子类中为每个结果指定一个逾期时间，并定期扫描缓存中的逾期元素」</strong>。</li>
<li>同样，它也没有解决「缓存清理」的问题，没有移除旧的计算结果以便为新的计算结果腾出空间，从而使缓存不会消耗过多的内存【这是这个缓存类的2个硬伤。】</li>
</ul>
<p>在完成并发缓存的实现后，就可以为 <a target="_blank" rel="noopener" href="https://github.com/funnycoding/blog/issues/30">第2章</a> 中 「因式分解Servlet」 添加结果缓存。</p>
<p>程序清单 5-20 中的 <code>Factorizer</code> 使用 <code>Memoizer</code> 来缓存之前的计算结果，这种方式不仅<strong>高效，而且可扩展性也更好：</strong></p>
<blockquote>
<p>程序清单 5-20 在因式分解 servlet 中使用 Memoizer 来缓存结果：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorizer</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;BigInteger, BigInteger[]&gt; c = <span class="keyword">new</span> Computable&lt;BigInteger, BigInteger[]&gt;&#123;</span><br><span class="line">    	<span class="keyword">public</span> BigInteger[] compute(BigInteger arg)&#123;</span><br><span class="line">    		<span class="keyword">return</span> factor(arg);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;BigInteger, BigInteger[]&gt; cache = <span class="keyword">new</span> Memoizer&lt;&gt;(c);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger i = extractFromRequest(req);</span><br><span class="line">            <span class="comment">// 从缓存中获取值，如果没有则计算值</span></span><br><span class="line">            encodeIntoResponse(resp, cache.compute(i));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            encodeError(resp, <span class="string">&quot;factorization interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第一部分小结"><a href="#第一部分小结" class="headerlink" title="第一部分小结"></a>第一部分小结</h2><p>目前为止，第一部分就结束了。这一部分中介绍了许多关于并发的基础知识，下面这个 “并发技巧清单” 列举了在第一部分中介绍的主要概念和规则：</p>
<ul>
<li>可变状态是至关重要的（It’s the mutable state,stupid)<ul>
<li>所有的并发问题都可以总结为如何协调对并发状态的访问。 可变状态越少，就越容易确保线程安全性。【当没有可变状态时，该类就是安全的，不存在线程安全性问题】</li>
</ul>
</li>
<li>尽量将域声明为 final 类型的，除非确实需要它们是可变的。</li>
<li>不可变对象一定是线程安全的。<ul>
<li>不可变对象能极大地降低并发编程的复杂性。它们更加简单而且安全，可以任意共享而无须使用加锁或者保护性复制机制。</li>
</ul>
</li>
<li>封装有助于管理复杂性。<ul>
<li>在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但是极不推荐这样做。将数据封装在类中，可以缩小对数据的访问路径，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。</li>
</ul>
</li>
<li>用锁来保护每个可变变量。</li>
<li>当保护同一个不变性条件中的所有变量时，要使用 「同一个」 锁。</li>
<li>在执行 「复合操作」，要持有锁。</li>
<li>如果从多个线程中访问访问访问同一个 「可变变量」 时没有同步机制，那么程序会出现问题。</li>
<li>不要故作聪明地推断出不需要使用同步</li>
<li>在设计过程中考虑线程安全，或者在文档中明确指出这个类不是线程安全的。</li>
<li>将同步策略文档化。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDmysql/%E7%AC%AC5%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDmysql/%E7%AC%AC5%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">第5章:创建高性能的索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-18 11:09:59" itemprop="dateCreated datePublished" datetime="2020-12-18T11:09:59+08:00">2020-12-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-13 10:19:25" itemprop="dateModified" datetime="2021-07-13T10:19:25+08:00">2021-07-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>索引在 MySQL 中也叫键（Key），是存储引擎用于快速找到记录的一种数据结构。</p>
<p>表的数据量增大时，索引对良好的性能非常关键。<strong>索引是优化查询性能的最有效的手段。</strong></p>
<h1 id="5-1-索引基础"><a href="#5-1-索引基础" class="headerlink" title="5.1 索引基础"></a>5.1 索引基础</h1><p>MySQL 中，存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM blog.user WHERE user_id &#x3D; 5;</span><br></pre></td></tr></table></figure>

<p>如果 user_id 列上建有索引，MySQL 将使用该索引找到 user_id 为 5 的行。MySQL 先在索引上按值进行查找，然后返回所有包含该值的数据行。</p>
<blockquote>
<p>索引可以包含一个或多个列的值。如果包含多个列，MySQL 只能高效使用最左前缀列。</p>
</blockquote>
<h2 id="5-1-1-索引类型"><a href="#5-1-1-索引类型" class="headerlink" title="5.1.1 索引类型"></a>5.1.1 索引类型</h2><h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h3><p>B-Tree 索引使用 B-Tree 数据结构来存储数据。</p>
<p><strong>MySQL 的默认索引类型</strong>，大多数存储引擎都支持，只是存储结构会有所差异。例如 InnoDB 使用 B+Tree<!--即每个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历--></p>
<p>存储引擎以不同的方式使用B-Tree索引，性能也各有不同， 各有优劣。 例如， MyISAM使用前缀压缩技术使得索引更小， 但lnnoDB则按照原数据格式进行存储。 再如MyISAM索引通过数据的物理位置引用被索引的行， 而InnoDB则根据主键引用被索引的行。</p>
<p><strong>B-Tree通常意味着所有的值都是按顺序存储的， 并且每一个叶子页到根的距离相同</strong>。图5-1展示了B-Tree索引的抽象表示， 大致反映了InnoDB索引是如何工作的。MyISAM使用的结构有所不同， 但基本思想是类似的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12219352-d6faa5076cc31613.png" alt="img"></p>
<p><strong>B-Tree索引能够加快访问数据的速度， 因为存储引擎不再需要进行全表扫描来获取需要的数据， 取而代之的是从索引的根节点（图示井未画出）开始进行搜索。</strong>根节点的槽中存放了指向子节点的指针， 存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点， 这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值， 要么该记录不存在。</p>
<p><strong>叶子节点比较特别， 它们的指针指向的是被索引的数据， 而不是其他的节点页</strong>（不同引擎的 ”指针” 类型不同）。 图5-1中仅绘制了一个节点和其对应的叶子节点， 其实在根节点和叶子节点之间可能有很多层节点页。 树的深度和表的大小直接相关。</p>
<p><strong>B-Tree 对索引列是顺序组织存储的， 所以很适合查找范围数据</strong>。 例如， 在一个基于文本域的索引树上， 按字母顺序传递连续的值进行查找是非常合适的， 所以像 “找出所有以 I 到 K 开头的名字“ 这样的查找效率会非常高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table people (</span><br><span class="line">	last_name varchar(50) not null,</span><br><span class="line">	first_name varchar(50) not null,</span><br><span class="line">	dob date not null,</span><br><span class="line">	gender enum(&#39;m&#39;,&#39;f&#39;) not null,</span><br><span class="line">	key(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>可以使用B-Tree索引的查询类型。 B-Tree索引适用于全键值、键值范围或键前缀查找</strong>。其中键前缀查找只适用于根据最左前缀的查找。前面所述的索引对如下类型的查询有效。</p>
<blockquote>
<p><strong>全值匹配</strong></p>
<p>全值匹配指的是和索引中的所有列进行匹配， 例如前面提到的索引可用于查找姓名为CubaAllen、出生于1960-01-01 的人。</p>
<p><strong>匹配最左前缀</strong></p>
<p>前面提到的索引可用于查找所有姓为Allen的人， 即只使用索引的第一列。</p>
<p><strong>匹配列前缀</strong></p>
<p>也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只使用了索引的第一列。</p>
<p><strong>匹配范围值</strong></p>
<p>例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。</p>
<p><strong>精确匹配某一列并范围匹配另外一列</strong></p>
<p>前面提到的索引也可用于查找所有姓为Allen, 井且名字是字母K开头（比如Kim、Karl等） 的人。即第一列last_name全匹配，第二列first_name范围匹配。</p>
<p><strong>只访问索引的查询</strong></p>
<p>B-Tree通常可以支持“只访问索引的查询”, 即查询只需要访问索引， 而无须访问数据行。后面我们将单独讨论这种“覆盖索引” 的优化。</p>
</blockquote>
<p>因为索引树中的节点是有序的， 所以除了按值查找之外， 索引还可以用于查询中的ORDER BY操作（按顺序查找）。一般来说， 如果B-Tree可以按照某种方式查找到值， 那么也可以按照这种方式用于排序。所以， 如果ORDER BY子句满足前面列出的几种查询类型， 则这个索引也可以满足对应的排序需求。</p>
<p>下面是一些关于B-Tree索引的限制：</p>
<blockquote>
<p>• <strong>如果不是按照索引的最左列开始查找， 则无法使用索引。</strong>例如上面例子中的索引无法用于查找名字为Bill的人， 也无法查找某个特定生日的人， 因为这两列都不是最左数据列。类似地， <strong>也无法查找姓氏以某个字母结尾的人</strong>。</p>
<p>•<strong>不能跳过索引中的列</strong>。 也就是说， 前面所述的索引无法用千查找姓为 Smith 并且在某个特定日期出生的人。 如果不指定名 (first_name), 则 MySQL 只能使用索引的 第一列。</p>
<p><strong>•如果查询中有某个列的范围查询， 则其右边所有列都无法使用索引优化查找</strong>。 例如 有查询 WHERE last_name=’Smith’ AND first_name LIKE ‘J%’ AND dob = ‘1976- 12-23 ‘, 这个查询只能使用索引的前两列， 因为这里LIKE是一个范围条件（但是服务器可以把其余列用于其他目的）。 如果范围查询列值的数最有限， 那么可以通过使用多个等于条件来代替范围条件。 </p>
</blockquote>
<p>在优化性能的时候， 可能需要<strong>使用相同的列但顺序不同的索引</strong>来满足不同类型的查询需求。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hashcode), 哈希码是一个较小的值，井且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>在MySQL中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。值得一提的是，Memory引擎是支持非唯一哈希索引的， 这在数据库世界里面是比较与众不同的。如果多个列的哈希值相同，</p>
<p>索引会以链表的方式存放多个记录指针到同一个哈希条目中。</p>
<p>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。 然而，哈希索引也有它的限制：</p>
<p>•    哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。 不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的 影响并不明显。</p>
<p>•    哈希索引数据并不是按照索引值顺序存储的，所以也就无法用千排序。</p>
<p>•    哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内 容来计算哈希值的。 例如，在数据列(A,B)上建立哈希索引，如果查询只有数据列A, 则无法使用该索引。</p>
<p>•    哈希索引只支持等值比较查询，包括＝、 IN() 、&lt;:=&gt;(注意&lt;&gt;和＜＝＞是不同的操作）。 也不支持任何范围查询，例如WHERE price&gt; 100。</p>
<p>•    访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈 希值）。 当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行 比较，直到找到所有符合条件的行。</p>
<p>•    如果哈希冲突很多的话，一些索引维护操作的代价也会很高。 例如，如果在某个选择性很低（哈希冲突很多） 的列上建立哈希索引，那么当从表中删除一行时， 存储 引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多， 代价越大。</p>
<p>因为这些限制，哈希索引只适用于某些特定的场合。 而一且适合哈希索引，则它带来的 性能提升将非常显著。 举个例子，在数据仓库应用中有一种经典的 “星型” schema, 需要关联很多查找表，哈希索引就非常适合查找表的需求。</p>
<p>除了Memory引擎外，NOB集群引擎也支持唯一哈希索引，且在NDB集群引擎中作用 非常特殊，但这不属千本书的范围。</p>
<p>InnoDB引擎有一个特殊的功能叫做 “自适应哈希索引(adaptivehash index)”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基千B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希 查找。 这是一个完全自动的、 内部的行为，用户无法控制或者配置，不过如果有必要， 完全可以关闭该功能。</p>
<p>创建自定义哈希索引。 如果存储引擎不支持哈希索引，则可以模拟像InnoDB一样创建哈希索引，这可以享受一些哈希索引的便利，例如只需要很小的索引就可以为超长的键创建索引。</p>
<p>思路很简单：在B-Tree基础上创建一个伪啥希索引。 这和真正的哈希索引不是一 回事， 因为还是使用B-Tree进行查找，但是它使用哈希值而不是键本身进行索引查找。 你需要做的就是在查询的WHERE子旬中手动指定使用哈希函数。</p>
<h1 id="5-2-索引的优点"><a href="#5-2-索引的优点" class="headerlink" title="5.2 索引的优点"></a>5.2 索引的优点</h1><p>索引可以让服务器快速地定位到表的指定位置。 但是这并不是索引的唯一作用，到目前为止可以看到，根据创建索引的数据结构不同，索引也有一些其他的附加作用。</p>
<p>最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。 因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。 最后， 因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。 </p>
<blockquote>
<p>据此特性，总结下来索引有如下三个优点：</p>
<ol>
<li><p>索引大大减少了服务器需要扫描的数据量。</p>
</li>
<li><p>索引可以帮助服务器避免排序和临时表。</p>
</li>
<li><p>索引可以将随机I/O变为顺序I/O。</p>
</li>
</ol>
</blockquote>
<h1 id="5-3-高性能的索引策略"><a href="#5-3-高性能的索引策略" class="headerlink" title="5.3 高性能的索引策略"></a>5.3 高性能的索引策略</h1><h2 id="5-3-1-独立的列"><a href="#5-3-1-独立的列" class="headerlink" title="5.3.1 独立的列"></a>5.3.1 独立的列</h2><p>如果查询中的列不是独立的则MySQL就不会使用索引。 <strong>列不是独立的，指的是列是表达式的一部分，或函数参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... WHERE id + 1 &#x3D; 5;</span><br><span class="line">SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) &lt;&#x3D; 10;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-2-前缀索引和索引选择性"><a href="#5-3-2-前缀索引和索引选择性" class="headerlink" title="5.3.2 前缀索引和索引选择性"></a>5.3.2 前缀索引和索引选择性</h2><p>在很长的字符列上使用索引时，会使索引大且慢。可以使用前面的模拟哈希索引。</p>
<p>也可以只索引开始的部分字符。对于 BLOB、TEXT 或很长的 VARCHAR 类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。需要选择足够长的前缀以保证较高的选择性（防止重复），同时不能太长以节约空间。</p>
<blockquote>
<p>前缀索引的优缺点：</p>
<ul>
<li>使索引更小、更快。</li>
<li>MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</li>
</ul>
</blockquote>
<h3 id="确定合适的前缀长度"><a href="#确定合适的前缀长度" class="headerlink" title="确定合适的前缀长度"></a>确定合适的前缀长度</h3><h4 id="1-生成测试数据"><a href="#1-生成测试数据" class="headerlink" title="1. 生成测试数据"></a>1. 生成测试数据</h4><p>在示例数据库 <a target="_blank" rel="noopener" href="https://blog.csdn.net/kikajack/article/details/80181263">sakila</a> 中没有合适的例子，需要从表 city 中生成一个示例表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- &lt;----从表 city 生成一个示例表 city_demo，这样就有足够的数据用来演示：</span><br><span class="line">CREATE TABLE sakila.city_demo(city VARCHAR(50) NOT NULL);</span><br><span class="line">INSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city;</span><br><span class="line"></span><br><span class="line">-- &lt;---- 这一行重复5次</span><br><span class="line">INSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city_demo;   </span><br><span class="line"></span><br><span class="line">-- &lt;---- 执行下面 SQL 随机分布数据：</span><br><span class="line">UPDATE sakila.city_demo SET city &#x3D; (SELECT city FROM sakila.city ORDER BY RAND() LIMIT 1);</span><br><span class="line"></span><br><span class="line">-- &lt;----首先，我们找到最常见的城市列表：</span><br><span class="line">mysql&gt; SELECT COUNT(*) as cnt, city FROM city_demo GROUP BY city ORDER BY cnt DESC LIMIT 10;</span><br><span class="line">+-----+-----------+</span><br><span class="line">| cnt | city      |</span><br><span class="line">+-----+-----------+</span><br><span class="line">|  72 | London    |</span><br><span class="line">|  48 | Baiyin    |</span><br><span class="line">|  48 | Jinzhou   |</span><br><span class="line">|  48 | Nador     |</span><br><span class="line">|  47 | Isesaki   |</span><br><span class="line">|  47 | Elista    |</span><br><span class="line">|  47 | Garland   |</span><br><span class="line">|  47 | Linz      |</span><br><span class="line">|  46 | Compton   |</span><br><span class="line">|  45 | Shikarpur |</span><br><span class="line">+-----+-----------+</span><br><span class="line">10 rows in set</span><br></pre></td></tr></table></figure>

<h4 id="2-现在查找最频繁出现的城市前缀"><a href="#2-现在查找最频繁出现的城市前缀" class="headerlink" title="2. 现在查找最频繁出现的城市前缀"></a>2. 现在查找最频繁出现的城市前缀</h4><p>先从 3 个前缀字母开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(*) as cnt, LEFT(city,3) AS pref FROM city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;</span><br><span class="line">+-----+------+</span><br><span class="line">| cnt | pref |</span><br><span class="line">+-----+------+</span><br><span class="line">| 418 | San  |</span><br><span class="line">| 181 | Tan  |</span><br><span class="line">| 175 | Cha  |</span><br><span class="line">| 166 | Sal  |</span><br><span class="line">| 161 | al-  |</span><br><span class="line">| 147 | Shi  |</span><br><span class="line">| 146 | Sou  |</span><br><span class="line">| 133 | Kam  |</span><br><span class="line">| 128 | Val  |</span><br><span class="line">| 123 | Man  |</span><br><span class="line">+-----+------+</span><br><span class="line">10 rows in set</span><br></pre></td></tr></table></figure>

<p>每个前缀都比原来的城市出现的次数更多，因此唯一前缀比唯一城市要少得多。然后我们增加前缀的长度，直到这个前缀的选择性接近完整列的选择性。经过实验后发现前缀长度为 7 时比较合适：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(*) AS cnt, LEFT(city,7) AS pref FROM city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;</span><br><span class="line">+-----+---------+</span><br><span class="line">| cnt | pref    |</span><br><span class="line">+-----+---------+</span><br><span class="line">|  72 | San Fel |</span><br><span class="line">|  72 | London  |</span><br><span class="line">|  66 | Valle d |</span><br><span class="line">|  54 | Santiag |</span><br><span class="line">|  48 | Nador   |</span><br><span class="line">|  48 | Baiyin  |</span><br><span class="line">|  48 | Jinzhou |</span><br><span class="line">|  47 | Isesaki |</span><br><span class="line">|  47 | Elista  |</span><br><span class="line">|  47 | Garland |</span><br><span class="line">+-----+---------+</span><br><span class="line">10 rows in set</span><br></pre></td></tr></table></figure>



<h4 id="3-计算最佳前缀长度"><a href="#3-计算最佳前缀长度" class="headerlink" title="3. 计算最佳前缀长度"></a>3. 计算最佳前缀长度</h4><p>可以通过计算完整列的选择性来计算合适的前缀长度，使前缀的选择性接近于完整列的选择性。计算完整列的选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [sakila]&gt; SELECT COUNT(DISTINCT city)&#x2F;COUNT(*) FROM sakila.city_demo;</span><br><span class="line">+-------------------------------+</span><br><span class="line">| COUNT(DISTINCT city)&#x2F;COUNT(*) |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| 0.0039                        |</span><br><span class="line">+-------------------------------+</span><br><span class="line">1 row in set (0.119 sec)</span><br></pre></td></tr></table></figure>

<p>计算不同前缀长度的选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [sakila]&gt; SELECT COUNT(DISTINCT LEFT(city, 3))&#x2F;COUNT(*) AS sel3,</span><br><span class="line">    -&gt; COUNT(DISTINCT LEFT(city, 4))&#x2F;COUNT(*) AS sel4,</span><br><span class="line">    -&gt; COUNT(DISTINCT LEFT(city, 5))&#x2F;COUNT(*) AS sel5,</span><br><span class="line">    -&gt; COUNT(DISTINCT LEFT(city, 6))&#x2F;COUNT(*) AS sel6,</span><br><span class="line">    -&gt; COUNT(DISTINCT LEFT(city, 7))&#x2F;COUNT(*) AS sel7</span><br><span class="line">    -&gt; FROM sakila.city_demo;</span><br><span class="line">+--------+--------+--------+--------+--------+</span><br><span class="line">| sel3   | sel4   | sel5   | sel6   | sel7   |</span><br><span class="line">+--------+--------+--------+--------+--------+</span><br><span class="line">| 0.0030 | 0.0037 | 0.0038 | 0.0039 | 0.0039 |</span><br><span class="line">+--------+--------+--------+--------+--------+</span><br><span class="line">1 row in set (0.312 sec)</span><br></pre></td></tr></table></figure>

<p>前缀长度达到 7 时，选择性提升的幅度基本稳定。</p>
<h3 id="创建前缀索引"><a href="#创建前缀索引" class="headerlink" title="创建前缀索引"></a>创建前缀索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [sakila]&gt; ALTER TABLE sakila.city_demo ADD KEY(city(7));</span><br><span class="line">Query OK, 0 rows affected (3.350 sec)               </span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<h3 id="创建后缀索引"><a href="#创建后缀索引" class="headerlink" title="创建后缀索引"></a>创建后缀索引</h3><p>比如，查找某个域名的所有电子邮件地址。MySQL原生并不支持反向索引，但是可以通过把字符串反转后存储，并基于此建立前缀索引。</p>
<h2 id="5-3-3-多列索引"><a href="#5-3-3-多列索引" class="headerlink" title="5.3.3 多列索引"></a>5.3.3 多列索引</h2><p> 一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table t&#123;</span><br><span class="line"> c1 int,</span><br><span class="line"> c2 int,</span><br><span class="line"> c3 int,</span><br><span class="line"> key(c1),</span><br><span class="line"> key(c2),</span><br><span class="line"> key(c3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能</strong>。</p>
<h2 id="5-3-4-选择合适的索引列顺序"><a href="#5-3-4-选择合适的索引列顺序" class="headerlink" title="5.3.4 选择合适的索引列顺序"></a>5.3.4 选择合适的索引列顺序</h2><p>我们遇到的最容易引起困惑的问题就是索引列的顺序。 正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要（顺便说明，本节内容适用于B-Tree索引；哈希或者其他类型的索引并不会像B-Tree索引一样按顺序存储数据）。</p>
<p>在一个多列B-Tree索引中，<strong>索引列的顺序意味着索引首先按照最左列进行排序</strong>，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。</p>
<p>所以多列索引的列顺序至关重要。对于如何选择索引的列顺序有一个经验法则：<strong>将选择性最高的列放到索引最前列</strong>。这个建议有用吗？在某些场景可能有帮助，但通常不如避免随机IO和排序那么重要。</p>
<p><strong>当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的</strong>。这时候索引的作用只是用于优化WHERE条件的查找。</p>
<h3 id="真实的案例分析1："><a href="#真实的案例分析1：" class="headerlink" title="真实的案例分析1："></a>真实的案例分析1：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> payment <span class="keyword">WHERE</span> staff_id = <span class="number">2</span> <span class="keyword">AND</span> customer_id = <span class="number">584</span>;</span><br></pre></td></tr></table></figure>

<p>是应该创建一个 (staff_id,customer_id) 索引还是应该颠倒一下顺序？可以跑一些查询来确定在这个表中值的分布情况，并确定哪个列的选择性更高。先用下面的查询预测一下，看看各个 WHERE 条件的分支对应的数据基数有多大：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(staff_id=2), SUM(customer_id=584) FROM payment\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     SUM(staff_id=2): 7992</span><br><span class="line">SUM(customer_id=584): 30</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>根据前面的经验法则，应该将索引列 custom_id 放到前面，因为对应条件值的 customer_id 数量更小。我们再来看看对于这个 customer_id 的条件值，对应的 staff_id 列的选择性如何：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(staff_id=2) FROM payment WHERE customer_id=584\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">SUM(staff_id=2): 17</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>这样做有一个地方需要注意，查询的结果非常依赖于选定的具体值。如果按上述办法优化，可能对其他一些条件值的查询不公平，服务器的整体性能可能变得更糟，或者其他某些查询的运行变得不如预期。</p>
<p>如果是从诸如 pt-query-digest 这样的工具的报告中提取 “最差” 查询，那么再按上述办法选定的索引顺序往往是非常高效的。<strong>如果没有类似的具体查询来运行，那么最好按经验法则来做，因为经验法则考虑的是全局基数和选择性，而不是某个具体查询</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,</span><br><span class="line">    -&gt; COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,</span><br><span class="line">    -&gt; COUNT(*)</span><br><span class="line">    -&gt; FROM payment\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>customer_id 的选择性更高，所以答案是将其作为索引列的第一列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE payment ADD KEY(customer_id, staff_id);</span><br><span class="line">Query OK, 0 rows affected (0.13 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<p><strong>当使用前缀索引的时候，在某些条件值的基数比正常值高的时候，问题就来了</strong>。</p>
<h3 id="真实的案例分析2："><a href="#真实的案例分析2：" class="headerlink" title="真实的案例分析2："></a>真实的案例分析2：</h3><p>下面是一个我们遇到过的真实案例，在一个用户分享购买商品和购买经验的论坛上，这个特殊表上的查询运行得非常慢：</p>
<p><img src="https://img-blog.csdnimg.cn/20201110015105316.png#pic_center" alt="在这里插入图片描述"></p>
<p>这个查询看似没有建立合适的索引，所以客户咨询我们是否可以优化。EXPLAIN 的结果如下：</p>
<img src="https://img-blog.csdnimg.cn/20201110015114505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JtMTk5OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:50%;" />

<p>MySQL 为这个查询选择了索引 (groupId，userId)，如果不考虑列的基数，这看起来是一个非常合理的选择。但如果考虑一下 user ID 和 group ID 条件匹配的行数，可能就会有不同的想法了：</p>
<img src="https://img-blog.csdnimg.cn/20201110015124615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JtMTk5OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:50%;" />

<p>从上面的结果来看符合组 (groupId) 条件几乎满足表中的所有行，符合用户 (userId) 条件的有 130 万条记录——也就是说索引基本上没什么用。因为这些数据是从其他应用中迁移过来的，迁移的时候把所有的消息都赋予了管理员组的用户。这个案例的解决办法是修改应用程序代码，区分这类特殊用户和组，禁止针对这类用户和组执行这个查询。</p>
<p><strong>从这个小案例可以看到经验法则和推论在多数情况是有用的，但要注意不要假设平均情况下的性能也能代表特殊情况下的性能，特殊情况可能会摧毁整个应用的性能</strong>。</p>
<p>最后，尽管关于选择性和基数的经验法则值得去研究和分析，但一定要记住别忘了 WHERE 子句中的排序、分组和范围条件等其他因素，这些因素可能对查询的性能造成非常大的影响。</p>
<h2 id="5-3-5-聚簇索引"><a href="#5-3-5-聚簇索引" class="headerlink" title="5.3.5 聚簇索引"></a>5.3.5 聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，<strong>但 InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行</strong>。</p>
<p><strong>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。术语 “聚簇” 表示数据行和相邻的键值紧凑地存储在一起<!--这并非总是成立，马上就可以看到-->。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引</strong>（不过，覆盖索引可以模拟多个聚簇索引的情况，本章后面将详细介绍）。</p>
<p>因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。</p>
<p>图 5-3 展示了聚簇索引中的记录是如何存放的。<strong>注意到，叶子页包含了行的全部数据，但是节点页只包含了索引列</strong>。在这个案例中，索引列包含的是整数值。</p>
<img src="https://img-blog.csdnimg.cn/20201118144745927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JtMTk5OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:33%;" />

<p><strong>InnoDB 将通过主键聚集数据。如果没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引</strong>。InnoDB 只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。</p>
<p>聚集的数据有一些重要的优点：</p>
<ul>
<li><strong>可以把相关数据保存在一起</strong>。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 IO。</li>
<li><strong>数据访问更快</strong>。聚簇索引将索引和数据保存在同一个 B-Tree 中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li>
<li><strong>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</strong>。</li>
</ul>
<p>同时，聚簇索引也有一些缺点：</p>
<ul>
<li>聚簇数据最大限度的提高了 I/O 密集型应用的性能，但<strong>如果数据全部都放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有那么优势了</strong>。</li>
<li><strong>插入速度严重依赖于插入顺序</strong>。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表。</li>
<li><strong>更新聚簇索引列的代价很高</strong>，因为会强制 InnoDB 将每个被更新的行移动到新的位置。</li>
<li><strong>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临 “页分裂” 的问题</strong>。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li><strong>聚簇索引可能导致全表扫描变慢</strong>，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li>
<li><strong>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列</strong>。</li>
<li><strong>二级索引访问需要两次索引查找，而不是一次</strong>。</li>
</ul>
<p>最后一点可能让人有些疑惑，<strong>为什么二级索引需要两次索引查找</strong>？答案在于二级索引中保存的 “行指针” 的实质。要记住，二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。</p>
<p>这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次 B-Tree 查找而不是一次。对于 InnoDB，自适应哈希索引能够减少这样的重复工作。</p>
<h3 id="InnoDB和MyISAM的数据分布对比"><a href="#InnoDB和MyISAM的数据分布对比" class="headerlink" title="InnoDB和MyISAM的数据分布对比"></a>InnoDB和MyISAM的数据分布对比</h3><h3 id="在InnoDB表中按主键顺序插入行"><a href="#在InnoDB表中按主键顺序插入行" class="headerlink" title="在InnoDB表中按主键顺序插入行"></a>在InnoDB表中按主键顺序插入行</h3><p><strong>最好避免随机的聚簇索引，特别对于I/O密集型的应用。例如，从性能的角度考虑，使用UUID作为聚簇索引会很糟糕：它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。</strong></p>
<p>为了演示这一点，我们做如下两个基准测试。</p>
<p>第一个使用整数ID插入shopinfo表，整数ID自增且为主键：</p>
<p>第二个例子是shopinfo_uuid表，除了主键改为UUID，其余和前面的shopinfo表完全相同。</p>
<p>我们先向这两个表各插入1万条记录。然后再向这两个表继续插入9万条记录，观察这两个表的插入耗时和表索引大小，下表对测试结果进行比较。</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>行数</th>
<th align="center">时间</th>
<th align="center">索引大小（MB）</th>
</tr>
</thead>
<tbody><tr>
<td>shopinfo</td>
<td>10000</td>
<td align="center">0.755s</td>
<td align="center">4.08</td>
</tr>
<tr>
<td>shopinfo_uuid</td>
<td>10000</td>
<td align="center">1.699s</td>
<td align="center">8.16</td>
</tr>
<tr>
<td>shopinfo</td>
<td>90000</td>
<td align="center">8.014s</td>
<td align="center">29.47</td>
</tr>
<tr>
<td>shopinfo_uuid</td>
<td>90000</td>
<td align="center">46.111s</td>
<td align="center">60.58</td>
</tr>
</tbody></table>
<p>通过测试，插入同样的行数和内容（除主键内容），向UUID主键插入行不仅花费的时间更长，而且索引占用的空间也更大。<a href="">这一方面是由于主键字段更长，另一方面毫无疑问是由于页分裂和碎片导致的。</a></p>
<p>由于主键的值是顺序的，InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB默认的最大填充因子是页大小的15/16，留出的部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这样顺序的方式加载，主键页就会近似于被顺序的记录填满，这也是所期望的结果。</p>
<img src="https://upload-images.jianshu.io/upload_images/3190591-341cb567b964f649.png" alt="img" style="zoom:50%;" />

<p>而当采用UUID的聚簇索引的表往插入数据，因为新行的主键值不一定比之前的插入值大，所以InnoDB无法简单的总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置—-通常是已有数据的中间位置—-并且分配空间。这会增加很多额外的工作，并导致数据分布不够优化。</p>
<img src="https://upload-images.jianshu.io/upload_images/3190591-429aa829eb39b79c.png" alt="img" style="zoom: 50%;" />

<p>下面总结使用UUID作为主键的一些缺点：</p>
<blockquote>
<ul>
<li>写入目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机I/O；</li>
<li>因为写入是乱序的，InnoDB不得不频繁的做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个，包含两个叶子节点和一个父节点。</li>
<li>由于频繁的页分裂，页会变得稀疏并被不规则的填充，所以最终数据会有碎片。</li>
</ul>
</blockquote>
<p>把这些随机值载入到聚簇索引以后，需要做一次optimize table来重建表并优化页的填充。</p>
<!--顺序主键也有缺点：对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是auto_increment锁机制；如果遇到这个问题，则可能需要考虑重新设计表或者应用，比如应用层面生成单调递增的主键ID，插表不使用auto_increment机制，或者更改innodb_autonc_lock_mode配置。-->

<h2 id="5-3-6-覆盖索引"><a href="#5-3-6-覆盖索引" class="headerlink" title="5.3.6 覆盖索引"></a>5.3.6 覆盖索引</h2><!-- 举一反三的思路：通常大家都会根据查询的WHERE条件来创建合适的索引，不过这只是索引优化的一个方面。设计优秀的索引应该考虑到整个查询，而不单单是WHERE条件部分。索引确实是一种查找数据的高效方式，但是MySQL也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。如果索引的叶子节点中包含要查询的数据，那么还有什么必要再回表查询呢？。-->

<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引“</p>
<p>覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下如果查询只需要扫描索引而无须回表，会带来多少好处：</p>
<ul>
<li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存中（这对于MyISAM尤其正确，因为MyISAM能压缩索引以变得更小）。</li>
<li>因为索引是按照列值顺存储的<!--至少在单个页内是如此-->，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。对于某些存储引擎，例如MyISAM和Percona XtraDB，甚至可以通过OPTIMIZE命令使得索引完全顺序排列，这让简单的范围查询能使用完全顺序的索引访问。</li>
<li>一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</li>
</ul>
<!--在所有这些场景中，在索引中满足查询的成本一般比查询行要小得多。-->
<p><strong>不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值</strong>，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。另外，不同的存储引擎实现覆盖索引的方式也不同，而且不是所有的引擎都支持覆盖索引(在写作本书时，Memory存储引擎就不支持覆盖索引)。</p>
<h3 id="示例1-Using-Extra的使用"><a href="#示例1-Using-Extra的使用" class="headerlink" title="示例1: Using Extra的使用"></a>示例1: Using Extra的使用</h3><p>当发起一个被索引覆盖的查询（也叫做索引覆盖查询）时，在EXPLAIN的Extra列可以看到“Using index“的信息。例如，表skaila.inventory有一个多列索引(store_id,film_id)。MySQL如果只需访问这两列，就可以使用这个索引做覆盖索引，如下所示：<br><img src="https://img-blog.csdn.net/20180302131848274?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlyZW50aWFucmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图1" style="zoom:33%;" /></p>
<h3 id="示例2-无法优化"><a href="#示例2-无法优化" class="headerlink" title="示例2: 无法优化"></a>示例2: 无法优化</h3><p>索引覆盖查询还有很多陷阱可能会导致无法实现优化。MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。假设索引覆盖了WHERE条件的字段，但不是整个查询涉及的字段。如果条件为假（false），MySQL5.5和更早的版本也总是会回表获取数据行，尽管并不需要这一行且最终会被过滤掉。<br>来看看为什么会发生这样的情况，以及如何重写查询以解决该问题。</p>
<p>从下面的查询开始：<br><img src="https://img-blog.csdn.net/20180302131909405?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlyZW50aWFucmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图2" style="zoom:33%;" /><br>这里索引无法覆盖查询，有两个原因：</p>
<ul>
<li>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。不过，理论上MySQL还有一个捷径可以利用：WHERE条件中的列是有索引可以覆盖的，因此MySQL可以使用该索引找到对应的actor并检查title是否匹配，过滤之后再读取需要的数据行。</li>
<li>MySQL不能在索引中执行LIKE操作。这是底层存储引擎API的限制。MySQL能在索引中做最左前缀匹配的LIKE比较，因为该操作可以转换为简单的比较操作，但是如果是通配符开头的LIKE查询，存储引擎就无法做比较匹配。这种情况下，MySQL服务器只能提取数据行的值而不是索引值来做比较。</li>
</ul>
<h3 id="示例3-延迟关联"><a href="#示例3-延迟关联" class="headerlink" title="示例3: 延迟关联"></a>示例3: 延迟关联</h3><p>也有办法可以解决上面说的两个问题，需要重写查询并巧妙地设计索引。先将索引扩展至三个数据列(artor,title,prod_id)，然后按如下方式重新查询：<br><img src="https://img-blog.csdn.net/20180302131926690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlyZW50aWFucmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图3" style="zoom:33%;" /></p>
<p>我们把这种方式叫做延迟关联（deferred join），因为延迟了对列的访问。</p>
<blockquote>
<p>在查询的第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id，然后根据这些prod_id值在外层查询匹配获取需要的所有列值。虽然无法使用索引覆盖整个查询，但总算比完全无法利用索引覆盖的好。这样优化的效果取决于WHERE条件匹配返回的行数。</p>
</blockquote>
<p>假设这个products表有100万行，我们来看一下上面两个查询在三个不同的数据集上的表现，每个数据集都包含100万行：<br>1、 第一个数据集，Sean Carrey出演了30000部作品，其中有20000部的标题中包含了Apollo。<br>2、 第一个数据集，Sean Carrey出演了30000部作品，其中有40部的标题中包含了Apollo。<br>3、 第一个数据集，Sean Carrey出演了50部作品，其中有10部的标题中包含了Apollo。</p>
<p>使用上面的三种数据集来测试两种不同的查询<br><img src="https://img-blog.csdn.net/20180302131947291?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlyZW50aWFucmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图4"><br>下面是对结果的分析：</p>
<ul>
<li>在示例1中，查询返回了一个很大的结果集，因此看不到优化的效果。大部分时间都花在读取和发送数据上了。</li>
<li>在示例2中，经过索引过滤，尤其是第二个条件过滤后只返回了很少的结果集，优化的效果非常明显：在这个数据集上性能提高了5倍，优化后的查询的效率主得益于需要读取40行完整数据行，而不是原查询中需要的30000行。</li>
<li>在示例3中，显示了子查询效率反而下降的情况。因为索引过滤时符合第一个条件的结果集已经很小，所以子查询带来的成本反而比从表中直接提取完整行更高。</li>
</ul>
<p>在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的查询。不过，可以更进一步优化InnoDB。回想一下，InnoDB的二级索引的叶子节点都包含了主键的值，这意味着InnoDB的二级索引可以有效地利用这些“额外“的主键来覆盖查询。<br>例如，sakila.actor使用InnoDB存储引擎，并在last_name字段有二级索引，虽然该索引的列不包含主键actor_id，但也能够用于对actor_id做覆盖查询：<br><img src="https://img-blog.csdn.net/20180302132006356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlyZW50aWFucmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图5" style="zoom:33%;" /></p>
<blockquote>
<p>这里由于该书发布时间很早，现在MySQL版本5.6以后已经支持索引条件推送(index condition push):</p>
<p>将数据的过滤条件传送到存储引擎层，而不是传给服务器层</p>
</blockquote>
<h2 id="5-3-7-使用索引扫描来做排序"><a href="#5-3-7-使用索引扫描来做排序" class="headerlink" title="5.3.7 使用索引扫描来做排序"></a>5.3.7 使用索引扫描来做排序</h2><p>mySQL有两种方式可以生成有序的结果，通过排序操作或者按照索引顺序扫描；如果explain的type列的值为index，则说明mysql使用了索引扫描来做排序（不要和extra列的Using index搞混了，那个是使用了覆盖索引查询）。</p>
<p>扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录，但如果索引不能覆盖查询所需的全部列，那就不得不扫描一条索引记录就回表查询一次对应的整行，这基本上都是随机IO，因此按索引顺序读取数据的速度通常要比顺序地 <!--应该是主键顺序--> 全表扫描慢，尤其是在IO密集型的工作负载时。</p>
<p>mysql可以使用同一个索引既满足排序，又用于查找行，因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样是最好的。</p>
<p>只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方向（倒序或升序，创建索引时可以指定ASC或DESC）都一样时，mysql才能使用索引来对结果做排序，如果查询需要关联多张表，则只有当order by子句引用的字段全部为第一个表时，才能使用索引做排序，order by子句和查找型查询的限制是一样的，需要满足索引的最左前缀的要求，否则mysql都需要执行排序操作，而无法使用索引排序。</p>
<p>有一种情况下ORDER BY 子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE 子旬或者JOIN 子旬中对这些列指定了常量，就可以“弥补” 索引的不足。</p>
<h2 id="5-3-8-索引压缩"><a href="#5-3-8-索引压缩" class="headerlink" title="5.3.8 索引压缩"></a>5.3.8 索引压缩</h2><h2 id="5-3-9冗余和重复索引"><a href="#5-3-9冗余和重复索引" class="headerlink" title="5.3.9冗余和重复索引"></a>5.3.9冗余和重复索引</h2><p>​    MySQL允许在相同列上创建多个索引，无论是有意的还是无意的。 MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。</p>
<p>​    重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。 应该避免这样创建重复索引，发现以后也应该立即移除。</p>
<p>​    冗余索引和重复索引有一些不同。 如果创建了索引(A, B)， 再创建索引 (A) 就是冗余索引，因为这只是前一个索引的前缀索引。 因此索引(A, B) 也可以当作索引 (A) 来使用（这种冗余只是对B-Tree索引来说的）。 但是如果再创建索引,(B, A), 则不是冗余索引，索引 (B)也不是，因为 B不是索引 (A, B) 的最左前缀列。 另外，其他不同类型的索引（例如哈希索引或者全文索引） 也不会是B-Tree索引的冗余索引，而无论覆盖的索引列是什么。</p>
<p>​    冗余索引通常发生在为表添加新索引的时候。 例如，有人可能会增加一个新的索引(A, B)而不是扩展已有的索引 (A)。还有一种情况是将一个索引扩展为(A, ID), 其中 ID 是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。 但也有时候出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。</p>
<h2 id="5-3-10-未使用的索引"><a href="#5-3-10-未使用的索引" class="headerlink" title="5.3.10 未使用的索引"></a>5.3.10 未使用的索引</h2><h2 id="5-3-11-索引和锁"><a href="#5-3-11-索引和锁" class="headerlink" title="5.3.11 索引和锁"></a>5.3.11 索引和锁</h2><p>索引可以让查询锁定更少的行。 如果你的查询从不访问那些不需要的行， 那么就会锁定 更少的行， 从两个方面来看这对性能都有好处。 首先， 虽然InnoDB的行锁效率很高，内存使用也很少， 但是锁定行的时候仍然会带来额外开销 ; 其次， 锁定超过需要的行会增加锁争用井减少并发性。</p>
<p>InnoDB只有在访问行的时候才会对其加锁， 而索引能够减少InnoDB访问的行数， 从而减少锁的数量。 但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。 如果索引无法过滤掉无效的行， 那么在InnoDB检索到数据返回给服务器层以后， MySQL服务器才能应用WHERE子句。 这时已经无法避免锁定行了： InnoDB已经锁住了这些行，到适当的时候才释放。 在MySQL5.1和更新的版本中，lnnoDB可以在服务器端过滤掉行后就释放锁， 但是在早期的MySQL版本中，InnoDB只有在事务提交后才能释放锁。</p>
<p> 尽可能将需要做范围查询的列放到索引的后面，以便优化器能使用尽可能多的索引列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set autocommit&#x3D;0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select actor_id from actor where actor_id &lt;5 and actor_id &lt;&gt;1 for update;</span><br><span class="line">+----------+</span><br><span class="line">| actor_id |</span><br><span class="line">+----------+</span><br><span class="line">|        2 |</span><br><span class="line">|        3 |</span><br><span class="line">|        4 |</span><br><span class="line">+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>这条sql仅仅返回2-4之间的行，但是实际上获取了1-4之间的行的排它锁。InnoDB会锁住第一行，这是因为Mysql为该查询选的执行计划是索引范围扫描。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select actor_id from actor where actor_id &lt;<span class="number">5</span> and actor_id &lt;&gt;<span class="number">1</span> <span class="keyword">for</span> update;</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+--------------------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra                    |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+--------------------------+</span><br><span class="line">|  <span class="number">1</span> | SIMPLE      | actor | range | PRIMARY       | PRIMARY | <span class="number">2</span>       | NULL |    <span class="number">3</span> | Using where; Using index |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+--------------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>换句话说，存储引擎的操作时”从索引的开头开始获取满足条件actor_id &lt; 5的记录”，服务器并没有告诉Innodb可以过滤掉第一行的where条件。<a href="">注意到Explain中的extra出现了”using where”，这表示MySQL服务器将存储引擎返回行以后在应用where过滤条件。</a></p>
<p>下面的第二个查询就能证明第1行确实被锁了，尽管第一个查询的结果并没有出现第1行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 第一个查询</span><br><span class="line">mysql&gt; set autocommit&#x3D;0;</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; select actor_id from actor where actor_id &lt;5 and actor_id &lt;&gt;1 for update;</span><br><span class="line">mysql&gt; commit;</span><br><span class="line"></span><br><span class="line">-- 第二个查询</span><br><span class="line">#另外开启一个新事务</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; select actor_id from actor where actor_id &#x3D;1 for update;</span><br><span class="line">+----------+</span><br><span class="line">| actor_id |</span><br><span class="line">+----------+</span><br><span class="line">|        1 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (12.82 sec) #第一个连接commit释放锁之后才能执行查询3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在MySQL中大多数情况下会使用B-Tree索引。编写查询语句时应该尽可能选择合适的索引以避免单行查找，尽可能使用数据原生顺序，尽可能使用索引覆盖查询。</p>
</blockquote>
<p>就像上面的例子展示的，即使使用索引，InnoDB也可能锁住不需要的数据。如果不使用索引查找和锁定行的话，MySQL会做全表扫描并且锁住所有的行，这实在太糟糕了。</p>
<blockquote>
<p>InnoDB在二级索引上使用的是共享（读）锁，但访问主键索引需要排他（写）锁。这消除了使用覆盖索引的可能性，并且使得select for update 比lock in share mode或非锁定查询要慢很多。</p>
</blockquote>
<p>注意：尽管理论上使用基于行的日志模式 <!--MVCC-->，在某些事物隔离级别下，服务器不再需要锁定行，但实践中经常无法实现这种预期。比如在Read-commited隔离级别和基于行的日志模式下。</p>
<h1 id="5-5-维护索引和表"><a href="#5-5-维护索引和表" class="headerlink" title="5.5 维护索引和表"></a>5.5 维护索引和表</h1><p>5.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter4%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter4%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/" class="post-title-link" itemprop="url">chapter4对象的组合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-17 11:57:11" itemprop="dateCreated datePublished" datetime="2020-12-17T11:57:11+08:00">2020-12-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-20 20:04:07" itemprop="dateModified" datetime="2021-03-20T20:04:07+08:00">2021-03-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h1><p>我们并不希望每一次内存访问都进行分析以确保程序时线程安全的，而是希望将一些现有的线程安全组件组合为更大规模的组件或程序。本章将介绍一些组合模式，这些模式能够将一个类更容易成为线程安全的，并且在维护这些类时不会无意中破坏类的安全性保证。</p>
<h2 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h2><p>通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否时线程安全的。</p>
<blockquote>
<p>在设计线程安全类的过程中，需要包含以下三个基本要素：<br>* 找出构成对象状态的所有变量。<br>* 找出约束状态变量的不变性条件。<br>* 建立对象状态的并发访问管理策略。</p>
</blockquote>
<p>要分析对象的状态，首先从对象的域开始。</p>
<blockquote>
<p>如果在对象的域中都是基本类型的变量，那么这些域将构成对象的全部状态。</p>
<p>如果在对象的域中引用了其他对象，那么该对象的状态就包含被引用对象的域。</p>
</blockquote>
<p>同步策略定义了如何在不违背对象不变性条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写为正式文档。</p>
<h3 id="收集同步需求"><a href="#收集同步需求" class="headerlink" title="收集同步需求"></a>收集同步需求</h3><p>要确保类的线程安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏，这就需要对其状态进行推断。对象与变量都有一个状态空间，即所有可能的取值。状态空间越小，就越容易判断线程的状态。final类型的域使用的越多，就能简化对象可能状态的分析过程。（不可变对象只有唯一的状态）</p>
<p>许多类中定义了一些不可变条件，拥有判断状态是有效的还是无效的。long类型的变量，其状态空间为从Long.MIN_VALUE到Long.MAX_VALUE，但Counter中value取值范围存在限制，即不能是负值。</p>
<p>在操作中还会包含一些后验条件来判断状态迁移是否是有效的。如果Counter的当前状态是17，那么下一个有效状态只能是18。<strong>当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。</strong>并非所有的操作都会在状态转换上施加限制，例如，当更新一个保存当前温度的变量时，该变量之前的状态并不会影响计算结果。</p>
<p><a href="">由于不变性条件以及后验条件在状态及状态转换上施加了各种约束</a>，因此就需要额外的同步与封装。如果某些状态是无效的，那么必须对底层的状态变量进行封装，否则客户端代码可能会使对象处于无效状态。如果在某个操作中存在无效的状态转换，那么该操作必须是原子的。如果没有施加这种约束，那么就可以放宽封装性或序列化需求，以便获得更高的灵活性或性能。</p>
<p>在类中也可以包含同时约束多个状态变量的不变性条件。在一个表示数值范围的类中可以包含两个状态变量，分别表示范围的上界和下界。这些变量必须遵循的约束是，下界值应该小于或等于上界值。类似于这种包含多个变量的不变性条件将带来原子性需求：这些相关的变量必须在单个原子操作中 <!--复合操作--> 进行读取或更新。不能首先更新一个变量，然后释放锁并再次获得锁，然后再更新其他的变量。因为在释放锁后，可能会使对象处于无效状态。如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。</p>
<blockquote>
<p>如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。</p>
</blockquote>
<h3 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h3><p>类的不变性条件与后验条件约束了在对象上有哪些状态和转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件。例如，不能够从空队列中移除一个元素，在输出元素前，队列必须处于“非空的”状态。如果在某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。</p>
<p>在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中，先验条件可能会由于其他线程执行的操作而变为真 <!--这就是Bug了--> 。<a href="">在并发程序中要一直等到先验条件为真，然后再执行该操作</a>。</p>
<p>在Java中，等待某个条件为真的各种内置机制，（包括等待和通知等机制）都与内置加锁机制紧密关联，要想正确地使用他们并不容易。要想实现某个等待先验条件为真时才执行的操作，一种更简单的方法是通过现有库中的类（例如阻塞队列【BlockingQueue】或信号量【Semaphore】）来实现依赖状态的行为。</p>
<h3 id="状态的所有权"><a href="#状态的所有权" class="headerlink" title="状态的所有权"></a>状态的所有权</h3><p>如果以某个对象为根节点构造一张对象图，那么该对象的状态将是对象图中所有对象包含的域的一个子集。</p>
<p>在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据。如果分配并填充了一个HashMap对象，那么就相当于创建多个对象：HashMap对象，在HashMap对象中包含的多个对象，以及在Map.Entry中可能包含的内部对象。HashMap对象的逻辑状态包括所有的Map.Entry对象以及内部对象，即使这些对象都是一些独立的对象。</p>
<p>所有权与封装性总是相互关联的：对象封装它拥有的状态，反之也成立，对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。所有权意味着控制权。然而，如果发布了某个可变对象的引用，那么就不再拥有独占的控制权，最多是“共享控制权”。对于从构造函数或者从方法中传递进来的对象，类通常并不拥有这些对象，除非这些方法是被专门设计为转移传递进来的对象的所有权（例如，同步容器封装器的工厂方法）。</p>
<p>容器类通常变现出一种“所有权分离”的形式，其中容器类拥有其自身的状态，而客户代码则拥有容器中各个对象的状态。Servlet框架中的ServletContext就是其中一个示例。ServletContext为Servlet提供了类似于Map形式的对象容器服务，在ServletContext可以通过名称来注册（setAttribute）或获取（getAttribute）应用程序对象。由Servlet容器实现的ServletContext对象必须是线程安全的，因为它肯定会被多个线程同时访问。当调用setAttribute和getAttribute时，Servlet不需要使用同步，但当使用保存在ServletContext中的对象时，则可能需要使用同步。这些对象由应用程序 <!--客户代码--> 拥有，Servlet容器只是替应用程序保管它们。与所有共享对象一样，它们必须安全地被共享。为了防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象要么是线程安全的对象，要么是事实不可变的对象，或者由锁来保护的对象。</p>
<h2 id="实例封闭-我上章说的对象封闭"><a href="#实例封闭-我上章说的对象封闭" class="headerlink" title="实例封闭(我上章说的对象封闭)"></a>实例封闭(我上章说的对象封闭)</h2><p>如果某对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用。你可以确保该对象只能由单个线程访问（线程封闭），或者一个锁来保护该对象的所有访问<!--复习第2章--></p>
<p>封装简化了线程安全类的实现过程，它提供了<strong>实例封闭机制</strong>。当一个对象被封闭到另一个对象中时，能够访问被封闭对象的所有代码路径都是已知。与对象可以由整个程序访问的情况相比，更易于对代码进行分析。通过封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。</p>
<blockquote>
<p>将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。</p>
</blockquote>
<p>被封闭对象一定不能超出既定的作用域。对象可以封闭在类的一个实例（例如作为类的一个私有成员）中，或者封闭在某个作用域内（例如作为一个局部变量），再或者封闭在线程内（例如在某个线程中将对象从一个方法传递到另一个方法，而不是在多个线程之间共享该对象）。</p>
<p>通过封闭机制来确保线程安全，通过封闭与加锁等机制使一个类成为线程安全的（即使这个类的状态变量并不是线程安全的）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过封闭机制来确保线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Person&gt; mySet = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        mySet.add(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">containsPerson</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySet.contains(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PersonSet的状态由HashSet来管理，而HashSet并非线程安全的<!--PersonSet是类的对象，mySet是其中一个域，那么PersonSet的状态就包含mySet以及mySet引用的Person对象，复习开头的定义-->。但由于mySet是私有的并且没有逸出，因此HashSet被封闭在PersonSet中。唯一能访问mySet的代码路径是addPerson与containsPerson，在执行它们时都要获得PersonSet上的锁。PersonSet的状态完全由它的内置锁保护满足<!--第二章的加锁约定-->，因此PersonSet是线程安全的类。</p>
<p>但如果Person类是可变的，那么在访问从PersonSet中获得的Person对象时<!--比如public Person getPerson()-->，还需要额外的同步。要想安全地使用Person对象，可以使Person对象成为一个线程安全类。也可以使用锁来保护Person对象，并确保所有客户端代码在访问Person对象之前都已经获得正确的锁。</p>
<p>实例封闭时构建线程安全类的一个最简单方式，它使得在锁策略的选择上拥有了更多地灵活性。在PersonSet中可以使用内置锁来保护它的状态，对于其他形式的锁只要自始至终都使用同一个锁，就可以保护状态。<strong>实例封闭还使得不同的状态可以由不同的锁来保护</strong>。</p>
<p>在Java平台的类库中还有很多实例封闭的示例，其中有些类的唯一用途就是将非线程安全的类转化为线程安全的类。一些基本的容器类例如ArrayList不是线程安全的，但类库提供了包装器工厂方法，例如<strong>Collections.synchronizedList及其类似方法，使得这些非线程安全的类可以在多线程环境中安全地使用。这些工厂方法通过”装饰器Decorator”模式将容器封装在一个同步的容器对象上，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象上。只要包装器对象拥有对底层容器对象的唯一引用（即把底层容器对象封闭在包装器中），那么它就是线程安全的。在这引起方法的Javadoc中指出，对底层容器对象的所有访问必须通过包装器来进行。</strong></p>
<p>如果将一个本该被封闭的对象发布出去，那么也能破坏封闭性。如果一个对象本应该封闭在特定的作用域内，那么让该对象逸出作用域就是一个错误。当发布其他对象时，例如迭代器或内部的类实例，可能会间接地发布被封闭对象，同样会使被封闭对象逸出。</p>
<blockquote>
<p>封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。</p>
</blockquote>
<h3 id="Java监视器模式"><a href="#Java监视器模式" class="headerlink" title="Java监视器模式"></a>Java监视器模式</h3><p>进入和退出同步代码的字节指令也称为monitorenter和monitorexit，而Java的内置锁也称为监视器锁或监视器。</p>
<p>遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。</p>
<p>Java监视器模式的主要优势就在于它的简单性，11章介绍通过更细粒度的加锁策略来提高可伸缩性。</p>
<p><strong>Java监视器模式仅仅是编写代码的约定，对于任何一种锁对象，只要自始至终都使用该锁对象</strong>，都可以用来保护对象的状态。如下程序给出了如何使用私有锁来保护状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过一个私有锁来保护状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object myLock = <span class="keyword">new</span> Object();</span><br><span class="line">		<span class="meta">@GuardedBy(&quot;myLock&quot;)</span>Widget widget;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(myLock)&#123;</span><br><span class="line">            <span class="comment">// 访问或修改Widget的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>私有的锁对象可以将锁封装起来，使客户代码无法得到锁，但客户代码可以通过公有方法来访问锁，以便（正确或者不正确）参与到它的同步策略中。</p>
<h3 id="示例：车辆追踪"><a href="#示例：车辆追踪" class="headerlink" title="示例：车辆追踪"></a>示例：车辆追踪</h3><p>　　以下程序清单中，我们看一个示例： 一个用于调度车辆的“车辆追踪器”。首先使用监视器模式来构建车辆追踪器，然后尝试放宽某些封装性需求同时又保持线程安全性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorVehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String ,MutablePoint&gt; locations;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MonitorVehicleTracker</span><span class="params">(Map&lt;String ,MutablePoint&gt; locations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.locations = deepCopy(locations);   <span class="comment">//返回拷贝信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Map&lt;String, MutablePoint&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deepCopy(locations); <span class="comment">//返回拷贝信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> MutablePoint <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        MutablePoint lo = locations.get(id);</span><br><span class="line">        <span class="keyword">return</span> lo == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> MutablePoint(lo);    <span class="comment">//返回拷贝信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocations</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        MutablePoint lo = locations.get(id);</span><br><span class="line">        <span class="keyword">if</span> (lo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lo.x = x;</span><br><span class="line">        lo.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, MutablePoint&gt; <span class="title">deepCopy</span><span class="params">(Map&lt;String, MutablePoint&gt; locations)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, MutablePoint&gt; result = <span class="keyword">new</span> HashMap&lt;String, MutablePoint&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String id : locations.keySet()) &#123;</span><br><span class="line">            result.put(id, <span class="keyword">new</span> MutablePoint(locations.get(id)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span>【不要这么做】</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePoint</span> </span>&#123;　　　　　　　</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePoint</span><span class="params">(MutablePoint p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = p.x;</span><br><span class="line">        <span class="keyword">this</span>.y = p.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　虽然类 MutablePoint 不是线程安全的，但追踪器类时线程安全的，<!--它所包含的 Map 对象和可变的 Point 对象都未曾发布-->。当需要返回车辆的位置时，通过 MutablePoint 拷贝构造函数或者 deepCopy 方法来复制正确的值，从而生成一个新的Map 对象 <!--更准确来说，新的句柄和新的对象-->，并且该对象中的值与原有 Map 对象中的 key 值和 value 值都相同。</p>
<p>　　在某种程度上，这种实现方式是通过再返回客户代码之前复制可变的数据来维持线程安全性的。通常情况下，这并不存在性能问题，但在车辆容器非常大的情况下将极大地降低性能。<!--这么多数据副本，内存不够了--></p>
<h2 id="线程安全性的委托-不依赖锁，依赖内部类是线程安全的"><a href="#线程安全性的委托-不依赖锁，依赖内部类是线程安全的" class="headerlink" title="线程安全性的委托(不依赖锁，依赖内部类是线程安全的)"></a>线程安全性的委托(不依赖锁，依赖内部类是线程安全的)</h2><p>大多数对象都是组合对象。当从头开始构建一个类，或者将多个非线程安全的类组合为一个类时，Java监视器模式是非常有用的。如果类中的各个组件都已经是线程安全的，会是什么情况？是否需要再增加一个额外的线程安全层？答案是“视情况而定”。在某些情况下，通过多个线程安全类组合而成的类是线程安全的，而在某些情况下，仅仅是好的开端。</p>
<h3 id="示例：基于委托的车辆追踪器"><a href="#示例：基于委托的车辆追踪器" class="headerlink" title="示例：基于委托的车辆追踪器"></a>示例：基于委托的车辆追踪器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将线程安全委托给ConcurrentMap</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingVehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Point&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Point&gt; unmodifiableMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegatingVehicleTracker</span><span class="params">(Map&lt;String, Point&gt; points)</span> </span>&#123;</span><br><span class="line">        locations = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Point&gt;(points);</span><br><span class="line">        unmodifiableMap = Collections.unmodifiableMap(locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Point&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unmodifiableMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> locations.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (locations.replace(id, <span class="keyword">new</span> Point(x, y)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid vehicle name: &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Alternate version of getLocations (Listing 4.8)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Point&gt; <span class="title">getLocationsAsStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(</span><br><span class="line">                <span class="keyword">new</span> HashMap&lt;String, Point&gt;(locations));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Point类使不可变的，所以它是线程安全的。<a href="">不可变的值可以被自由地共享与发布</a>，<a href="">因此在返回location时不需要复制。</a>DelegatingVehicleTracker没有使用任何显示的同步，所有对状态的访问都由ConcurrentHashMap来管理<!--unmodifiableMap是线程安全的，不影响其状态，所以不考虑了-->，而且Map所有的key和value都是不可变的。</p>
<p>如果使用最初的MutablePoint类而不是Point类，就会破坏封装性，因为Map&lt;String, Point&gt; getLocations() 会发布一个指向可变状态的引用，而这个引用不是线程安全的。</p>
<blockquote>
<p>在使用监视器模式的车辆追踪器中返回的是车辆位置的快照，而在使用委托车辆追踪器中返回的是一个不可修改但却实时的车辆位置试图。这意味着，如果线程A调用getLocations，而线程B随后修改了某些点的位置，那么在返回给线程A的Map中将反映出这些变化。这可能是优点(更新的数据)，可能是缺点（可能导致不一致的车辆位置视图），具体情况取决于你的需求。</p>
</blockquote>
<p>如果委托的车辆追踪器也系统得到车辆位置的快照，那么getLocations可以返回对locations这个Map对象的一个浅拷贝。由于Map的内容是不可变的，因此只需复制Map的结构，而不用复制它的内容。</p>
<h3 id="独立的状态变量"><a href="#独立的状态变量" class="headerlink" title="独立的状态变量"></a>独立的状态变量</h3><p>可以将线程安全性委托给多个状态变量，<strong>只要这些变量是彼此独立的</strong>，<!--即组合而成的类，并不会在其包含的多个状态变量上增加任何不变性条件，或者说约束条件-->。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisualComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;KeyListener&gt; keyListeners</span><br><span class="line">            = <span class="keyword">new</span> CopyOnWriteArrayList&lt;KeyListener&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MouseListener&gt; mouseListeners</span><br><span class="line">            = <span class="keyword">new</span> CopyOnWriteArrayList&lt;MouseListener&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addKeyListener</span><span class="params">(KeyListener listener)</span> </span>&#123;</span><br><span class="line">        keyListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMouseListener</span><span class="params">(MouseListener listener)</span> </span>&#123;</span><br><span class="line">        mouseListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKeyListener</span><span class="params">(KeyListener listener)</span> </span>&#123;</span><br><span class="line">        keyListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMouseListener</span><span class="params">(MouseListener listener)</span> </span>&#123;</span><br><span class="line">        mouseListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VisualComponent使用CopyOnWriteArrayList来保存各个监听器列表。它是一个线程安全的链表，特别适用于管理监听器列表。每个列表都是线程安全的，由于各个状态之间不存在耦合关系，<!--比如key和mouse就是彼此完全独立的--> 因此VisualComponent可以将它的线程安全性委托给mouseListeners和keyListeners等对象。</p>
<h3 id="当委托失效时"><a href="#当委托失效时" class="headerlink" title="当委托失效时"></a>当委托失效时</h3><p>大多数组合对象都不会像VisualComponent这样简单：<strong>在它们的状态变量之间存在着某些不变性条件</strong>。NumberRange使用了两个AtomicInteger来管理状态，并且含有一个约束条件，即第一个数值要小于或等于第二个数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberRange</span> </span>&#123;</span><br><span class="line">    <span class="comment">// INVARIANT: lower &lt;= upper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger lower = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger upper = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Warning -- unsafe check-then-act</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; upper.get())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;can&#x27;t set lower to &quot;</span> + i + <span class="string">&quot; &gt; upper&quot;</span>);</span><br><span class="line">        lower.set(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Warning -- unsafe check-then-act</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; lower.get())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;can&#x27;t set upper to &quot;</span> + i + <span class="string">&quot; &lt; lower&quot;</span>);</span><br><span class="line">        upper.set(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInRange</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt;= lower.get() &amp;&amp; i &lt;= upper.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NumberRange 不是线程安全的<!--NumberRange是含有隐藏的不变性条件的，因为boolean isInRange(int i)是依赖于lower和upper两个变量，所以两个变量有约束条件-->，没有维持对下界和上界进行约束的不变性条件。假设取值范围在（0， 10），如果一个线程调用 setLower（5），而另一个线程调用 setUpper（4），那么在一些错误的执行时序中，比如下图所示</p>
<table>
<thead>
<tr>
<th align="left">ThreadA</th>
<th>ThreadB</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Line6: setLower（5）</td>
<td></td>
</tr>
<tr>
<td align="left">Line8: i &gt; upper.get() = 10 通过了检查</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td>Line13: setUpper（4）</td>
</tr>
<tr>
<td align="left"></td>
<td>LIne15: i &lt; lower.get() = 0 通过了检查</td>
</tr>
<tr>
<td align="left">Line10: lower.set(i);</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td>LIne17: upper.set(i);</td>
</tr>
</tbody></table>
<p>这两个调用都通过了检查，并且都设置成功。因此，虽然 AtomicInteger 是线程安全的，但经过组合得到的类却不是线程安全的。<strong>由于状态变量lower和upper不是彼此独立的</strong><!--前面一节的代码中，状态变量都是彼此独立的而且线程安全，所以类的线程安全性可以委托给线程安全状态变量-->，<strong>因此NumberRange不能将线程安全性委托给他的线程安全状态变量</strong>。</p>
<p>如果某个类含有复合操作，例如NumberRange，那么仅靠委托并不足以实现线程安全性。在这种情况下，这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。</p>
<blockquote>
<p>如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。</p>
</blockquote>
<h3 id="发布底层的状态变量"><a href="#发布底层的状态变量" class="headerlink" title="发布底层的状态变量"></a>发布底层的状态变量</h3><p>当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能修改它们？</p>
<ul>
<li>答案仍然是取决于在类中对这些变量施加了哪些不变性条件。<ul>
<li>虽然Counter中的value域可以为任何整数值，但Counter施加的约束条件是只能取正整数，此外递增操作同样约束了下一个状态的有效取值范围。如果将value声明为一个公有域，那么客户代码可以将它修改为一个无效值，因此发布value会导致这个类出错 <!--当前counter依赖于上一次counter结果，有约束条件or不变性条件--> 。</li>
<li>另一方面，如果某个变量表示的时当前温度或者最近登录用户的ID，那么即使另一个类在某个时刻修改了这个值，也不会破坏任何不变性条件，因此发布这个变量也是可以接受的。<!--温度和ID没有约束条件--></li>
</ul>
</li>
</ul>
<blockquote>
<p>如果一个状态变量时线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。<!--这就是正确地运用线程安全性的委托--></p>
</blockquote>
<p>例如，发布VisualComponent中的mouseListeners或keyListeners等变量就是安全的。由于VisutalComponent并没有在其监听器链表的合法状态上施加任何约束，因此这些域可以声明为共有域或者发布，而不会破坏线程安全性。</p>
<h3 id="示例：发布状态的车辆追踪器"><a href="#示例：发布状态的车辆追踪器" class="headerlink" title="示例：发布状态的车辆追踪器"></a>示例：发布状态的车辆追踪器</h3><p>我们来构造车辆追踪器的另一个版本，并在这个版本中发布底层的可变状态。我们需要修接口以适应这种变化，即使用可变且线程安全的 Point 类。<!--这个实例就是呼应了4.3.4内容，发布底层对象的状态变量。注意和4.3.1示例的区别，4.3.1示例的底层对象是没有发布对象的，而且是不可变的。现在是发布+可变--></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafePoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafePoint</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafePoint</span><span class="params">(SafePoint p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(p.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafePoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublishingVehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SafePoint&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SafePoint&gt; unmodifiableMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PublishingVehicleTracker</span><span class="params">(Map&lt;String, SafePoint&gt; locations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.locations = <span class="keyword">new</span> ConcurrentHashMap&lt;String, SafePoint&gt;(locations);</span><br><span class="line">        <span class="keyword">this</span>.unmodifiableMap = Collections.unmodifiableMap(<span class="keyword">this</span>.locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, SafePoint&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unmodifiableMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SafePoint <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> locations.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!locations.containsKey(id))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid vehicle name: &quot;</span> + id);</span><br><span class="line">        locations.get(id).set(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在现有的线程安全类中添加功能"><a href="#在现有的线程安全类中添加功能" class="headerlink" title="在现有的线程安全类中添加功能"></a>在现有的线程安全类中添加功能</h2><p>有的时候，现有的类只能支持大部分的操作，此时就需要在不破坏线程安全性的情况下添加一个新的操作。</p>
<p>要添加一个新的原子操作，最安全的做法时修改原始的类，但这通常无法做到，因为你可能无法访问或修改类的源代码。要想修改原始的类，就需要理解代码中的同步策略。这样增加的功能才能与原有的设计保持一致。如果直接将新方法添加到类中，那么意味着实现同步策略的所有代码仍然处于一个源代码文件中，从而更容易理解与维护。</p>
<p>另一种方法是扩展这个类，假定在设计这个类时考虑了可扩展性。但是并非所有的类都像Vector那样将状态向子类公开，因此也就不适合采用这种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterVector</span> &lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// When extending a serializable class, you should redefine serialVersionUID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3963416950630760754L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> absent = !contains(x);</span><br><span class="line">        <span class="keyword">if</span> (absent)</span><br><span class="line">            add(x);</span><br><span class="line">        <span class="keyword">return</span> absent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“扩展”方法比直接将代码添加到类中更加脆弱，因为现在的同步策略实现被分布到多个单独维护的源代码文件中。如果底层的类改变了同步策略并选择了不同的锁来保护它的状态变量，那么子类会被破坏，因为在同步策略改变后它无法再使用正确的锁来控制对基类状态的并发访问。（在Vector的规范中定义了它的同步策略，因此BetterVector不存在这个问题。）</p>
<h3 id="客户端加锁机制"><a href="#客户端加锁机制" class="headerlink" title="客户端加锁机制"></a>客户端加锁机制</h3><p>对于Collections.synchronizedList封装的ArrayList，这两种方法在原始类中添加一个方法或者对类进行扩展都行不通，因为客户代码并不知道在同步封装器工厂方法中返回的List对象的类型。<strong>第三种策略是扩展类的功能，但并不是扩展类本身，而是将扩展代码放入一个“辅助类”中</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">		......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> absent = !list.contains(x);</span><br><span class="line">        <span class="keyword">if</span> (absent)</span><br><span class="line">            list.add(x);</span><br><span class="line">        <span class="keyword">return</span> absent;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--上述代码不能实现线程安全的原因在于使用了不同的锁。-->必须使List在实现客户端加锁或外部加锁时使用同一个锁。客户端加锁是指，对于使用某个对象X的客户端代码，使用X本身用于保护保护其状态的锁来保护这段客户代码。要使用客户端加锁，你必须知道对象X使用的是哪一个锁。

<p>在Vector和同步封装器类的文档中指出，他们通过Vector或同步封装器类的内置锁来支持客户端加锁。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> absent = !list.contains(x);</span><br><span class="line">            <span class="keyword">if</span> (absent)</span><br><span class="line">                list.add(x);</span><br><span class="line">            <span class="keyword">return</span> absent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过添加一个原子操作来扩展类是脆弱的，因为它将类的加锁代码分布到多个类中。然而，客户端加锁却更加脆弱，因为它将类C的加锁代码放到与C完全无关的其他类中。当在那些并不承诺遵循加锁策略的类上使用客户端加锁时，要特别小心。</p>
<p><strong>客户端加锁机制与扩展类机制有许多共同点，二者都是将派生类的行为与基类的实现耦合在一起。正如扩展会破坏实现的封装性，客户端加锁同样会破坏同步策略的封装性。</strong><!--在我看来，都不是好方法--></p>
<h3 id="组合-非常棒！"><a href="#组合-非常棒！" class="headerlink" title="组合(非常棒！)"></a>组合(非常棒！)</h3><p>当为现有的类添加原子操作时，有一种更好的方法：组合。ImproveList通过将List对象的操作委托给底层的List实例来实现List的操作，同时还添加了一个原子的putIfAbsent方法。<!--与Collections.synchronizedList和其他容器封装器一样，ImproveList假设把某个链表对象传递给构造函数以后，客户代码不会再直接使用这个对象，而只能通过ImproveList来访问它。--></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImprovedList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PRE: list argument is thread-safe.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImprovedList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123; <span class="keyword">this</span>.list = list; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> contains = list.contains(x);</span><br><span class="line">        <span class="keyword">if</span> (contains)</span><br><span class="line">            list.add(x);</span><br><span class="line">        <span class="keyword">return</span> !contains;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Plain vanilla delegation for List methods.</span></span><br><span class="line">    <span class="comment">// Mutative methods must be synchronized to ensure atomicity of putIfAbsent.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; list.clear(); &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//... 按照类似的方式委托List的其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ImproveList通过自身的内置锁增加了一层额外的加锁。它并不关心底层的List是否是线程安全的，即使List不是线程安全的或者修改了它的加锁实现，ImproveList也会提供一致的加锁机制来实现线程安全性。虽然额外的同步层可能导致轻微的性能损失，但与模拟另一个对象的加锁策略相比，ImproveList更为健壮。事实上，我们使用了Java监视器模式来封装现有的List，并且只要在类中拥有指向底层List的唯一外部引用，就能确保线程安全性。</p>
<h2 id="将同步策略文档化"><a href="#将同步策略文档化" class="headerlink" title="将同步策略文档化"></a>将同步策略文档化</h2><blockquote>
<p>在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。</p>
</blockquote>
<p>synchronized，volatile或者任何一个线程安全类都对应于某种同步策略，用于在并发访问时确保数据的完整性。这种策略的程序设计的要素之一，因此应该将其文档化。当然，在设计阶段时编写设计决策文档的最佳时间。这之后的几周或几个月后，一些设计细节会最逐渐变得模糊，因此一定要在忘记之前将它们记录下来。</p>
<p>在设计同步策略时需要考虑多个方面，例如，将哪些变量声明为volatile类型，哪些变量用锁来保护，哪些锁保护哪些变量，哪些变量必须是不可变的或者被封闭在线程中的，哪些操作必须是原子操作等。其中某些方面时严格的实现细节，应该将它们文档化以便于日后的维护。还有一些方面会影响类中加锁行为的外在表现，也应该将其视为规范的一部分写入文档。</p>
<p>我们认为“可能是线程安全”的类通常并不是线程安全的。</p>
<p>如果某个类没有明确地声明是线程安全的，那么就不要假设它是线程安全的，从而有效地避免类似于SimpleDateFormat的问题。</p>
<h4 id="解释含糊的文档"><a href="#解释含糊的文档" class="headerlink" title="解释含糊的文档"></a>解释含糊的文档</h4><p>许多Java技术规范都没有说明接口的线程安全性，例如ServletContext，HttpSession或DataSource。</p>
<p>你只能去猜测。一个提高猜测准确性的方法是，从实现者（例如容器或数据库的供应商）的角度去解释规范，而不是从使用者的角度去解释。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1/chapt1-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1/chapt1-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">第1章:MySQL架构与历史</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-15 09:28:13" itemprop="dateCreated datePublished" datetime="2020-12-15T09:28:13+08:00">2020-12-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-10 15:19:36" itemprop="dateModified" datetime="2023-03-10T15:19:36+08:00">2023-03-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://cxis.me/2018/05/01/Kafka%E6%A6%82%E8%A6%81/">https://cxis.me/2018/05/01/Kafka%E6%A6%82%E8%A6%81/</a></p>
<p>Kafka设计初衷是为了解决互联网公司超大量级数据的实时传输，需要考虑以下问题：</p>
<ul>
<li>吞吐量、延时，每次写操作会把数据写到OS的页缓存中，OS负责刷盘，Kafka采用追加方式，避免磁盘随机写操作；消费的时候读取消息会尝试从OS的页缓存中读取，命中缓存后直接发送到Socket上，就是零拷贝技术。</li>
<li>消息持久化</li>
<li>负载均衡、故障转移</li>
<li>伸缩性</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="框架："><a href="#框架：" class="headerlink" title="框架："></a>框架：</h2><ul>
<li>Zookeeper集群，kafka用Zookeeper来负责集群元数据管理、控制器的选举等操作</li>
<li>Producer，生产者，负责创建消息，投递到Kafka中</li>
<li>Consumer，消费者，消费消息，连接到Kafka接收消息</li>
<li>Broker，服务代理节点，负责存储消息</li>
</ul>
<h2 id="消息："><a href="#消息：" class="headerlink" title="消息："></a>消息：</h2><ul>
<li>Topic，消息以主题为单位归类，是一个逻辑概念，代表一类消息，通常可使用topic来区分实际业务。 topic通常会被多个消费者订阅。</li>
</ul>
<h2 id="patition保证无状态的可拓展性："><a href="#patition保证无状态的可拓展性：" class="headerlink" title="patition保证无状态的可拓展性："></a>patition保证无状态的可拓展性：</h2><ul>
<li>Partition，分区，主题是逻辑概念，可以细分为多个分区，一个分区只属于单个主题。同一主题下的不同分区包含消息是不同的，partition是不可修改的有序消息序列。用户对partition唯一能做的操作就是在消息序列尾部追加写入消息。partition上的每条消息都会被分配一个唯一的序列号，叫做位移offset</li>
<li>Offset，topic的partition下每条消息都被分配一个唯一的offset，消费端也有offset概念，用来表示消费partition的消费进度。</li>
</ul>
<h2 id="patition保证可用性"><a href="#patition保证可用性" class="headerlink" title="patition保证可用性"></a>patition保证可用性</h2><ul>
<li>Replica，Kafka的备份日志称为副本replica，防止数据丢失。副本分为两类：领导者副本leader replica和追随者副本follower replica。follower replica不负责响应客户端发来的消息写入和消费者请求，只是被动的向leader replica获取数据。leader replica所在broker宕机时，Kafka会从剩余的replica中选举新的leader继续提供服务</li>
</ul>
<h2 id="patition保证一致性："><a href="#patition保证一致性：" class="headerlink" title="patition保证一致性："></a>patition保证一致性：</h2><ul>
<li>Leader，leader对外提供服务</li>
<li>Follower，follower被动追随leader状态，保持与leader同步，当做leader后备。leader挂掉后就会有一个follower备选举成新的leader。</li>
<li>ISR，ISR是in-sync replica，与leader replica保持同步的replica集合。Kafka为partition动态维护一个replica，该集合中所有replica保存的消息日志都与leader replica保持同步，只有这个集合中的replica才能被选举为leader，只有该集合中所有replica都接到了同一条消息，Kafka才会认为消息是已提交状态，也就是消息发送成功。如果replica落后于leader replica的进度，当达到一定程度时，Kaffka会将这些replica踢出ISR，当这些replica追上了leader进度时，Kafka会将他们加入到ISR中。</li>
<li>HW，Hight Watermark，高水位，标识了一个特定的消息偏移量，消费者只能拉取到这个offset之前的消息</li>
<li>LEO，Log End Offset，标识当前日志文件中下一条待写入消息的offset</li>
</ul>
<h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>消息由消息头部、key、value组成：</p>
<ul>
<li>CRC，4字节</li>
<li>版本号，1字节</li>
<li>属性，1字节</li>
<li>时间戳，8字节</li>
<li>key长度，4字节</li>
<li>key，k个字节，消息键，对消息做partition时使用，决定消息保存在某个topic下的哪个partition</li>
<li>value长度，4字节</li>
<li>value，v个字节，消息体，保存实际的消息数据</li>
</ul>
<p>Kafka使用紧凑的二进制字节数组来保存消息，没有多余的比特位浪费。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>适合处理生产环境中流式数据：</p>
<ul>
<li>消息传输</li>
<li>网站行为日志追踪</li>
<li>审计数据收集</li>
<li>日志收集</li>
<li>Event Sourcing</li>
<li>流式处理</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1/chapt2-%E7%94%9F%E4%BA%A7%E8%80%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1/chapt2-%E7%94%9F%E4%BA%A7%E8%80%85/" class="post-title-link" itemprop="url">第1章:MySQL架构与历史</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-15 09:28:13" itemprop="dateCreated datePublished" datetime="2020-12-15T09:28:13+08:00">2020-12-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-13 10:20:05" itemprop="dateModified" datetime="2023-03-13T10:20:05+08:00">2023-03-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Producer架构"><a href="#Producer架构" class="headerlink" title="Producer架构"></a>Producer架构</h1><p><img src="https://cxis.me/Kafka%e4%b8%ad%e7%9a%84Producer/producer-1.png" alt="producer"></p>
<ol>
<li>序列化，<ul>
<li>消息在网络上必须以字节byte的形式传输，所以需要在heap上创建一块内存区域<ul>
<li>频率地创建内存区域导致gc，所以RecordAccumulator使用BufferPool复用ByteBuffer</li>
</ul>
</li>
<li>生产者需要用序列化器Serializer把对象转化成字节数组，才能通过网络发送给Kafka</li>
</ul>
</li>
<li>分区器，Partitioner，为消息分配分区，<ul>
<li>默认分区器DefaultPartitioner，key不为null，会对key进行哈希来计算分区号；</li>
<li>如果key为null，消息会以轮询的方式发往TOPIC内各个patition</li>
</ul>
</li>
<li>拦截器，Interceptor</li>
<li>RecordAccumulator，消息累加器或者消息收集器，<ul>
<li>用来缓存消息，以便Sender线程可以批量发送，减少网络传输的消耗提升性能。RecordAccumulator内部为每个分区维护一个双端队列，发送的消息都被追加到双端队列中，队列中内容是ProducerBatch，ProducerBatch中包含一个或多个ProducerRecord。</li>
</ul>
</li>
<li>Sender，会从RecordAccumulator中获取缓存的消息，将消息发送出去</li>
<li>Request，是Kafka的各种协议请求，这里是ProduceRequest</li>
<li>缓存</li>
<li>Selector<ul>
<li>网络模型之一：IO多路复用</li>
</ul>
</li>
<li>InFlightRequests，用来缓存已经发出去但还没有收到响应的请求</li>
</ol>
<p>Producer是线程安全的，可以在多线程环境中复用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1/chapt3-%E6%B6%88%E8%B4%B9%E8%80%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1/chapt3-%E6%B6%88%E8%B4%B9%E8%80%85/" class="post-title-link" itemprop="url">第1章:MySQL架构与历史</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-15 09:28:13" itemprop="dateCreated datePublished" datetime="2020-12-15T09:28:13+08:00">2020-12-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-10 15:21:35" itemprop="dateModified" datetime="2023-03-10T15:21:35+08:00">2023-03-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
