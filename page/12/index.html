<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/12/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%954th%20-%20Robert%20Sedgewick/union-find%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%954th%20-%20Robert%20Sedgewick/union-find%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">union-find算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-28 10:59:50" itemprop="dateCreated datePublished" datetime="2021-05-28T10:59:50+08:00">2021-05-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-13 20:48:05" itemprop="dateModified" datetime="2021-06-13T20:48:05+08:00">2021-06-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="union-find算法的API"><a href="#union-find算法的API" class="headerlink" title="union-find算法的API"></a>union-find算法的API</h2><p>union-find算法用于检测动态连通性，例如计算机网络中的两个节点是否连通，在一个特定圈子里的两个人是否有间接的朋友关系，等等。</p>
<img src="https://upload-images.jianshu.io/upload_images/15884954-de7ef738949aad50.png" alt="img" style="zoom:67%;" />

<p>对于图的动态连接性问题，我们最关心的问题是：图中节点间之间是否存在路径（节点是否处于同一个连通分量中）。对于图的动态变化，我们允许动态地添加边，但是不允许删除边。因此，定义API如下：</p>
<table>
<thead>
<tr>
<th align="left">API签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>bool connected(int p, int q)</code></td>
<td align="left">节点<code>p</code>与节点<code>q</code>是否连通</td>
</tr>
<tr>
<td align="left"><code>void union(int p, int q)</code></td>
<td align="left">将节点<code>p</code>与节点<code>q</code>连接起来</td>
</tr>
<tr>
<td align="left"><code>int find(int p)</code></td>
<td align="left">寻找<code>p</code>处于哪一个连通分量中</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> id[]; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">//连通分量数量</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">     count = N;</span><br><span class="line">     id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">         id[i] = i;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> find(p) == find(q);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>; </span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="union-find算法的实现1：quick-find"><a href="#union-find算法的实现1：quick-find" class="headerlink" title="union-find算法的实现1：quick-find"></a>union-find算法的实现1：quick-find</h2><p>id[] 表示的事连通分量id,以节点为索引</p>
<p>quick-find算法是union-find算法的众多实现中最简单也最没有效率的一种，它的主要实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> id[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查找点 p 和点 q 在id数组中的值，从而可以接着判断它们是否在相同的连通分量中</span></span><br><span class="line">  <span class="keyword">int</span> pID = find(p);</span><br><span class="line">  <span class="keyword">int</span> qID = find(q);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// p, q已经在相同的分量中，无需任何操作</span></span><br><span class="line">  <span class="keyword">if</span> (pID == qID) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行到这里，说明 p 和 q 不在相同的分量中，因此需要把它们进行归并，在这里，是把 p 所在的分量里的所有元素全部重命名为 q 所在的分量里的名称（唯一）</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (id[i] == pID)  id[i] = qID;</span><br><span class="line">  </span><br><span class="line">  count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>find() 函数用于查找一个点 p 的名称；union() 函数用于归并两个点 p 和 q，如果它们已经在同一个连通分量里，那么不会产生任何归并效果。</p>
<blockquote>
<p>之所以把这种算法叫quick-find，是因为它的 find() 操作很快，只需要访问id数组一次；</p>
<p>但是quick-find的 union() 操作却很慢，因为它需要访问整个id数组。</p>
</blockquote>
<blockquote>
<p>命题F:  归并2个连接分量的操作，访问数组的次数在( N+3，2N+1)，其中N是点的个数。</p>
<p>union() 函数一开始的两个 find() 操作无论如何是逃不掉的，所以这里至少就访问了 2 次id数组。因此，最后的for循环应该是至少访问了 N+1 次数组，但这又是怎么算出来的呢？id[i] == qID 至少会被执行一次，所以for循环访问数组的次数就至少是 N+1 次了。</p>
<p>当id数组中，除了q之外，其他所有元素都与p处于同一连通分量中的话，那么，if (id[i] == pID) 这个条件就会成立 N-1 次，这意味着 id[i] = qID 会被执行 N-1 次，而N次 if 判断无论如何都是会被执行的，所以for循环里访问数组的次数是 (N-1)+ (N-1) + 1=2N-1 次，另外前面说了，union()函数中两个find()操作是免不了的，所以还要再加2次，总共是 2N-1+2=2N+1 次。</p>
</blockquote>
<h2 id="union-find算法的实现2：quick-union"><a href="#union-find算法的实现2：quick-union" class="headerlink" title="union-find算法的实现2：quick-union"></a>union-find算法的实现2：quick-union</h2><!--考虑一下，为什么以上的解法会造成“牵一发而动全身”？因为每个节点所属的组号都是单独记录，各自为政的，没有将它们以更好的方式组织起来，当涉及到修改的时候，除了逐一通知、修改，别无他法。什么样子的数据结构能够将一些节点给组织起来？常见的就是链表，图，树，什么的了。但是哪种结构对于查找和修改的效率最高？毫无疑问是树，因此考虑如何将节点和组的关系以树的形式表现出来。-->

<p>为了提高union()的速度，它和quick-find算法互补。它也是基于相同的数据结构 - 以触点作为索引的id[]数组。但是意义已经不同了，采用parent-link的方式将节点组织起来，举例而言，id[p]的值就是p节点的父节点的序号，如果p是树根的话，id[p]的值就是p，因此最后经过若干次查找，一个节点总是能够找到它的根节点，即满足id[root] = root的节点也就是组的根节点了，然后就可以使用根节点的序号来表示组号。所以在处理一个pair的时候，将首先找到pair中每一个节点的组号(即它们所在树的根节点的序号)，如果属于不同的组的话，就将其中一个根节点的父节点设置为另外一个根节点，相当于将一颗独立的树编程另一颗独立的树的子树</p>
<p><img src="https://pic4.zhimg.com/80/v2-44540ed217035c0d23167324ddf4b063_720w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private int find(int p)&#123;</span><br><span class="line">	while(p !&#x3D; id[p]) p &#x3D; id[p]; &#x2F;&#x2F;找出连接分量的名称，即根节点名称</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void union(int p, int q)&#123;</span><br><span class="line">	int pRoot &#x3D; find(p);</span><br><span class="line">	int qRoot &#x3D; find(q);</span><br><span class="line">	if(pRoot &#x3D;&#x3D; qRoot) return;</span><br><span class="line">	</span><br><span class="line">	id[pRoot] &#x3D; iqRoot;  &#x2F;&#x2F;将p和q的根节点连接在一起</span><br><span class="line">	</span><br><span class="line">	count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="union-find算法的实现3：加权quick-union"><a href="#union-find算法的实现3：加权quick-union" class="headerlink" title="union-find算法的实现3：加权quick-union"></a>union-find算法的实现3：加权quick-union</h2><p>uick-union算法有一个明显的缺点，就是会出现一个极端情况：</p>
<p><img src="https://pic4.zhimg.com/80/v2-3e0f32ff867519251c1ec7d81b1f010b_720w.jpg" alt="img"></p>
<p>在这种情况中，树的深度会非常大，最大可以达到N-1，显然这样遍历树就很不划算，于是解决办法是：判断数的深度，并总是将小树连接到大树上。</p>
<p><img src="https://pic2.zhimg.com/80/v2-1e31170eb5b80af6d2f91704c080410d_720w.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedQuickUnionUf</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sz; <span class="comment">//各个根节点所对应的分量的大小，以触点为索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeightedQuickUnionUf</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	count = N;</span><br><span class="line">	id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) id[i] = i;</span><br><span class="line">	sz = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) sz[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(p != id[p]) p = id[p]; <span class="comment">//找出连接分量的名称，即根节点名称</span></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = find(p);</span><br><span class="line">	<span class="keyword">int</span> j = find(q);</span><br><span class="line">	<span class="keyword">if</span>(i == j) <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将小树挂在大树上</span></span><br><span class="line">	<span class="keyword">if</span>( sz[i] &lt; sz[j])&#123;</span><br><span class="line">		id[i] = j;</span><br><span class="line">		sz[j] += sz[i];</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        id[j] = i;</span><br><span class="line">		sz[i] += sz[j];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>命题：森林中大小为K的树的高度&lt;=lgK</p>
<p>证明：归纳法：当k=1，高度&lt;=lg1；假设当k=i, 高度 &lt;= lgi; 那么当i&lt;=j, 并且 i + j =k‘,  我们将小树i和大树归并，那么小树中所有节点深度+1, 大树节点深度不变，而归并后的树k’大小为i+j = k’, 而1+lgi= lg(i+i) &lt;= lg(i+j) = lgk‘; 得证。</p>
</blockquote>
<p><img src="https://pic4.zhimg.com/80/v2-aa15e51d568de64766f60ffd28f0b443_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-39d79a38fd9116c76cb552dfdb9bd9a9_720w.jpg" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-03-%E8%A7%A3%E5%86%B3%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%92%8C%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-03-%E8%A7%A3%E5%86%B3%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%92%8C%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B/" class="post-title-link" itemprop="url">kafka-03-保障消息有序性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-27 19:20:31" itemprop="dateCreated datePublished" datetime="2021-05-27T19:20:31+08:00">2021-05-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h2><h3 id="为什么要保证消息的顺序"><a href="#为什么要保证消息的顺序" class="headerlink" title="为什么要保证消息的顺序"></a>为什么要保证消息的顺序</h3><p>订单有很多状态，比如：下单、支付、完成、撤销等，不可能<code>下单</code>的消息都没读取到，就先读取<code>支付</code>或<code>撤销</code>的消息吧，如果真的这样，数据产生错乱</p>
<h3 id="如何保证消息顺序"><a href="#如何保证消息顺序" class="headerlink" title="如何保证消息顺序"></a>如何保证消息顺序</h3><h4 id="方案1：producer端只写固定的partition（有缺陷）"><a href="#方案1：producer端只写固定的partition（有缺陷）" class="headerlink" title="方案1：producer端只写固定的partition（有缺陷）"></a>方案1：producer端只写固定的partition（有缺陷）</h4><p><code>kafka</code>的<code>topic</code>是无序的，但是一个<code>topic</code>包含多个<code>partition</code>，每个<code>partition</code>内部是有序的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqOzug1A48UnG15tonQ3wBkbB5yicVnHpydn5Hq2PwiawKTVj8Vk6DB7sQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>只要保证生产者写消息时，按照一定的规则写到同一个<code>partition</code>，不同的消费者读不同的<code>partition</code>的消息，就能保证生产和消费者消息的顺序。</p>
<p>同一个<code>商户编号</code>的消息写到同一个<code>partition</code>，<code>topic</code>中创建了<code>4</code>个<code>partition</code>，然后部署了<code>4</code>个消费者节点，构成<code>消费者组</code>，一个<code>partition</code>对应一个消费者节点。从理论上说，这套方案是能够保证消息顺序的。<img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqrza43TUBKePfwRPaSrtSJiclN6ibdof2qKwyhIfGoicR4Z6C2icQP5vWuA/640" alt="Image"></p>
<p><strong>优点</strong></p>
<ul>
<li>保障了producer发送信息的时候，是有序的</li>
</ul>
<p><strong>缺陷</strong></p>
<ul>
<li>不能保障Topic的partition接收信息，是有序的。比如，公司在那段时间网络经常不稳定，业务接口时不时报超时，业务请求时不时会连不上数据库，某条数据丢失了；还有，因为网络原因，最早发送的信息，最晚被topic接收 <!--不过，可以通过topic发送ack解决--></li>
</ul>
<h4 id="方案2：producer端异步失败重试，consumer端做判断"><a href="#方案2：producer端异步失败重试，consumer端做判断" class="headerlink" title="方案2：producer端异步失败重试，consumer端做判断"></a>方案2：producer端异步失败重试，consumer端做判断</h4><p><code>同步重试机制</code>在出现异常的情况，会严重影响消息消费者的消费速度，降低它的吞吐量。</p>
<p>如果用<code>异步重试机制</code>，处理失败的消息就得保存到<code>重试表</code>下来。</p>
<p>但有个新问题立马出现：<strong>只存一条消息如何保证顺序？</strong></p>
<p>存一条消息的确无法保证顺序，假如：”下单“消息失败了，还没来得及异步重试。此时，”支付“消息被消费了，它肯定是不能被正常消费的。</p>
<p>这时有种更简单的方案浮出水面：消费者在处理消息时，先判断该<code>订单号</code>在<code>重试表</code>有没有数据，如果有则直接把当前消息保存到<code>重试表</code>。如果没有，则进行业务处理，如果出现异常，把该消息保存到<code>重试表</code>。</p>
<p>后来我们用<code>elastic-job</code>建立了<code>失败重试机制</code>，如果重试了<code>7</code>次后还是失败，则将该消息的状态标记为<code>失败</code>，发邮件通知开发人员。</p>
<h2 id="消息挤压"><a href="#消息挤压" class="headerlink" title="消息挤压"></a>消息挤压</h2><h3 id="挤压原因1：消息体过大"><a href="#挤压原因1：消息体过大" class="headerlink" title="挤压原因1：消息体过大"></a>挤压原因1：消息体过大</h3><p>一次简单的消息从生产到消费过程，需要经过<code>2次网络IO</code>和<code>2次磁盘IO</code>。如果消息体过大，势必会增加IO的耗时，进而影响kafka生产和消费的速度。消费者速度太慢的结果，就会出现消息积压情况。</p>
<p>可以这样设计了：</p>
<ol>
<li>订单系统发送的消息体只用包含：id和状态等关键信息。</li>
<li>后厨显示系统消费消息后，通过id调用订单系统的订单详情查询接口获取数据。</li>
<li>后厨显示系统判断数据库中是否有该订单的数据，如果没有则入库，有则更新。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqib2hB0qSIXBPjxAH1vZQbn97tcMKQBmWBDL1Rc1ytjLXoXcCPic301pQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="挤压原因2：路由规则不合理"><a href="#挤压原因2：路由规则不合理" class="headerlink" title="挤压原因2：路由规则不合理"></a>挤压原因2：路由规则不合理</h3><p>不是所有<code>partition</code>上的消息都有积压，而是只有一个。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqdaENvsBRclJSZ2zvNoXxfpDS9IgJvpM6icibHB8Y32Jt4khMicw7wictmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>刚开始，我以为是消费那个<code>partition</code>消息的节点出了什么问题导致的。但是经过排查，没有发现任何异常。</p>
<p>发现，有几个商户的订单量特别大，刚好这几个商户被分到同一个<code>partition</code>，使得该<code>partition</code>的消息量比其他<code>partition</code>要多很多。</p>
<p>这时我们才意识到，发消息时按<code>商户编号</code>路由<code>partition</code>的规则不合理，可能会导致有些<code>partition</code>消息太多，消费者处理不过来，而有些<code>partition</code>却因为消息太少，消费者出现空闲的情况。</p>
<p>为了避免出现这种分配不均匀的情况，我们需要对发消息的路由规则做一下调整。</p>
<p>用订单号做路由相对更均匀，不会出现单个订单发消息次数特别多的情况。除非是遇到某个人一直加菜的情况，但是加菜是需要花钱的，所以其实同一个订单的消息数量并不多。调整后按<code>订单号</code>路由到不同的<code>partition</code>，同一个订单号的消息，每次到发到同一个<code>partition</code>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqoJO69ia8Fv9p1uc0HEHaJcYg85VaBlsHm25ubexHCFmmicbVWsN6IACA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="如何处理消息挤压？"><a href="#如何处理消息挤压？" class="headerlink" title="如何处理消息挤压？"></a>如何处理消息挤压？</h3><p>每个<code>partition</code>都积压了<code>十几万</code>的消息没有消费，比以往加压的消息数量增加了<code>几百倍</code>。</p>
<p>原来是有其他业务在JOB中批量发消息导致的问题导致。</p>
<p><strong>积压的这<code>十几万</code>的消息该如何处理呢？</strong></p>
<ul>
<li><p>直接调大<code>partition</code>数量是不行的，历史消息已经存储到4个固定的<code>partition</code>，只有新增的消息才会到新的<code>partition</code>。我们重点需要处理的是已有的partition。</p>
</li>
<li><p>直接加<code>consumer</code>服务节点也不行，因为<code>kafka</code>允许同topic的多个<code>partition</code>被一个<code>consumer</code>消费，但不允许一个<code>partition</code>被同组的多个<code>consumer</code>消费，可能会造成资源浪费。</p>
</li>
<li><p>用多线程处理，改成了用<code>线程池</code>处理消息，核心线程和最大线程数都配置成了<code>50</code>。线程数是可以通过<code>zookeeper</code>动态调整的</p>
</li>
</ul>
<img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqt9gnrBjrNqmrxqjJlghuZszz8ibdGic6KbthGAdYX8yqkSibxFlH1ibFeA/640" alt="图片" style="zoom:50%;" />

<p>顺便说一下，<a href="">对于要求严格保证消息顺序的场景，可以将线程池改成多个队列，每个队列用单线程处理</a>。</p>
<h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p><code>kafka</code>消费消息时支持三种模式：</p>
<ul>
<li>at most once模式 最多一次。保证每一条消息commit成功之后，再进行消费处理。消息可能会丢失，但不会重复。</li>
<li>at least once模式 至少一次。保证每一条消息处理成功之后，再进行commit。消息不会丢失，但可能会重复。</li>
<li>exactly once模式 精确传递一次。将offset作为唯一id与消息同时处理，并且保证处理的原子性。消息只会处理一次，不丢失也不会重复。但这种方式很难做到。</li>
</ul>
<p><code>kafka</code>默认的模式是<code>at least once</code>，但这种模式可能会产生<a href="">重复消费</a>的问题，所以我们的业务逻辑必须做<a href="">幂等设计</a>。</p>
<p>而我们的业务场景保存数据时使用了<code>INSERT INTO ...ON DUPLICATE KEY UPDATE</code>语法，不存在时插入，存在时更新，是天然支持幂等性的。</p>
<h2 id="多环境消费问题"><a href="#多环境消费问题" class="headerlink" title="多环境消费问题"></a>多环境消费问题</h2><p>我们当时线上环境分为：<code>pre</code>(预发布环境) 和 <code>prod</code>(生产环境)，两个环境共用同一个数据库，并且共用同一个kafka集群。</p>
<p>需要注意的是，在配置<code>kafka</code>的<code>topic</code>的时候，要加前缀用于区分不同环境。pre环境的以pre_开头，比如：pre_order，生产环境以prod_开头，比如：prod_order，防止消息在不同环境中串了。</p>
<p>但有次运维在<code>pre</code>环境切换节点，配置<code>topic</code>的时候，配错了，配成了<code>prod</code>的<code>topic</code>。刚好那天，我们有新功能上<code>pre</code>环境。结果悲剧了，<code>prod</code>的有些消息被<code>pre</code>环境的<code>consumer</code>消费了，而由于消息体做了调整，导致<code>pre</code>环境的<code>consumer</code>处理消息一直失败。</p>
<p>其结果是生产环境丢了部分消息。不过还好，最后生产环境消费者通过重置<code>offset</code>，重新读取了那一部分消息解决了问题，没有造成太大损失。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/Quartz-%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/Quartz-%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Quartz-集群原理分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-26 14:44:16" itemprop="dateCreated datePublished" datetime="2021-05-26T14:44:16+08:00">2021-05-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Quartz集群部署实践"><a href="#Quartz集群部署实践" class="headerlink" title="Quartz集群部署实践"></a>Quartz集群部署实践</h2><p>CRM中Quartz与Spring结合使用，Spring通过提供org.springframework.scheduling.quartz下的封装类对Quartz支持。</p>
<p><strong>Quartz集群部署：</strong></p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/c45f767d.png" alt="Quartz集群部署"></p>
<p>Quartz集群中的每个节点是一个独立的Quartz应用，它又管理着其他的节点。该集群需要分别对每个节点分别启动或停止，不像应用服务器的集群，独立的Quartz节点并不与另一个节点或是管理节点通信。Quartz应用是通过数据库表来感知到另一应用。只有使用持久的JobStore才能完成Quqrtz集群。</p>
<p><strong>基于Spring的集群配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 调度工厂 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;quartzScheduler&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;quartzProperties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.scheduler.instanceName&quot;</span>&gt;</span>CRMscheduler<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.scheduler.instanceId&quot;</span>&gt;</span>AUTO<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 线程池配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.threadPool.class&quot;</span>&gt;</span>org.quartz.simpl.SimpleThreadPool<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.threadPool.threadCount&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.threadPool.threadPriority&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- JobStore 配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.class&quot;</span>&gt;</span>org.quartz.impl.jdbcjobstore.JobStoreTX<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 集群配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.isClustered&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.clusterCheckinInterval&quot;</span>&gt;</span>15000<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.maxMisfiresToHandleAtATime&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.misfireThreshold&quot;</span>&gt;</span>120000<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.tablePrefix&quot;</span>&gt;</span>QRTZ_<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schedulerName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CRMscheduler&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--必须的，QuartzScheduler 延时启动，应用启动完后 QuartzScheduler 再启动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;startupDelay&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;applicationContextSchedulerContextKey&quot;</span> <span class="attr">value</span>=<span class="string">&quot;applicationContextKey&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--可选，QuartzScheduler 启动时更新己存在的Job，这样就不用每次修改targetObject后删除qrtz_job_details表对应记录了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;overwriteExistingJobs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置自动启动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoStartup&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册触发器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;triggers&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;userSyncScannerTrigger&quot;</span> /&gt;</span></span><br><span class="line">                     ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册jobDetail --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jobDetails&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schedulerListeners&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;quartzExceptionSchedulerListener&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.class属性为JobStoreTX，将任务持久化到数据中。因为集群中节点依赖于数据库来传播Scheduler实例的状态，你只能在使用JDBC JobStore时应用Quartz集群。</span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.isClustered属性为true，通知Scheduler实例要它参与到一个集群当中。</span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.clusterCheckinInterval属性定义了Scheduler实例检入到数据库中的频率(单位：毫秒)。Scheduler检查是否其他的实例到了它们应当检入的时候未检入；这能指出一个失败的Scheduler实例，且当前 Scheduler会以此来接管任何执行失败并可恢复的Job。通过检入操作，Scheduler 也会更新自身的状态记录。clusterChedkinInterval越小，Scheduler节点检查失败的Scheduler实例就越频繁。默认值是 15000 (即15 秒)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Quartz集群原理分析"><a href="#Quartz集群原理分析" class="headerlink" title="Quartz集群原理分析"></a>Quartz集群原理分析</h2><h3 id="Quartz集群数据库表"><a href="#Quartz集群数据库表" class="headerlink" title="Quartz集群数据库表"></a>Quartz集群数据库表</h3><p>Quartz的集群部署方案在架构上是分布式的，没有负责集中管理的节点，而是利用数据库锁的方式来实现集群环境下进行并发控制。BTW，分布式部署时需要保证各个节点的系统时间一致。</p>
<p>Quartz数据库核心表如下：</p>
<table>
<thead>
<tr>
<th align="left">Table Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">QRTZ_CALENDARS</td>
<td align="left">存储Quartz的Calendar信息</td>
</tr>
<tr>
<td align="left">QRTZ_CRON_TRIGGERS</td>
<td align="left">存储CronTrigger，包括Cron表达式和时区信息</td>
</tr>
<tr>
<td align="left">QRTZ_FIRED_TRIGGERS</td>
<td align="left">存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息</td>
</tr>
<tr>
<td align="left">QRTZ_PAUSED_TRIGGER_GRPS</td>
<td align="left">存储已暂停的Trigger组的信息</td>
</tr>
<tr>
<td align="left">QRTZ_SCHEDULER_STATE</td>
<td align="left">存储少量的有关Scheduler的状态信息，和别的Scheduler实例</td>
</tr>
<tr>
<td align="left"><strong>QRTZ_LOCKS</strong></td>
<td align="left"><strong>存储程序的悲观锁的信息</strong></td>
</tr>
<tr>
<td align="left">QRTZ_JOB_DETAILS</td>
<td align="left">存储每一个已配置的Job的详细信息</td>
</tr>
<tr>
<td align="left">QRTZ_JOB_LISTENERS</td>
<td align="left">存储有关已配置的JobListener的信息</td>
</tr>
<tr>
<td align="left">QRTZ_SIMPLE_TRIGGERS</td>
<td align="left">存储简单的Trigger，包括重复次数、间隔、以及已触的次数</td>
</tr>
<tr>
<td align="left">QRTZ_BLOG_TRIGGERS</td>
<td align="left">Trigger作为Blob类型存储</td>
</tr>
<tr>
<td align="left">QRTZ_TRIGGER_LISTENERS</td>
<td align="left">存储已配置的TriggerListener的信息</td>
</tr>
<tr>
<td align="left">QRTZ_TRIGGERS</td>
<td align="left">存储已配置的Trigger的信息</td>
</tr>
</tbody></table>
<p>其中，QRTZ_LOCKS就是Quartz集群实现同步机制的行锁表，其表结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--QRTZ_LOCKS表结构</span><br><span class="line">CREATE TABLE &#96;QRTZ_LOCKS&#96; (</span><br><span class="line">  &#96;LOCK_NAME&#96; varchar(40) NOT NULL,</span><br><span class="line">   PRIMARY KEY (&#96;LOCK_NAME&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">--QRTZ_LOCKS记录</span><br><span class="line">+-----------------+ </span><br><span class="line">| LOCK_NAME       |</span><br><span class="line">+-----------------+ </span><br><span class="line">| CALENDAR_ACCESS |</span><br><span class="line">| JOB_ACCESS      |</span><br><span class="line">| MISFIRE_ACCESS  |</span><br><span class="line">| STATE_ACCESS    |</span><br><span class="line">| TRIGGER_ACCESS  |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>

<p>可以看出QRTZ_LOCKS中有5条记录，代表5把锁，分别用于实现多个Quartz Node对Job、Trigger、Calendar访问的同步控制。</p>
<h3 id="Quartz线程模型"><a href="#Quartz线程模型" class="headerlink" title="Quartz线程模型"></a>Quartz线程模型</h3><p>在Quartz中有两类线程：Scheduler调度线程和任务执行线程。</p>
<ul>
<li><p>调度主线程(QuartzSchedulerThread)：QuartzScheduler被创建时创建一个QuartzSchedulerThread实例。</p>
</li>
<li><p>任务执行线程：Quartz不会在主线程(QuartzSchedulerThread)中处理用户的Job。Quartz把线程管理的职责委托给ThreadPool，一般的设置使用SimpleThreadPool。SimpleThreadPool创建了一定数量的WorkerThread实例来使得Job能够在线程中进行处理。WorkerThread是定义在SimpleThreadPool类中的内部类，它实质上就是一个线程。例如，CRM中配置如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 线程池配置 --&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.threadPool.class&quot;&gt;org.quartz.simpl.SimpleThreadPool&lt;&#x2F;prop&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.threadPool.threadCount&quot;&gt;20&lt;&#x2F;prop&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.threadPool.threadPriority&quot;&gt;5&lt;&#x2F;prop&gt;</span><br></pre></td></tr></table></figure>



<h3 id="集群源码分析"><a href="#集群源码分析" class="headerlink" title="集群源码分析"></a>集群源码分析</h3><p>Quartz究竟是如何保证集群情况下trgger处理的信息同步？</p>
<p>下面跟着源码一步一步分析，调度主线程(QuartzSchedulerThread)包含有决定何时下一个Job将被触发的处理循环，主要逻辑在其run()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> lastAcquireFailed = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">while</span> (!halted.get()) &#123;</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();</span><br><span class="line">     <span class="keyword">if</span>(availThreadCount &gt; <span class="number">0</span>) &#123; </span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="comment">//调度器在trigger队列中寻找30秒内一定数目的trigger(需要保证集群节点的系统时间一致)</span></span><br><span class="line">     triggers = qsRsrcs.getJobStore().acquireNextTriggers(</span><br><span class="line">                            now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="comment">//触发trigger</span></span><br><span class="line">     List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers);</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="comment">//释放trigger</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; triggers.size(); i++) &#123;</span><br><span class="line">         qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可知，QuartzScheduler调度线程不断获取trigger，触发trigger，释放trigger。下面分析trigger的获取过程，qsRsrcs.getJobStore()返回对象是JobStore，集群环境配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- JobStore 配置 --&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.jobStore.class&quot;&gt;org.quartz.impl.jdbcjobstore.JobStoreTX&lt;&#x2F;prop&gt;</span><br></pre></td></tr></table></figure>

<p>JobStoreTX继承自JobStoreSupport，而JobStoreSupport的acquireNextTriggers、triggersFired、releaseAcquiredTrigger方法负责具体trigger相关操作，都必须获得TRIGGER_ACCESS锁。核心逻辑在executeInNonManagedTXLock方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">executeInNonManagedTXLock</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String lockName, </span></span></span><br><span class="line"><span class="function"><span class="params">        TransactionCallback&lt;T&gt; txCallback, <span class="keyword">final</span> TransactionValidator&lt;T&gt; txValidator)</span> <span class="keyword">throws</span> JobPersistenceException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> transOwner = <span class="keyword">false</span>;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getLockHandler().requiresConnection()) &#123;</span><br><span class="line">                conn = getNonManagedTXConnection();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取锁</span></span><br><span class="line">            transOwner = getLockHandler().obtainLock(conn, lockName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn = getNonManagedTXConnection();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> T result = txCallback.execute(conn);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            commitConnection(conn);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JobPersistenceException e) &#123;</span><br><span class="line">            rollbackConnection(conn);</span><br><span class="line">            <span class="keyword">if</span> (txValidator == <span class="keyword">null</span> || !retryExecuteInNonManagedTXLock(lockName, <span class="keyword">new</span> TransactionCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">execute</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> JobPersistenceException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> txValidator.validate(conn, result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long sigTime = clearAndGetSignalSchedulingChangeOnTxCompletion();</span><br><span class="line">        <span class="keyword">if</span>(sigTime != <span class="keyword">null</span> &amp;&amp; sigTime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            signalSchedulingChangeImmediately(sigTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JobPersistenceException e) &#123;</span><br><span class="line">        rollbackConnection(conn);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        rollbackConnection(conn);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JobPersistenceException(<span class="string">&quot;Unexpected runtime exception: &quot;</span></span><br><span class="line">                + e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            releaseLock(lockName, transOwner);      <span class="comment">//释放锁</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cleanupConnection(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上代码可知Quartz集群基于数据库锁的同步操作流程如下图所示：</p>
<img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/05dac2dd.png" alt="Quartz集群基于锁的同步方案" style="zoom: 67%;" />





<p>一个调度器实例在执行涉及到分布式问题的数据库操作前，首先要获取QUARTZ_LOCKS表中对应的行级锁，获取锁后即可执行其他表中的数据库操作，随着操作事务的提交，行级锁被释放，供其他调度实例获取。集群中的每一个调度器实例都遵循这样一种严格的操作规程。</p>
<p>getLockHandler()方法返回的对象类型是Semaphore，获取锁和释放锁的具体逻辑由该对象维护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Semaphore &#123;</span><br><span class="line"></span><br><span class="line">     boolean obtainLock(Connection conn, String lockName) throws LockException;</span><br><span class="line"></span><br><span class="line">     void releaseLock(String lockName) throws LockException;</span><br><span class="line"></span><br><span class="line">     boolean requiresConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口的实现类完成具体操作锁的逻辑，在JobStoreSupport的初始化方法中注入的Semaphore具体类型是StdRowLockSemaphore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setLockHandler(new StdRowLockSemaphore(getTablePrefix(), getInstanceName(), getSelectWithLockSQL()));</span><br></pre></td></tr></table></figure>

<p>StdRowLockSemaphore的源码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class StdRowLockSemaphore extends DBSemaphore &#123;</span><br><span class="line">&#x2F;&#x2F;锁定SQL语句</span><br><span class="line">public static final String SELECT_FOR_LOCK &#x3D; &quot;SELECT * FROM &quot;</span><br><span class="line">        + TABLE_PREFIX_SUBST + TABLE_LOCKS + &quot; WHERE &quot; + COL_LOCK_NAME</span><br><span class="line">        + &quot; &#x3D; ? FOR UPDATE&quot;;</span><br><span class="line"></span><br><span class="line">public static final String INSERT_LOCK &#x3D; &quot;INSERT INTO &quot; + TABLE_PREFIX_SUBST </span><br><span class="line">        + TABLE_LOCKS + &quot;(&quot; + COL_SCHEDULER_NAME + &quot;, &quot; </span><br><span class="line">        + COL_LOCK_NAME + &quot;) VALUES (&quot; + SCHED_NAME_SUBST + &quot;, ?)&quot;; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定锁定SQL</span><br><span class="line">protected void executeSQL(Connection conn, String lockName, String expandedSQL) throws LockException &#123;</span><br><span class="line">    PreparedStatement ps &#x3D; null;</span><br><span class="line">    ResultSet rs &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ps &#x3D; conn.prepareStatement(expandedSQL);</span><br><span class="line">        ps.setString(1, lockName);</span><br><span class="line">        ......</span><br><span class="line">        rs &#x3D; ps.executeQuery();</span><br><span class="line">        if (!rs.next()) &#123;</span><br><span class="line">            throw new SQLException(Util.rtp(</span><br><span class="line">                &quot;No row exists in table &quot; + TABLE_PREFIX_SUBST +</span><br><span class="line">                TABLE_LOCKS + &quot; for lock named: &quot; + lockName, getTablePrefix()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (SQLException sqle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ...... &#x2F;&#x2F;release resources</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取QRTZ_LOCKS行级锁</span><br><span class="line">public boolean obtainLock(Connection conn, String lockName) throws LockException &#123;</span><br><span class="line">    lockName &#x3D; lockName.intern();</span><br><span class="line"></span><br><span class="line">    if (!isLockOwner(conn, lockName)) &#123;</span><br><span class="line">        executeSQL(conn, lockName, expandedSQL);</span><br><span class="line"></span><br><span class="line">        getThreadLocks().add(lockName);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;释放QRTZ_LOCKS行级锁</span><br><span class="line">public void releaseLock(Connection conn, String lockName) &#123;</span><br><span class="line">    lockName &#x3D; lockName.intern();</span><br><span class="line"></span><br><span class="line">    if (isLockOwner(conn, lockName)) &#123;</span><br><span class="line">        getThreadLocks().remove(lockName);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下Quartz集群同步机制：每当要进行与某种业务相关的数据库操作时，先去QRTZ_LOCKS表中查询操作相关的业务对象所需要的锁，在select语句之后加for update来实现。例如，TRIGGER_ACCESS表示对任务触发器相关的信息进行修改、删除操作时所需要获得的锁。这时，执行查询这个表数据的SQL形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from QRTZ_LOCKS t where t.lock_name&#x3D;&#39;TRIGGER_ACCESS&#39; for update</span><br></pre></td></tr></table></figure>

<p>当一个线程使用上述的SQL对表中的数据执行查询操作时，若查询结果中包含相关的行，数据库就对该行进行ROW LOCK；若此时，另外一个线程使用相同的SQL对表的数据进行查询，由于查询出的数据行已经被数据库锁住了，此时这个线程就只能等待，直到拥有该行锁的线程完成了相关的业务操作，执行了commit动作后，数据库才会释放了相关行的锁，这个线程才能继续执行。</p>
<p>通过这样的机制，在集群环境下，结合悲观锁的机制就可以防止一个线程对数据库数据的操作的结果被另外一个线程所覆盖，从而可以避免一些难以觉察的错误发生。当然，达到这种效果的前提是需要把Connection设置为手动提交，即autoCommit为false。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="为什么我在一台机器上，看不到Job打印的执行日志"><a href="#为什么我在一台机器上，看不到Job打印的执行日志" class="headerlink" title="为什么我在一台机器上，看不到Job打印的执行日志"></a><strong>为什么我在一台机器上，看不到Job打印的执行日志</strong></h3><p>因为Quartz是分布式搭建的，触发定时任务时，只在集群中的某一台机器上执行。所以，我查看的机器，不是执行的机器，所以看不到也正常。我就在本地测试的时候，发现其他同事也开着程序。。。。导致定时任务一直在他们那里执行，我根本看不到。。。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-05-%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-05-%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">shiro应用-05-过滤器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-24 17:39:13" itemprop="dateCreated datePublished" datetime="2021-05-24T17:39:13+08:00">2021-05-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们都知道shiro是个认证权限框架，除了登录、退出逻辑我们需要侵入项目代码之外，验证用户是否已经登录、是否拥有权限的代码其实都是过滤器来完成的，可以这么说，shiro其实就是一个过滤器链集合。</p>
<p>那么今天我们详细讨论一下shiro底层到底给我们提供了多少默认的过滤器供我们使用，又都有什么用呢？带着问题，我们先去shiro官网看看对于默认过滤器集的说明。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://shiro.apache.org/web.html#default-filters">http://shiro.apache.org/web.h…</a></li>
</ul>
<blockquote>
<p>When running a web-app, Shiro will create some useful default Filter instances and make them available in the [main] section automatically. You can configure them in main as you would any other bean and reference them in your chain definitions.</p>
<p>The default Filter instances available automatically are defined by the DefaultFilter enum and the enum’s name field is the name available for configuration.</p>
</blockquote>
<p>默认筛选器实例由DefaultFilter enum中定义，enum s name字段是可用于配置的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public enum DefaultFilter &#123;</span><br><span class="line"></span><br><span class="line">    anon(AnonymousFilter.class),</span><br><span class="line">    authc(FormAuthenticationFilter.class),</span><br><span class="line">    authcBasic(BasicHttpAuthenticationFilter.class),</span><br><span class="line">    logout(LogoutFilter.class),</span><br><span class="line">    noSessionCreation(NoSessionCreationFilter.class),</span><br><span class="line">    perms(PermissionsAuthorizationFilter.class),</span><br><span class="line">    port(PortFilter.class),</span><br><span class="line">    rest(HttpMethodPermissionFilter.class),</span><br><span class="line">    roles(RolesAuthorizationFilter.class),</span><br><span class="line">    ssl(SslFilter.class),</span><br><span class="line">    user(UserFilter.class);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于知道我们常用的anon、authc、perms、roles、user过滤器是哪里来的了！这些过滤器我们都是可以直接使用的。</p>
<img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/8e77bde372b64a83baa2c7d782137a61.png" alt="img" style="zoom: 33%;" />



<h4 id="AbstractFilter"><a href="#AbstractFilter" class="headerlink" title="AbstractFilter"></a>AbstractFilter</h4><p>这个过滤器还得说说，shiro最底层的抽象过滤器，虽然我们极少直接继承它，它通过实现<code>Filter</code>获得过滤器的特性。</p>
<p>完成一些过滤器基本初始化操作，<code>FilterConfig</code>：过滤器配置对象，用于servlet容器在初始化期间将信息传递给其他过滤器。</p>
<h4 id="NameableFilter"><a href="#NameableFilter" class="headerlink" title="NameableFilter"></a>NameableFilter</h4><p>命名过滤器，给过滤器定义名称！也是比较基层的过滤器了，未拓展其他功能，我们很少会直接继承这个过滤器。为重写doFilter方法。</p>
<h4 id="OncePerRequestFilter"><a href="#OncePerRequestFilter" class="headerlink" title="OncePerRequestFilter"></a>OncePerRequestFilter</h4><p>重写doFilter方法，保证每个servlet方法只会被过滤一次。可以看到doFilter方法中，第一行代码就是<code>String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName();</code>然后通过<code>request.getAttribute(alreadyFilteredAttributeName) != null</code>来判断过滤器是否已经被调用过，从而保证过滤器不会被重复调用。</p>
<p>进入方法之前，先标记<code>alreadyFilteredAttributeName</code>为True，抽象<code>doFilterInternal</code>方法执行之后再remove掉<code>alreadyFilteredAttributeName</code>。</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/391f6d511eb5486e82611a2774eac82f.png" alt="img"></p>
<p>所以OncePerRequestFilter过滤器保证只会被一次调用的功能，提供了抽象方法<code>doFilterInternal</code>让后面的过滤器可以重写，执行真正的过滤器处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected abstract void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">            throws ServletException, IOException;</span><br></pre></td></tr></table></figure>



<h4 id="AdviceFilter"><a href="#AdviceFilter" class="headerlink" title="AdviceFilter"></a>AdviceFilter</h4><p>看到Advice，很自然想到切面环绕编程，一般有pre、post、after几个方法。所以这个AdviceFilter过滤器就是提供了和AOP相似的切面功能。</p>
<p>继承OncePerRequestFilter过滤器重写doFilterInternal方法，我们可以先看看：</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/1f169663547f42119c98d93f4d4ab97b.png" alt="img"></p>
<p>可以看到上面4个序号：</p>
<ol>
<li>preHandle 前置过滤，默认true</li>
<li>executeChain 执行真正代码过滤逻辑-&gt;chain.doFilter</li>
<li>postHandle 后置过滤</li>
<li>cleanup 其实主要逻辑是afterCompletion方法</li>
</ol>
<p>于是，我们从OncePerRequestFilter的一个doFilterInternal分化成了切面编程，更容易前后控制执行逻辑。所以如果继承AdviceFilter时候，我们可以重写preHandle方法，判断用户是否满足已登录或者其他业务逻辑，返回false时候表示不通过过滤器。</p>
<h4 id="PathMatchingFilter"><a href="#PathMatchingFilter" class="headerlink" title="PathMatchingFilter"></a>PathMatchingFilter</h4><p>请求路径匹配过滤器，通过匹配请求url，判断请求是否需要过滤，如果url未在需要过滤的集合内，则跳过，否则进入<code>isFilterChainContinued</code>的onPreHandle方法。</p>
<p>我们可以看下代码：</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/62f7317fd4ec467682f3da3aa11a3c87.png" alt="img"></p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/b568d5dceb2b4a19aad6fd72348f5e58.png" alt="img"></p>
<p>从上面3个步骤中可以看到，PathMatchingFilter提供的功能是：自定义匹配url，匹配上的请求最终跳转到<code>onPreHandle</code>方法。</p>
<p>这个过滤器为后面的常用过滤器提供的基础，比如我们在config中配置如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;login &#x3D; anon</span><br><span class="line">&#x2F;admin&#x2F;* &#x3D; authc</span><br></pre></td></tr></table></figure>

<p>拦截/login请求，经过AnonymousFilter过滤器，我们可以看下</p>
<ul>
<li>org.apache.shiro.web.filter.authc.AnonymousFilter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AnonymousFilter extends PathMatchingFilter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 公众号：MarkerHub</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) &#123;</span><br><span class="line">        &#x2F;&#x2F; Always return true since we allow access to anyone</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AnonymousFilter重写了onPreHandle方法，只不过直接返回了true，说明拦截的链接可以直接通过，不需要其他拦截逻辑。</p>
<p>而authc-&gt;FormAuthenticationFilter也是间接继承了PathMatchingFilter。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FormAuthenticationFilter extends AuthenticatingFilter</span><br></pre></td></tr></table></figure>

<p>所以，需要拦截某个链接进行业务逻辑过滤的可以继承PathMatchingFilter方法拓展哈。</p>
<h4 id="AccessControlFilter"><a href="#AccessControlFilter" class="headerlink" title="AccessControlFilter"></a>AccessControlFilter</h4><p>访问控制过滤器。继承PathMatchingFilter过滤器，重写onPreHandle方法，又分出了两个抽象方法来控制</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/63cb9b7e06f249089c88fa25f480ddd3.png" alt="img"></p>
<ul>
<li>isAccessAllowed 是否允许访问</li>
<li>onAccessDenied 是否拒绝访问</li>
</ul>
<p>所以，我们现在可以通过重写这个抽象两个方法来控制过滤逻辑。另外多提供了3个方法，方便后面的过滤器使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">saveRequestAndRedirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    saveRequest(request);</span><br><span class="line">    redirectToLogin(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">saveRequest</span><span class="params">(ServletRequest request)</span> </span>&#123;</span><br><span class="line">    WebUtils.saveRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">redirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String loginUrl = getLoginUrl();</span><br><span class="line">    WebUtils.issueRedirect(request, response, loginUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中redirectToLogin提供了调整到登录页面的逻辑与实现，为后面的过滤器发现未登录跳转到登录页面提供了基础。</p>
<h4 id="AuthenticationFilter"><a href="#AuthenticationFilter" class="headerlink" title="AuthenticationFilter"></a>AuthenticationFilter</h4><p>继承AccessControlFilter，重写了isAccessAllowed方法，通过判断用户是否已经完成登录来判断用户是否允许继续后面的逻辑判断。这里可以看出，从这个过滤器开始，后续的判断会与用户的登录状态相关，直接继承这些过滤器，我们不需要再自己手动去判断用户是否已经登录。并且提供了登录成功之后跳转的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AuthenticationFilter extends AccessControlFilter &#123;</span><br><span class="line">    public void setSuccessUrl(String successUrl) &#123;</span><br><span class="line">        this.successUrl &#x3D; successUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123;</span><br><span class="line">        Subject subject &#x3D; getSubject(request, response);</span><br><span class="line">        return subject.isAuthenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AuthenticatingFilter"><a href="#AuthenticatingFilter" class="headerlink" title="AuthenticatingFilter"></a>AuthenticatingFilter</h4><p>继承AuthenticationFilter，提供了自动登录、是否登录请求等方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公众号：MarkerHub</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticatingFilter</span> <span class="keyword">extends</span> <span class="title">AuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERMISSIVE = <span class="string">&quot;permissive&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO - complete JavaDoc</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">executeLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AuthenticationToken token = createToken(request, response);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;createToken method implementation returned null. A valid non-null AuthenticationToken &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;must be created in order to execute a login attempt.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Subject subject = getSubject(request, response);</span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="keyword">return</span> onLoginSuccess(token, subject, request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> onLoginFailure(token, e, request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AuthenticationToken <span class="title">createToken</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公众号：MarkerHub</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.isAccessAllowed(request, response, mappedValue) ||</span><br><span class="line">                (!isLoginRequest(request, response) &amp;&amp; isPermissive(mappedValue));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>executeLogin 执行登录</li>
<li>onLoginSuccess 登录成功跳转</li>
<li>onLoginFailure 登录失败跳转</li>
<li>createToken 创建登录的身份token</li>
<li>isAccessAllowed 是否允许被访问</li>
<li>isLoginRequest 是否登录请求</li>
</ul>
<p>这个方法提供了自动登录，比如我们获取到token之后实行自动登录</p>
<h4 id="FormAuthenticationFilter"><a href="#FormAuthenticationFilter" class="headerlink" title="FormAuthenticationFilter"></a>FormAuthenticationFilter</h4><p>基于form表单的账号密码自动登录的过滤器，我们只需要看这个方法就明白，和renren-fast的实现相似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AuthenticatingFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_USERNAME_PARAM = <span class="string">&quot;username&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PASSWORD_PARAM = <span class="string">&quot;password&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_REMEMBER_ME_PARAM = <span class="string">&quot;rememberMe&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationToken <span class="title">createToken</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        String username = getUsername(request);</span><br><span class="line">        String password = getPassword(request);</span><br><span class="line">        <span class="keyword">return</span> createToken(username, password, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公众号：MarkerHub</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoginRequest(request, response)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLoginSubmission(request, response)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                    log.trace(<span class="string">&quot;Login submission detected.  Attempting to execute login.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> executeLogin(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                    log.trace(<span class="string">&quot;Login page view.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//allow them to see the login page ;)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">&quot;Attempting to access a path which requires authentication.  Forwarding to the &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Authentication url [&quot;</span> + getLoginUrl() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            saveRequestAndRedirectToLogin(request, response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onAccessDenied调用executeLogin方法。默认的token是UsernamepasswordToken。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/23/My%20Lord%20Jesus/%E4%B8%BB%E6%97%A5%E8%AE%B2%E9%81%93/2021-05-23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/23/My%20Lord%20Jesus/%E4%B8%BB%E6%97%A5%E8%AE%B2%E9%81%93/2021-05-23/" class="post-title-link" itemprop="url">2021-05-23主日讲道</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-23 13:54:56 / Modified: 10:47:02" itemprop="dateCreated datePublished" datetime="2021-05-23T13:54:56+08:00">2021-05-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>题目：同一脚踪，拓展 神国 – 神的道<br>讲员：于宏洁<br>经文：</p>
<ul>
<li>再次强调：必须依靠圣灵</li>
<li>另外一个因素：神的道</li>
</ul>
<p>以西结书的异象：</p>
<ul>
<li>即使 神家如枯骨一样，神的话临到，枯骨变得有生命</li>
<li>枯骨指的是没有盼望，只要活着就有盼望</li>
</ul>
<blockquote>
<p>食物一天吃都不行，但是 神的话，一个星期不吃都没事。我们做儿女的需要反思了。</p>
</blockquote>
<p>所有的祷告都建立在与 神的相交上</p>
<ul>
<li>读经祷告，都是为了遇见说话的 神</li>
<li>读经不是用眼睛看，而是用耳朵听 （以赛亚书58：）</li>
</ul>
<p> 神的道在 神国拓展中起作用</p>
<p>- </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">java探针-类加载问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-22 11:08:25" itemprop="dateCreated datePublished" datetime="2021-05-22T11:08:25+08:00">2021-05-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>得益于Java SE 6提供的Instrumentation接口。基于Instrumentation可开发运行时修改class字节码的Java Agent应用（Java探针），可在<a href="">类加载之前替换类的字节码</a>、或在<a href="">类加载之后通过重新加载类方式修改类的字节码</a>。</p>
<p>只是实现运行时修改class字节码还不足以称为“探针”。基于Instrumentation开发的Java Agent，只需要在Java应用启动命令上加上虚拟机参数“-javaagent”指定Java Agent应用jar包的位置，而不需要在工程项目中引入其jar包，即可将探针插入应用代码的各个角落。通过<a href="">与应用使用不同的类加载实现环境隔离</a>，让人有种Java Agent是吸附在应用上运行的错觉。</p>
<h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>由父类加载器加载的类，不能引用子类加载器加载的类，否则会抛出NoClassDefFoundError。</p>
<p>JDK提供的<code>java.*</code>类都由启动类加载器加载。如果我们在<code>java agent</code>中修改<code>java.*</code>包下的类，插入调用logback打印日记的代码，结果会怎样？由于<code>java agent</code>包下的logback由AppClassLoader加载，而加载<code>java.*</code>包下的类是BootClassLoader(AppClassLoader的父类加载器)，在<code>java.*</code>包下的类中插入调用logback打印日记的代码，首先在加载<code>java.*</code>包下的类时，jvm会查看BootClassLoader有没有加载过这个类，如果没有加载过尝试加载，但BootClassLoader加载不了logback包的类，而启动类加载器不会向子类加载器去询问，即使子类加载器加载了这个类。所以就会出现NoClassDefFoundError。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>如果非要修改java包下的类，且非要在java包下的类中访问项目中我们编写的类或者第三方jar包提供的类、或者我们编写的javaagent包下的类，如何避免NoClassDefFoundError呢？</p>
<p>研究下Arthas:</p>
<ul>
<li>用于接收埋点代码上报事件的类（Spy）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Spy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method beforMethod;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method completeMethod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(String className, String methodName, String descriptor, Object[] params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beforMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforMethod.invoke(<span class="keyword">null</span>, className, methodName, descriptor, params);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object returnValueOrThrowable, String className, String methodName, String descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (completeMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                completeMethod.invoke(<span class="keyword">null</span>, returnValueOrThrowable, className, methodName, descriptor);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>before：方法执行之前上报；</p>
<p>complete：方法return之前或者抛出异常之前上报，当方法抛出异常时，第一个参数为异常，否则第一个参数为返回值</p>
<p>methodName: 上报方法</p>
</blockquote>
<ul>
<li>将Spy放在一个独立的jar包下，在premain、agentmain方法中调用Instrumentation的appendToBootstrapClassLoaderSearch方法，将Spy类所在的jar包交由启动类加载器扫描加载，如下代码所示。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; agent-spy.jar</span><br><span class="line">String agentSpyJar &#x3D; jarPath[1];</span><br><span class="line">File spyJarFile &#x3D; new File(agentSpyJar);</span><br><span class="line">instrumentation.appendToBootstrapClassLoaderSearch(new JarFile(spyJarFile));</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在Spy类中打印类加载器，如果打印的结果为null，则说明Spy类是由启动类加载器加载的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final class Spy &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Spy class loader is &quot; + Spy.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Agent与应用环境隔离"><a href="#实现Agent与应用环境隔离" class="headerlink" title="实现Agent与应用环境隔离"></a>实现Agent与应用环境隔离</h2><p>隔离是避免Agent污染应用自身，使开发Java Agent无需考虑引入的jar包是否与目标应用引入的jar包冲突。</p>
<h3 id="与springboot隔离失败原因"><a href="#与springboot隔离失败原因" class="headerlink" title="与springboot隔离失败原因"></a>与springboot隔离失败原因</h3><p>Java Agent与Spring Boot应用相遇时会发生什么？</p>
<p>Spring Boot应用打包后，将Agent附着到应用启动可能会抛出醒目的NoClassDefFoundError异常，背后的原因是<a href="">Agent与打包后的Spring Boot应用使用了不同的类加载器</a>。</p>
<ul>
<li>Agent的jar包由AppClassLoader加载。我们可能会在Agent中调用被监控的SpringBoot应用的代码，也可能调用Agent依赖的第三方jar包的API，而这些jar包恰好在SpringBoot应用中也有导入，就可能会出现NoClassDefFoundError。</li>
<li>SpringBoot应用打包后，JVM进程启动入口不再是我们写的main方法，而是SpringBoot生成的启动类。SpringBoot使用自定义的类加载器（LaunchedClassLoader）加载jar中的类和第三方jar包中的类，该类加载器的父类加载器为AppClassLoader。也就是说，SpringBoot应用打包后，加载java agent包下的类加载器是SpringBoot的类加载器的父类。</li>
</ul>
<blockquote>
<p>疑惑？这在IDEA中测试是不会发生的</p>
<p>因为在IDEA中，项目的class文件和第三方库是通过AppClassLoader加载的，而使用-javaagent指定的jar也是通过AppClassLoader加载，所以在idea中测试不会遇到这个问题。</p>
</blockquote>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>让加载agent包不使用AppClassLoader加载器加载，而是使用自定义的类加载器加载。</p>
<p>参考Alibaba开源的Arthas的实现，自定义URLClassLoader加载agent包以及agent依赖的第三方jar包。</p>
<p>由于premain或者agentmain方法所在的类由jvm使用AppClassLoader所加载，所以必须将agent拆分为两个jar包。核心功能放在agent-core包下，premain或者agentmain方法所在的类放在agent-boot包下。在premain或者agentmain方法中使用自定义的URLClassLoader类加载器加载agent-core。</p>
<ul>
<li>自定义类加载器OnionClassLoader，继承URLClassLoader，如下代码所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnionClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnionClassLoader</span><span class="params">(URL[] urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(urls, ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (loadedClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadedClass;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优先从parent（SystemClassLoader）里加载系统类，避免抛出ClassNotFoundException</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; (name.startsWith(<span class="string">&quot;sun.&quot;</span>) || name.startsWith(<span class="string">&quot;java.&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> aClass;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在构造方法中指定OnionClassLoader的父类加载器为AppClassLoader的父类加载器。</p>
<p><code>ClassLoader.getSystemClassLoader()</code>：获取系统类加载器（AppClassLoader）</p>
<ul>
<li>在premain或者agentmain方法中使用OnionClassLoader类加载器加载agent-core。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File agentJarFile = <span class="keyword">new</span> File(agentJar);</span><br><span class="line"><span class="keyword">final</span> ClassLoader agentLoader = <span class="keyword">new</span> OnionClassLoader(<span class="keyword">new</span> URL[]&#123;agentJarFile.toURI().toURL()&#125;);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; transFormer = agentLoader.loadClass(<span class="string">&quot;com.msyc.agent.core.OnionClassFileTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt; constructor = transFormer.getConstructor(String.class);</span><br><span class="line">Object instance = constructor.newInstance(opsParams);</span><br><span class="line"></span><br><span class="line">instrumentation.addTransformer((ClassFileTransformer) instance);</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>根据agent-core.jar所在绝对路径构造OnionClassLoader；</li>
<li>加载agent-core.jar下的ClassFileTransformer；</li>
<li>使用反射创建ClassFileTransformer实例；</li>
<li>将ClassFileTransformer添加到Instrumentation;</li>
</ul>
</blockquote>
<p>OnionClassFileTransformer类所依赖的agent-core包下的类，自然也会被使用OnionClassLoader类加载器加载，包括agent-core依赖的第三方jar包。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/yibbONzdtFf2t8JVXHNXRpibzSgFAqUAMkfyP8gypoicPR23f3cqb0icdKtGjjAicYowOAHJr07HqlV9YPbqqqPE4qg/640" alt="图片"></p>
<h2 id="适配webmvc框架"><a href="#适配webmvc框架" class="headerlink" title="适配webmvc框架"></a><strong>适配webmvc框架</strong></h2><p>生成分布式调用链日记的难点在于方法埋点和方法调用日记串连。</p>
<p>分布式调用链日记串连的方式有多种，笔者采用的是最简单的方式：打点id+打点时间。</p>
<ul>
<li>对于同进程内的同线程，可用打点id将调用的方法串连起来，根据打点时间与一个累加器的值排序方法调用日记。</li>
<li>对于不同进程，通过传递打点id可将不同应用的打点日记串连起来，根据打点时间排序。</li>
</ul>
<p>例如，适配webmvc框架的目的是从请求头获取调用来源传递过来的打点ID(事务ID)。对DispatcherServlet#doDispatch方法插桩，从HttpServletRequest参数获取请求头“S-Tid”。“S-Tid”是自定义的请求头参数，用于传递打点ID。</p>
<p>笔者在实现适配webmvc和openfeign时都遇到了同样的问题，如在适配webmvc时，修改DispatcherServlet的doDispatch方法时，asm框架抛出java.lang.TypeNotPresentException。</p>
<ul>
<li>java.lang.TypeNotPresentException：当应用程序试图使用表示类型名称的字符串对类型进行访问，但无法找到带有指定名称的类型定义时，抛出该异常。</li>
</ul>
<p>其原因是，使用asm框架改写DispatcherServlet类时，asm会使用Class.forName方法加载符号引用的类，如果加载不到目标类则抛出TypeNotPresentException。</p>
<p>默认asm会使用加载自身的类加载器去尝试加载当前改写类所依赖的一些类，而加载asm框架使用的类加载器与加载agent-core包使用的是同一个类加载器，DispatcherServlet则由SpringBoot的LaunchedClassLoader类加载器所加载。</p>
<p>好在ClassFileTransformer#transform方法传递了用于加载当前类的类加载器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class OnionClassFileTransformer implements ClassFileTransformer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public byte[] transform(ClassLoader loader, String className,                             Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                            ProtectionDomain protectionDomain,                             byte[] classfileBuffer) &#123;</span><br><span class="line">             &#x2F;&#x2F; ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>如果当前需要改写的类是DispatcherServlet，则transform方法的第一个参数为即将用于加载DispatcherServlet类的类加载器；</li>
</ul>
<p>我们只需要指定asm使用ClassFileTransformer#transform方法传递进来的类加载器加载DispatcherServlet依赖的类即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassWriter classWriter &#x3D; new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES) &#123;</span><br><span class="line">       @Override</span><br><span class="line">       protected ClassLoader getClassLoader() &#123;</span><br><span class="line">            return loader;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>如代码所示，我们重写asm的ClassWriter类的getClassLoader方法，返回的类加载器是ClassFileTransformer#transform方法传递进来的类加载器。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-01/" class="post-title-link" itemprop="url">kafka-分析与调优</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 12:34:40" itemprop="dateCreated datePublished" datetime="2021-05-21T12:34:40+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Kafka报-IO-Exception-many-open-files"><a href="#Kafka报-IO-Exception-many-open-files" class="headerlink" title="Kafka报 IO Exception(many open files)"></a>Kafka报 IO Exception(many open files)</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><hr>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVd71ajm8l4SQibTbQic73zsFR1OryAj6gpuVAfviaTAyQzKmMNK1y5et2w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>首先我们要能看懂Kafka-manager上的一些监控指标，topic列表中关于topic的信息项如下所示：</p>
<ul>
<li><p>Brokers Spread %<br>该topic中队列在Broker中的使用率，例如集群中有5个broker，但topic只在４个broker上创建了队列，那使用率为80％。</p>
</li>
<li><p>Brokers Skew %<br>topic的队列倾斜率。如果集群中存在5个broker节点，topic的总分区数量为4,副本因子为2，但这些队列只分布在其中的４台broker中。那topic的<strong>broker使用率(Broker Spread)为80%**。<br>众所周知，引入多节点的目的就是负载均衡，队列在broker中的分配自然是希望越均衡越好，期望每台broker上存储2个队列(副本因子为2，总共８个队列)，表示没有发生倾斜，如果一台broker中的存在３个队列，而另外一个broker上１个队列，那说明发生了倾斜，</strong>计算公式为超过平均队列数的broker节点个数除以总所在Broker数量**，其Brokers Skew等于(1/3)=33%。  <!--队列就是：分区 + 副本--></p>
</li>
<li><p>Brokers Leader Skew %<br>topic分区中Leader分区的倾斜率。在Kafka中，<strong>只有分区的Leader节点具有读写权限</strong>，真正影响读写性能的是Leader分区是否均衡，试想一下，如果一个topic有6个分区，但所有的Leader分区只分布在一两个Broker节点上，这个<strong>topic的写入、读取性能将受到制约，这个值建议维持在0％</strong>。</p>
</li>
<li><p>Replicas<br>副本数、副本因子，即一个分区数据存储的份数，该数值包含Leader分区。</p>
</li>
<li><p>Under Replicated %<br>没有跟上复制进度的副本比例，在Kafka的复制模型中，主分区负责读写，该复制组内的其他副本从主节点同步数据，如果跟不上主节点的复制进度，将被提出ISR，被剔除ISR的副本不具备选举Leader的资格，<strong>这个数据如果长期或频繁高于0，说明集群一定出现了问题</strong>。</p>
</li>
</ul>
<p>Producer Message/Sec<br>消息发送实时TPS，通过JMX采集，需要在kafka-manager中开启如下参数：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVibB9l70MzWAEFyUMZIvia0bxQrJYlciaeCmPBFNwWjJI95TiaUV293sX5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li>Summed Recent Offsets<br>该主题当前最大的消息偏移量。</li>
</ul>
<p>经过对Topic列表观察，发现开发环境存在大量的topic都只有一个队列，并且都分布在第一节点上，其截图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVRdFRpiaHaB1GsEt8uibID722MYlxAurdoJnTK6EcIKrtDzGZjkqL5vjA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">在这里插入图片描述</p>
<p>从界面上对应的指标：Brokers Spread即Broker的利用率只有３分之一，抽取几个数据量大的主题，判断其路由信息，得知都分布在第一个Broker节点上，这样就导致其中一个节点大量出现文章开头部分提到的错误：<strong>Too many open files</strong>。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><hr>
<h5 id="3-1-扩分区"><a href="#3-1-扩分区" class="headerlink" title="3.1 扩分区"></a>3.1 扩分区</h5><p>问题定位出来了，由于Broker利用率不均匀，大量topic只创建了一个队列，并且还集中落到了第一个节点。</p>
<p>针对这种情况，首先想到的方案：扩分区。</p>
<h5 id="3-1-1-通过Kafka-manager"><a href="#3-1-1-通过Kafka-manager" class="headerlink" title="3.1.1 通过Kafka-manager"></a>3.1.1 通过Kafka-manager</h5><p>Step1：在Kafka-manager的topic列表，点击具体的topic，进入详情页面，点击[add Partitions]，如图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVPXLfzpo8iaZoYQarg7ws4SczYTMFxic6YCNvJoYFmLs4kLl6Qwad1Ekg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>Step2：点击增加分区，弹出如下框：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVfuicI2KEPBO13zgMaw4Qbrcoe8meRTz2vyCDkx4QeicY8k9bYHZxk6oQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>说明如下：</p>
<ul>
<li>Partitions<br>扩容后的总分区个数，并不是本次增加的分区个数。</li>
<li>Brokers<br>分区需要分布的Broker，建议全选，充分利用整个集群的性能。</li>
</ul>
<h5 id="3-1-2-运维命令"><a href="#3-1-2-运维命令" class="headerlink" title="3.1.2 运维命令"></a>3.1.2 运维命令</h5><p>可以通过Kafka提供的kafka-topics命令，修改topic的分区，具体参考如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVzjZFWZ47UpkVb3iaNkWMHqenWIXsCBjuGW1T1e42cRiaWiby6sQf4lJzQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<blockquote>
<p>温馨提示：对这些运维命令不熟悉没关系，基本都提供了–help</p>
</blockquote>
<h5 id="3-2-分区移动"><a href="#3-2-分区移动" class="headerlink" title="3.2 分区移动"></a>3.2 分区移动</h5><p>由于存在大量的只有一个分区的topic，并且这些topic都分布到了第一个节点，是不是可以将某些topic的分区移动到其他节点呢？</p>
<p>接下来介绍一下分区移动如何操作。</p>
<h5 id="3-2-1-kafka-manager"><a href="#3-2-1-kafka-manager" class="headerlink" title="3.2.1 kafka-manager"></a>3.2.1 kafka-manager</h5><p>Step1：进入topic详情页面，点击[Generate Partition Assignments]，如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVm6ibJZh43iaVwh40jX6Fz3AsbnibricqkmBWbOHRVhdMH5UiaMRhicPQic3Hw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>Step2：进入页面后，选择需要迁移到的brroker，还可以改变topic的副本因子，最后点击[Generate Partition Assignments]，如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVa0Z8umQiaib5DRzibX2I0icvPyMdiaEm3Px6F8ERyGFy9cBziaQEwIN0QzGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>Step3：点击完成后，此时只是生成了分区迁移计划，并没有真正的执行，需要点击[Reassign Parttions]按钮。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVAceM0RH9Ktq7URs2FpdA404icN4qExz8ib0u0kJiaFNCHHz9QcZqDMVHg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h5 id="3-2-2-运维命令"><a href="#3-2-2-运维命令" class="headerlink" title="3.2.2 运维命令"></a>3.2.2 运维命令</h5><p>Step1：首先我们需要准备需要执行迁移的topic信息，例如将如下信息保存在文件dw_test_kafka_040802-topics-to-move.json中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;topics&quot;:</span><br><span class="line">    [</span><br><span class="line">        &#123;&quot;topic&quot;:&quot;dw_test_kafka_040802&quot;&#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Step2：使用kafka提供的kafka-reassign-partitions.sh命令生成执行计划</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVAUy43eHQT4wodWDoyINRX7icKnHesVuh6korWVXqjf3VrtYBZGU9gTw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>上面的参数其实对照kafka-manager的图理解起来会更快，点出如下关键点：</p>
<ul>
<li>–broker-list<br>分区需要分布的broker。如果多个，使用双引号，例如 “0,1,2”。</li>
<li>–topics-to-move-json-file<br>需要执行迁移的topic列表。</li>
<li>–generate<br>表示生成执行计划(并不真正执行)</li>
</ul>
<p>执行成功后会输出当前的分区分布计划与新的执行计划，通常我们可以先将当前的执行计划存储到一个备份目录中，将新生成的计划存储到一个文件中。</p>
<p>Step3：使用kafka提供的kafka-reassign-partitions.sh命令执行分区迁移计划</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVianvMtHR60SJxxBeHga7AZ7IsibjuAtTQL02R7hmFRy8wWgVv49brWGA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>其关键点如下：</p>
<ul>
<li>–reassignment-json-file<br>指定上一步骤生成的执行计划。</li>
</ul>
<p>执行成功过后输出Successfully，重分区是一个非常复杂的过程，命令执行完成后，并不会真正执行完成，可以通过查询主题的详细信息来判断是否真正迁移成功。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVDGxJwcvfIUpiaxrjI16DiaEL9FR3HzmvjzeoPAOGvLwZhRpDHqpjwpOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h4 id="进阶与架构思维"><a href="#进阶与架构思维" class="headerlink" title="进阶与架构思维"></a>进阶与架构思维</h4><hr>
<p>通过kafka-reassign-partitions.sh对分区进行迁移，会影响业务方的正常使用吗？即会影响消息的消费与发送吗？</p>
<p>我们需要对分区迁移的实现原理做进一步探究，本文暂不从源码角度详细剖析，只是举例阐述一下分区迁移的实现机制。</p>
<p>需求：一个TopicA的其中一个分区p0，分布在broker id为1,2,3上，目前要将其迁移到brokerId为4,5,6。</p>
<p>在介绍迁移过程之前，我们先定义三个变量：</p>
<ul>
<li>OAR<br>迁移前分区的分布情况。</li>
<li>RAR<br>迁移后的分区分布情况</li>
<li>AR<br>当前运行过程中的分区分布情况</li>
</ul>
<p>结合上述例子，其整个迁移步骤如下：</p>
<table>
<thead>
<tr>
<th align="center">AR</th>
<th align="center">Leader(ISR)</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{1,2,3}</td>
<td align="center">1{1,2,3}</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">1{1,2,3}</td>
<td align="left">首先基于RAR集合(迁移后的新broker)上创建对应的分区，并开始从Leader同步数据</td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">1{1,2,3,4,5,6}</td>
<td align="left">新创建的副本追上主节点的进度，并进入ISR集合</td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">4{1,2,3,4,5,6}</td>
<td align="left">如果Leader不在RAR所在的集合中，则发起一次选举，将Leader变更为RAR中其中一台。</td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">4{4,5,6}</td>
<td align="left">将OAR中的副本状态设置为OfflineReplica(下线)，将其从ISR中剔除</td>
</tr>
<tr>
<td align="center">{4,5,6}</td>
<td align="center">4{4,5,6}</td>
<td align="left">删除下线的副本，完成整个迁移操作</td>
</tr>
</tbody></table>
<p>从上面这个过程，只有在Leader选举期间会对消息发送、消息消费造成影响，但通过Zookeeper实现Leader选举可在秒级别响应，结合Kafka消息发送端的缓冲队列、重试机制，在理论上可以做到对业务无影响。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%8A%80%E6%9C%AF/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%8A%80%E6%9C%AF/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-01/" class="post-title-link" itemprop="url">分库分表-01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 09:21:40" itemprop="dateCreated datePublished" datetime="2021-05-21T09:21:40+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/q_MMXEphKl56ngLy8R6jmg">https://mp.weixin.qq.com/s/q_MMXEphKl56ngLy8R6jmg</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-01/" class="post-title-link" itemprop="url">分布式事务一致性引擎-01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 09:17:23" itemprop="dateCreated datePublished" datetime="2021-05-21T09:17:23+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="分布式事务从入门到放弃-二-–详述DT引擎一致性原理及设计"><a href="#分布式事务从入门到放弃-二-–详述DT引擎一致性原理及设计" class="headerlink" title="分布式事务从入门到放弃(二)–详述DT引擎一致性原理及设计"></a>分布式事务从入门到放弃(二)–详述DT引擎一致性原理及设计</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dFmxdLtPFCXIR73gg2d1UA">https://mp.weixin.qq.com/s/dFmxdLtPFCXIR73gg2d1UA</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;mid=2650000675&amp;idx=1&amp;sn=f411dcfdf6135409b94963cbb45b4b0c&amp;chksm=882fa783bf582e950184684cb74ca701cde6618068a31b4a07773dc3c7f5d7afd400178df2c1&amp;cur_album_id=1579057632903004162&amp;scene=189#rd">https://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;mid=2650000675&amp;idx=1&amp;sn=f411dcfdf6135409b94963cbb45b4b0c&amp;chksm=882fa783bf582e950184684cb74ca701cde6618068a31b4a07773dc3c7f5d7afd400178df2c1&amp;cur_album_id=1579057632903004162&amp;scene=189#rd</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zAgR8Axo_nTiwvVEkVMM9w">https://mp.weixin.qq.com/s/zAgR8Axo_nTiwvVEkVMM9w</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-02/" class="post-title-link" itemprop="url">分布式事务一致性引擎-01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 09:17:23" itemprop="dateCreated datePublished" datetime="2021-05-21T09:17:23+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="分布式事务从入门到放弃–数据一致性引擎概览"><a href="#分布式事务从入门到放弃–数据一致性引擎概览" class="headerlink" title="分布式事务从入门到放弃–数据一致性引擎概览"></a>分布式事务从入门到放弃–数据一致性引擎概览</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Ow2HWBEgeqHdbMw3XNeyoA">https://mp.weixin.qq.com/s/Ow2HWBEgeqHdbMw3XNeyoA</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
