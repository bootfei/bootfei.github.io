<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/7/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">177</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/12/database/elastic/Lucene-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/12/database/elastic/Lucene-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Lucene-底层结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-12 20:04:10" itemprop="dateCreated datePublished" datetime="2021-03-12T20:04:10+08:00">2021-03-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-13 00:18:47" itemprop="dateModified" datetime="2021-03-13T00:18:47+08:00">2021-03-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p> Elasticsearch最强大的就是为每个字段提供了倒排索引，当查询的时候不用担心没有索引可以利用，什么是倒排索引，举个简单例子：</p>
<table>
<thead>
<tr>
<th>文档ID</th>
<th>年龄</th>
<th>性别</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>25</td>
<td>女</td>
</tr>
<tr>
<td>2</td>
<td>32</td>
<td>女</td>
</tr>
<tr>
<td>3</td>
<td>25</td>
<td>男</td>
</tr>
</tbody></table>
<p> 每一行是一个文档（document），每个document都有一个文档ID。那么给这些文档建立的倒排索引就是：</p>
<p>年龄的索引：</p>
<table>
<thead>
<tr>
<th>年龄</th>
<th>文档ID列表：posting list</th>
</tr>
</thead>
<tbody><tr>
<td>25</td>
<td>[1,3]</td>
</tr>
<tr>
<td>32</td>
<td>[2]</td>
</tr>
</tbody></table>
<p>性别的索引：</p>
<table>
<thead>
<tr>
<th>性别</th>
<th>文档ID列表：posting list</th>
</tr>
</thead>
<tbody><tr>
<td>男</td>
<td>[3]</td>
</tr>
<tr>
<td>女</td>
<td>[1,2]</td>
</tr>
</tbody></table>
<p>可以看到，倒排索引是针对每个字段的，每个字段都有自己的倒排索引，25、32这些叫做term，[1,3]这种叫做posting list，</p>
<p>它是一个int的数组，存储了所有符合某个term的文档id，这时候我们想找出年龄为25的人，就会很快速。</p>
<p>但是这里只有两个term，如果有成百上千个term呢，那找出某个term就会很慢，因为term还没有排序，解决这个问题需要了解两个概念：Term Dictionary 和 Term Index。<!--这就是ES比Mysql的原因--></p>
<h1 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h1><h2 id="Term-Dictionary"><a href="#Term-Dictionary" class="headerlink" title="Term Dictionary"></a>Term Dictionary</h2><p>Elasticsearch为了能快速找到某个term，将所有的term进行了排序，然后二分法查找term，类似于上学时候老师教我们的翻新华字典的方式，所以这叫做Term Dictionary，这种查询方式其实和传统关系型数据库的B-Tree的方式很相似，所以这并不是Elasticsearch快的原因。</p>
<table>
<thead>
<tr>
<th>Term（已经排过序了a -&gt; z）</th>
<th>Posting List</th>
</tr>
</thead>
<tbody><tr>
<td>ab</td>
<td>[….]</td>
</tr>
<tr>
<td>abc</td>
<td>[….]</td>
</tr>
<tr>
<td>b</td>
<td>[….]</td>
</tr>
</tbody></table>
<p>查询abc的时候，使用二分查找，hi = term.size(), lo = 0;</p>
<p>可以看到，整个Term列 = Term Dictionary</p>
<h2 id="Term-Index"><a href="#Term-Index" class="headerlink" title="Term Index"></a>Term Index</h2><p>如果说Term Dictionary是直接去二分法翻字典，那么Term Index就是字典的目录页。</p>
<p>假设我们的term如果全是英文单词，那么Term Index就是26个字母表，但是通常term未必都是英文，而可以是任意的byte数组。因为就算26个英文字符也不一定都有对应的term，比如：a开头的term只有一个，c开头的term有一百万个，x开头的term一个也没有，这样查询到c的时候又会很慢了。所以通常情况下Term Index 是包含term的一些前缀的一棵树，例如这样的一个Term Index：</p>
<img src="https://img-blog.csdn.net/20181010140158769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjg5Mzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:80%;" />

<p>这样的情况下通过Term Index据可以快速定位到某个offset(分支的开端)，然后以此位置向下查找，再加上<a href="">FST</a>（Finite-State Transducer，Lucene4.0开始使用该算法来查找Term 在Dictionary中的位置）的<a href="">压缩技术</a>，将Term Index 缓存到内存中，通过Term Index 找到对应的Term Dictionary的 block，然后再去磁盘直接找到term，减少磁盘的随机读写次数，大大的提升查询效率。（FST在下个章节单独介绍）</p>
<h1 id="Posting-List压缩技术"><a href="#Posting-List压缩技术" class="headerlink" title="Posting List压缩技术"></a>Posting List压缩技术</h1><p>谈到roaring bitmaps就要先了解bitset 或者bitmap，Bitset是一种的数据结构，对应posting list如果是：[2,3,5,7,9] 那么对于对应的bitset就是：[0,1,1,0,1,0,1,0,1,0]，用0和1来表示该位置的数值的有无，这种做法就是一个byte可以代表8个文档，当大数据量时，仍然会消耗很多内存，所以直接将bitset结构存入内存不太理想。</p>
<p>Elasticsearch不仅压缩了Term Index，还对posting list 进行了压缩，posting list虽然只存储了文档id，但是当文档id很大的时候，比PB级的数据，Elasticsearch对posting list的压缩做了两件事：排序和大数变小数，引用一张被引用无数次的图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL05ld2F5NjY1NS9uZXdheTY2NTUuZ2l0aHViLmNvbS9tYXN0ZXIvaW1hZ2VzL2VsYXN0aWNzZWFyY2gtc3R1ZHkvZnJhbWVPZlJlZmVyZW5jZS5wbmc?x-oss-process=image/format,png" alt="Alt text"></p>
<h2 id="压缩技巧1解读"><a href="#压缩技巧1解读" class="headerlink" title="压缩技巧1解读"></a>压缩技巧1解读</h2><p>step1：在对posting list进行压缩时进行了正序排序。<br>step2：通过增量将73后面的大数变成小数存储增量值。<br>step3:  转换成二进制，取占最大位的数，227占8位，前三个占八位，30占五位，后三个数每个占五位。</p>
<h2 id="压缩技巧2解读"><a href="#压缩技巧2解读" class="headerlink" title="压缩技巧2解读"></a>压缩技巧2解读</h2><p>从第三步可以看出，这种压缩方式仍然不够高效，所以Lucene使用的数据结构叫做Roaring Bitmap，其压缩的原理可以理解为，与其保存100个0，占用100个bit，还不如保存0一次，然后声明这个0有100个，它以两个自己可以表示的最大数65535为界，将posting list分块bloack，比如第一块block是0-65535，第二块block是65536-131071，如图:</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL05ld2F5NjY1NS9uZXdheTY2NTUuZ2l0aHViLmNvbS9tYXN0ZXIvaW1hZ2VzL2VsYXN0aWNzZWFyY2gtc3R1ZHkvUm9hcmluZ2JpdG1hcHMucG5n?x-oss-process=image/format,png" alt="Alt text"></p>
<p>step1：从小到大进行排序。<br>step2：将大数除以65536，用除得的结果和余数来表示这个大数。<br>step3:    以65535为界进行分块。<br>注意：如果一块block存储了超过了4096 个value，直接用bitset存，2个字节就用个简单的数组存放好了，比如short[]，修正一下：1KB=1024B=1024byte=8192bit，每个值一个bytes，4096*2bytes = 8192bytes，刚好达到每一个block的界限 4096 = 65536 / 2 / 8</p>
<h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><p>如何使用联合索引查询？</p>
<ul>
<li>Skip List 数据结构，同时遍历多个term的posting list，互相skip</li>
<li>使用bitset数据结构，对多个term分别求出bitset，对bitset做AND操作</li>
</ul>
<h2 id="Skip-List-跳表原理"><a href="#Skip-List-跳表原理" class="headerlink" title="Skip List 跳表原理"></a>Skip List 跳表原理</h2><p>先了解跳表需要先知道跳表应该具有以下性质：</p>
<ul>
<li>由多层有序链表组成。</li>
<li>最底层Level 1的链表包含所有的其他链表的元素。</li>
<li>如果一个元素在链表Level n中存在，那么他在Level n以下的所有链表中都存在。</li>
<li>每个节点都包含连个指针，分别指同Level链表的下一个元素和下一层的元素。</li>
</ul>
<p>这是一个有序列链表：</p>
<p><img src="https://img-blog.csdn.net/2018101116263239?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjg5Mzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>从链表中搜索（27，44，61）需要查找的次数为：2+4+6 = 12次，可以得到所有结果，这样做其实没有用到链表的有序性，我们在查询44、66时候其实都做了一些重复查找，势必会造成效率低的问题，这时候可以用Skip List算法来优化查找次数，把某些节点提取出来，将链表分成两级：</p>
<p><img src="https://img-blog.csdn.net/20181011162409919?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjg5Mzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>这样我们在查找44和61的时候次数就得到了简化，因为列表时有序的，所以当我们查到27的时候，44的大概位置就知道了，查到44的时候，61的大概位置也就知道了，避免了一部分重复查查找，这时候我们找到所以结果的次数为2+3+4 = 9次 <!--我一开始以为是2+4+5=11次，后来发现Level2和Level1的36是同一个地址，50也是同一个地址，不该算做一次查询--> ，查询61的时候似乎又对44的查找重复了一次，似乎还有优化的空间，那我们再对二级链表再进行一次分级：</p>
<p><img src="https://img-blog.csdn.net/20181011163014593?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjg5Mzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>这时候可以看到我们查找61的时候只需要从15-50-61，三次就可以查找到结果，没有去走查找44时的36，所以现在查询次数得到了再次优化，也就是2+3+3 = 8次，有人说：就优化了一次查询，需要做得这么复杂吗，能有那么大的性能优势吗？的确，这里数据量很少，组合查询的索引也只有三个，看起来确实没有优势，但是当面对PB级数据的时候，链表的分级将无限扩大大，我们在查询结果时所”跳” 的跨度也会非常大，原先需要查找一百万次的结果，可能仅仅三次就查找到了，这个时候就会显得非常高效。</p>
<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p>从Skip List的查找原理可以看出，它的高效其实是牺牲了一定的空间冗余换来的，所以在有些情况下还是使用bitset更加的直观，比如下面这种数据结构：</p>
<p>111    222    333    444<br>111    222    333    444    555    666    777<br>111    222    333    444    555    666    777    888</p>
<p>如果使用跳表，查找第一行数据在另外两行中查找看是否存在，为了得到最后得到交集的结果，操作就要繁琐的多。</p>
<p>如果使用bitset直接进行压缩，按位与，得到的结果就是最后的交集。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/08/database/elastic/elastic-%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/database/elastic/elastic-%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">elastic-安装</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-08 17:05:46" itemprop="dateCreated datePublished" datetime="2021-03-08T17:05:46+08:00">2021-03-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-14 10:22:17" itemprop="dateModified" datetime="2021-03-14T10:22:17+08:00">2021-03-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-单机安装"><a href="#Elasticsearch-单机安装" class="headerlink" title="Elasticsearch 单机安装"></a><strong>Elasticsearch</strong> 单机安装</h1><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;elasticsearch&#x2F;elasticsearch-6.6.2.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="解压缩并且修改配置文件"><a href="#解压缩并且修改配置文件" class="headerlink" title="解压缩并且修改配置文件"></a>解压缩并且修改配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf elasticsearch-6.6.2.tar.gz</span><br><span class="line"></span><br><span class="line">cd elasticsearch-6.6.2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color='red'>注意：把elasticsearch软件必须放入/home/es（es是新建用户）的目录下，并把elasticsearch设置为es用户所属</font></p>
<h2 id="修改Linux配置"><a href="#修改Linux配置" class="headerlink" title="修改Linux配置"></a>修改Linux配置</h2><h3 id="max-file-descriptors-4096-for-elasticsearch-process-is-too-low-increase-to-at-least-65536"><a href="#max-file-descriptors-4096-for-elasticsearch-process-is-too-low-increase-to-at-least-65536" class="headerlink" title="max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]"></a>max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</h3><p>每个进程最大同时打开文件数太小，可通过下面2个命令查看当前数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulimit -Hn</span><br><span class="line"></span><br><span class="line">ulimit -Sn</span><br></pre></td></tr></table></figure>

<p>修改/etc/security/limits.conf文件，增加配置，用户退出后重新登录生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line"></span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure>

<h3 id="max-number-of-threads-3818-for-user-qf-is-too-low-increase-to-at-least-4096"><a href="#max-number-of-threads-3818-for-user-qf-is-too-low-increase-to-at-least-4096" class="headerlink" title="max number of threads [3818] for user [qf] is too low, increase to at least [4096]"></a>max number of threads [3818] for user [qf] is too low, increase to at least [4096]</h3><p>可通过命令查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulimit -Hu</span><br><span class="line"></span><br><span class="line">ulimit -Su</span><br></pre></td></tr></table></figure>

<p>问题同上，最大线程个数太低。修改配置文件/etc/security/limits.conf，增加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* soft nproc 4096</span><br><span class="line"></span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure>

<h3 id="max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least-262144"><a href="#max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least-262144" class="headerlink" title="max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]"></a>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</h3><p>修改/etc/sysctl.conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line">sysctl -p #执行命令sysctl -p生效</span><br></pre></td></tr></table></figure>

<p>增加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count&#x3D;262144</span><br></pre></td></tr></table></figure>

<p>错误解决完毕：重新启动</p>
<h2 id="修改ES配置"><a href="#修改ES配置" class="headerlink" title="修改ES配置"></a>修改ES配置</h2><h3 id="创建日志、数据存储目录：（留作备用，初次先创建）"><a href="#创建日志、数据存储目录：（留作备用，初次先创建）" class="headerlink" title="创建日志、数据存储目录：（留作备用，初次先创建）"></a><strong>创建日志、数据存储目录：（留作备用，初次先创建）</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;data&#x2F;logs&#x2F;es</span><br><span class="line">mkdir -p &#x2F;data&#x2F;es&#x2F;&#123;data,work,plugins,scripts&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a><strong>创建用户</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd es -s &#x2F;bin&#x2F;bash #es不能在root用户下启动，必须创建新的用户，用来启动es</span><br></pre></td></tr></table></figure>

<p>注意：es不能在root用户下启动，必须创建新的用户，用来启动es</p>
<h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a><strong>切换用户</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su es</span><br></pre></td></tr></table></figure>

<p>再次启动，发现还是报错，原因：当前用户没有执行权限</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R es &#x2F;home&#x2F;qifei&#x2F;elasticsearch-6.2.4</span><br></pre></td></tr></table></figure>

<h3 id="允许外网访问"><a href="#允许外网访问" class="headerlink" title="允许外网访问"></a>允许外网访问</h3><p>授权成功，发现elasticsearch已经在es用户下面了，可以启动了，但是启动成功，浏览器不能访问，因此还需要做如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi confifig&#x2F;Elasticsearch.yml</span><br><span class="line"></span><br><span class="line">network.host: 0.0.0.0 #设置外网访问，默认禁止外网访问</span><br></pre></td></tr></table></figure>



<h3 id="修改ES的JVM大小"><a href="#修改ES的JVM大小" class="headerlink" title="修改ES的JVM大小"></a>修改ES的JVM大小</h3><p>vi config/jvm.options</p>
<p>-Xms1g</p>
<p>-Xmx1g</p>
<p>必须保持一样大</p>
<blockquote>
<p>* soft nofile 65536</p>
<p>* hard nofile 65536</p>
<p>* soft nproc 4096</p>
<p>* hard nproc 4096</p>
</blockquote>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>不要root启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd qf</span><br><span class="line">echo &quot;Password&quot; | passwd qf --stdin</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;elasticsearch</span><br><span class="line"></span><br><span class="line">bin&#x2F;elasticsearch -d #后台启动（守护模式）</span><br></pre></td></tr></table></figure>



<h3 id="验证环境"><a href="#验证环境" class="headerlink" title="验证环境"></a>验证环境</h3><p>not run elasticsearch as root </p>
<p>curl <a target="_blank" rel="noopener" href="http://localhost:9200/?pretty">http://localhost:9200/?pretty</a></p>
<h1 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h1><p>下载后解压到elasticsearch的plugins目录下</p>
<p>POST /_analyze { “analyzer”: “simple”, “text”: “ 我是中国人” }</p>
<h2 id="ik分词器"><a href="#ik分词器" class="headerlink" title="ik分词器"></a>ik分词器</h2><p>wget <a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v6.6.2">https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v6.6.2</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;_analyze </span><br><span class="line">&#123; </span><br><span class="line">    &quot;analyzer&quot;: &quot;ik_smart&quot;, </span><br><span class="line">    &quot;text&quot;: &quot;我是中国人 &quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pinyin分词器"><a href="#pinyin分词器" class="headerlink" title="pinyin分词器"></a>pinyin分词器</h2><p>wget <a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-pinyin/releases/tag/v6.6.2">https://github.com/medcl/elasticsearch-analysis-pinyin/releases/tag/v6.6.2</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;medcl&#x2F;_analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;text&quot;:[&quot;河南濮阳&quot;],</span><br><span class="line">    &quot;analyzer&quot;: &quot;pinyin_analyzer&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>wget <a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/kibana/kibana-6.6.2-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/kibana/kibana-6.6.2-linux-x86_64.tar.gz</a></p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi kibana-6.4.2-linux-x86_64&#x2F;config&#x2F;kibana.yml</span><br><span class="line"></span><br><span class="line">server.port: 5601 ## Kibana服务端口</span><br><span class="line"></span><br><span class="line">server.host: &quot;0.0.0.0&quot; ## Kibana服务地址</span><br><span class="line"></span><br><span class="line">elasticsearch.url: &quot;http:&#x2F;&#x2F;localhost:9200&quot; ##elasticsearch服务地址</span><br></pre></td></tr></table></figure>

<h2 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./bin/kibana</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">后台启动</span></span><br><span class="line">./bin/kibana &amp; disown </span><br></pre></td></tr></table></figure>

<h2 id="验证环境-1"><a href="#验证环境-1" class="headerlink" title="验证环境"></a>验证环境</h2><p>访问<a target="_blank" rel="noopener" href="http://192.168.199.216:5601/app/kibana">http://192.168.199.216:5601/app/kibana</a></p>
<p>如果失败，关闭防火墙</p>
<h1 id="HeadNode安装"><a href="#HeadNode安装" class="headerlink" title="HeadNode安装"></a>HeadNode安装</h1><h1 id="head插件主要用途"><a href="#head插件主要用途" class="headerlink" title="head插件主要用途"></a><strong>head</strong>插件主要用途</h1><p>elasticsearch-head是一个用来浏览、与Elastic Search簇进行交互的web前端展示插件。</p>
<p>elasticsearch-head是一个用来监控Elastic Search状态的客户端插件。</p>
<p>elasticsearch主要有以下三个主要操作——</p>
<p>1）簇浏览，显示簇的拓扑并允许你执行索引（index)和节点层面的操作。</p>
<p>2）查询接口，允许你查询簇并以原始json格式或表格的形式显示检索结果。</p>
<p>3）显示簇状态，有许多快速访问的tabs用来显示簇的状态。 </p>
<p>4）支持RestfulAPI接口，包含了许多选项产生感兴趣的结果，包括： </p>
<p>第一，请求方式:get,put,post,delete;json请求数据，节点node， 路径path。 </p>
<p>第二，JSON验证器。 </p>
<p>第三，定时请求的能力。</p>
<p>第四，用javascript表达式传输结果的能力。 </p>
<p>第五，统计一段时间的结果或该段时间结果比对的能力。</p>
<p>第六，以简单图标的形式绘制传输结果</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><p>安装步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#下载nodejs,head插件运行依赖node</span><br><span class="line">wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v9.9.0&#x2F;node-v9.9.0-linux-x64.tar.xz</span><br><span class="line"></span><br><span class="line">#解压</span><br><span class="line">tar -xf node-v9.9.0-linux-x64.tar.xz</span><br><span class="line"></span><br><span class="line">#重命名</span><br><span class="line">mv node-v9.9.0-linux-x64 nodeJs</span><br><span class="line"></span><br><span class="line">#配置文件</span><br><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">export NODE_HOME&#x3D;&#x2F;home&#x2F;coder&#x2F;server&#x2F;node- v8.12.0-linux-x64 </span><br><span class="line">export PATH&#x3D;$PATH:$NODE_HOME&#x2F;bin</span><br><span class="line"></span><br><span class="line">#刷新配置</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">#查询node版本，同时查看是否安装成功</span><br><span class="line">node -v</span><br><span class="line"></span><br><span class="line">#下载head插件</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head&#x2F;archive&#x2F;master.zip</span><br><span class="line"></span><br><span class="line">#解压</span><br><span class="line">unzip master.zip</span><br><span class="line"></span><br><span class="line">#使用淘宝的镜像库进行下载，速度很快</span><br><span class="line"></span><br><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">#进入head插件解压目录，执行安装命令</span><br><span class="line">cnpm install</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>此时未连接，需要配置才能连接：<br>修改 Gruntfile.js文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改_site/app.js：<br>修改IP地址，连接elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启用CORS: 当head插件访问es时，您必须在elasticsearch中启用CORS，否则您的浏览器将拒绝跨域。</span><br><span class="line">在elasticsearch配置中：</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">您还必须设置，http.cors.allow-origin因为默认情况下不允许跨域。http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">是允许配置的，但由于这样配置的任何地方都可以访问，所以有安全风险。</span><br><span class="line">我在集群安装的时候已经配好了、如果你刚配置、需要重启ElasticSearch服务</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">访问head插件</span><br></pre></td></tr></table></figure>



<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a><strong>运行</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start #启动head插件</span><br></pre></td></tr></table></figure>

<p>启动运行端口为：9100</p>
<p>访问：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Linux常用命令集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-07 21:07:42" itemprop="dateCreated datePublished" datetime="2021-03-07T21:07:42+08:00">2021-03-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-15 09:27:05" itemprop="dateModified" datetime="2021-04-15T09:27:05+08:00">2021-04-15</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">[-l limit] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">[[user@]host1:]file1 [...] [[user@]host2:]file2</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [可选参数] file_source file_target </span><br></pre></td></tr></table></figure>

<ul>
<li>-r： 递归复制整个目录。</li>
<li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
<li>-P port：注意是大写的P, port是指定数据传输用到的端口号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、*.tar 用 tar –xvf 解压 </span><br><span class="line">2、*.gz 用 gzip -d或者gunzip 解压 </span><br><span class="line">3、*.tar.gz和*.tgz 用 tar –xzf 解压 </span><br><span class="line">4、*.bz2 用 bzip2 -d或者用bunzip2 解压 </span><br><span class="line">5、*.tar.bz2用tar –xjf 解压 </span><br><span class="line">6、*.Z 用 uncompress 解压 </span><br><span class="line">7、*.tar.Z 用tar –xZf 解压 </span><br><span class="line">8、*.rar 用 unrar e解压 </span><br><span class="line">9、*.zip 用 unzip 解压</span><br></pre></td></tr></table></figure>

<h2 id="unzip解压zip文件"><a href="#unzip解压zip文件" class="headerlink" title="unzip解压zip文件"></a>unzip解压zip文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip [-cflptuvz][-agCjLMnoqsVX][-P &lt;密码&gt;][.zip文件][文件][-d &lt;目录&gt;][-x &lt;文件&gt;] 或 unzip [-Z]</span><br></pre></td></tr></table></figure>

<ul>
<li>-d&lt;目录&gt; 指定文件解压缩后所要存储的目录。</li>
</ul>
<h2 id="tar解压-gz、tar、bz2"><a href="#tar解压-gz、tar、bz2" class="headerlink" title="tar解压.gz、tar、bz2"></a>tar解压.gz、tar、bz2</h2><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c: 建立压缩档案 </span><br><span class="line">-x：解压 </span><br><span class="line">-t：查看内容 </span><br><span class="line">-r：向压缩归档文件末尾追加文件 </span><br><span class="line">-u：更新原压缩包中的文件</span><br></pre></td></tr></table></figure>

<p>下面的参数是根据需要在压缩或解压档案时可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-z：有gzip属性的 </span><br><span class="line">-j：有bz2属性的 </span><br><span class="line">-Z：有compress属性的 </span><br><span class="line">-v：显示所有过程 </span><br><span class="line">-O：将文件解开到标准输出</span><br></pre></td></tr></table></figure>

<p>下面的参数 -f 是必须的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 </span><br></pre></td></tr></table></figure>



<h1 id="文件夹命令"><a href="#文件夹命令" class="headerlink" title="文件夹命令"></a>文件夹命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-p] dirName</span><br><span class="line"></span><br><span class="line">mkdir -p &#x2F;data&#x2F;qifei&#x2F;&#123;data,work,plugins,scripts&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>-p 确保目录名称存在，不存在的就建一个。</li>
</ul>
<h1 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h1><h2 id="查看压缩日志文件命令zcat"><a href="#查看压缩日志文件命令zcat" class="headerlink" title="查看压缩日志文件命令zcat"></a>查看压缩日志文件命令zcat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看gz类型的压缩日志</span><br><span class="line">gunzip -c service.log.gz | less</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/04/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/rpc/dubbo/dubbo-01-%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/04/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/rpc/dubbo/dubbo-01-%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">dubbo-01-入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-04 09:53:30" itemprop="dateCreated datePublished" datetime="2021-03-04T09:53:30+08:00">2021-03-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-07 10:23:06" itemprop="dateModified" datetime="2021-03-07T10:23:06+08:00">2021-03-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Dubbo概述"><a href="#Dubbo概述" class="headerlink" title="Dubbo概述"></a>Dubbo概述</h1><h2 id="什么是-PRC"><a href="#什么是-PRC" class="headerlink" title="什么是 PRC?"></a>什么是 <strong>PRC</strong>?</h2><p>RPC(Remote Procedure Call Protocol)——远程过程调用协议，它是一种通过网络从远 程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 协议假定某些传输协议 的存在，如 TCP 或 UDP，为通信程序之间携带信息数据。在 OSI 网络通信模型(OSI 七层网 络模型，OSI，Open System Interconnection，开放系统互联)中，RPC 跨越了传输层和应用 层。RPC 使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<p>RPC 采用客户机/服务器模式(即 C/S 模式)。请求程序就是一个客户机，而服务提供程 序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然 后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息 到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后， 客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p>
<h2 id="Dubbo-四大组件"><a href="#Dubbo-四大组件" class="headerlink" title="Dubbo 四大组件"></a><strong>Dubbo</strong> 四大组件</h2><p>Dubbo 中存在四大组件:</p>
<ul>
<li><p><strong>Provider</strong>:服务提供者。</p>
</li>
<li><p><strong>Consumer</strong>:服务消费者。<font color="red">会从Registry下载Provider注册列表，负载均衡、限流等操作，都是Consumer自己根据这个注册列表中的Provider进行操作。</font></p>
</li>
<li><p><strong>Registry</strong>:服务注册与发现的中心，提供目录服务，亦称为服务注册中心</p>
</li>
<li><p><strong>Monitor</strong>:统计服务的调用次数、调用时间等信息的日志服务，并可以对服务设置权限、降级处理等，称为服务管控中心</p>
</li>
</ul>
<h1 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h1><p>注意：业务接口已经打成jar包，消费者和生产者直接导入jar包即可。</p>
<h2 id="直连方式"><a href="#直连方式" class="headerlink" title="直连方式"></a>直连方式</h2><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><ul>
<li><p>pom依赖</p>
<ul>
<li><p>业务接口依赖</p>
</li>
<li><p>Dubbo 依赖(2.7.0 版本) </p>
</li>
<li><p>Spring 依赖(4.3.16 版本)</p>
</li>
<li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.abc&lt;/groupId&gt;
    &lt;artifactId&gt;01-consumer&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
        &lt;!-- 自定义版本号 --&gt;
        &lt;spring-version&gt;4.3.16.RELEASE&lt;/spring-version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!--业务接口工程依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.abc&lt;/groupId&gt;
            &lt;artifactId&gt;00-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- dubbo依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
            &lt;version&gt;2.7.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- Spring依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- commons-logging依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-logging&lt;/groupId&gt;
            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 配置文件： src&#x2F;main&#x2F;resources 下定义 spring-consumer.xml 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">           xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&quot;</span><br><span class="line">           xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定当前工程在管控平台中的名称--&gt;</span><br><span class="line">        &lt;dubbo:application name&#x3D;&quot;01-consumer&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定注册中心：不使用注册中心--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;N&#x2F;A&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--直连式连接提供者--&gt;</span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;someService&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                         url&#x3D;&quot;dubbo:&#x2F;&#x2F;localhost:20880&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>main：作为测试类</p>
<ul>
<li><pre><code class="java">public class ConsumerRun &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
        SomeService service = (SomeService) ac.getBean(&quot;someService&quot;);
        String hello = service.hello(&quot;China&quot;);
        System.out.println(hello);
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### 生产者</span><br><span class="line"></span><br><span class="line">- pom依赖</span><br><span class="line"></span><br><span class="line">  -  业务接口依赖</span><br><span class="line">  - Dubbo 依赖(2.7.0 版本) </span><br><span class="line">  - Spring 依赖(4.3.16 版本)</span><br><span class="line"></span><br><span class="line">- 定义接口实现类（略）</span><br><span class="line"></span><br><span class="line">- 配置文件： src&#x2F;main&#x2F;resources 下定义 spring-provider.xml 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">           xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&quot;</span><br><span class="line">           xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定当前工程在管控平台中的名称--&gt;</span><br><span class="line">        &lt;dubbo:application name&#x3D;&quot;01-provider&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定注册中心：不使用注册中心--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;N&#x2F;A&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--注册业务接口实现类，它是真正的服务提供者--&gt;</span><br><span class="line">        &lt;bean id&#x3D;&quot;someService&quot; class&#x3D;&quot;com.abc.provider.SomeServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--服务暴露--&gt;</span><br><span class="line">        &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                       ref&#x3D;&quot;someService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>main: 启动类</p>
<ul>
<li><pre><code class="java">    public static void main(String[] args) throws IOException &#123;
        // 创建Spring容器
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-provider.xml&quot;);
        // 启动Spring容器
        ((ClassPathXmlApplicationContext) ac).start();
        // 使主线程阻塞
        System.in.read();
    &#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **Zookeeper** **注册中心**</span><br><span class="line"></span><br><span class="line">### 消费者</span><br><span class="line"></span><br><span class="line">- 导入依赖</span><br><span class="line">  </span><br><span class="line">- 复制前面的提供者工程 01-provider，并更名为 02-provider-zk。修改 pom 文件，并在其中导入 Zookeeper 客户端依赖 curator。</span><br><span class="line">  </span><br><span class="line">- 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:application name&#x3D;&quot;02-consumer-zk&quot;&gt;</span><br><span class="line">            &lt;dubbo:parameter key&#x3D;&quot;qos.port&quot; value&#x3D;&quot;33333&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;dubbo:application&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定服务注册中心：zk单机--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定服务注册中心：zk集群--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS1:2181?backup&#x3D;zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS1:2181,zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;someService&quot; check&#x3D;&quot;false&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ul>
<li><p>导入依赖</p>
<ul>
<li><p>复制前面的提供者工程 01-provider，并更名为 02-provider-zk。修改 pom 文件，并在其中导入 Zookeeper 客户端依赖 curator。</p>
</li>
<li><pre><code class="java"> &lt;!-- zk客户端依赖：curator --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
            &lt;version&gt;2.13.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
            &lt;version&gt;2.13.0&lt;/version&gt;
        &lt;/dependency&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">      &lt;dubbo:application name&#x3D;&quot;02-provider-zk&quot;&#x2F;&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;!--声明注册中心：单机版zk--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;!--声明注册中心：zk群集--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS1:2181?backup&#x3D;zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS1:2181,zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;bean id&#x3D;&quot;someService&quot; class&#x3D;&quot;com.abc.provider.SomeServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                ref&#x3D;&quot;someService&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>zk集群 + 不同协议</p>
<ul>
<li><pre><code class="xml">    &lt;dubbo:application name=&quot;02-provider-zk&quot; /&gt;

    &lt;!--声明注册中心：单机版zk--&gt;
    &lt;dubbo:registry address=&quot;zookeeper://zkOS:2181&quot;/&gt;
    &lt;!--&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;zkOS:2181&quot;/&gt;--&gt;

    &lt;!--声明注册中心：zk群集--&gt;
    &lt;!--&lt;dubbo:registry address=&quot;zookeeper://zkOS1:2181?backup=zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;/&gt;--&gt;
    &lt;!--&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;zkOS1:2181,zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;/&gt;--&gt;

    &lt;bean id=&quot;someService&quot; class=&quot;com.abc.provider.SomeServiceImpl&quot;/&gt;

    &lt;dubbo:protocol id=&quot;dp&quot; name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;
    &lt;dubbo:protocol id=&quot;dp2&quot; name=&quot;dubbo&quot; port=&quot;20881&quot;/&gt;
    &lt;dubbo:protocol id=&quot;rp&quot; name=&quot;rmi&quot; port=&quot;9411&quot;/&gt;

    &lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; protocol=&quot;dp,dp2&quot;/&gt;

    &lt;dubbo:provider id=&quot;xxx&quot; timeout=&quot;2000&quot; protocol=&quot;dp&quot; default=&quot;true&quot;/&gt;
    &lt;dubbo:provider id=&quot;ooo&quot; delay=&quot;2000&quot; protocol=&quot;dp2&quot; default=&quot;true&quot;/&gt;
    &lt;dubbo:provider id=&quot;jjj&quot;  /&gt;
    &lt;dubbo:provider id=&quot;kkk&quot;  /&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">- 添加日志</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;properties</span><br><span class="line">    log4j.appender.console&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">    log4j.appender.console.Target&#x3D;System.out</span><br><span class="line">    log4j.appender.console.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">    log4j.appender.console.layout.ConversionPattern&#x3D;[%-5p] %m%n</span><br><span class="line">    log4j.rootLogger&#x3D;info,console</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="将-Dubbo-应用到-web-工程"><a href="#将-Dubbo-应用到-web-工程" class="headerlink" title="将 Dubbo 应用到 web 工程"></a><strong>将</strong> <strong>Dubbo</strong> <strong>应用到</strong> <strong>web</strong> <strong>工程</strong></h2><p>前面所有提供者与消费者均是 Java 工程，而在生产环境中，它们都应是 web 工程，Dubbo如何应用于 Web 工程中呢？</p>
<h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><ul>
<li><p>pom依赖</p>
<ul>
<li><p> dubbo2.7.0 版本依赖</p>
<p> zk 客户端 curator 依赖</p>
<p> servlet 与 jsp 依赖</p>
<p> spring 相关依赖</p>
<p> spring 需要的 commons-logging 依赖</p>
<p> 自定义 00-api 依赖</p>
</li>
<li><pre><code class="xml">&lt;!-- Servlet 依赖 --&gt; 
&lt;dependency&gt; 
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; 
    &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- JSP 依赖 --&gt; 
&lt;dependency&gt; 
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; 
    &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; 
    &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **定义** **web.xml**</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">             xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">             xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_1.xsd&quot;</span><br><span class="line">             version&#x3D;&quot;3.1&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--注册Spring配置文件--&gt;</span><br><span class="line">        &lt;context-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:spring-*.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;context-param&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--注册ServletContext监听器--&gt;</span><br><span class="line">        &lt;listener&gt;</span><br><span class="line">            &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">        &lt;&#x2F;listener&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>修改</strong> <strong>spring-provider.xml</strong>：略</p>
</li>
</ul>
<h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><ul>
<li><p>pom依赖</p>
<ul>
<li><p> dubbo2.7.0 版本依赖</p>
<p> zk 客户端 curator 依赖</p>
<p> servlet 与 jsp 依赖</p>
<p> spring 相关依赖</p>
<p> spring 需要的 commons-logging 依赖</p>
<p> 自定义 00-api 依赖</p>
</li>
</ul>
</li>
<li><p><strong>定义</strong> <strong>web.xml</strong></p>
<ul>
<li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

    &lt;!--对于2.6.4版本，其Spring配置文件必须指定从&lt;context-param&gt;中加载--&gt;
    &lt;!--&lt;context-param&gt;--&gt;
        &lt;!--&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;--&gt;
        &lt;!--&lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;--&gt;
    &lt;!--&lt;/context-param&gt;--&gt;

    &lt;!--字符编码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!--注册中央调度器--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--不能写/*，不建议写/，建议扩展名方式--&gt;
        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **修改** **spring-consumer.xml**：略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># **Dubbo** **管理控制台**</span><br><span class="line"></span><br><span class="line">2019 年初，官方发布了 Dubbo 管理控制台 0.1 版本。结构上采取了前后端分离的方式，前端使用 Vue 和 Vuetify 分别作为 Javascript 框架和 UI 框架，后端采用 Spring Boot 框架。</span><br><span class="line"></span><br><span class="line"> **下载**</span><br><span class="line"></span><br><span class="line">Dubbo 管理控制台的下载地址为：https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;incubator-dubbo-ops</span><br><span class="line"></span><br><span class="line">**配置**</span><br><span class="line"></span><br><span class="line">在下载的 zip 文件的解压目录的 dubbo-admin-server\src\main\resources 下，修改配置文件 application.properties。主要就是修改注册中心、配置中心，与元数据中心的 zk 地址。这是一个 springboot 工程，默认端口号为 8080，若要修改端口号，则在配置文件中增加形如 server.port&#x3D;8888 的配置。</span><br><span class="line"></span><br><span class="line">**打包**</span><br><span class="line"></span><br><span class="line">在命令行窗口中进入到解压目录根目录，执行打包命令。mvn clean package。</span><br><span class="line"></span><br><span class="line">打包结束后，进入到解压目录下的 dubbo-admin-distribution 目录下的 target 目录。目录下有个 dubbo-admin-0.1.jar 文件。该 Jar 包文件即为 Dubbo 管理控制台的运行文件，可以将其放到任意目录下运行。</span><br><span class="line"></span><br><span class="line">**启动zk**</span><br><span class="line"></span><br><span class="line">**启动管控台**</span><br><span class="line"></span><br><span class="line">将 dubbo-admin-0.1.jar 文件存放到任意目录下，例如 D 盘根目录下，直接运行。</span><br><span class="line"></span><br><span class="line">**访问**</span><br><span class="line"></span><br><span class="line">在浏览器地址栏中输入 http:&#x2F;&#x2F;localhost:8080 ，即可看到 Dubbo 管理控制台界面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># **Dubbo** **高级配置**</span><br><span class="line"></span><br><span class="line">&gt; 注意：consumer是从Registry获取provider注册表，所以consumer端也可以设置负载均衡等配置，从而覆盖从Registry获取的注册表</span><br><span class="line">&gt;</span><br><span class="line">&gt; | interface + version + group | provider host | 负载均衡设置 | 请求次数 |</span><br><span class="line">&gt; | --------------------------- | ------------- | ------------ | -------- |</span><br><span class="line">&gt; | someService, 1.00, beijing  | h1, h2,h3     | random       | 3        |</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 关闭服务检查</span><br><span class="line"></span><br><span class="line">默认情况下，若服务消费者先于服务提供者启动，则消费者端会报错。因为默认情况下消费者会在启动时查检其要消费的服务的提供者是否已经注册，若未注册则抛出异常。可以在消费者端的 spring 配置文件中添加 check&#x3D;”false”属性，则可关闭服务检查功能。</span><br><span class="line"></span><br><span class="line">## **多版本控制**</span><br><span class="line"></span><br><span class="line">消费者和生产者都要同步改</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&lt;dubbo:application name=&quot;04-consumer-version&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>&lt;dubbo:registry address=”zookeeper://zkOS:2181” /&gt;</p>
<!--指定消费0.0.1版本，即oldService提供者-->
<!--<dubbo:reference id="someService"  version="0.0.1"-->
<pre><code>             &lt;!--interface=&quot;com.abc.service.SomeService&quot;/&gt;--&gt;</code></pre>
<!--指定消费0.0.2版本，即newService提供者-->
<p>&lt;dubbo:reference id=”someService”  version=”0.0.2”<br>                 interface=”com.abc.service.SomeService”/&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## **服务分组**</span><br><span class="line"></span><br><span class="line">服务分组与多版本控制的使用方式几乎是相同的，只要将 version 替换为 group 即可。</span><br><span class="line"></span><br><span class="line">但使用目的不同。使用版本控制的目的是为了升级，将原有老版本替换掉，将来不再提供老版本的服务，所以不同版本间不能出现相互调用。而分组的目的则不同，其也是针对相同接口，给出了多种实现类。但不同的是，这些不同实现并没有谁替换掉谁的意思，是针对不同需求，或针对不同功能模块所给出的不同实现。这些实现所提供的服务是并存的，所以它们间可以出现相互调用关系。例如，对于支付服务的实现，可以有微信支付实现与支付宝支付实现等。</span><br><span class="line"></span><br><span class="line">## **同一服务支持多种协议**</span><br><span class="line"></span><br><span class="line">这里需要理解这个服务暴露协议的意义。其是指出，消费者若要连接当前的服务，就需要通过这里指定的协议及端口号进行访问。这里的端口号可以是任意的，不一定非要使用默认的端口号（Dubbo 默认为 20880，rmi 默认为 1099）。这里指定的协议名称及端口号，在当前服务注册到注册中心时会一并写入到服务映射表中。当消费者根据服务名称查找到相应主机时，其同时会查询出消费此服务的协议、端口号等信息。其底层就是一个 Socket 编程，通过主机名与端口号进行连接。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:application name&#x3D;&quot;05-provider-group&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dubbo:protocal name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20880&quot;&#x2F;&gt;</span><br><span class="line">	&lt;dubbo:protocal name&#x3D;&quot;rmi&quot; port&#x3D;&quot;1099&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册Service实现类--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;weixinService&quot; class&#x3D;&quot;com.abc.provider.WeixinServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;zhifubaoService&quot; class&#x3D;&quot;com.abc.provider.ZhifubaoServiceImpl&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--暴露服务--&gt;</span><br><span class="line">    &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                   ref&#x3D;&quot;weixinService&quot; group&#x3D;&quot;pay.weixin&quot; protocal&#x3D;&quot;dubbo,rmi&quot;&#x2F;&gt;</span><br><span class="line">    &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                   ref&#x3D;&quot;zhifubaoService&quot; group&#x3D;&quot;pay.zhifubao&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="不同服务使用不同协议"><a href="#不同服务使用不同协议" class="headerlink" title="不同服务使用不同协议"></a><strong>不同服务使用不同协议</strong></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;05-provider-group&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://zkOS:2181&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocal</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocal</span> <span class="attr">name</span>=<span class="string">&quot;rmi&quot;</span> <span class="attr">port</span>=<span class="string">&quot;1099&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--注册Service实现类--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.abc.provider.WeixinServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;zhifubaoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.abc.provider.ZhifubaoServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--暴露服务--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">ref</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.weixin&quot;</span> <span class="attr">protocal</span>=<span class="string">&quot;rmi&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">ref</span>=<span class="string">&quot;zhifubaoService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.zhifubao&quot;</span> <span class="attr">protocal</span>=<span class="string">&quot;dubbo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h2><p>Dubbo 内置了四种负载均衡算法。</p>
<ul>
<li>random</li>
</ul>
<p>随机算法，是 Dubbo 默认的负载均衡算法。存在服务堆积问题。</p>
<ul>
<li><strong>roundrobin</strong></li>
</ul>
<p>轮询算法。按照设定好的权重依次进行调度。</p>
<ul>
<li><strong>leastactive</strong> </li>
</ul>
<p>最少活跃度调度算法。即被调度的次数越少，其优选级就越高，被调度到的机率就越高。</p>
<ul>
<li>consistent hash</li>
</ul>
<p>一致性 hash 算法。对于相同参数的请求，其会被路由到相同的提供者。</p>
<h3 id="消费者端指定"><a href="#消费者端指定" class="headerlink" title="消费者端指定"></a><strong>消费者端指定</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--暴露服务--&gt;</span><br><span class="line">&lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">               ref&#x3D;&quot;weixinService&quot; group&#x3D;&quot;pay.weixin&quot; protocal&#x3D;&quot;rmi&quot; loadBalance&#x3D;&quot;random&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="服务端指定"><a href="#服务端指定" class="headerlink" title="服务端指定"></a>服务端指定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--暴露服务--&gt;</span><br><span class="line">&lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">               ref&#x3D;&quot;weixinService&quot; group&#x3D;&quot;pay.weixin&quot; protocal&#x3D;&quot;rmi&quot; loadBalance&#x3D;&quot;random&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="集群容错策略与重试次数"><a href="#集群容错策略与重试次数" class="headerlink" title="集群容错策略与重试次数"></a><strong>集群容错策略与重试次数</strong></h2><p>集群容错指的是，当消费者调用提供者集群时发生异常的处理方案。</p>
<p>Dubbo 内置了 6 种集群容错策略。</p>
<p> <strong>Failover</strong> </p>
<p>故障转移策略。当消费者调用提供者集群中的某个服务器失败时，其会自动尝试着调用</p>
<p>其它服务器。该策略通常用于读操作，例如，消费者要通过提供者从 DB 中读取某数据。但</p>
<p>重试会带来服务延迟。</p>
<p> <strong>Failfast</strong> </p>
<p>快速失败策略。消费者端只发起一次调用，若失败则立即报错。通常用于非幂等性的写</p>
<p>操作，比如新增记录。</p>
<p>幂等：在请求参数相同的前提下，请求一次与请求 n 次，对系统产生的影响是相同的。</p>
<p> GET：幂等</p>
<p> POST：非幂等</p>
<p> PUT：幂等</p>
<p> DELETE：幂等</p>
<p><strong>Failsafe</strong> </p>
<p>失败安全策略。当消费者调用提供者出现异常时，直接忽略本次消费操作。该策略通常用于执行相对不太重要的服务，例如，写入审计日志等操作。</p>
<p> <strong>Failback</strong> </p>
<p>失败自动恢复策略。消费者调用提供者失败后，Dubbo 会记录下该失败请求，然后定时</p>
<p>自动重新发送该请求。该策略通常用于实时性要求不太高的服务，例如消息通知操作。</p>
<p><strong>Forking</strong> </p>
<p>并行策略。消费者对于同一服务并行调用多个提供者服务器，只要一个成功即调用结束</p>
<p>并返回结果。通常用于实时性要求较高的读操作，但其会浪费较多服务器资源。</p>
<p><strong>Broadcast</strong> </p>
<p>广播策略。广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有</p>
<p>提供者更新缓存或日志等本地资源信息。</p>
<h3 id="消费者端指定-1"><a href="#消费者端指定-1" class="headerlink" title="消费者端指定"></a><strong>消费者端指定</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--暴露服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:ref</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">ref</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.weixin&quot;</span> <span class="attr">cluster</span>=<span class="string">&quot;failfast&quot;</span> <span class="attr">reties</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务端指定-1"><a href="#服务端指定-1" class="headerlink" title="服务端指定"></a>服务端指定</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--暴露服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">ref</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.weixin&quot;</span> <span class="attr">cluster</span>=<span class="string">&quot;failfast&quot;</span> <span class="attr">reties</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="服务降级基础（面试题）"><a href="#服务降级基础（面试题）" class="headerlink" title="服务降级基础（面试题）"></a><strong>服务降级基础（面试题）</strong></h2><p> <strong>什么是服务降级</strong></p>
<p>服务降级，当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务有策略的降低服务级别，以释放服务器资源，保证核心任务的正常运行。</p>
<p><strong>服务降级方式</strong></p>
<p>能够实现服务降级方式很多，常见的有如下几种情况：</p>
<p> 部分服务暂停    </p>
<p> 全部服务暂停</p>
<p> 随机拒绝服务</p>
<p> 部分服务延迟</p>
<p><strong>服务降级与</strong> <strong>Mock</strong> <strong>机制</strong></p>
<p>Dubbo的服务降级采用的是mock机制。其具有两种降级处理方式：Mock Null降级处理，与 Mock Class 降级处理。</p>
<h3 id="Mock-Null降级处理"><a href="#Mock-Null降级处理" class="headerlink" title="Mock Null降级处理"></a>Mock Null降级处理</h3><p>只需要修改服务端</p>
<ul>
<li><p><strong>修改</strong> <strong>pom</strong> <strong>文件</strong>：由于这里不再需要 00-api 工程了，所以在 pom 文件中将对 00-api 工程的依赖删除即可。改为消费者和提供者在自己的项目中保留一份相同的接口</p>
<ul>
<li><pre><code class="java">//consumer自己保留的接口，provider也是如此
package com.abc.service;

public interface UserService &#123;
    String getUsernameById(int id);
    void addUser(String username);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- **修改** **spring-consumer.xml**: mock&#x3D;&quot;return null&quot;</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;userService&quot; mock&#x3D;&quot;return null&quot; check&#x3D;&quot;false&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.UserService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>修改消费者启动类</strong></p>
<ul>
<li><pre><code class="java">public static void main(String[] args) &#123;
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
    UserService service = (UserService) ac.getBean(&quot;userService&quot;);

    // 对于有返回值的方法，其返回结果为null
    String username = service.getUsernameById(3);
    System.out.println(&quot;username = &quot; + username);
    // 对于没有返回值的方法，其没有任何结果
    service.addUser(&quot;China&quot;);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### Mock Class 降级处理</span><br><span class="line"></span><br><span class="line">降级都是指的调用端(consumer)，所以是consumer需要修改</span><br><span class="line"></span><br><span class="line">- **定义** **Mock Class**</span><br><span class="line"></span><br><span class="line">  - 在业务接口所在的包中，本例为 com.abc.service 包，定义一个类，该类的命名需要满足以下规则：业务接口简单类名 + Mock</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    package com.abc.service;</span><br><span class="line">    </span><br><span class="line">    public class UserServiceMock implements UserService &#123;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public String getUsernameById(int id) &#123;</span><br><span class="line">            return &quot;没有该用户：&quot; + id;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public void addUser(String username) &#123;</span><br><span class="line">            System.out.println(&quot;添加该用户失败：&quot; + username);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>修改</strong> <strong>spring-consumer.xml</strong>: mock=”true”</p>
<ul>
<li><pre><code class="xml">    &lt;dubbo:reference id=&quot;userService&quot; mock=&quot;true&quot; check=&quot;false&quot;
                     interface=&quot;com.abc.service.UserService&quot;/&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **服务调用超时**</span><br><span class="line"></span><br><span class="line">前面的服务降级的发生，其实是由于消费者调用服务超时引起的，即从发出调用请求到获取到提供者的响应结果这个时间超出了设定的时限。默认服务调用超时时限为 1 秒。可以在消费者端与提供者端设置超时时限。</span><br><span class="line"></span><br><span class="line">### 生产者</span><br><span class="line"></span><br><span class="line">- **修改依赖**：由于这里不再需要 00-api 工程了，所以在 pom 文件中将对 00-api 工程的依赖删除即可。因为provider and consumer share the same interface in their responding projecct.</span><br><span class="line">- **定义接口实现类**</span><br><span class="line">  - 在 com.abc.provider 包中定义接口的实现类。该实现类中的业务方法添加一个 2 秒的Sleep，以延长向消费者返回结果的时间。</span><br><span class="line"></span><br><span class="line">### 消费者</span><br><span class="line"></span><br><span class="line">- 配置类：timeout&#x3D;&quot;2000&quot;</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;userService&quot; mock&#x3D;&quot;true&quot; timeout&#x3D;&quot;2000&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.UserService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h2><blockquote>
<ul>
<li><p><strong>直接限流</strong></p>
<ul>
<li><p>*executes** <strong>限流</strong> <strong>–</strong> <strong>仅提供者端</strong></p>
<ul>
<li><p>该属性仅能设置在提供者端。可以设置为接口级别，也可以设置为方法级别。限制的是服务（方法）并发执行数量。execute=”10”</p>
</li>
<li><pre><code>    &lt;dubbo:reference ref=&quot;userService&quot;  execute=&quot;10&quot;
                     interface=&quot;com.abc.service.UserService&quot;/&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **accepts** **限流** **–** **仅提供者端**</span><br><span class="line"></span><br><span class="line">  - 该属性仅可设置在提供者端的&lt;dubbo:provider&#x2F;&gt;与&lt;dubbo:protocol&#x2F;&gt;。用于对指定协议的连接数量进行限制。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    限制当前提供者在使用dubbo协议时最多接受10个消费者链接</span><br><span class="line">    &lt;dubbo:provider protocal&#x3D;&quot;dubbo&quot; accepts&#x3D;10&gt;&lt;&#x2F;dubbo:provider&gt;</span><br><span class="line">    </span><br><span class="line">    限制当前提供者在使用dubbo协议时最多接受10个消费者链接</span><br><span class="line">    &lt;dubbo:protocal name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20880&quot; accepts&#x3D;10&gt;&lt;&#x2F;dubbo:protocal&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>actives</strong> <strong>限流</strong> <strong>–</strong> <strong>两端</strong></p>
<ul>
<li><p>该限流方式与前两种不同的是，其可以设置在提供者端，也可以设置在消费者端。可以设置为接口级别，也可以设置为方法级别。</p>
</li>
<li><p><strong>提供者端限流</strong></p>
<p>根据消费者与提供者间建立的连接类型的不同，其意义也不同：</p>
<p> 长连接：表示当前长连接最多可以处理的请求个数。与长连接的数量没有关系。</p>
<p> 短连接：表示当前服务可以同时处理的短连接数量。</p>
<ul>
<li><pre><code class="xml">&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot; actives=&quot;10&quot;/&gt;

&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot;&gt;
    &lt;dubbo:method name=&quot;hello&quot; actives=&quot;10&quot;&gt;&lt;/dubbo:method&gt;
&lt;/dubbo:service&gt;

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **消费者端限流**</span><br><span class="line"></span><br><span class="line">  根据消费者与提供者间建立的连接类型的不同，其意义也不同：</span><br><span class="line"></span><br><span class="line">   长连接：表示当前消费者所发出的长连接中最多可以提交的请求个数。与长连接的数量没有关系。</span><br><span class="line"></span><br><span class="line">   短连接：表示当前消费者可以提交的短连接数量。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot; actives&#x3D;&quot;10&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot;&gt;</span><br><span class="line">    	&lt;dubbo:method name&#x3D;&quot;hello&quot; actives&#x3D;&quot;10&quot;&gt;&lt;&#x2F;dubbo:method&gt;</span><br><span class="line">    &lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>connections</strong> <strong>限流 - 两端</strong> </p>
<ul>
<li><p>可以设置在提供者端，也可以设置在消费者端。限定连接的个数。对于短连接，该属性效果与 actives 相同。但对于长连接，其限制的是长连接的个数。一般情况下，我们会使 connectons 与 actives 联用，让 connections 限制长连接个数，让actives 限制一个长连接中可以处理的请求个数。联用前提：使用默认的 Dubbo 服务暴露协议。</p>
</li>
<li><p><strong>提供者端限流</strong></p>
<ul>
<li><pre><code class="xml">&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot; connections=&quot;10&quot;/&gt;

&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot;&gt;
    &lt;dubbo:method name=&quot;hello&quot; connections=&quot;10&quot;&gt;&lt;/dubbo:method&gt;
&lt;/dubbo:service&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **消费者端限流**</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot; connections&#x3D;&quot;10&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot;&gt;</span><br><span class="line">    	&lt;dubbo:method name&#x3D;&quot;hello&quot; connections&#x3D;&quot;10&quot;&gt;&lt;&#x2F;dubbo:method&gt;</span><br><span class="line">    &lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>间接限流</strong></p>
<ul>
<li><p><strong>延迟连接 **– **仅消费者端</strong></p>
<ul>
<li><p>仅可设置在消费者端，且不能设置为方法级别。仅作用于 Dubbo 服务暴露协议。将长连接的建立推迟到消费者真正调用提供者时。可以减少长连接的数量。</p>
</li>
<li><pre><code class="xml">//消费者端该接口的所有方法都是延迟建立连接
&lt;dubbo:ref interface=&quot;com.abc.service.SomeService&quot; id=&quot;someService&quot; lazy=&quot;true&quot;/&gt;

//消费者端所有接口的所有方法都是延迟建立连接
&lt;dubbo:consumer lazy=&quot;true&quot;&gt;&lt;/dubbo:consumer&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **粘连连接** **–** **仅消费者**</span><br><span class="line"></span><br><span class="line">  - 仅能设置在消费者端，其可以设置为接口级别，也可以设置为方法级别。仅作用于Dubbo 服务暴露协议。其会使客户端尽量向同一个提供者发起调用，除非该提供者挂了，其会连接另一台。只要启用了粘连连接，其就会自动启用延迟连接。其限制的是流向，而非流量。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot; sticky&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot;&gt;</span><br><span class="line">    	&lt;dubbo:method name&#x3D;&quot;hello&quot; connections&#x3D;&quot;10&quot; sticky&#x3D;&quot;true&quot;&gt;&lt;&#x2F;dubbo:method&gt;</span><br><span class="line">    &lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>负载均衡 - 双端</strong></p>
<ul>
<li><p>可以设置在消费者端，亦可设置在提供者端；可以设置在接口级别，亦可设置在方法级别。其限制的是流向，而非流量。</p>
</li>
<li><pre><code>loadBalance=&quot;leastactive&quot;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">## **声明式缓存** - 仅消费者</span><br><span class="line"></span><br><span class="line">为了进一步提高消费者对用户的响应速度，减轻提供者的压力，Dubbo 提供了基于结果的声明式缓存。该缓存是基于消费者端的，所以使用很简单，只需修改消费者配置文件，与提供者无关。</span><br><span class="line"></span><br><span class="line">- **修改消费者配置文件**：仅需在&lt;dubbo:reference&#x2F;&gt;中添加 cache&#x3D;”true”属性即可。</span><br><span class="line">- **默认缓存** **1000** **个结果**: 声明式缓存中可以缓存多少个结果呢？默认可以缓存 1000 个结果。若超出 1000，将采用 LRU 策略来删除缓存，以保证最热的数据被缓存。注意，该删除缓存的策略不能修改。</span><br><span class="line">- **应用场景**: 应用于查询结果不会发生改变的情况，例如，查询某产品的序列号、订单、身份证号等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 多注册中心</span><br><span class="line"></span><br><span class="line">- 消费者</span><br><span class="line"></span><br><span class="line"> - 配置文件</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;xml</span><br><span class="line">         &lt;!--声明注册中心--&gt;</span><br><span class="line">         &lt;dubbo:registry id&#x3D;&quot;bjCenter&quot; address&#x3D;&quot;zookeeper:&#x2F;&#x2F;bjZK:2181&quot;&#x2F;&gt;</span><br><span class="line">         &lt;dubbo:registry id&#x3D;&quot;gzCenter&quot; address&#x3D;&quot;zookeeper:&#x2F;&#x2F;gzZK:2181&quot;&#x2F;&gt;</span><br><span class="line">         &lt;dubbo:registry id&#x3D;&quot;cqCenter&quot; address&#x3D;&quot;zookeeper:&#x2F;&#x2F;cqZK:2181&quot;&#x2F;&gt;</span><br><span class="line">     </span><br><span class="line">         &lt;!--指定调用bjCenter注册中心微信服务--&gt;</span><br><span class="line">         &lt;dubbo:reference id&#x3D;&quot;weixin&quot;  group&#x3D;&quot;pay.weixin&quot; registry&#x3D;&quot;bjCenter&quot;</span><br><span class="line">                          interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br><span class="line">     </span><br><span class="line">         &lt;!--指定调用gzCenter与cqCenter注册中心支付宝服务--&gt;</span><br><span class="line">         &lt;dubbo:reference id&#x3D;&quot;gzZhifubao&quot;  group&#x3D;&quot;pay.zhifubao&quot; registry&#x3D;&quot;gzCenter&quot;</span><br><span class="line">                          interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br><span class="line">         &lt;dubbo:reference id&#x3D;&quot;cqZhifubao&quot;  group&#x3D;&quot;pay.zhifubao&quot; registry&#x3D;&quot;cqCenter&quot;</span><br><span class="line">                          interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br><span class="line">     </span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>生产者</p>
<ul>
<li><p>配置文件</p>
<ul>
<li><pre><code class="xml">    &lt;!--声明注册中心--&gt;
    &lt;dubbo:registry id=&quot;bjCenter&quot; address=&quot;zookeeper://bjZK:2181&quot;/&gt;  &lt;!--北京中心--&gt;
    &lt;dubbo:registry id=&quot;shCenter&quot; address=&quot;zookeeper://shZK:2181&quot;/&gt;  &lt;!--上海中心--&gt;
    &lt;dubbo:registry id=&quot;gzCenter&quot; address=&quot;zookeeper://gzZK:2181&quot;/&gt;  &lt;!--广州中心--&gt;
    &lt;dubbo:registry id=&quot;cqCenter&quot; address=&quot;zookeeper://cqZK:2181&quot;/&gt;  &lt;!--重庆中心--&gt;

    &lt;!--注册Service实现类--&gt;
    &lt;bean id=&quot;weixinService&quot; class=&quot;com.abc.provider.WeixinServiceImpl&quot;/&gt;
    &lt;bean id=&quot;zhifubaoService&quot; class=&quot;com.abc.provider.ZhifubaoServiceImpl&quot;/&gt;

    &lt;!--暴露服务：同一个服务注册到不同的中心；不同的服务注册到不同的中心--&gt;
    &lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot;
                   ref=&quot;weixinService&quot; group=&quot;pay.weixin&quot; register=&quot;bjCenter, shCenter&quot;/&gt;
    &lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot;
                   ref=&quot;zhifubaoService&quot; group=&quot;pay.zhifubao&quot; register=&quot;gzCenter, cqCenter&quot;/&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">## **单功能注册中心** -- 仅提供者，但是提供者和消费者是相对概念</span><br><span class="line"></span><br><span class="line">注册中心提供服务发现、服务注册两种功能，但是某些场景下，我们只想用其中一个功能。</span><br><span class="line"></span><br><span class="line">这些仅订阅或仅注册，只对当前配置文件中的服务起作用，不会影响注册中心本身的功能。</span><br><span class="line"></span><br><span class="line">- **仅订阅**</span><br><span class="line"></span><br><span class="line">  - 概念: 对于某服务来说，其可以发现和调用注册中心中的其它服务，但不能被其它服务发现和调用，这种情形称为仅订阅。简单说就是，仅可去发现，但不能被发现。其底层的实现是，当前服务可以从注册中心下载注册列表，但其不会将自己的信息写入到注册列表。</span><br><span class="line"></span><br><span class="line">  - **设置方式**：对于“仅订阅”注册中心的实现，只需修改提供者配置文件，在&lt;dubbo:registry&#x2F;&gt;标签中添加 register&#x3D;”false”属性。即对于当前服务来说，注册中心不再接受其注册，但该服务可以通过注册中心去发现和调用其它服务。</span><br><span class="line"></span><br><span class="line">- **仅注册**</span><br><span class="line"></span><br><span class="line">  - 概念：对于某服务来说，其可以被注册中心的其它服务发现和调用，但不能发现和调用注册中心中的其它服务，这种情形称为仅注册。简单来说就是，仅可被发现，但不能去发现。[从底层实现来说就是，当前服务可以写入到注册列表，但其不能下载注册列表。]()</span><br><span class="line">  - 设置方式：对于“仅注册”注册中心的实现，[只需修改提供者配置文件]()，在&lt;dubbo:registry&#x2F;&gt;标签中添加 subscribe&#x3D;”false”的属性。即对于当前服务来说，注册中心中的其它服务可以发现和调用当前服务，但其不能发现和调用其它服务。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **服务暴露延迟 -- 仅提供者**</span><br><span class="line"></span><br><span class="line">如果我们的服务启动过程需要 warmup 事件，就可以使用 delay 进行服务延迟暴露。只需在服务提供者的&lt;dubbo:service&#x2F;&gt;标签中添加 delay 属性。其值可以有三类：</span><br><span class="line"></span><br><span class="line"> 正数：单位为毫秒，表示在提供者对象创建完毕后的指定时间后再发布服务。</span><br><span class="line"></span><br><span class="line"> 0：默认值，表示当前提供者创建完毕后马上向注册中心暴露服务。</span><br><span class="line"></span><br><span class="line"> -1：表示在 Spring 容器初始化完毕后再向注册中心暴露服务。</span><br><span class="line"></span><br><span class="line">&gt; [先提供者创建完成，然后Spring容器初始化完成]()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 消费者的异步调用</span><br><span class="line"></span><br><span class="line">在 Dubbo 简介时，我们分析了 Dubbo 的四大组件工作原理图，其中消费者调用提供者采用的是同步调用方式。其实，消费者对于提供者的调用，也可以采用异步方式进行调用。异步调用一般应用于提供者提供的是耗时性 IO 服务。</span><br><span class="line"></span><br><span class="line">比如consumer 需要同时调用 provider 的a服务消耗3ms，b服务5ms</span><br><span class="line"></span><br><span class="line">- 同步的话：消耗&#x3D;3+5</span><br><span class="line">- 异步的话：消耗&#x3D;min（3，5）</span><br><span class="line"></span><br><span class="line">### Future异步执行原理  -- 仅消费者</span><br><span class="line"></span><br><span class="line">异步方法调用执行原理如下图所示，其中实线为同步调用，而虚线为异步调用。</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190803211841665.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5NjUyMDM&#x3D;,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line"> UserThread：消费者线程</span><br><span class="line"></span><br><span class="line"> IOThrea：提供者线程</span><br><span class="line"></span><br><span class="line"> Server：对 IO 型操作的真正执行者</span><br><span class="line"></span><br><span class="line">&gt; get&#x2F;wait方法时阻塞的</span><br><span class="line"></span><br><span class="line">#### 提供者 -- 不需要做任何修改</span><br><span class="line"></span><br><span class="line">#### 消费者</span><br><span class="line"></span><br><span class="line">- 配置文件</span><br><span class="line"></span><br><span class="line">  - Third, Fourth异步方式</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;</span><br><span class="line">        &lt;dubbo:application name&#x3D;&quot;10-consumer-async&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot; &#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;otherService&quot;  timeout&#x3D;&quot;20000&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.OtherService&quot; &gt;</span><br><span class="line">            &lt;dubbo:method name&#x3D;&quot;doThird&quot; async&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;dubbo:method name&#x3D;&quot;doFourth&quot; async&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;dubbo:reference&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>测试类</p>
<ul>
<li><p>测试异步调用的请求时间</p>
<ul>
<li><p>请求非常快，但是没数据</p>
</li>
<li><pre><code>  public static void main(String[] args)
            throws ExecutionException, InterruptedException &#123;
        ApplicationContext ac =
                new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
        OtherService service = (OtherService) ac.getBean(&quot;otherService&quot;);

        // 记录异步调用开始时间
        long asyncStart = System.currentTimeMillis();

        // 异步调用
        service.doThird();
        service.doFourth();

        long syncInvokeTime = System.currentTimeMillis() - asyncStart;
        System.out.println(&quot;两个异步调用共计用时（毫秒）：&quot; + syncInvokeTime);
    &#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 测试异步调用，获取结果的时间</span><br><span class="line"></span><br><span class="line">  - 就比较慢，等待结果返回</span><br><span class="line"></span><br><span class="line">  - 注意：RpcContext.getContext().getFuture()是和异步调用成对出现的</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;java</span><br><span class="line">      String result1 &#x3D; service.doThird();</span><br><span class="line">      System.out.println(&quot;调用结果1 &#x3D; &quot; + result1);</span><br><span class="line">      Future&lt;String&gt; thirdFuture &#x3D; RpcContext.getContext().getFuture();</span><br><span class="line">      </span><br><span class="line">      String result3 &#x3D; service.doFourth();</span><br><span class="line">      System.out.println(&quot;调用结果3 &#x3D; &quot; + result3);</span><br><span class="line">      Future&lt;String&gt; fourFuture &#x3D; RpcContext.getContext().getFuture();</span><br></pre></td></tr></table></figure>

- 错误写法是: 导致thirdFuture和fourFuture都是最近的调用service.doFourth()的结果

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String result1 = service.doThird();</span><br><span class="line">String result3 = service.doFourth();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;调用结果1 = &quot;</span> + result1);</span><br><span class="line">Future&lt;String&gt; thirdFuture = RpcContext.getContext().getFuture();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;调用结果3 = &quot;</span> + result3);</span><br><span class="line">Future&lt;String&gt; fourFuture = RpcContext.getContext().getFuture();</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- ```java
  public static void main(String[] args)
              throws ExecutionException, InterruptedException &#123;
          ApplicationContext ac =
                  new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
          OtherService service = (OtherService) ac.getBean(&quot;otherService&quot;);

          // 记录异步调用开始时间
          long asyncStart = System.currentTimeMillis();

          // 异步调用
          String result1 = service.doThird();
          System.out.println(&quot;调用结果1 = &quot; + result1);
          Future&lt;String&gt; thirdFuture = RpcContext.getContext().getFuture();

          String result3 = service.doFourth();
          System.out.println(&quot;调用结果3 = &quot; + result3);
          Future&lt;String&gt; fourFuture = RpcContext.getContext().getFuture();

          // 阻塞
          String result2 = thirdFuture.get();
          System.out.println(&quot;调用结果2 = &quot; + result2);
          String result4 = fourFuture.get();
          System.out.println(&quot;调用结果4 = &quot; + result4);

          long useTime = System.currentTimeMillis() - asyncStart;
          System.out.println(&quot;获取到异步调用结果共计用时：&quot; + useTime);
      &#125;
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">### **CompletableFuture** **异步调用**  -- 消费者和生产者</span><br><span class="line"></span><br><span class="line">使用 Future 实现异步调用，对于无需获取返回值的操作来说不存在问题，但消费者若需要获取到最终的异步执行结果，则会出现问题：消费者在使用 Future 的 get()方法获取返回值时被阻塞, CPU被无意义的轮休消耗。</span><br><span class="line"></span><br><span class="line">为了解决这个问题，Dubbo 又引入了 CompletableFuture 来实现对提供者的异步调用。</span><br><span class="line"></span><br><span class="line">#### 消费者</span><br><span class="line"></span><br><span class="line">- 配置文件去除asyn属性</span><br><span class="line"></span><br><span class="line">- 公共接口类</span><br><span class="line"></span><br><span class="line">  - 以前是</span><br><span class="line"></span><br></pre></td></tr></table></figure>
public interface OtherService &#123;
    String doFirst();
    String doSecond();
    String doThird();
    String doFourth();
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 现在是</span><br><span class="line"></span><br></pre></td></tr></table></figure>
public interface OtherService &#123;
    String doFirst();
    String doSecond();

    CompletableFuture&lt;String&gt; doThird();
    CompletableFuture&lt;String&gt; doFourth();
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 主函数使用CompletableFuture</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">     public static void main(String[] args)</span><br><span class="line">                throws ExecutionException, InterruptedException &#123;</span><br><span class="line">            ApplicationContext ac &#x3D;</span><br><span class="line">                    new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);</span><br><span class="line">            OtherService service &#x3D; (OtherService) ac.getBean(&quot;otherService&quot;);</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; 记录异步调用开始时间</span><br><span class="line">            long asyncStart &#x3D; System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; 异步调用</span><br><span class="line">            CompletableFuture&lt;String&gt; doThirdFuture &#x3D; service.doThird();</span><br><span class="line">            CompletableFuture&lt;String&gt; doFourthFuture &#x3D; service.doFourth();</span><br><span class="line">    </span><br><span class="line">            long syncInvokeTime &#x3D; System.currentTimeMillis() - asyncStart;</span><br><span class="line">            System.out.println(&quot;两个异步调用共计用时（毫秒）：&quot; + syncInvokeTime);</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; 回调方法</span><br><span class="line">            doThirdFuture.whenComplete((result, throwable) -&gt; &#123;</span><br><span class="line">                if(throwable !&#x3D; null) &#123;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;异步调用提供者的doThird()返回值：&quot; + result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">            doFourthFuture.whenComplete((result, throwable) -&gt; &#123;</span><br><span class="line">                if(throwable !&#x3D; null) &#123;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;异步调用提供者的doFourth()返回值：&quot; + result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">            long getResultTime &#x3D; System.currentTimeMillis() - asyncStart;</span><br><span class="line">            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;（毫秒）：&quot; + getResultTime);</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><ul>
<li><p>和consumer一样，把公共接口类改了</p>
<ul>
<li><p>以前具体的接口实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String doThird() &#123;</span><br><span class="line">	sleep();</span><br><span class="line">	return &quot;doThird()&quot;;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>现在具体的接口实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="comment">// 耗时操作仍由业务线程调用</span></span><br><span class="line">       sleep();</span><br><span class="line">       CompletableFuture&lt;String&gt; future =</span><br><span class="line">               CompletableFuture.completedFuture(<span class="string">&quot;doThird()-----&quot;</span>);</span><br><span class="line">       <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">long</span> useTime = endTime - startTime;</span><br><span class="line">       System.out.println(<span class="string">&quot;doThird()方法执行用时：&quot;</span> + useTime);</span><br><span class="line">       <span class="keyword">return</span> future;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>Future 与 CompletableFuture 的对比：</p>
<ul>
<li><p>Future：Dubbo2.7.0 版本之前消费者异步调用提供者的实现方式。源自于 JDK5，对异步结果的获取采用了阻塞与轮询方式。</p>
</li>
<li><p>CompletableFuture：Dubbo2.7.0 版本之后消费者异步调用提供者的实现方式。源自于JDK8，对异步结果的获取采用了回调的方式。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://deepakvadgama.com/blog/completable-future-internals/">介绍Future与CompletableFuture的文章</a></p>
<h2 id="提供者的异步执行"><a href="#提供者的异步执行" class="headerlink" title="提供者的异步执行"></a><strong>提供者的异步执行</strong></h2><p>从前面“对提供者的异步调用”例子可以看出，消费者对提供者实现了异步调用，消费者线程的执行过程不再发生阻塞，但提供者对 IO 耗时操作仍采用的是同步调用，即 IO 操作仍会阻塞 Dubbo 的提供者线程。</p>
<blockquote>
<p>但需要注意，提供者对 IO 操作的异步调用，并不会提升 RPC 响应速度，因为耗时操作终归是需要消耗那么多时间后才能给出结果的。</p>
<p>对用户体验没什么提升，就是接口延迟；但是极大的提升了吞吐量，不再阻塞业务线程。</p>
</blockquote>
<ul>
<li><p>以前接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 耗时操作仍由业务线程调用, 所以阻塞了业务线程</span></span><br><span class="line">    sleep();</span><br><span class="line">    CompletableFuture&lt;String&gt; future =</span><br><span class="line">        CompletableFuture.completedFuture(<span class="string">&quot;doThird()-----&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> useTime = endTime - startTime;</span><br><span class="line">    System.out.println(<span class="string">&quot;doThird()方法执行用时：&quot;</span> + useTime);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在具体的接口实现:<font color="red"> 耗时操作不再由业务线程直接调用</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="comment">// 异步调用耗时操作</span></span><br><span class="line">       CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           <span class="comment">// 耗时操作是由CompletableFuture调用的，而不是由业务线程直接调用，所以不再阻塞业务线程</span></span><br><span class="line">           sleep();</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;doThird()&quot;</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;doThird()方法执行用时：&quot;</span> + (endTime - startTime));</span><br><span class="line">       <span class="keyword">return</span> future;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="属性配置优先级"><a href="#属性配置优先级" class="headerlink" title="属性配置优先级"></a><strong>属性配置优先级</strong></h2><p>Dubbo 配置文件中各个标签属性配置的优先级总原则是：</p>
<ul>
<li><p>方法级优先，接口级(服务级)次之，全局配置再次之。</p>
</li>
<li><p>如果级别一样，则消费方优先，提供方次之。</p>
</li>
</ul>
<p>另外，还有两个标签需要说明一下：</p>
<ul>
<li><p><a href="dubbo:consumer/">dubbo:consumer/</a>设置在消费者端，用于设置消费者端的默认配置，即消费者端的全局设置。当然也可以设置在提供者端。但是以消费者优先级高</p>
</li>
<li><p><a href="dubbo:provider/">dubbo:provider/</a>设置在提供者端，用于设置提供者端的默认配置，即提供者端的默认配置。当然也可以设置在消费者端。但是以消费者优先级高</p>
</li>
</ul>
<p><strong>配置建议</strong></p>
<p><strong>provider</strong> <strong>上配置合理的</strong> <strong>provider</strong> <strong>端属性</strong></p>
<p><strong>在</strong> <strong>provider</strong> <strong>上尽量多配置</strong> <strong>consumer</strong> <strong>端属性</strong></p>
<ul>
<li>因为provider更清楚自己的性能和服务</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Distributed%20Streaming%20Platform/RocketMQ/RocketMQ-01-%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Distributed%20Streaming%20Platform/RocketMQ/RocketMQ-01-%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">RocketMQ-01-入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-03-01 17:33:31 / Modified: 17:33:39" itemprop="dateCreated datePublished" datetime="2021-03-01T17:33:31+08:00">2021-03-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/IO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/IO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="post-title-link" itemprop="url">IO模型与多路复用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-20 11:32:56" itemprop="dateCreated datePublished" datetime="2021-02-20T11:32:56+08:00">2021-02-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-07 10:23:06" itemprop="dateModified" datetime="2021-03-07T10:23:06+08:00">2021-03-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="User-space-Kernel-space"><a href="#User-space-Kernel-space" class="headerlink" title="User space/Kernel space"></a>User space/Kernel space</h1><p>学习 Linux 时，经常可以看到两个词:User space(用户空间)和 Kernel space(内核空间)。</p>
<p>虚拟内存被操作系统划分成两块:内核空间和用户空间，内核空间是内核代码运行的地方，用户空间是用户程序代码运行的地方。当进程运行在内核空间时就处于内核态，当进程运行在用户空间时就处于用户态。</p>
<p>查看 CPU 时间在 User space 与 Kernel Space 之间的分配情况，可以使用top命令。它的第三行输出就是 CPU 时间分配统计。</p>
<ul>
<li>第一项24.8 us(user 的缩写)就是 CPU 消耗在 User space 的时间百分比，第二项0.5 sy(system 的 缩写)是消耗在 Kernel space 的时间百分比。</li>
<li>随便也说一下其他 6 个指标的含义。</li>
<li>ni:niceness 的缩写，CPU 消耗在 nice 进程(低优先级)的时间百分比</li>
<li>id:idle 的缩写，CPU 消耗在闲置进程的时间百分比，这个值越低，表示 CPU 越忙</li>
<li>wa:wait 的缩写，CPU 等待外部 I/O 的时间百分比，这段时间 CPU 不能干其他事，但是也没有执行运算，这个 值太高就说明外部设备有问题</li>
<li>hi:hardware interrupt 的缩写，CPU 响应硬件中断请求的时间百分比 si:software interrupt 的缩写，CPU 响应软件中断请求的时间百分比</li>
<li>st:stole time 的缩写，该项指标只对虚拟机有效，表示分配给当前虚拟机的 CPU 时间之中，被同一台物理机上 的其他虚拟机偷走的时间百分比</li>
</ul>
<h1 id="PIO与DMA"><a href="#PIO与DMA" class="headerlink" title="PIO与DMA"></a>PIO与DMA</h1><p>有必要简单地说说慢速I/O设备和内存之间的数据传输方式。</p>
<ul>
<li>PIO<br>我们拿磁盘来说，很早以前，磁盘和内存之间的数据传输是需要CPU控制的，也就是说如果我们读取磁盘文件到内存中，数据要经过CPU存储转发，这种方式称为PIO。显然这种方式非常不合理，需要占用大量的CPU时间来读取文件，造成文件访问时系统几乎停止响应。</li>
<li>DMA<br>后来，DMA（直接内存访问，Direct Memory Access）取代了PIO，它可以不经过CPU而直接进行磁盘和内存的数据交换。在DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传送即可，DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就在很大程度上降低了CPU占有率，大大节省了系统资源，而它的传输速度与PIO的差异其实并不十分明显，因为这主要取决于慢速设备的速度。</li>
</ul>
<p>可以肯定的是，PIO模式的计算机我们现在已经很少见到了。</p>
<h1 id="缓存IO与直接IO"><a href="#缓存IO与直接IO" class="headerlink" title="缓存IO与直接IO"></a>缓存IO与直接IO</h1><ul>
<li>缓存IO:数据从磁盘先通过DMA copy到内核空间，再从内核空间通过cpu copy到用户空间 </li>
<li>直接IO:数据从磁盘通过DMA copy到用户空间</li>
</ul>
<img src="https://yqfile.alicdn.com/img_9ab2d009b5aa815127aeed8847a7f25d.jpeg" alt="img" style="zoom:67%;" />

<h2 id="缓存IO"><a href="#缓存IO" class="headerlink" title="缓存IO"></a>缓存IO</h2><p><font color="red">缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。</font>在Linux的缓存I/O机制中，数据先从磁盘复制到<a href="">内核空间缓冲区</a>，然后从<a href="">内核空间缓冲区</a>复制到<a href="">应用程序的地址空间</a>。</p>
<ul>
<li>读操作: 操作系统检查<a href="">内核缓冲区</a>有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回;否则从磁盘中读取，然后缓存在操作系统的缓存中。</li>
<li>写操作：将用户空间的数据复制到内核空间的缓存中。<ul>
<li>对于用户来说，写操作已经完成，至于内核空间何时将缓存写入磁盘，有操作系统决定。除非用户显示调用fsync命令</li>
</ul>
</li>
</ul>
<p>优缺点</p>
<ul>
<li><p>优点：</p>
<ul>
<li>一定程度上分离了用户空间和系统空间，保障了系统的安全运行；</li>
<li>减少了与磁盘IO的次数，提高了性能</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样数据在传输过程中需要在程序地址空间（用户空间）和缓存（内核空间）进行多次的数据复制操作，这些操作造成很大的CPU和内存消耗。</li>
</ul>
</li>
</ul>
<h2 id="直接IO-绕过内核缓冲区-自己管理I-O缓存区"><a href="#直接IO-绕过内核缓冲区-自己管理I-O缓存区" class="headerlink" title="直接IO(绕过内核缓冲区,自己管理I/O缓存区)"></a>直接IO(<code>绕过内核缓冲区,自己管理I/O缓存区</code>)</h2><p><font color="red">直接IO就是应用程序直接访问磁盘数据，而不经过内核缓冲 区，也就是绕过内核缓冲区,自己管理I/O缓存区，这样做的目 的是减少一次从内核缓冲区到用户程序缓存的数据复制。</font></p>
<p>引入<a href="">内核缓冲区</a>的目的在于提高磁盘文件的访问性能，因为当进程需要读取磁盘文件时，如果文件内容已经在<a href="">内缓<br>冲区</a>中，那么就不需要再次访问磁盘;而当进程需要向文件中写入数据时，实际上只是写到了<a href="">内核缓冲区</a>便告诉进程已经写成功，而真正写入磁盘是通过一定的策略进行延迟的。</p>
<p>然而，对于一些较复杂的应用(MySQL)，它们为了充分提高性能，会绕过<a href="">内核缓冲区</a>，由程序自己管理并且实现IO缓存，包括缓存机制和写延迟机制，以支持独特的查询机制，比如Mysql通过合理的策略来提高查询缓存命中率。另一方面，绕过<a href="">内核缓冲区</a>也可以减少系统内存的开销，因为内核缓冲区本身就在使用系统内存。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEyNDQ4Ni04YTE3MjI0ZDYyNDE2MDUx?x-oss-process=image/format,png" alt="image" style="zoom: 33%;" />

<p>优缺点：</p>
<ul>
<li>优点：<ul>
<li>应用程序直接访问磁盘数据，不经过操作系统<a href="">内核缓冲区</a>，这样做的目的是减少一次<a href="">内核缓存</a>与<a href="">程序缓存</a>的复制。这种方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。</li>
</ul>
</li>
<li>缺点:<ul>
<li>如果被访问的数据不在程序缓存中，那么会从磁盘直接读取数据，非常低效的操作。</li>
</ul>
</li>
</ul>
<p>Linux提供了对这种需求的支持，即在open()系统调用中增加参数选项O_DIRECT，用它打开的文件便可以直接访问磁盘文件。</p>
<h1 id="IO访问方式"><a href="#IO访问方式" class="headerlink" title="IO访问方式"></a>IO访问方式</h1><h2 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h2><img src="https://yqfile.alicdn.com/img_41dd13543f263358e3ac143b5dcac23e.jpeg" alt="图片描述" style="zoom:75%;" />

<p>当应用程序调用read接口时，操作系统检查在内核的高速缓存有没有需要的数据，如果已经缓存了，那么就直接从 缓存中返回，如果没有，则从磁盘中读取，然后缓存在操作系统的缓存中。</p>
<p>应用程序调用write接口时，将数据从用户地址空间复制到内核地址空间的缓存中，这时对用户程序来说，写操作已 经完成，至于什么时候再写到磁盘中，由操作系统决定，除非显示调用了sync同步命令。</p>
<h2 id="网络IO-I-Osendfile-零拷贝-kafka的特性"><a href="#网络IO-I-Osendfile-零拷贝-kafka的特性" class="headerlink" title="网络IO(I/Osendfile/零拷贝,kafka的特性)"></a>网络IO<code>(I/Osendfile/零拷贝,kafka的特性</code>)</h2><p>网络传输的第4层（传输层）TCP协议通过socket获取IO流完成的</p>
<h3 id="普通的网络传输步骤"><a href="#普通的网络传输步骤" class="headerlink" title="普通的网络传输步骤"></a>普通的网络传输步骤</h3><p>1）操作系统将数据从<a href="">磁盘hard drive</a>复制到<a href="">内核缓存kernel buffer</a>中<br>2）应用将数据从<a href="">内核缓存</a>复制到<a href="">应用缓存user buffer</a>中<br>3）应用将数据写回<a href="">内核的Socket缓存 (socket buffer)</a>中<br>4）操作系统将数据从<a href="">Socket缓存</a>区复制到<a href="">网卡缓存 (protocal engine)</a>，然后将其通过网络发出</p>
<p><img src="https://yqfile.alicdn.com/img_268ed262dadff71f51f42ad10ea46c9c.jpeg" alt="图片描述"></p>
<p>1、当调用read系统调用时,通过DMA（Direct Memory Access）将数据copy到内核模式<br>2、然后由CPU控制将内核模式数据copy到用户模式下的 buffer中<br>3、read调用完成后，write调用首先将用户模式下 buffer中的数据copy到内核模式下的socket buffer中<br>4、最后通过DMA copy将内核模式下的socket buffer中的数据copy到网卡设备中传送。</p>
<p>从上面的过程可以看出，数据白白从内核模式到用户模式走了一圈，浪费了两次copy，而这两次copy都是CPU copy，即占用CPU资源。</p>
<h3 id="sendFile"><a href="#sendFile" class="headerlink" title="sendFile"></a>sendFile</h3><p>Linux2.4内核对sendfile做了改进，下图所示<br><img src="https://yqfile.alicdn.com/img_8b7e24bd7f67281e97cd0cf6a32d513e.jpeg" alt="图片描述"><br>改进后的处理过程如下：<br>1、DMA copy将磁盘数据copy到kernel buffer中<br>2、向socket buffer中追加当前要发送的数据在kernel buffer中的位置和偏移量<br>3、DMA gather copy根据socket buffer中的位置和偏移量直接将kernel buffer中的数据copy到网卡上。<br>经过上述过程，数据只经过了2次copy就从磁盘传送出去了。（事实上这个Zero copy是针对内核来讲的，数据在内核模式下是Zero－copy的）。<br>当前许多高性能http server都引入了sendfile机制，如nginx，lighttpd等。</p>
<h3 id="FileChannel-transferTo-Java中的零拷贝"><a href="#FileChannel-transferTo-Java中的零拷贝" class="headerlink" title="FileChannel.transferTo(Java中的零拷贝)"></a>FileChannel.transferTo(<code>Java中的零拷贝</code>)</h3><p>Java NIO中FileChannel.transferTo(long position, long count, WriteableByteChannel target)方法将当前通道中的数据传送到目标通道target中，在支持Zero-Copy的linux系统中，transferTo()的实现依赖于 sendfile()调用。</p>
<p><img src="https://yqfile.alicdn.com/img_80b6694edf8b127a0ab4f3a8763421e4.png" alt="图片描述"></p>
<p>传统方式对比零拷贝方式：</p>
<p><img src="https://yqfile.alicdn.com/img_8cb2e11479b0cb46056998b6d32f1f3b.jpeg" alt="图片描述"></p>
<p>整个数据通路涉及4次数据复制和2个系统调用，如果使用sendfile则可以避免多次数据复制，操作系统可以<strong>直接将数据从内核页缓存中复制到网卡缓存</strong>，这样可以大大加快整个过程的速度。</p>
<p>大多数时候，我们都在向Web服务器请求静态文件，比如图片、样式表等，根据前面的介绍，我们知道在处理这些请求的过程中，磁盘文件的数据先要经过内核缓冲区，然后到达用户内存空间，因为是不需要任何处理的静态数据，所以它们又被送到网卡对应的内核缓冲区，接着再被送入网卡进行发送。</p>
<p>数据从内核出去，绕了一圈，又回到内核，没有任何变化，看起来真是浪费时间。在Linux 2.4的内核中，尝试性地引入了一个称为khttpd的内核级Web服务器程序，它只处理静态文件的请求。引入它的目的便在于内核希望请求的处理尽量在内核完成，减少内核态的切换以及用户态数据复制的开销。</p>
<p>同时，Linux通过系统调用将这种机制提供给了开发者，那就是sendfile()系统调用。它可以将磁盘文件的特定部分直接传送到代表客户端的socket描述符，加快了静态文件的请求速度，同时也减少了CPU和内存的开销。</p>
<p>在OpenBSD和NetBSD中没有提供对sendfile的支持。通过strace的跟踪看到了Apache在处理151字节的小文件时，使用了mmap()系统调用来实现内存映射，但是<strong>在Apache处理较大文件的时候，内存映射会导致较大的内存开销，得不偿失</strong>，所以Apache使用了sendfile64()来传送文件，sendfile64()是sendfile()的扩展实现，它在Linux 2.4之后的版本中提供。</p>
<p>这并不意味着sendfile在任何场景下都能发挥显著的作用。<strong>对于请求较小的静态文件，sendfile发挥的作用便显得不那么重要</strong>，通过压力测试，我们模拟100个并发用户请求151字节的静态文件，是否使用sendfile的吞吐率几乎是相同的，可见<strong>在处理小文件请求时，发送数据的环节在整个过程中所占时间的比例相比于大文件请求时要小很多，所以对于这部分的优化效果自然不十分明显</strong>。</p>
<h2 id="网络IO和磁盘IO对比"><a href="#网络IO和磁盘IO对比" class="headerlink" title="网络IO和磁盘IO对比"></a>网络IO和磁盘IO对比</h2><ul>
<li><p>磁盘IO主要的延时是由（以15000rpm硬盘为例）： </p>
<ul>
<li>机械转动延时（机械磁盘的主要性能瓶颈，平均为2ms） + 寻址延时（2~3ms） + 块传输延时（一般4k每块，40m/s的传输速度，延时一般为0.1ms) 决定。（平均为5ms）</li>
</ul>
</li>
<li><p>网络IO主要延时由： </p>
<ul>
<li>服务器响应延时 + 带宽限制 + 网络延时 + 跳转路由延时 + 本地接收延时 决定。（一般为几十到几千毫秒，受环境干扰极大）</li>
</ul>
</li>
</ul>
<p>所以两者一般来说网络IO延时要大于磁盘IO的延时。</p>
<h1 id="Socket网络编程"><a href="#Socket网络编程" class="headerlink" title="Socket网络编程"></a>Socket网络编程</h1><p>第4层传输层TCP协议就是使用socket接收和发送IO流</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 要连接的服务端IP地址和端口 </span></span><br><span class="line">    	String host = <span class="string">&quot;127.0.0.1&quot;</span>; <span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line">      <span class="comment">// 与服务端建立连接</span></span><br><span class="line">      Socket socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">      <span class="comment">// 建立连接后获得输出流</span></span><br><span class="line">      OutputStream outputStream = socket.getOutputStream(); </span><br><span class="line">    	String message=<span class="string">&quot;你好 yiwangzhibujian&quot;</span>; </span><br><span class="line">    	socket.getOutputStream().write(message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    	outputStream.close();</span><br><span class="line">      socket.close();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>



<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 监听指定的端口</span></span><br><span class="line">      <span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line">      ServerSocket server = <span class="keyword">new</span> ServerSocket(port); <span class="comment">// server将一直等待连接的到来 </span></span><br><span class="line">     	System.out.println(<span class="string">&quot;server将一直等待连接的到来&quot;</span>);</span><br><span class="line">      <span class="comment">//如果使用多线程，那就需要线程池，防止并发过高时创建过多线程耗尽资源 </span></span><br><span class="line">      ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      Socket socket = server.accept();</span><br><span class="line">      Runnable runnable=()-&gt;&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 </span></span><br><span class="line">            InputStream inputStream = socket.getInputStream(); </span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">              sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;get message from client: &quot;</span> + sb);</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">					&#125; </span><br><span class="line">      &#125;;</span><br><span class="line">      threadPool.submit(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="处理web请求的两种体系结构"><a href="#处理web请求的两种体系结构" class="headerlink" title="处理web请求的两种体系结构"></a>处理web请求的两种体系结构</h1><p>在web服务中，处理web请求通常有两种体系结构，分别为：<strong>thread-based architecture（基于线程的架构）、event-driven architecture（事件驱动模型）</strong></p>
<h2 id="thread-based-architecture（基于线程的架构）"><a href="#thread-based-architecture（基于线程的架构）" class="headerlink" title="thread-based architecture（基于线程的架构）"></a>thread-based architecture（基于线程的架构）</h2><p>thread-based architecture（基于线程的架构），通俗的说就是：多线程并发模式，一个连接一个线程，服务器每当收到客户端的一个请求， 便开启一个独立的线程来处理。</p>
<img src="https://pic1.zhimg.com/80/v2-288b2a61dbfcf488eefd4a6ab9ad08dc_1440w.jpg" alt="img" style="zoom:33%;" />

<p>这种模式一定程度上极大地提高了服务器的吞吐量，由于在不同线程中，之前的请求在read阻塞以后，不会影响到后续的请求。<strong>但是</strong>，仅适用于于并发量不大的场景，因为：</p>
<ul>
<li>线程需要占用一定的内存资源</li>
<li>创建和销毁线程也需一定的代价</li>
<li>操作系统在切换线程也需要一定的开销</li>
<li>线程处理I/O，在等待输入或输出的这段时间处于空闲的状态，同样也会造成cpu资源的浪费</li>
<li><strong>如果连接数太高，系统将无法承受</strong></li>
</ul>
<h2 id="event-driven-architecture（事件驱动模型）"><a href="#event-driven-architecture（事件驱动模型）" class="headerlink" title="event-driven architecture（事件驱动模型）"></a>event-driven architecture（事件驱动模型）</h2><p>事件驱动体系结构是目前比较广泛使用的一种。这种方式会定义一系列的事件处理器来响应事件的发生，并且将<strong>服务端接受连接</strong>与<strong>对事件的处理</strong>分离。其中，<strong>事件是一种状态的改变</strong>。比如，tcp中socket的new incoming connection、ready for read、ready for write。</p>
<h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><font color="red">反应器设计模式(Reactor pattern)是一种为处理并发服务请求，并将请求提交到 一个或者多个服务处理程序的事件设计模式。当客户端请求抵达后，服务处理程序 使用多路分配策略，由一个非阻塞的线程来接收所有的请求，然后派发这些请求至 相关的工作线程进行处理。</font></p>
<p>从这个描述中，我们知道Reactor模式<strong>首先是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers</strong>；<a href="">Service Handler</a>会对输入的<a href="">请求（Event）</a>进行<a href="">多路复用</a>，并同步地将它们分发给相应的<a href="">Request Handler</a>。</p>
<p><img src="https://img-blog.csdnimg.cn/20191223084249141.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MTI3NzI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://pic3.zhimg.com/80/v2-eae3b6613735ad11b30333825dae8b16_1440w.jpg" alt="img"></p>
<p><strong>Reactor模式主要包含下面几部分内容:</strong></p>
<ul>
<li><a href="">初始事件分发器(Initialization Dispatcher)</a>：用于管理<a href="">Event Handler</a>，定义注册、移除EventHandler等。它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调<a href="">Event Handler</a>中的handle_event()方法</li>
<li><a href="">同步（多路）事件分离器(Synchronous Event Demultiplexer)</a>：无限循环等待新事件的到来，一旦发现有新的事件到来，就会通知<a href="">初始事件分发器</a>去调取特定的<a href="">事件处理器</a>。阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。在Java NIO中用Selector来封装，当Selector.select()返回时，可以调用Selector的selectedKeys()方法获取Set</li>
<li><a href="">系统处理程序(Handle)</a>：操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指<a href="">Socket Handle</a>，即一个网络连接（Connection，在Java NIO中的Channel）。这个Channel注册到Synchronous Event Demultiplexer中，以监听Handle中发生的事件，对ServerSocketChannnel可以是CONNECT事件，对SocketChannel可以是READ、WRITE、CLOSE事件等。</li>
<li><a href="">事件处理器(Event Handler)</a>： 定义事件处理方法，以供Initialization Dispatcher回调使用。</li>
<li><a href="">Concrete Event Handler</a>：事件EventHandler接口，实现特定事件处理逻辑。</li>
</ul>
<p><strong>Reactor 类结构中包含有的主要角色：</strong></p>
<ol>
<li>Handle：标示文件描述符</li>
<li>Event Demultiplexer：对操作系统内核实现I/O复用接口的封装等待发生事件发生</li>
<li>Event Handler：事件处理接口</li>
<li>Event Handler A/B：实现应用程序所提供的特定事件处理逻辑</li>
<li>Reactor：反应器定义一个接口，注册和删除关注的事件句柄、运行事件处理循环、等待就绪事件触发，分发事件到注册的回调函数。</li>
</ol>
<p><a href="">对于Reactor模式，可以将其看做由两部分组成，一部分是由Boss组成，另一部分是由worker组成</a>。Boss就像老板一样，主要是拉活儿、谈项目，一旦Boss接到活儿了，就下发给下面的work去处理。</p>
<h4 id="业务流程时序图"><a href="#业务流程时序图" class="headerlink" title="业务流程时序图"></a>业务流程时序图</h4><img src="https://img2020.cnblogs.com/blog/627770/202007/627770-20200712133918539-241195601.png" alt="Image result for Reactor 时序图" style="zoom: 50%;" />

<ol>
<li>应用启动，将关注的事件handle注册到Reactor中;</li>
<li>调用Reactor，进入无限事件循环，等待注册的事件到来;</li>
<li>事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理;</li>
</ol>
<h4 id="为什么使用Reactor模式"><a href="#为什么使用Reactor模式" class="headerlink" title="为什么使用Reactor模式"></a>为什么使用Reactor模式</h4><ul>
<li>多线程模式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为每个单独到来的请求，专门启动一条线程，这样的话造成系统的开销很大，并且在单核的机上，多线程并不能提高系</span><br><span class="line">统的性能，除非在有一些阻塞的情况发生。否则线程切换的开销会使处理的速度变慢。</span><br></pre></td></tr></table></figure>

<ul>
<li>Reactor模式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器端启动一条单线程，用于轮询IO操作是否就绪，当有就绪的才进行相应的读写操作，这样的话就减少了服务器产 生大量的线程，也不会出现线程之间的切换产生的性能消耗。(目前JAVA的NIO就采用的此种模式，这里引申出一个问 题:在多核情况下NIO的扩展问题)</span><br></pre></td></tr></table></figure>

<p>以上两种处理方式都是基于同步的，多线程的处理是我们传统模式下对高并发的处 理方式，Reactor模式的处理是现今面对高并发的主流方式。                         </p>
<h4 id="Reactor模式-单线程模式"><a href="#Reactor模式-单线程模式" class="headerlink" title="Reactor模式-单线程模式"></a>Reactor模式-单线程模式</h4><p>Java中的NIO模式的Selector网络通讯，其实就是一个简单的Reactor模型。可以说是单线程的Reactor模式</p>
<p><img src="https://pic4.zhimg.com/80/v2-5f97abecc66698d6b1ce3034267e1fff_1440w.jpg" alt="img"></p>
<p>Reactor的单线程模式的单线程主要是针对于I/O操作而言，也就是所以的I/O的accept()、read()、write()以及connect()操作都在一个线程上完成的。</p>
<p>但在目前的单线程Reactor模式中，不仅I/O操作在该Reactor线程上，连非I/O的业务操作也在该线程上进行处理了，这可能会大大延迟I/O请求的响应。所以我们应该将非I/O的业务逻辑操作从Reactor线程上卸载，以此来加速Reactor线程对I/O请求的响应。</p>
<h4 id="Reactor模式-工作者线程池模式"><a href="#Reactor模式-工作者线程池模式" class="headerlink" title="Reactor模式-工作者线程池模式"></a>Reactor模式-工作者线程池模式</h4><p>与单线程模式不同的是，添加了一个<strong>工作者线程池</strong>，并将非I/O操作从Reactor线程中移出转交给工作者线程池（Thread Pool）来执行。这样能够提高Reactor线程的I/O响应，不至于因为一些耗时的业务逻辑而延迟对后面I/O请求的处理。</p>
<p><img src="https://pic3.zhimg.com/80/v2-2ffa44b686eea3ce55c7489fd67d1c1e_1440w.jpg" alt="img"></p>
<p>在工作者线程池模式中，虽然非I/O操作交给了线程池来处理，但是<strong>所有的I/O操作依然由Reactor单线程执行</strong>，在高负载、高并发或大数据量的应用场景，依然较容易成为瓶颈。所以，对于Reactor的优化，又产生出下面的多线程模式。</p>
<h4 id="Reactor模式-多线程模式"><a href="#Reactor模式-多线程模式" class="headerlink" title="Reactor模式-多线程模式"></a>Reactor模式-多线程模式</h4><p>对于多个CPU的机器，为充分利用系统资源，将Reactor拆分为两部分：mainReactor和subReactor</p>
<p><img src="https://pic4.zhimg.com/80/v2-14b10c1dd4c45a1fe3fd92f91fffe2e3_1440w.jpg" alt="img"></p>
<p><strong>mainReactor</strong>负责监听server socket，用来处理网络新连接的建立，将建立的socket Channel指定注册给subReactor，通常<strong>一个线程</strong>就可以处理 ；</p>
<p><strong>subReactor</strong>维护自己的selector, 基于mainReactor 注册的socketChannel多路分离I/O读写事件，读写网络数据，通常使用<strong>多线程</strong>；</p>
<p>对非I/O的操作，依然转交给工作者线程池（Thread Pool）执行。</p>
<p>此种模型中，每个模块的工作更加专一，耦合度更低，性能和稳定性也大量的提升，支持的可并发客户端数量可达到上百万级别。关于此种模型的应用，目前有很多优秀的框架已经在应用了，比如mina和netty 等。Reactor模式-多线程模式下去掉工作者线程池（Thread Pool），则是Netty中NIO的默认模式。</p>
<ul>
<li>mainReactor对应Netty中配置的BossGroup线程组，主要负责接受客户端连接的建立。一般只暴露一个服务端口，BossGroup线程组一般一个线程工作即可</li>
<li>subReactor对应Netty中配置的WorkerGroup线程组，BossGroup线程组接受并建立完客户端的连接后，将网络socket转交给WorkerGroup线程组，然后在WorkerGroup线程组内选择一个线程，进行I/O的处理。WorkerGroup线程组主要处理I/O，一般设置<code>2*CPU核数</code>个线程</li>
</ul>
<h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><h1 id="4种IO模型"><a href="#4种IO模型" class="headerlink" title="4种IO模型"></a>4种IO模型</h1><p>在理解关于同步和阻塞的概念前，需要知道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I&#x2F;0 操作 主要分成两部分</span><br><span class="line">① 数据准备，将数据加载到内核缓存（数据加载到操作系统）</span><br><span class="line">② 将内核缓存中的数据加载到用户缓存（从操作系统复制到应用中）</span><br></pre></td></tr></table></figure>

<p><strong>同步和异步的概念描述的是用户线程与内核的交互方式</strong></p>
<p><strong>阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式</strong></p>
<h2 id="争议：异步就是异步"><a href="#争议：异步就是异步" class="headerlink" title="争议：异步就是异步"></a>争议：<strong>异步就是异步</strong></h2><p><strong><img src="https://images2018.cnblogs.com/blog/874126/201808/874126-20180815160154943-682702591.png" alt="img"></strong></p>
<p><img src="https://images2018.cnblogs.com/blog/874126/201808/874126-20180815160307369-420684321.png" alt="img"></p>
<p>【<strong>同步/异步】和【</strong>阻塞/非阻塞】的关注点是存在区别的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">【同步&#x2F;异步】表示是两个事件交互的是否有序依赖关系</span><br><span class="line">同步：针对执行结果，A事件必须知道B事件的结果M后才执行得到结果。</span><br><span class="line">异步：针对执行结果，执行A事件和执行B事件没有关系。</span><br><span class="line"></span><br><span class="line">阻塞&#x2F;非阻塞表示执行过程出现的状态</span><br><span class="line">阻塞：针对执行者来说，执行A事件，执行过程因为条件未满足，执行状态变成等待状态。</span><br><span class="line">非阻塞：针对执行者来说，就是事件A执行遇到未满足条件，执行另外独立的C事件。</span><br><span class="line"></span><br><span class="line">总结：两者之间是没有关系的</span><br><span class="line">【同步&#x2F;异步】</span><br><span class="line">   概念上是：事件A，B的结果之间的是否存在依赖关系；</span><br><span class="line">   影响上是：保证依赖数据的正确性</span><br><span class="line">【阻塞&#x2F;非阻塞】</span><br><span class="line">   概念上是：自身执行状态。</span><br><span class="line">   影响上是：阻塞导致资源浪费。</span><br><span class="line"></span><br><span class="line">特别注意：异步只有异步，同步才有阻塞和非阻塞的说法！</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">总整体看：传统的请求，是同步的（也是阻塞的），请求响应是有序的(请求响应之间也是等待的）；AJAX是异步请求（也是非阻塞的）。</span><br><span class="line">同步不等于阻塞：</span><br><span class="line">单个看：AJAX从客户端执行单个请求看数据是同步，但是执行是非阻塞，在未收到响应继续执行其他请求。</span><br></pre></td></tr></table></figure>



<p>服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种: </p>
<p>(1<a href="">)同步阻塞IO(Blocking IO)</a>:即传统的IO模型。Tomcat和Apache</p>
<p>(2)<a href="">同步非阻塞IO(Non-blocking IO)</a>:默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为 NONBLOCK。注意这里所说的NIO并非Java的NIO(New IO)库。</p>
<p>(3)<a href="">IO多路复用(IO Multiplexing)</a>:即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的 Selector和Linux中的epoll都是这种模型。</p>
<p>(4)异步IO(Asynchronous IO):即经典的Proactor模式，也称为异步非阻塞IO</p>
<h2 id="同步阻塞IO-Blocking-IO"><a href="#同步阻塞IO-Blocking-IO" class="headerlink" title="同步阻塞IO(Blocking IO)"></a>同步阻塞IO(Blocking IO)</h2><img src="https://img-blog.csdnimg.cn/20200806153255444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjYyMjY2,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />



<img src="https://images2018.cnblogs.com/blog/874126/201808/874126-20180815215329688-621626362.png" alt="img" style="zoom:50%;" />

<ul>
<li><a href="">用户线程(上上图中的处理线程)</a>通过<a href="">系统调用read发起IO读操作(上上图中的read)</a>，由用户空间转到内核空间。内核等到数据包到达后，然后将 接收的数据拷贝到用户空间，完成read操作。</li>
<li>即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程 是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    read(socket, buffer); <span class="comment">//阻塞</span></span><br><span class="line">    process(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模型特点 ：</strong></p>
<ul>
<li>采用阻塞IO模式获取输入的数据</li>
<li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li>
</ul>
<p><strong>问题分析：</strong></p>
<ul>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read 操作，造成线程资源浪费</li>
</ul>
<h2 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h2><img src="https://images0.cnblogs.com/blog/405877/201411/142332004602984.png" alt="img" style="zoom:50%;" />

<p>同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即 返回。</p>
<p>由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程 需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(read(socket, buffer) != SUCCESS);</span><br><span class="line">	process(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，用户线程需要不停地发送系统调用以获取这个 I/O 操作的最新状态，这个过程称为<strong>轮询（poll）</strong>。</p>
<p><a href="">虽然用户线程不再被阻塞了，但用户线程需要不断地进行轮询，轮询过程会消耗额外的 CPU 资源。因此 CPU 的有效利用率同样不高。</a></p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><img src="https://img-blog.csdnimg.cn/20200806154511111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjYyMjY2,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" />

<h3 id="针对传统阻塞-I-O-模型的-2-个缺点的改进：（IO多路复用-线程池）"><a href="#针对传统阻塞-I-O-模型的-2-个缺点的改进：（IO多路复用-线程池）" class="headerlink" title="针对传统阻塞 I/O 模型的 2 个缺点的改进：（IO多路复用 + 线程池）"></a>针对传统阻塞 I/O 模型的 2 个缺点的改进：（IO多路复用 + 线程池）</h3><p>1、每个连接创建一个线程：（线程池）</p>
<ul>
<li>基于线程池复用线程资源</li>
</ul>
<p>2、每个连接对应一个阻塞对象：（IO多路复用）</p>
<ul>
<li>多个连接共用一个阻塞对象，应用程序只需要在<a href="">一个阻塞对象(Service Handler)</a>等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理</li>
</ul>
<h3 id="Select函数"><a href="#Select函数" class="headerlink" title="Select函数"></a>Select函数</h3><p>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。</p>
<img src="https://images0.cnblogs.com/blog/405877/201411/142332187256396.png" alt="img" style="zoom: 25%;" />



<ol>
<li>用户首先将需要进行IO操作的socket添加到select中 <!--正如 new ServerSocket(port)，对某个port进行监控和IO操作--></li>
<li>然后阻塞等待select系统调用返回。</li>
<li>当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</li>
</ol>
<blockquote>
<p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，<a href="">使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求</a>。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到<font color="red"><strong>在同一个线程内同时处理多个IO请求的目的</strong></font>。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>
</blockquote>
<p>用户线程 <!--相对于OS中的内核，server确实是OS中的用户线程--> 使用select函数的伪代码描述为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    select(socket);</span><br><span class="line">  	<span class="comment">//其中while循环前将socket添加到select监视中，然后在while内一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sockets = select();</span><br><span class="line">        <span class="keyword">for</span>(socket in sockets) &#123;</span><br><span class="line">            <span class="keyword">if</span>(can_read(socket)) &#123;</span><br><span class="line">                read(socket, buffer);</span><br><span class="line">                process(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，使用select函数的优点并不仅限于此。虽然上述方式允许单线程内处理多个IO请求 <!--一个线程通过无线循环执行socket = select()来处理每个socket请求-->，但是每个IO请求的过程还是阻塞的（<a href="">在select函数上阻塞</a>）<!--select()要等待监听的socket有数据传过来-->，平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。<!--就是将这张图中的用户线程，换成一个专门的线程来处理阻塞事务--></p>
<h3 id="Reactor设计模式"><a href="#Reactor设计模式" class="headerlink" title="Reactor设计模式"></a>Reactor设计模式</h3><p>IO多路复用模型使用了Reactor设计模式实现了这一机制。</p>
<img src="https://images0.cnblogs.com/blog/405877/201411/142332350853195.png" alt="img" style="zoom: 33%;" />

<p><strong>图4 Reactor设计模式</strong></p>
<p>如图4所示，EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。</p>
<img src="https://images0.cnblogs.com/blog/405877/201411/142333254136604.png" alt="img" style="zoom:33%;" />

<p><strong>图5 IO多路复用</strong></p>
<p>如图5所示，通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数<a href="">handle_event</a>），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。<a href="">注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket</a>。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的 <!--与同步非阻塞IO一样-->，不过这并不会产生影响，因为<a href="">用户线程</a>发起<a href="">IO请求（read请求）</a>时，数据已经到达了，用户线程一定不会被阻塞  <!--用户线程read请求时，Reactor线程已经通知用户线程socket可读了-->。</p>
<p><a href="">用户线程</a>使用IO多路复用模型的伪代码描述为：<!--用户线程有很多，process是具体的业务逻辑--></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UserEventHandler::handle_event() &#123;</span><br><span class="line">    <span class="keyword">if</span>(can_read(socket)) &#123;</span><br><span class="line">        read(socket, buffer);</span><br><span class="line">        process(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	Reactor.register(<span class="keyword">new</span> UserEventHandler(socket));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="">用户线程</a>需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，<a href="">用户线程</a>只需要将自己的EventHandler注册到Reactor即可。Reactor中handle_events事件循环的伪代码大致如下。<!--其实和上述的select函数方法一样,Reactor只有一个线程--></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reactor::handle_events() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sockets = select();</span><br><span class="line">        <span class="keyword">for</span>(socket in sockets) &#123;</span><br><span class="line">       		 get_event_handler(socket).handle_event();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。</p>
<p>IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用 <!--就是select()方法会阻塞Reactor线程-->。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。</p>
<h2 id="异步IO（不是重点）"><a href="#异步IO（不是重点）" class="headerlink" title="异步IO（不是重点）"></a>异步IO（不是重点）</h2><p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p>
<p>异步IO模型使用了Proactor设计模式实现了这一机制。</p>
<p><img src="https://images0.cnblogs.com/blog/405877/201411/151608309061672.jpg" alt="img"></p>
<p>图6 Proactor设计模式</p>
<p>如图6，Proactor模式和Reactor模式在结构上比较相似，不过在用户（Client）使用方式上差别较大。Reactor模式中，用户线程通过向Reactor对象注册感兴趣的事件监听，然后事件触发时调用事件处理函数。而Proactor模式中，用户线程将AsynchronousOperation（读/写等）、Proactor以及操作完成时的CompletionHandler注册到AsynchronousOperationProcessor。AsynchronousOperationProcessor使用Facade模式提供了一组异步操作API（读/写等）供用户使用，当用户线程调用异步API后，便继续执行自己的任务。AsynchronousOperationProcessor 会开启独立的内核线程执行异步操作，实现真正的异步。当异步IO操作完成时，AsynchronousOperationProcessor将用户线程与AsynchronousOperation一起注册的Proactor和CompletionHandler取出，然后将CompletionHandler与IO操作的结果数据一起转发给Proactor，Proactor负责回调每一个异步操作的事件完成处理函数handle_event。虽然Proactor模式中每个异步操作都可以绑定一个Proactor对象，但是一般在操作系统中，Proactor被实现为Singleton模式，以便于集中化分发操作完成事件。</p>
<img src="https://images0.cnblogs.com/blog/405877/201411/142333511475767.png" alt="img" style="zoom:25%;" />

<p>图7 异步IO</p>
<p>如图7所示，异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核，然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。</p>
<p>用户线程使用异步IO模型的伪代码描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void UserCompletionHandler::handle_event(buffer) &#123;</span><br><span class="line">		process(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">		aio_read(socket, new UserCompletionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。</p>
<p>相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。</p>
<h1 id="Redis使用多路复用"><a href="#Redis使用多路复用" class="headerlink" title="Redis使用多路复用"></a>Redis使用多路复用</h1><p>redis 是一个单线程却性能非常好的内存数据库， 主要用来作为缓存系统。redis采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。</p>
<h2 id="为什么-Redis-中要使用-I-O-多路复用这种技术呢？"><a href="#为什么-Redis-中要使用-I-O-多路复用这种技术呢？" class="headerlink" title="为什么 Redis 中要使用 I/O 多路复用这种技术呢？"></a>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</h2><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。<!--redis单线程机制，天生只能使用IO多路复用--></p>
<p>redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p>
<p>epoll是众多i/o多路复用技术当中的一种，相比其他io多路复用技术(select, poll等等)，epoll有诸多优点：</p>
<ul>
<li>epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, 一般来说这个数目和系统内存关系很大 ，具体数目可以 cat /proc/sys/fs/file-max 察看。</li>
<li>效率提升， Epoll 最大的优点就在于它只管你“活跃”的连接 ，而跟连接总数无关，因此在实际的网络环境中， Epoll 的效率就会远远高于 select 和 poll 。</li>
<li>内存拷贝， Epoll 在这点上使用了“共享内存 ”，这个内存拷贝也省略了。</li>
</ul>
<h2 id="epoll与select-poll的区别"><a href="#epoll与select-poll的区别" class="headerlink" title="epoll与select/poll的区别"></a>epoll与select/poll的区别</h2><p>   select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪，能够通知程序进行相应的操作。</p>
<p>   select的本质是采用32个整数的32位，即32<em>32= 1024来标识，fd值为1-1024。当fd的值超过1024限制时，就必须修改FD_SETSIZE的大小。这个时候就可以表示32</em>max值范围的fd。</p>
<p>   poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于表示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。</p>
<p>   epoll还是poll的一种优化，返回后不需要对所有的fd进行遍历，在内核中维持了fd的列表。select和poll是将这个内核列表维持在用户态，然后传递到内核中。与poll/select不同，epoll不再是一个单独的系统调用，而是由epoll_create/epoll_ctl/epoll_wait三个系统调用组成，后面将会看到这样做的好处。epoll在2.6以后的内核才支持。</p>
<p><strong>select/poll的几大缺点：</strong></p>
<ul>
<li>每次调用select/poll，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>同时每次调用select/poll都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>针对select支持的文件描述符数量太小了，默认是1024</li>
<li>select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；</li>
<li>select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。</li>
</ul>
<p>相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。</p>
<h2 id="epoll-IO多路复用模型实现机制"><a href="#epoll-IO多路复用模型实现机制" class="headerlink" title="epoll IO多路复用模型实现机制"></a>epoll IO多路复用模型实现机制</h2><p>由于epoll的实现机制与select/poll机制完全不同，上面所说的 select的缺点在epoll上不复存在。</p>
<p>epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p>
<p>如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</p>
<p>但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长</p>
<p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先的select/poll调用分成了3个部分：</p>
<ul>
<li>调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</li>
<li>调用epoll_ctl向epoll对象中添加这100万个连接的套接字</li>
<li>调用epoll_wait收集发生的事件的连接</li>
</ul>
<p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p>
<h2 id="epoll-IO底层实现"><a href="#epoll-IO底层实现" class="headerlink" title="epoll IO底层实现"></a>epoll IO底层实现</h2><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p>
<p><img src="data:image/jpeg;base64,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"></p>
<p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p>
<p>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p>
<p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQdae_utkuyKOqbey3lfFOJz0CHH6V_-QNQ3w&usqp=CAU" alt="Image result for redis epoll底层实现 红黑树"></p>
<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>
<p>优势：</p>
<p><strong>1）. 不用重复传递。</strong></p>
<p>我们调用epoll_wait时就相当于以往调用select/poll，但是这时却不用传递socket句柄给内核，因为内核已经在epoll_ctl中拿到了要监控的句柄列表。</p>
<p> <strong>2）. 在内核里，一切皆文件</strong></p>
<p>epoll向内核注册了一个文件系统，用于存储上述的被监控socket。当你调用epoll_create时，就会在这个虚拟的epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。</p>
<p>epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。</p>
<p> <strong>3）. 极其高效的原因：</strong></p>
<p>这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</p>
<p>当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。从上面这句可以看出，epoll的基础就是回调！ </p>
<p>一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="redis-epoll底层实现红黑树"><a href="#redis-epoll底层实现红黑树" class="headerlink" title="redis epoll底层实现红黑树"></a>redis epoll底层实现红黑树</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/20/database/redis/redis-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/20/database/redis/redis-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">redis-面试问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-02-20 10:22:35 / Modified: 10:33:27" itemprop="dateCreated datePublished" datetime="2021-02-20T10:22:35+08:00">2021-02-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p>【问题】</p>
<ul>
<li>Redis 有哪些数据类型？</li>
<li>Redis 的数据类型分别适用于什么样的场景？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 数据类型和应用\</em></strong></p>
<p>数据类型的特性和应用细节点较多，详情可以参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial/blob/master/docs/nosql/redis/redis-datatype.md">Redis 数据类型(opens new window)</a></p>
</blockquote>
<p>（1）Redis 支持五种基本数据类型：</p>
<ul>
<li>String：常用于 KV 缓存</li>
<li>Hash：存储结构化数据，如：产品信息、用户信息等。</li>
<li>List：存储列表，如：粉丝列表、文章评论列表等。可以通过 lrange 命令进行分页查询。</li>
<li>Set：存储去重列表，如：粉丝列表等。可以基于 set 玩儿交集、并集、差集的操作。例如：求两个人的共同好友列表。</li>
<li>Sorted Set：存储含评分的去重列表，如：各种排行榜。</li>
</ul>
<p>（2）除此以外，还有 Bitmaps、HyperLogLogs、GEO、Streams 等高级数据类型。</p>
<h2 id="Redis-内存淘汰"><a href="#Redis-内存淘汰" class="headerlink" title="#Redis 内存淘汰"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0">#</a>Redis 内存淘汰</h2><p>【问题】</p>
<ul>
<li>Redis 有哪些内存淘汰策略？</li>
<li>这些淘汰策略分别适用于什么场景？</li>
<li>Redis 有哪些删除失效 key 的方法？</li>
<li>如何设置 Redis 中键的过期时间？</li>
<li>如果让你实现一个 LRU 算法，怎么做？</li>
</ul>
<hr>
<p>【解答】</p>
<p>（1）Redis 过期策略是：<strong>定期删除+惰性删除</strong>。</p>
<ul>
<li>消极方法（passive way），在主键被访问时如果发现它已经失效，那么就删除它。</li>
<li>主动方法（active way），定期从设置了失效时间的主键中选择一部分失效的主键删除。</li>
</ul>
<p>（2）Redis 内存淘汰策略：</p>
<ul>
<li><strong><code>noeviction</code></strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。</li>
<li><strong><code>allkeys-lru</code></strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>allkeys-random</code></strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-lru</code></strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>volatile-random</code></strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-ttl</code></strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li>
</ul>
<p>（3）如何选择内存淘汰策略：</p>
<ul>
<li>如果数据呈现幂等分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 <code>allkeys-lru</code>。</li>
<li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 <code>allkeys-random</code>。</li>
<li><code>volatile-lru</code> 策略和 <code>volatile-random</code> 策略适合我们将一个 Redis 实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果。</li>
<li>将 key 设置过期时间实际上会消耗更多的内存，因此我们建议使用 <code>allkeys-lru</code> 策略从而更有效率的使用内存。</li>
</ul>
<p>（4）LRU 算法实现思路：可以继承 LinkedHashMap，并覆写 removeEldestEntry 方法来实现一个最简单的 LRUCache</p>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="#Redis 持久化"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E6%8C%81%E4%B9%85%E5%8C%96">#</a>Redis 持久化</h2><p>【问题】</p>
<ul>
<li>Redis 有几种持久化方式？</li>
<li>Redis 的不同持久化方式的特性和原理是什么？</li>
<li>RDB 和 AOF 各有什么优缺点？分别适用于什么样的场景？</li>
<li>Redis 执行持久化时，可以处理请求吗？</li>
<li>AOF 有几种同步频率？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 持久化\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-persistence.html">Redis 持久化</a></p>
</blockquote>
<p>（1）Redis 支持两种持久化方式：RDB 和 AOF。</p>
<p>（2）RDB 即某一时刻的二进制数据快照。</p>
<p>Redis 会周期性生成 RDB 文件。</p>
<p>生成 RDB 流程：Redis fork 一个子进程，负责生成 RDB；生成 RDB 采用 Copy On Write 模式，此时，如果收到写请求，会在原副本上操作，不影响工作。</p>
<p>RDB 只能恢复生成快照时刻的数据，之后的数据无法恢复。生成 RDB 的资源开销高昂。RDB 适合做冷备。</p>
<p>（3）AOF 会将写命令不断追加到 AOF 文本日志末尾。</p>
<p>AOF 丢数据比 RDB 少，但文件会比 RDB 文件大很多。</p>
<p>一般，AOF 设置 <code>appendfsync</code> 同步频率为 <strong><code>everysec</code></strong> 即可。</p>
<p>（4）RDB or AOF</p>
<p>建议同时使用 RDB 和 AOF。用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="#Redis 事务"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E4%BA%8B%E5%8A%A1">#</a>Redis 事务</h2><p>【问题】</p>
<ul>
<li>Redis 的并发竞争问题是什么？如何解决这个问题？</li>
<li>Redis 支持事务吗？</li>
<li>Redis 事务是严格意义的事务吗？Redis 为什么不支持回滚。</li>
<li>Redis 事务如何工作？</li>
<li>了解 Redis 事务中的 CAS 行为吗？</li>
</ul>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 的事务特性、原理\</em></strong></p>
<p>详情参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-quickstart.html#%E5%85%ADredis-%E4%BA%8B%E5%8A%A1">Redis 应用指南之 事务</a></p>
</blockquote>
<p><strong>Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去</strong>。</p>
<p>Redis 不支持回滚的理由：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p><code>MULTI</code> 、 <code>EXEC</code> 、 <code>DISCARD</code> 和 <code>WATCH</code> 是 Redis 事务相关的命令。</p>
<p>Redis 有天然解决这个并发竞争问题的类 CAS 乐观锁方案：每次要<strong>写之前，先判断</strong>一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>
<h2 id="Redis-管道"><a href="#Redis-管道" class="headerlink" title="#Redis 管道"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E7%AE%A1%E9%81%93">#</a>Redis 管道</h2><p>【问题】</p>
<ul>
<li>除了事务，还有其他批量执行 Redis 命令的方式吗？</li>
</ul>
<p>【解答】</p>
<p>Redis 是一种基于 C/S 模型以及请求/响应协议的 TCP 服务。Redis 支持管道技术。管道技术允许请求以异步方式发送，即旧请求的应答还未返回的情况下，允许发送新请求。这种方式可以大大提高传输效率。使用管道发送命令时，Redis Server 会将部分请求放到缓存队列中（占用内存），执行完毕后一次性发送结果。如果需要发送大量的命令，会占用大量的内存，因此应该按照合理数量分批次的处理。</p>
<h2 id="Redis-高并发"><a href="#Redis-高并发" class="headerlink" title="#Redis 高并发"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E9%AB%98%E5%B9%B6%E5%8F%91">#</a>Redis 高并发</h2><p>【问题】</p>
<ul>
<li>Redis 是单线程模型，为何吞吐量还很高？</li>
<li>Redis 的 IO 多路复用原理是什么？</li>
<li>Redis 集群如何分片和寻址？</li>
<li>Redis 集群如何扩展？</li>
<li>Redis 集群如何保证数据一致？</li>
<li>Redis 集群如何规划？你们公司的生产环境上如何部署 Redis 集群？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 集群\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-cluster.html">Redis 集群</a></p>
</blockquote>
<p>（1）单线程</p>
<p>Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 单机吞吐量也很高，能达到几万 QPS。</p>
<p>Redis 单线程模型，依然有很高的并发吞吐，原因在于：</p>
<ul>
<li>Redis 读写都是内存操作。</li>
<li>Redis 基于<strong>非阻塞的 IO 多路复用机制</strong>，同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</li>
<li>单线程，避免了线程创建、销毁、上下文切换的开销，并且避免了资源竞争。</li>
</ul>
<p>（2）扩展并发吞吐量、存储容量</p>
<p>Redis 的高性能（扩展并发吞吐量、存储容量）通过主从架构来实现。</p>
<p>Redis 集群采用主从模型，提供复制和故障转移功能，来保证 Redis 集群的高可用。通常情况，一主多从模式已经可以满足大部分项目的需要。根据实际的并发量，可以通过增加节点来扩展并发吞吐。</p>
<p>一主多从模式下，主节点负责写操作（单机几万 QPS），从节点负责查询操作（单机十万 QPS）。</p>
<p>进一步，如果需要缓存大量数据，就需要分区（sharding）。Redis 集群通过划分虚拟 hash 槽来分片，每个主节点负责一定范围的 hash 槽。当需要扩展集群节点时，重新分配 hash 槽即可，redis-trib 会自动迁移变更 hash 槽中所属的 key。</p>
<p>（3）Redis 集群数据一致性</p>
<p>Redis 集群基于复制特性实现节点间的数据一致性。</p>
<h2 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="#Redis 复制"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E5%A4%8D%E5%88%B6">#</a>Redis 复制</h2><p>【问题】</p>
<ul>
<li>Redis 复制的工作原理？Redis 旧版复制和新版复制有何不同？</li>
<li>Redis 主从节点间如何复制数据？</li>
<li>Redis 的数据一致性是强一致性吗？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 复制\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-replication.html">Redis 复制</a></p>
</blockquote>
<p>（1）旧版复制基于 <code>SYNC</code> 命令实现。分为同步（sync）和命令传播（command propagate）两个操作。这种方式存在缺陷：不能高效处理断线重连后的复制情况。</p>
<p>（2）新版复制基于 <code>PSYNC</code> 命令实现。同步操作分为了两块：</p>
<ul>
<li><p><strong><code>完整重同步（full resychronization）</code></strong> 用于初次复制；</p>
</li>
<li><p><code>部分重同步（partial resychronization）</code></p>
</li>
</ul>
<p>  用于断线后重复制。</p>
<ul>
<li>主从服务器的<strong>复制偏移量（replication offset）</strong></li>
<li>主服务器的<strong>复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行 ID</strong></li>
</ul>
<p>（3）Redis 集群主从节点复制的工作流程：</p>
<ul>
<li>步骤 1. 设置主从服务器</li>
<li>步骤 2. 主从服务器建立 TCP 连接。</li>
<li>步骤 3. 发送 PING 检查通信状态。</li>
<li>步骤 4. 身份验证。</li>
<li>步骤 5. 发送端口信息。</li>
<li>步骤 6. 同步。</li>
<li>步骤 7. 命令传播。</li>
</ul>
<h2 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="#Redis 哨兵"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E5%93%A8%E5%85%B5">#</a>Redis 哨兵</h2><p>【问题】</p>
<ul>
<li>Redis 如何实现高可用？</li>
<li>Redis 哨兵的功能？</li>
<li>Redis 哨兵的原理？</li>
<li>Redis 哨兵如何选举 Leader？</li>
<li>Redis 如何实现故障转移？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 哨兵\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-sentinel.html">Redis 哨兵</a></p>
</blockquote>
<p>（1）Redis 的高可用是通过哨兵来实现（Raft 协议的 Redis 实现）。Sentinel（哨兵）可以监听主服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<p>由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200131135847.png" alt="img"></p>
<h2 id="Redis-vs-Memcached"><a href="#Redis-vs-Memcached" class="headerlink" title="#Redis vs. Memcached"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-vs-memcached">#</a>Redis vs. Memcached</h2><p>【问题】</p>
<p>Redis 和 Memcached 有什么区别？</p>
<p>分布式缓存技术选型，选 Redis 还是 Memcached，为什么？</p>
<p>Redis 和 Memcached 各自的线程模型是怎样的？</p>
<p>为什么单线程的 Redis 性能却不输于多线程的 Memcached？</p>
<p>【解答】</p>
<p>Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。memcache 支持简单的数据类型，String。</p>
<p>Redis 支持数据的备份，即 master-slave 模式的数据备份。</p>
<p>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中</p>
<p>redis 的速度比 memcached 快很多</p>
<p>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的 IO 复用模型。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d7773080d4570?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis与Memcached的区别与比较"></p>
<p>如果想要更详细了解的话，可以查看慕课网上的这篇手记（非常推荐） <strong>：《脚踏两只船的困惑 - Memcached 与 Redis》</strong>：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/23549">www.imooc.com/article/23549(opens new window)</a></p>
<p><strong>终极策略：</strong> 使用 Redis 的 String 类型做的事，都可以用 Memcached 替换，以此换取更好的性能提升； 除此以外，优先考虑 Redis；</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/19/database/redis/redis-6-%E9%94%81%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/19/database/redis/redis-6-%E9%94%81%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">redis-6-锁与常见缓存问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-19 17:54:12" itemprop="dateCreated datePublished" datetime="2021-02-19T17:54:12+08:00">2021-02-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-14 10:22:17" itemprop="dateModified" datetime="2021-03-14T10:22:17+08:00">2021-03-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis实现乐观锁"><a href="#Redis实现乐观锁" class="headerlink" title="Redis实现乐观锁"></a>Redis实现乐观锁</h1><h2 id="Redis乐观锁"><a href="#Redis乐观锁" class="headerlink" title="Redis乐观锁"></a>Redis乐观锁</h2><p>乐观锁基于CAS(Compare And Swap)思想(比较并替换)，是不具有互斥性，不会产生锁等待而消 耗资源，但是需要反复的重试，但也是因为重试的机制，能比较快的响应。因此我们可以利用redis来 实现乐观锁。</p>
<p>具体思路如下:</p>
<ul>
<li>监控 锁定量</li>
<li>如果该值被修改成功则表示该请求被通过， 反之表示该请求未通过。</li>
<li>从监控到修改到执行都需要在redis里操作，这样就需要用 到Redis事务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String watchKeys = <span class="string">&quot;watchKeys&quot;</span>; </span><br><span class="line">        <span class="comment">//初始值 </span></span><br><span class="line">        value=<span class="number">1</span> jedis.set(watchKeys, <span class="number">1</span>); </span><br><span class="line">        <span class="comment">//监听key为watchKeys的值 </span></span><br><span class="line">      	jedis.watch(watchkeys);</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        Transaction tx = jedis.multi();</span><br><span class="line">        <span class="comment">//watchKeys自增加一 </span></span><br><span class="line">      	tx.incr(watchKeys);</span><br><span class="line">        <span class="comment">//执行事务，如果其他线程对watchKeys中的value进行修改，则该事务将不会执行 </span></span><br><span class="line">      	<span class="comment">//通过redis事务以及watch命令实现乐观锁</span></span><br><span class="line">        List&lt;Object&gt; exec = tx.exec();</span><br><span class="line">        <span class="keyword">if</span> (exec == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;事务未执行&quot;</span>); &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;事务成功执行，watchKeys的value成功修改&quot;</span>); &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis乐观锁实现秒杀"><a href="#Redis乐观锁实现秒杀" class="headerlink" title="Redis乐观锁实现秒杀"></a>Redis乐观锁实现秒杀</h2><p>在生产环境里，经常会利用redis乐观锁来实现秒杀，Redis乐观锁是Redis事务的经典应用。</p>
<p>由于秒杀只有少部分请求能够成功，而大量的请求是并发产生的，所以如何确定哪个请求成功了，就是 由redis乐观锁来实现。</p>
<p>具体思路如下:</p>
<ul>
<li>监控锁定量，如果该值被修改了，那么则会失败，反之，成功。<a href="">用户首先尝试获取秒杀的资格。(通过事务watch()函数)</a></li>
<li><a href="">用户获取秒杀资格后，再去检查库存是否有库存(通过事务检查库存)</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKill</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//库存key</span></span><br><span class="line">          String redisKey = <span class="string">&quot;stock&quot;</span>;</span><br><span class="line">          ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6378</span>); </span><br><span class="line">              <span class="comment">// 可以被秒杀的库存的初始值，库存总共20个 </span></span><br><span class="line">              jedis.set(redisKey, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">              jedis.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">          executorService.execute(() -&gt; &#123;</span><br><span class="line">            Jedis jedis1 = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6378</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jedis1.watch(redisKey);<span class="comment">//乐观锁的核心业务</span></span><br><span class="line">                String redisValue = jedis1.get(redisKey);</span><br><span class="line">                <span class="keyword">int</span> valInteger = Integer.valueOf(redisValue);</span><br><span class="line">                String userInfo = UUID.randomUUID().toString();</span><br><span class="line">                <span class="comment">//用户成功获取抢夺的资格，然后检查库存量</span></span><br><span class="line">                <span class="keyword">if</span> (valInteger &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                    Transaction tx = jedis1.multi(); </span><br><span class="line">                  	tx.incr(redisKey);</span><br><span class="line">                    List list = tx.exec();</span><br><span class="line">                    <span class="comment">// 秒成功 失败返回空list而不是空</span></span><br><span class="line">                    <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;用户:&quot;</span> + userInfo + <span class="string">&quot;，秒杀成功!当前成功人数:&quot;</span> +(valInteger + <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 版本变化，被别人抢了。 </span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;用户:&quot;</span> + userInfo + <span class="string">&quot;，秒杀失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 秒完了 </span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;已经有20人秒杀成功，秒杀结束&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              	e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              	jedis1.close();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>



<h1 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h1><ul>
<li>单应用中使用锁(单进程多线程)： synchronized、ReentrantLock </li>
<li>分布式应用中使用锁(多进程多线程) ：分布式锁是控制分布式系统之间同步访问共享资源的一种方式</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用Redis的单线程特性对共享资源进行串行化处理</p>
<h2 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h2><h3 id="方式1（使用set命令实现）–推荐"><a href="#方式1（使用set命令实现）–推荐" class="headerlink" title="方式1（使用set命令实现）–推荐"></a>方式1（使用set命令实现）–推荐</h3><ul>
<li>“NX”:没有键值则设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 使用redis的set命令实现获取分布式锁 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> lockKey 可以就是锁 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> requestId 请求ID，保证同一性 uuid+threadID </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> expireTime 过期时间，避免死锁 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String lockKey,String requestId,<span class="keyword">int</span> expireTime)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//NX:保证互斥性 // hset 原子性操作 </span></span><br><span class="line">    String result = jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTime); </span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;OK&quot;</span>.equals(result)) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方式2（使用setnx命令实现）-–-并发会产生问题"><a href="#方式2（使用setnx命令实现）-–-并发会产生问题" class="headerlink" title="方式2（使用setnx命令实现） – 并发会产生问题"></a>方式2（使用setnx命令实现） – 并发会产生问题</h3><p><a href="">因为2个redis操作，即设置key和设置expireTime，不是原子性的复合操作，所以会有并发问题</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String lockKey,String requestId,<span class="keyword">int</span> expireTime)</span> </span>&#123; </span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId); </span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//成功设置 失效时间 </span></span><br><span class="line">        jedis.expire(lockKey, expireTime); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><h3 id="方式1（del命令实现）-–-并发会产生问题"><a href="#方式1（del命令实现）-–-并发会产生问题" class="headerlink" title="方式1（del命令实现） – 并发会产生问题"></a>方式1（del命令实现） – 并发会产生问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 释放分布式锁 * <span class="doctag">@param</span> lockKey * <span class="doctag">@param</span> requestId */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(String lockKey,String requestId)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123; </span><br><span class="line">        jedis.del(lockKey); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题在于如果调用jedis.del()方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的 锁。</p>
<p>那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行 jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将 客户端B的锁给解除了。</p>
</blockquote>
<h3 id="方式2（redis-lua脚本实现）–-推荐"><a href="#方式2（redis-lua脚本实现）–-推荐" class="headerlink" title="方式2（redis+lua脚本实现）– 推荐"></a>方式2（redis+lua脚本实现）– 推荐</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String lockKey, String requestId)</span> </span>&#123; </span><br><span class="line">    String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); </span><br><span class="line">    <span class="keyword">if</span> (result.equals(<span class="number">1L</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Redis常见缓存问题"><a href="#Redis常见缓存问题" class="headerlink" title="Redis常见缓存问题"></a>Redis常见缓存问题</h1><h2 id="数据读"><a href="#数据读" class="headerlink" title="数据读"></a>数据读</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote>
<p>查询缓存中永远不存在的一个值。因为这个值数据库没有。 </p>
</blockquote>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。</p>
<p>也就是说，对不存在的key进行高并发访问，导致数据库压力瞬间增大，这就叫做【缓存穿透】。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方案：</span><br><span class="line"></span><br><span class="line">对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</span><br></pre></td></tr></table></figure>

<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>大量缓存集中失效。 </p>
<p>大量数据访问压力一下怼到数据库身上 </p>
</blockquote>
<p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。</p>
<p>突然间大量的key失效了或redis重启，大量访问数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解决方案:</span><br><span class="line"></span><br><span class="line">1、 key的失效期分散开 不同的key设置不同的有效期</span><br><span class="line"></span><br><span class="line">2、设置二级缓存</span><br><span class="line"></span><br><span class="line">3、高可用</span><br></pre></td></tr></table></figure>

<h3 id="缓存穿透-1"><a href="#缓存穿透-1" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote>
<p>单个缓存有效期到了，失效了。 </p>
<p>而且在这个时间点有大量的请求进来（导致这些请求都访问到数据库）。 </p>
</blockquote>
<p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p>
<p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用分布式锁控制访问的线程</span><br><span class="line"></span><br><span class="line">使用redis的setnx互斥锁先进行判断，这样其他线程就处于等待状态，保证不会有大并发操作去操作数据库。</span><br><span class="line"></span><br><span class="line">if(redis.sexnx()&#x3D;&#x3D;1)&#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;先查询缓存</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;查询数据库</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;加入缓存</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">不设超时时间，写一致问题</span><br></pre></td></tr></table></figure>

<h2 id="数据写"><a href="#数据写" class="headerlink" title="数据写"></a>数据写</h2><blockquote>
<p>数据不一致的根源 ： 数据源不一样</p>
</blockquote>
<p>如何解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">强一致性很难，追求最终一致性</span><br><span class="line">互联网业务数据处理的特点</span><br><span class="line">高吞吐量</span><br><span class="line">低延迟</span><br><span class="line">数据敏感性低于金融业</span><br><span class="line">时序控制是否可行？</span><br><span class="line">先更新数据库再更新缓存或者先更新缓存再更新数据库</span><br><span class="line">本质上不是一个原子操作，所以时序控制不可行</span><br><span class="line">保证数据的最终一致性(延时双删)</span><br><span class="line">1、先更新数据库同时删除缓存项(key)，等读的时候再填充缓存</span><br><span class="line">2、2秒后再删除一次缓存项(key)</span><br><span class="line">3、设置缓存过期时间 Expired Time 比如 10秒 或1小时</span><br><span class="line">4、将缓存删除失败记录到日志中，利用脚本提取失败记录再次删除（缓存失效期过长 7*24）</span><br></pre></td></tr></table></figure>

<p>升级方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过数据库的binlog来异步淘汰key，利用工具(canal)将binlog日志采集发送到MQ中，然后通过ACK机制确认处理删除缓存。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/19/database/mysql/mysql-0-MySQL%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/19/database/mysql/mysql-0-MySQL%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">mysql-MySQL语法与安装</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-02-19 16:52:09 / Modified: 17:19:54" itemprop="dateCreated datePublished" datetime="2021-02-19T16:52:09+08:00">2021-02-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MYSQL安装"><a href="#MYSQL安装" class="headerlink" title="MYSQL安装"></a>MYSQL安装</h1><p>查看MySQL软件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum remove -y mysql mysql-libs mysql-common #卸载mysql</span><br><span class="line">rm -rf /var/lib/mysql #删除mysql下的数据文件</span><br><span class="line">rm /etc/my.cnf #删除mysql配置文件</span><br><span class="line">yum remove -y mysql-community-release-el6-5.noarch #删除组件</span><br></pre></td></tr></table></figure>

<p>安装MySQL</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载rpm文件</span></span><br><span class="line">wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpm #执行rpm源文件</span><br><span class="line">rpm -ivh mysql-community-release-el6-5.noarch.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash">执行安装文件</span></span><br><span class="line">yum install mysql-community-server</span><br></pre></td></tr></table></figure>

<p>启动MySQL</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>

<p>设置root用户密码<br>例如:为 root 账号设置密码为 root :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/mysqladmin -u root password &#x27;root&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">没有密码 有原来的密码则加</span></span><br><span class="line">/usr/bin/mysqladmin -u root -p &#x27;123&#x27; password &#x27;root&#x27;</span><br></pre></td></tr></table></figure>



<p>登录mysql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot</span><br></pre></td></tr></table></figure>

<p>配置mysql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;my.cnf</span><br></pre></td></tr></table></figure>

<p>MySQL远程连接授权</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39; WITH GRANT OPTION;</span><br><span class="line">FLUSH PRIVILEGES;--刷新权限</span><br></pre></td></tr></table></figure>

<ul>
<li>ALL PRIVILEGES :表示授予所有的权限，此处可以指定具体的授权权限。</li>
<li><em>.</em> :表示所有库中的所有表</li>
<li>‘root’@’%’ : myuser是数据库的用户名，%表示是任意ip地址，可以指定具体ip地址。</li>
<li>IDENTIFIED BY ‘mypassword’ :mypassword是数据库的密码。</li>
</ul>
<h1 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a><strong>DDL</strong>语句</h1><p>创建数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库名 character set 字符集;</span><br></pre></td></tr></table></figure>

<p>…</p>
<h1 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h1><p>更新记录、插入、删除:update</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段名&#x3D;值,字段名&#x3D;值 where 条件;</span><br></pre></td></tr></table></figure>

<h1 id="DQL语句"><a href="#DQL语句" class="headerlink" title="DQL语句"></a>DQL语句</h1><p>查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select pname,price from product;</span><br></pre></td></tr></table></figure>

<p><strong>聚合函数(组函数)</strong></p>
<p>  特点:只对单列进行操作</p>
<p>常用的聚合函数:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum():求某一列的和 </span><br><span class="line">avg():求某一列的平均值 </span><br><span class="line">max():求某一列的最大值 </span><br><span class="line">min():求某一列的最小值 </span><br><span class="line">count():求某一列的元素个数</span><br></pre></td></tr></table></figure>



<h1 id="SQL解析顺序"><a href="#SQL解析顺序" class="headerlink" title="SQL解析顺序"></a>SQL解析顺序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 行过滤</span><br><span class="line">FROM &lt;left_table&gt;</span><br><span class="line">ON &lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; JOIN &lt;right_table&gt; </span><br><span class="line">WHERE &lt;where_condition&gt;</span><br><span class="line">GROUP BY &lt;group_by_list&gt;</span><br><span class="line">HAVING &lt;having_condition&gt; </span><br><span class="line"></span><br><span class="line">--列过滤</span><br><span class="line">SELECT</span><br><span class="line">DISTINCT &lt;select_list&gt;</span><br><span class="line"></span><br><span class="line">--排序</span><br><span class="line">9 ORDER BY &lt;order_by_condition&gt; -- MySQL附加</span><br><span class="line">10 LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>如果使用 LEFT JOIN ，则主表在它左边</li>
<li>如果使用 RIGHT JOIN ，则主表在它右边</li>
<li>查询结果以主表为主，从表记录匹配不到，则补 null</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM(将最近的两张表，进行笛卡尔积)---VT1</span><br><span class="line">ON(将VT1按照它的条件进行过滤)---VT2</span><br><span class="line">LEFT JOIN(保留左表的记录)---VT3</span><br><span class="line">WHERE(过滤VT3中的记录)--VT4...VTn</span><br><span class="line">GROUP BY(对VT4的记录进行分组)---VT5</span><br><span class="line">HAVING(对VT5中的记录进行过滤)---VT6</span><br><span class="line">SELECT(对VT6中的记录，选取指定的列)--VT7</span><br><span class="line">ORDER BY(对VT7的记录进行排序)--VT8</span><br><span class="line">LIMIT(对排序之后的值进行分页)--MySQL特有的语法</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/18/Christ/%E4%B8%BB%E6%97%A5%E8%AE%B2%E9%81%93/2021-02-28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/Christ/%E4%B8%BB%E6%97%A5%E8%AE%B2%E9%81%93/2021-02-28/" class="post-title-link" itemprop="url">2021-02-28主日讲道</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-18 13:54:56" itemprop="dateCreated datePublished" datetime="2021-02-18T13:54:56+08:00">2021-02-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-02-28 11:28:19" itemprop="dateModified" datetime="2021-02-28T11:28:19+08:00">2021-02-28</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>《拓展神国》 于宏杰</p>
<p>被神的爱激励，是我们敬拜神、亲近神的动力</p>
<blockquote>
<p>伊甸园的后遗症：我们在罪中，属于亚当的</p>
<ul>
<li>我们的家庭一直under attack by our enenmy</li>
</ul>
<p>客西马尼园：耶稣基督给了我们盼望</p>
</blockquote>
<p>神的国：</p>
<ul>
<li>属灵的实际：神的旨意、耶稣的心意、圣灵的工作</li>
<li>神国的实际：神的旨意、耶稣的心意、圣灵的工作通过我们彰显<ul>
<li>小到不和妻子吵架</li>
<li>大到为神xundao</li>
</ul>
</li>
</ul>
<p>使徒行传：圣灵的带领</p>
<ul>
<li>一个不变的属灵原则：<ul>
<li>人种的是什么，收的就是什么（加拉太书）<ul>
<li>比如我没有朋友，因为我们没有花时间和朋友交流</li>
<li>比如我没有快乐，因为我们没有感恩</li>
</ul>
</li>
<li>少种的少收，多种的多收，<font color="red">这话是真的</font>（哥林多）</li>
</ul>
</li>
</ul>
<blockquote>
<p>这两句话能不能顺序颠倒？</p>
<ul>
<li>属世界的人也知道第二句话，为了金钱、为了名利、为了自己，不断的种。但是他们不知道种的是什么。</li>
<li>我们必须首先知道我们要种的是什么。</li>
</ul>
</blockquote>
<ul>
<li>每次遵从圣灵，我们就是在圣灵里的撒种</li>
<li>神国的拓展是圣灵的工作<ul>
<li>不过是托付给教会，托付给我们百姓</li>
<li>不是我们自己做，圣灵通过我们做工作<ul>
<li>比如电风扇不是自己转，而是电驱动</li>
<li>比如我们用吸尘器打扫家很仔细，但是吸尘器却没有插电源。这就是仇敌的工作</li>
<li>仇敌惧怕的是地与天结合，惧怕我们与圣灵结合</li>
</ul>
</li>
<li>主耶稣：但圣灵降临在你们身上，你们就必得着能力。所以我们自己没有能力，但是圣灵给我们能力</li>
<li>初期教会面临着各种困难，甚至丧命<ul>
<li>当我们与神的关系不对，我们什么都做不对。而且我们会将自己微小的困难巨大化。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>我们是有影响力的</p>
<ul>
<li>我们2、3个人奉主的名祷告，神必与我们同在</li>
</ul>
<p>我们的影响力必须是正面的、洁净的</p>
<ul>
<li>我们时常造成负面影响，比如背后议论</li>
</ul>
<p>我们的影响力必须要扩大</p>
<ul>
<li>耶路撒冷被不断鞭打，使徒走出去，福音拓展</li>
<li>外面充满了需要</li>
<li>我们不要在自己的舒适区，我们知道的够多了，但是<font color="red">我们知道的是真的</font></li>
</ul>
</blockquote>
<p>圣灵的水流，就是圣灵的工作（以西结书）</p>
<ul>
<li>所到之处，带来改变、带来生命</li>
</ul>
<p>圣灵是神赐给顺从之人</p>
<ul>
<li>基督借着圣灵内住在我们身上</li>
<li>客观真理，圣灵永远在我们身上</li>
<li>主观来说，我们常常没有经历圣灵的喜乐</li>
<li>顺从圣灵的，乃是平安；顺从肉体的，乃是死</li>
<li>神只在乎我愿不愿意顺服，做光</li>
</ul>
<p>榜样</p>
<blockquote>
<ul>
<li>安提阿教会作为榜样<ul>
<li>他们侍奉主禁食，放弃了最理所当然的神赐给我们的权利<ul>
<li>为了在主面前有影响力、为了破坏敌人的工作</li>
</ul>
</li>
<li>圣灵不是一种supernature的经历、能力（可能是邪恶的灵），而是有位格的<ul>
<li>「他们侍奉主、禁食的时候，圣灵说：“<em>要为我分派巴拿巴</em>和扫罗，去做我召他们所做的工。” 」</li>
</ul>
</li>
</ul>
</li>
<li>保罗的榜样<ul>
<li><font color="red">圣灵不许，耶稣禁止</font>。保罗听从。也是我们需要学的，顺服圣灵说的no</li>
<li>神从来不轻看我们的顺服</li>
</ul>
</li>
</ul>
</blockquote>
<p>我们在职场上做榜样</p>
<ul>
<li>要有使命感，换工作是为了建立神的国<ul>
<li>比如泰国的职场弟兄，换一次工作就建立一个职场教会</li>
</ul>
</li>
<li>不要追求更好的生活，否则就被巴比伦掳走了</li>
<li>「活物的灵在轮中(以西结书)」：灵无论往在哪里去，我们都跟随。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
