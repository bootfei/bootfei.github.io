<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/7/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-03-%E8%A7%A3%E5%86%B3%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%92%8C%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-03-%E8%A7%A3%E5%86%B3%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%92%8C%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B/" class="post-title-link" itemprop="url">kafka-03-保障消息有序性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-27 19:20:31" itemprop="dateCreated datePublished" datetime="2021-05-27T19:20:31+08:00">2021-05-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h2><h3 id="为什么要保证消息的顺序"><a href="#为什么要保证消息的顺序" class="headerlink" title="为什么要保证消息的顺序"></a>为什么要保证消息的顺序</h3><p>订单有很多状态，比如：下单、支付、完成、撤销等，不可能<code>下单</code>的消息都没读取到，就先读取<code>支付</code>或<code>撤销</code>的消息吧，如果真的这样，数据产生错乱</p>
<h3 id="如何保证消息顺序"><a href="#如何保证消息顺序" class="headerlink" title="如何保证消息顺序"></a>如何保证消息顺序</h3><h4 id="方案1：producer端只写固定的partition（有缺陷）"><a href="#方案1：producer端只写固定的partition（有缺陷）" class="headerlink" title="方案1：producer端只写固定的partition（有缺陷）"></a>方案1：producer端只写固定的partition（有缺陷）</h4><p><code>kafka</code>的<code>topic</code>是无序的，但是一个<code>topic</code>包含多个<code>partition</code>，每个<code>partition</code>内部是有序的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqOzug1A48UnG15tonQ3wBkbB5yicVnHpydn5Hq2PwiawKTVj8Vk6DB7sQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>只要保证生产者写消息时，按照一定的规则写到同一个<code>partition</code>，不同的消费者读不同的<code>partition</code>的消息，就能保证生产和消费者消息的顺序。</p>
<p>同一个<code>商户编号</code>的消息写到同一个<code>partition</code>，<code>topic</code>中创建了<code>4</code>个<code>partition</code>，然后部署了<code>4</code>个消费者节点，构成<code>消费者组</code>，一个<code>partition</code>对应一个消费者节点。从理论上说，这套方案是能够保证消息顺序的。<img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqrza43TUBKePfwRPaSrtSJiclN6ibdof2qKwyhIfGoicR4Z6C2icQP5vWuA/640" alt="Image"></p>
<p><strong>优点</strong></p>
<ul>
<li>保障了producer发送信息的时候，是有序的</li>
</ul>
<p><strong>缺陷</strong></p>
<ul>
<li>不能保障Topic的partition接收信息，是有序的。比如，公司在那段时间网络经常不稳定，业务接口时不时报超时，业务请求时不时会连不上数据库，某条数据丢失了；还有，因为网络原因，最早发送的信息，最晚被topic接收 <!--不过，可以通过topic发送ack解决--></li>
</ul>
<h4 id="方案2：producer端异步失败重试，consumer端做判断"><a href="#方案2：producer端异步失败重试，consumer端做判断" class="headerlink" title="方案2：producer端异步失败重试，consumer端做判断"></a>方案2：producer端异步失败重试，consumer端做判断</h4><p><code>同步重试机制</code>在出现异常的情况，会严重影响消息消费者的消费速度，降低它的吞吐量。</p>
<p>如果用<code>异步重试机制</code>，处理失败的消息就得保存到<code>重试表</code>下来。</p>
<p>但有个新问题立马出现：<strong>只存一条消息如何保证顺序？</strong></p>
<p>存一条消息的确无法保证顺序，假如：”下单“消息失败了，还没来得及异步重试。此时，”支付“消息被消费了，它肯定是不能被正常消费的。</p>
<p>这时有种更简单的方案浮出水面：消费者在处理消息时，先判断该<code>订单号</code>在<code>重试表</code>有没有数据，如果有则直接把当前消息保存到<code>重试表</code>。如果没有，则进行业务处理，如果出现异常，把该消息保存到<code>重试表</code>。</p>
<p>后来我们用<code>elastic-job</code>建立了<code>失败重试机制</code>，如果重试了<code>7</code>次后还是失败，则将该消息的状态标记为<code>失败</code>，发邮件通知开发人员。</p>
<h2 id="消息挤压"><a href="#消息挤压" class="headerlink" title="消息挤压"></a>消息挤压</h2><h3 id="挤压原因1：消息体过大"><a href="#挤压原因1：消息体过大" class="headerlink" title="挤压原因1：消息体过大"></a>挤压原因1：消息体过大</h3><p>一次简单的消息从生产到消费过程，需要经过<code>2次网络IO</code>和<code>2次磁盘IO</code>。如果消息体过大，势必会增加IO的耗时，进而影响kafka生产和消费的速度。消费者速度太慢的结果，就会出现消息积压情况。</p>
<p>可以这样设计了：</p>
<ol>
<li>订单系统发送的消息体只用包含：id和状态等关键信息。</li>
<li>后厨显示系统消费消息后，通过id调用订单系统的订单详情查询接口获取数据。</li>
<li>后厨显示系统判断数据库中是否有该订单的数据，如果没有则入库，有则更新。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqib2hB0qSIXBPjxAH1vZQbn97tcMKQBmWBDL1Rc1ytjLXoXcCPic301pQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="挤压原因2：路由规则不合理"><a href="#挤压原因2：路由规则不合理" class="headerlink" title="挤压原因2：路由规则不合理"></a>挤压原因2：路由规则不合理</h3><p>不是所有<code>partition</code>上的消息都有积压，而是只有一个。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqdaENvsBRclJSZ2zvNoXxfpDS9IgJvpM6icibHB8Y32Jt4khMicw7wictmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>刚开始，我以为是消费那个<code>partition</code>消息的节点出了什么问题导致的。但是经过排查，没有发现任何异常。</p>
<p>发现，有几个商户的订单量特别大，刚好这几个商户被分到同一个<code>partition</code>，使得该<code>partition</code>的消息量比其他<code>partition</code>要多很多。</p>
<p>这时我们才意识到，发消息时按<code>商户编号</code>路由<code>partition</code>的规则不合理，可能会导致有些<code>partition</code>消息太多，消费者处理不过来，而有些<code>partition</code>却因为消息太少，消费者出现空闲的情况。</p>
<p>为了避免出现这种分配不均匀的情况，我们需要对发消息的路由规则做一下调整。</p>
<p>用订单号做路由相对更均匀，不会出现单个订单发消息次数特别多的情况。除非是遇到某个人一直加菜的情况，但是加菜是需要花钱的，所以其实同一个订单的消息数量并不多。调整后按<code>订单号</code>路由到不同的<code>partition</code>，同一个订单号的消息，每次到发到同一个<code>partition</code>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqoJO69ia8Fv9p1uc0HEHaJcYg85VaBlsHm25ubexHCFmmicbVWsN6IACA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="如何处理消息挤压？"><a href="#如何处理消息挤压？" class="headerlink" title="如何处理消息挤压？"></a>如何处理消息挤压？</h3><p>每个<code>partition</code>都积压了<code>十几万</code>的消息没有消费，比以往加压的消息数量增加了<code>几百倍</code>。</p>
<p>原来是有其他业务在JOB中批量发消息导致的问题导致。</p>
<p><strong>积压的这<code>十几万</code>的消息该如何处理呢？</strong></p>
<ul>
<li><p>直接调大<code>partition</code>数量是不行的，历史消息已经存储到4个固定的<code>partition</code>，只有新增的消息才会到新的<code>partition</code>。我们重点需要处理的是已有的partition。</p>
</li>
<li><p>直接加<code>consumer</code>服务节点也不行，因为<code>kafka</code>允许同topic的多个<code>partition</code>被一个<code>consumer</code>消费，但不允许一个<code>partition</code>被同组的多个<code>consumer</code>消费，可能会造成资源浪费。</p>
</li>
<li><p>用多线程处理，改成了用<code>线程池</code>处理消息，核心线程和最大线程数都配置成了<code>50</code>。线程数是可以通过<code>zookeeper</code>动态调整的</p>
</li>
</ul>
<img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqt9gnrBjrNqmrxqjJlghuZszz8ibdGic6KbthGAdYX8yqkSibxFlH1ibFeA/640" alt="图片" style="zoom:50%;" />

<p>顺便说一下，<a href="">对于要求严格保证消息顺序的场景，可以将线程池改成多个队列，每个队列用单线程处理</a>。</p>
<h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p><code>kafka</code>消费消息时支持三种模式：</p>
<ul>
<li>at most once模式 最多一次。保证每一条消息commit成功之后，再进行消费处理。消息可能会丢失，但不会重复。</li>
<li>at least once模式 至少一次。保证每一条消息处理成功之后，再进行commit。消息不会丢失，但可能会重复。</li>
<li>exactly once模式 精确传递一次。将offset作为唯一id与消息同时处理，并且保证处理的原子性。消息只会处理一次，不丢失也不会重复。但这种方式很难做到。</li>
</ul>
<p><code>kafka</code>默认的模式是<code>at least once</code>，但这种模式可能会产生<a href="">重复消费</a>的问题，所以我们的业务逻辑必须做<a href="">幂等设计</a>。</p>
<p>而我们的业务场景保存数据时使用了<code>INSERT INTO ...ON DUPLICATE KEY UPDATE</code>语法，不存在时插入，存在时更新，是天然支持幂等性的。</p>
<h2 id="多环境消费问题"><a href="#多环境消费问题" class="headerlink" title="多环境消费问题"></a>多环境消费问题</h2><p>我们当时线上环境分为：<code>pre</code>(预发布环境) 和 <code>prod</code>(生产环境)，两个环境共用同一个数据库，并且共用同一个kafka集群。</p>
<p>需要注意的是，在配置<code>kafka</code>的<code>topic</code>的时候，要加前缀用于区分不同环境。pre环境的以pre_开头，比如：pre_order，生产环境以prod_开头，比如：prod_order，防止消息在不同环境中串了。</p>
<p>但有次运维在<code>pre</code>环境切换节点，配置<code>topic</code>的时候，配错了，配成了<code>prod</code>的<code>topic</code>。刚好那天，我们有新功能上<code>pre</code>环境。结果悲剧了，<code>prod</code>的有些消息被<code>pre</code>环境的<code>consumer</code>消费了，而由于消息体做了调整，导致<code>pre</code>环境的<code>consumer</code>处理消息一直失败。</p>
<p>其结果是生产环境丢了部分消息。不过还好，最后生产环境消费者通过重置<code>offset</code>，重新读取了那一部分消息解决了问题，没有造成太大损失。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/Quartz-%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/Quartz-%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Quartz-集群原理分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-26 14:44:16" itemprop="dateCreated datePublished" datetime="2021-05-26T14:44:16+08:00">2021-05-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Quartz集群部署实践"><a href="#Quartz集群部署实践" class="headerlink" title="Quartz集群部署实践"></a>Quartz集群部署实践</h2><p>CRM中Quartz与Spring结合使用，Spring通过提供org.springframework.scheduling.quartz下的封装类对Quartz支持。</p>
<p><strong>Quartz集群部署：</strong></p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/c45f767d.png" alt="Quartz集群部署"></p>
<p>Quartz集群中的每个节点是一个独立的Quartz应用，它又管理着其他的节点。该集群需要分别对每个节点分别启动或停止，不像应用服务器的集群，独立的Quartz节点并不与另一个节点或是管理节点通信。Quartz应用是通过数据库表来感知到另一应用。只有使用持久的JobStore才能完成Quqrtz集群。</p>
<p><strong>基于Spring的集群配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 调度工厂 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;quartzScheduler&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;quartzProperties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.scheduler.instanceName&quot;</span>&gt;</span>CRMscheduler<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.scheduler.instanceId&quot;</span>&gt;</span>AUTO<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 线程池配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.threadPool.class&quot;</span>&gt;</span>org.quartz.simpl.SimpleThreadPool<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.threadPool.threadCount&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.threadPool.threadPriority&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- JobStore 配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.class&quot;</span>&gt;</span>org.quartz.impl.jdbcjobstore.JobStoreTX<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 集群配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.isClustered&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.clusterCheckinInterval&quot;</span>&gt;</span>15000<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.maxMisfiresToHandleAtATime&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.misfireThreshold&quot;</span>&gt;</span>120000<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.quartz.jobStore.tablePrefix&quot;</span>&gt;</span>QRTZ_<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schedulerName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CRMscheduler&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--必须的，QuartzScheduler 延时启动，应用启动完后 QuartzScheduler 再启动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;startupDelay&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;applicationContextSchedulerContextKey&quot;</span> <span class="attr">value</span>=<span class="string">&quot;applicationContextKey&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--可选，QuartzScheduler 启动时更新己存在的Job，这样就不用每次修改targetObject后删除qrtz_job_details表对应记录了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;overwriteExistingJobs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置自动启动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoStartup&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册触发器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;triggers&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;userSyncScannerTrigger&quot;</span> /&gt;</span></span><br><span class="line">                     ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册jobDetail --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jobDetails&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schedulerListeners&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;quartzExceptionSchedulerListener&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.class属性为JobStoreTX，将任务持久化到数据中。因为集群中节点依赖于数据库来传播Scheduler实例的状态，你只能在使用JDBC JobStore时应用Quartz集群。</span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.isClustered属性为true，通知Scheduler实例要它参与到一个集群当中。</span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.clusterCheckinInterval属性定义了Scheduler实例检入到数据库中的频率(单位：毫秒)。Scheduler检查是否其他的实例到了它们应当检入的时候未检入；这能指出一个失败的Scheduler实例，且当前 Scheduler会以此来接管任何执行失败并可恢复的Job。通过检入操作，Scheduler 也会更新自身的状态记录。clusterChedkinInterval越小，Scheduler节点检查失败的Scheduler实例就越频繁。默认值是 15000 (即15 秒)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Quartz集群原理分析"><a href="#Quartz集群原理分析" class="headerlink" title="Quartz集群原理分析"></a>Quartz集群原理分析</h2><h3 id="Quartz集群数据库表"><a href="#Quartz集群数据库表" class="headerlink" title="Quartz集群数据库表"></a>Quartz集群数据库表</h3><p>Quartz的集群部署方案在架构上是分布式的，没有负责集中管理的节点，而是利用数据库锁的方式来实现集群环境下进行并发控制。BTW，分布式部署时需要保证各个节点的系统时间一致。</p>
<p>Quartz数据库核心表如下：</p>
<table>
<thead>
<tr>
<th align="left">Table Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">QRTZ_CALENDARS</td>
<td align="left">存储Quartz的Calendar信息</td>
</tr>
<tr>
<td align="left">QRTZ_CRON_TRIGGERS</td>
<td align="left">存储CronTrigger，包括Cron表达式和时区信息</td>
</tr>
<tr>
<td align="left">QRTZ_FIRED_TRIGGERS</td>
<td align="left">存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息</td>
</tr>
<tr>
<td align="left">QRTZ_PAUSED_TRIGGER_GRPS</td>
<td align="left">存储已暂停的Trigger组的信息</td>
</tr>
<tr>
<td align="left">QRTZ_SCHEDULER_STATE</td>
<td align="left">存储少量的有关Scheduler的状态信息，和别的Scheduler实例</td>
</tr>
<tr>
<td align="left"><strong>QRTZ_LOCKS</strong></td>
<td align="left"><strong>存储程序的悲观锁的信息</strong></td>
</tr>
<tr>
<td align="left">QRTZ_JOB_DETAILS</td>
<td align="left">存储每一个已配置的Job的详细信息</td>
</tr>
<tr>
<td align="left">QRTZ_JOB_LISTENERS</td>
<td align="left">存储有关已配置的JobListener的信息</td>
</tr>
<tr>
<td align="left">QRTZ_SIMPLE_TRIGGERS</td>
<td align="left">存储简单的Trigger，包括重复次数、间隔、以及已触的次数</td>
</tr>
<tr>
<td align="left">QRTZ_BLOG_TRIGGERS</td>
<td align="left">Trigger作为Blob类型存储</td>
</tr>
<tr>
<td align="left">QRTZ_TRIGGER_LISTENERS</td>
<td align="left">存储已配置的TriggerListener的信息</td>
</tr>
<tr>
<td align="left">QRTZ_TRIGGERS</td>
<td align="left">存储已配置的Trigger的信息</td>
</tr>
</tbody></table>
<p>其中，QRTZ_LOCKS就是Quartz集群实现同步机制的行锁表，其表结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--QRTZ_LOCKS表结构</span><br><span class="line">CREATE TABLE &#96;QRTZ_LOCKS&#96; (</span><br><span class="line">  &#96;LOCK_NAME&#96; varchar(40) NOT NULL,</span><br><span class="line">   PRIMARY KEY (&#96;LOCK_NAME&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">--QRTZ_LOCKS记录</span><br><span class="line">+-----------------+ </span><br><span class="line">| LOCK_NAME       |</span><br><span class="line">+-----------------+ </span><br><span class="line">| CALENDAR_ACCESS |</span><br><span class="line">| JOB_ACCESS      |</span><br><span class="line">| MISFIRE_ACCESS  |</span><br><span class="line">| STATE_ACCESS    |</span><br><span class="line">| TRIGGER_ACCESS  |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>

<p>可以看出QRTZ_LOCKS中有5条记录，代表5把锁，分别用于实现多个Quartz Node对Job、Trigger、Calendar访问的同步控制。</p>
<h3 id="Quartz线程模型"><a href="#Quartz线程模型" class="headerlink" title="Quartz线程模型"></a>Quartz线程模型</h3><p>在Quartz中有两类线程：Scheduler调度线程和任务执行线程。</p>
<ul>
<li><p>调度主线程(QuartzSchedulerThread)：QuartzScheduler被创建时创建一个QuartzSchedulerThread实例。</p>
</li>
<li><p>任务执行线程：Quartz不会在主线程(QuartzSchedulerThread)中处理用户的Job。Quartz把线程管理的职责委托给ThreadPool，一般的设置使用SimpleThreadPool。SimpleThreadPool创建了一定数量的WorkerThread实例来使得Job能够在线程中进行处理。WorkerThread是定义在SimpleThreadPool类中的内部类，它实质上就是一个线程。例如，CRM中配置如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 线程池配置 --&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.threadPool.class&quot;&gt;org.quartz.simpl.SimpleThreadPool&lt;&#x2F;prop&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.threadPool.threadCount&quot;&gt;20&lt;&#x2F;prop&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.threadPool.threadPriority&quot;&gt;5&lt;&#x2F;prop&gt;</span><br></pre></td></tr></table></figure>



<h3 id="集群源码分析"><a href="#集群源码分析" class="headerlink" title="集群源码分析"></a>集群源码分析</h3><p>Quartz究竟是如何保证集群情况下trgger处理的信息同步？</p>
<p>下面跟着源码一步一步分析，调度主线程(QuartzSchedulerThread)包含有决定何时下一个Job将被触发的处理循环，主要逻辑在其run()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> lastAcquireFailed = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">while</span> (!halted.get()) &#123;</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();</span><br><span class="line">     <span class="keyword">if</span>(availThreadCount &gt; <span class="number">0</span>) &#123; </span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="comment">//调度器在trigger队列中寻找30秒内一定数目的trigger(需要保证集群节点的系统时间一致)</span></span><br><span class="line">     triggers = qsRsrcs.getJobStore().acquireNextTriggers(</span><br><span class="line">                            now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="comment">//触发trigger</span></span><br><span class="line">     List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers);</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     <span class="comment">//释放trigger</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; triggers.size(); i++) &#123;</span><br><span class="line">         qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可知，QuartzScheduler调度线程不断获取trigger，触发trigger，释放trigger。下面分析trigger的获取过程，qsRsrcs.getJobStore()返回对象是JobStore，集群环境配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- JobStore 配置 --&gt;</span><br><span class="line">&lt;prop key&#x3D;&quot;org.quartz.jobStore.class&quot;&gt;org.quartz.impl.jdbcjobstore.JobStoreTX&lt;&#x2F;prop&gt;</span><br></pre></td></tr></table></figure>

<p>JobStoreTX继承自JobStoreSupport，而JobStoreSupport的acquireNextTriggers、triggersFired、releaseAcquiredTrigger方法负责具体trigger相关操作，都必须获得TRIGGER_ACCESS锁。核心逻辑在executeInNonManagedTXLock方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">executeInNonManagedTXLock</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String lockName, </span></span></span><br><span class="line"><span class="function"><span class="params">        TransactionCallback&lt;T&gt; txCallback, <span class="keyword">final</span> TransactionValidator&lt;T&gt; txValidator)</span> <span class="keyword">throws</span> JobPersistenceException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> transOwner = <span class="keyword">false</span>;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getLockHandler().requiresConnection()) &#123;</span><br><span class="line">                conn = getNonManagedTXConnection();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取锁</span></span><br><span class="line">            transOwner = getLockHandler().obtainLock(conn, lockName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn = getNonManagedTXConnection();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> T result = txCallback.execute(conn);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            commitConnection(conn);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JobPersistenceException e) &#123;</span><br><span class="line">            rollbackConnection(conn);</span><br><span class="line">            <span class="keyword">if</span> (txValidator == <span class="keyword">null</span> || !retryExecuteInNonManagedTXLock(lockName, <span class="keyword">new</span> TransactionCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">execute</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> JobPersistenceException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> txValidator.validate(conn, result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long sigTime = clearAndGetSignalSchedulingChangeOnTxCompletion();</span><br><span class="line">        <span class="keyword">if</span>(sigTime != <span class="keyword">null</span> &amp;&amp; sigTime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            signalSchedulingChangeImmediately(sigTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JobPersistenceException e) &#123;</span><br><span class="line">        rollbackConnection(conn);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        rollbackConnection(conn);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JobPersistenceException(<span class="string">&quot;Unexpected runtime exception: &quot;</span></span><br><span class="line">                + e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            releaseLock(lockName, transOwner);      <span class="comment">//释放锁</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cleanupConnection(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上代码可知Quartz集群基于数据库锁的同步操作流程如下图所示：</p>
<img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/05dac2dd.png" alt="Quartz集群基于锁的同步方案" style="zoom: 67%;" />





<p>一个调度器实例在执行涉及到分布式问题的数据库操作前，首先要获取QUARTZ_LOCKS表中对应的行级锁，获取锁后即可执行其他表中的数据库操作，随着操作事务的提交，行级锁被释放，供其他调度实例获取。集群中的每一个调度器实例都遵循这样一种严格的操作规程。</p>
<p>getLockHandler()方法返回的对象类型是Semaphore，获取锁和释放锁的具体逻辑由该对象维护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Semaphore &#123;</span><br><span class="line"></span><br><span class="line">     boolean obtainLock(Connection conn, String lockName) throws LockException;</span><br><span class="line"></span><br><span class="line">     void releaseLock(String lockName) throws LockException;</span><br><span class="line"></span><br><span class="line">     boolean requiresConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口的实现类完成具体操作锁的逻辑，在JobStoreSupport的初始化方法中注入的Semaphore具体类型是StdRowLockSemaphore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setLockHandler(new StdRowLockSemaphore(getTablePrefix(), getInstanceName(), getSelectWithLockSQL()));</span><br></pre></td></tr></table></figure>

<p>StdRowLockSemaphore的源码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class StdRowLockSemaphore extends DBSemaphore &#123;</span><br><span class="line">&#x2F;&#x2F;锁定SQL语句</span><br><span class="line">public static final String SELECT_FOR_LOCK &#x3D; &quot;SELECT * FROM &quot;</span><br><span class="line">        + TABLE_PREFIX_SUBST + TABLE_LOCKS + &quot; WHERE &quot; + COL_LOCK_NAME</span><br><span class="line">        + &quot; &#x3D; ? FOR UPDATE&quot;;</span><br><span class="line"></span><br><span class="line">public static final String INSERT_LOCK &#x3D; &quot;INSERT INTO &quot; + TABLE_PREFIX_SUBST </span><br><span class="line">        + TABLE_LOCKS + &quot;(&quot; + COL_SCHEDULER_NAME + &quot;, &quot; </span><br><span class="line">        + COL_LOCK_NAME + &quot;) VALUES (&quot; + SCHED_NAME_SUBST + &quot;, ?)&quot;; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定锁定SQL</span><br><span class="line">protected void executeSQL(Connection conn, String lockName, String expandedSQL) throws LockException &#123;</span><br><span class="line">    PreparedStatement ps &#x3D; null;</span><br><span class="line">    ResultSet rs &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ps &#x3D; conn.prepareStatement(expandedSQL);</span><br><span class="line">        ps.setString(1, lockName);</span><br><span class="line">        ......</span><br><span class="line">        rs &#x3D; ps.executeQuery();</span><br><span class="line">        if (!rs.next()) &#123;</span><br><span class="line">            throw new SQLException(Util.rtp(</span><br><span class="line">                &quot;No row exists in table &quot; + TABLE_PREFIX_SUBST +</span><br><span class="line">                TABLE_LOCKS + &quot; for lock named: &quot; + lockName, getTablePrefix()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (SQLException sqle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ...... &#x2F;&#x2F;release resources</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取QRTZ_LOCKS行级锁</span><br><span class="line">public boolean obtainLock(Connection conn, String lockName) throws LockException &#123;</span><br><span class="line">    lockName &#x3D; lockName.intern();</span><br><span class="line"></span><br><span class="line">    if (!isLockOwner(conn, lockName)) &#123;</span><br><span class="line">        executeSQL(conn, lockName, expandedSQL);</span><br><span class="line"></span><br><span class="line">        getThreadLocks().add(lockName);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;释放QRTZ_LOCKS行级锁</span><br><span class="line">public void releaseLock(Connection conn, String lockName) &#123;</span><br><span class="line">    lockName &#x3D; lockName.intern();</span><br><span class="line"></span><br><span class="line">    if (isLockOwner(conn, lockName)) &#123;</span><br><span class="line">        getThreadLocks().remove(lockName);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下Quartz集群同步机制：每当要进行与某种业务相关的数据库操作时，先去QRTZ_LOCKS表中查询操作相关的业务对象所需要的锁，在select语句之后加for update来实现。例如，TRIGGER_ACCESS表示对任务触发器相关的信息进行修改、删除操作时所需要获得的锁。这时，执行查询这个表数据的SQL形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from QRTZ_LOCKS t where t.lock_name&#x3D;&#39;TRIGGER_ACCESS&#39; for update</span><br></pre></td></tr></table></figure>

<p>当一个线程使用上述的SQL对表中的数据执行查询操作时，若查询结果中包含相关的行，数据库就对该行进行ROW LOCK；若此时，另外一个线程使用相同的SQL对表的数据进行查询，由于查询出的数据行已经被数据库锁住了，此时这个线程就只能等待，直到拥有该行锁的线程完成了相关的业务操作，执行了commit动作后，数据库才会释放了相关行的锁，这个线程才能继续执行。</p>
<p>通过这样的机制，在集群环境下，结合悲观锁的机制就可以防止一个线程对数据库数据的操作的结果被另外一个线程所覆盖，从而可以避免一些难以觉察的错误发生。当然，达到这种效果的前提是需要把Connection设置为手动提交，即autoCommit为false。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="为什么我在一台机器上，看不到Job打印的执行日志"><a href="#为什么我在一台机器上，看不到Job打印的执行日志" class="headerlink" title="为什么我在一台机器上，看不到Job打印的执行日志"></a><strong>为什么我在一台机器上，看不到Job打印的执行日志</strong></h3><p>因为Quartz是分布式搭建的，触发定时任务时，只在集群中的某一台机器上执行。所以，我查看的机器，不是执行的机器，所以看不到也正常。我就在本地测试的时候，发现其他同事也开着程序。。。。导致定时任务一直在他们那里执行，我根本看不到。。。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-05-%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-05-%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">shiro应用-05-过滤器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-24 17:39:13" itemprop="dateCreated datePublished" datetime="2021-05-24T17:39:13+08:00">2021-05-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们都知道shiro是个认证权限框架，除了登录、退出逻辑我们需要侵入项目代码之外，验证用户是否已经登录、是否拥有权限的代码其实都是过滤器来完成的，可以这么说，shiro其实就是一个过滤器链集合。</p>
<p>那么今天我们详细讨论一下shiro底层到底给我们提供了多少默认的过滤器供我们使用，又都有什么用呢？带着问题，我们先去shiro官网看看对于默认过滤器集的说明。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://shiro.apache.org/web.html#default-filters">http://shiro.apache.org/web.h…</a></li>
</ul>
<blockquote>
<p>When running a web-app, Shiro will create some useful default Filter instances and make them available in the [main] section automatically. You can configure them in main as you would any other bean and reference them in your chain definitions.</p>
<p>The default Filter instances available automatically are defined by the DefaultFilter enum and the enum’s name field is the name available for configuration.</p>
</blockquote>
<p>默认筛选器实例由DefaultFilter enum中定义，enum s name字段是可用于配置的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public enum DefaultFilter &#123;</span><br><span class="line"></span><br><span class="line">    anon(AnonymousFilter.class),</span><br><span class="line">    authc(FormAuthenticationFilter.class),</span><br><span class="line">    authcBasic(BasicHttpAuthenticationFilter.class),</span><br><span class="line">    logout(LogoutFilter.class),</span><br><span class="line">    noSessionCreation(NoSessionCreationFilter.class),</span><br><span class="line">    perms(PermissionsAuthorizationFilter.class),</span><br><span class="line">    port(PortFilter.class),</span><br><span class="line">    rest(HttpMethodPermissionFilter.class),</span><br><span class="line">    roles(RolesAuthorizationFilter.class),</span><br><span class="line">    ssl(SslFilter.class),</span><br><span class="line">    user(UserFilter.class);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于知道我们常用的anon、authc、perms、roles、user过滤器是哪里来的了！这些过滤器我们都是可以直接使用的。</p>
<img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/8e77bde372b64a83baa2c7d782137a61.png" alt="img" style="zoom: 33%;" />



<h4 id="AbstractFilter"><a href="#AbstractFilter" class="headerlink" title="AbstractFilter"></a>AbstractFilter</h4><p>这个过滤器还得说说，shiro最底层的抽象过滤器，虽然我们极少直接继承它，它通过实现<code>Filter</code>获得过滤器的特性。</p>
<p>完成一些过滤器基本初始化操作，<code>FilterConfig</code>：过滤器配置对象，用于servlet容器在初始化期间将信息传递给其他过滤器。</p>
<h4 id="NameableFilter"><a href="#NameableFilter" class="headerlink" title="NameableFilter"></a>NameableFilter</h4><p>命名过滤器，给过滤器定义名称！也是比较基层的过滤器了，未拓展其他功能，我们很少会直接继承这个过滤器。为重写doFilter方法。</p>
<h4 id="OncePerRequestFilter"><a href="#OncePerRequestFilter" class="headerlink" title="OncePerRequestFilter"></a>OncePerRequestFilter</h4><p>重写doFilter方法，保证每个servlet方法只会被过滤一次。可以看到doFilter方法中，第一行代码就是<code>String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName();</code>然后通过<code>request.getAttribute(alreadyFilteredAttributeName) != null</code>来判断过滤器是否已经被调用过，从而保证过滤器不会被重复调用。</p>
<p>进入方法之前，先标记<code>alreadyFilteredAttributeName</code>为True，抽象<code>doFilterInternal</code>方法执行之后再remove掉<code>alreadyFilteredAttributeName</code>。</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/391f6d511eb5486e82611a2774eac82f.png" alt="img"></p>
<p>所以OncePerRequestFilter过滤器保证只会被一次调用的功能，提供了抽象方法<code>doFilterInternal</code>让后面的过滤器可以重写，执行真正的过滤器处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected abstract void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">            throws ServletException, IOException;</span><br></pre></td></tr></table></figure>



<h4 id="AdviceFilter"><a href="#AdviceFilter" class="headerlink" title="AdviceFilter"></a>AdviceFilter</h4><p>看到Advice，很自然想到切面环绕编程，一般有pre、post、after几个方法。所以这个AdviceFilter过滤器就是提供了和AOP相似的切面功能。</p>
<p>继承OncePerRequestFilter过滤器重写doFilterInternal方法，我们可以先看看：</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/1f169663547f42119c98d93f4d4ab97b.png" alt="img"></p>
<p>可以看到上面4个序号：</p>
<ol>
<li>preHandle 前置过滤，默认true</li>
<li>executeChain 执行真正代码过滤逻辑-&gt;chain.doFilter</li>
<li>postHandle 后置过滤</li>
<li>cleanup 其实主要逻辑是afterCompletion方法</li>
</ol>
<p>于是，我们从OncePerRequestFilter的一个doFilterInternal分化成了切面编程，更容易前后控制执行逻辑。所以如果继承AdviceFilter时候，我们可以重写preHandle方法，判断用户是否满足已登录或者其他业务逻辑，返回false时候表示不通过过滤器。</p>
<h4 id="PathMatchingFilter"><a href="#PathMatchingFilter" class="headerlink" title="PathMatchingFilter"></a>PathMatchingFilter</h4><p>请求路径匹配过滤器，通过匹配请求url，判断请求是否需要过滤，如果url未在需要过滤的集合内，则跳过，否则进入<code>isFilterChainContinued</code>的onPreHandle方法。</p>
<p>我们可以看下代码：</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/62f7317fd4ec467682f3da3aa11a3c87.png" alt="img"></p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/b568d5dceb2b4a19aad6fd72348f5e58.png" alt="img"></p>
<p>从上面3个步骤中可以看到，PathMatchingFilter提供的功能是：自定义匹配url，匹配上的请求最终跳转到<code>onPreHandle</code>方法。</p>
<p>这个过滤器为后面的常用过滤器提供的基础，比如我们在config中配置如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;login &#x3D; anon</span><br><span class="line">&#x2F;admin&#x2F;* &#x3D; authc</span><br></pre></td></tr></table></figure>

<p>拦截/login请求，经过AnonymousFilter过滤器，我们可以看下</p>
<ul>
<li>org.apache.shiro.web.filter.authc.AnonymousFilter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AnonymousFilter extends PathMatchingFilter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 公众号：MarkerHub</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) &#123;</span><br><span class="line">        &#x2F;&#x2F; Always return true since we allow access to anyone</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AnonymousFilter重写了onPreHandle方法，只不过直接返回了true，说明拦截的链接可以直接通过，不需要其他拦截逻辑。</p>
<p>而authc-&gt;FormAuthenticationFilter也是间接继承了PathMatchingFilter。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FormAuthenticationFilter extends AuthenticatingFilter</span><br></pre></td></tr></table></figure>

<p>所以，需要拦截某个链接进行业务逻辑过滤的可以继承PathMatchingFilter方法拓展哈。</p>
<h4 id="AccessControlFilter"><a href="#AccessControlFilter" class="headerlink" title="AccessControlFilter"></a>AccessControlFilter</h4><p>访问控制过滤器。继承PathMatchingFilter过滤器，重写onPreHandle方法，又分出了两个抽象方法来控制</p>
<p><img src="https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200511/63cb9b7e06f249089c88fa25f480ddd3.png" alt="img"></p>
<ul>
<li>isAccessAllowed 是否允许访问</li>
<li>onAccessDenied 是否拒绝访问</li>
</ul>
<p>所以，我们现在可以通过重写这个抽象两个方法来控制过滤逻辑。另外多提供了3个方法，方便后面的过滤器使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">saveRequestAndRedirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    saveRequest(request);</span><br><span class="line">    redirectToLogin(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">saveRequest</span><span class="params">(ServletRequest request)</span> </span>&#123;</span><br><span class="line">    WebUtils.saveRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">redirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String loginUrl = getLoginUrl();</span><br><span class="line">    WebUtils.issueRedirect(request, response, loginUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中redirectToLogin提供了调整到登录页面的逻辑与实现，为后面的过滤器发现未登录跳转到登录页面提供了基础。</p>
<h4 id="AuthenticationFilter"><a href="#AuthenticationFilter" class="headerlink" title="AuthenticationFilter"></a>AuthenticationFilter</h4><p>继承AccessControlFilter，重写了isAccessAllowed方法，通过判断用户是否已经完成登录来判断用户是否允许继续后面的逻辑判断。这里可以看出，从这个过滤器开始，后续的判断会与用户的登录状态相关，直接继承这些过滤器，我们不需要再自己手动去判断用户是否已经登录。并且提供了登录成功之后跳转的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AuthenticationFilter extends AccessControlFilter &#123;</span><br><span class="line">    public void setSuccessUrl(String successUrl) &#123;</span><br><span class="line">        this.successUrl &#x3D; successUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123;</span><br><span class="line">        Subject subject &#x3D; getSubject(request, response);</span><br><span class="line">        return subject.isAuthenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AuthenticatingFilter"><a href="#AuthenticatingFilter" class="headerlink" title="AuthenticatingFilter"></a>AuthenticatingFilter</h4><p>继承AuthenticationFilter，提供了自动登录、是否登录请求等方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公众号：MarkerHub</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticatingFilter</span> <span class="keyword">extends</span> <span class="title">AuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERMISSIVE = <span class="string">&quot;permissive&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO - complete JavaDoc</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">executeLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AuthenticationToken token = createToken(request, response);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;createToken method implementation returned null. A valid non-null AuthenticationToken &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;must be created in order to execute a login attempt.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Subject subject = getSubject(request, response);</span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="keyword">return</span> onLoginSuccess(token, subject, request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> onLoginFailure(token, e, request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AuthenticationToken <span class="title">createToken</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公众号：MarkerHub</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.isAccessAllowed(request, response, mappedValue) ||</span><br><span class="line">                (!isLoginRequest(request, response) &amp;&amp; isPermissive(mappedValue));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>executeLogin 执行登录</li>
<li>onLoginSuccess 登录成功跳转</li>
<li>onLoginFailure 登录失败跳转</li>
<li>createToken 创建登录的身份token</li>
<li>isAccessAllowed 是否允许被访问</li>
<li>isLoginRequest 是否登录请求</li>
</ul>
<p>这个方法提供了自动登录，比如我们获取到token之后实行自动登录</p>
<h4 id="FormAuthenticationFilter"><a href="#FormAuthenticationFilter" class="headerlink" title="FormAuthenticationFilter"></a>FormAuthenticationFilter</h4><p>基于form表单的账号密码自动登录的过滤器，我们只需要看这个方法就明白，和renren-fast的实现相似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AuthenticatingFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_USERNAME_PARAM = <span class="string">&quot;username&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PASSWORD_PARAM = <span class="string">&quot;password&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_REMEMBER_ME_PARAM = <span class="string">&quot;rememberMe&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationToken <span class="title">createToken</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        String username = getUsername(request);</span><br><span class="line">        String password = getPassword(request);</span><br><span class="line">        <span class="keyword">return</span> createToken(username, password, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公众号：MarkerHub</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoginRequest(request, response)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLoginSubmission(request, response)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                    log.trace(<span class="string">&quot;Login submission detected.  Attempting to execute login.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> executeLogin(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                    log.trace(<span class="string">&quot;Login page view.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//allow them to see the login page ;)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">&quot;Attempting to access a path which requires authentication.  Forwarding to the &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Authentication url [&quot;</span> + getLoginUrl() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            saveRequestAndRedirectToLogin(request, response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onAccessDenied调用executeLogin方法。默认的token是UsernamepasswordToken。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">java探针-类加载问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-22 11:08:25" itemprop="dateCreated datePublished" datetime="2021-05-22T11:08:25+08:00">2021-05-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>得益于Java SE 6提供的Instrumentation接口。基于Instrumentation可开发运行时修改class字节码的Java Agent应用（Java探针），可在<a href="">类加载之前替换类的字节码</a>、或在<a href="">类加载之后通过重新加载类方式修改类的字节码</a>。</p>
<p>只是实现运行时修改class字节码还不足以称为“探针”。基于Instrumentation开发的Java Agent，只需要在Java应用启动命令上加上虚拟机参数“-javaagent”指定Java Agent应用jar包的位置，而不需要在工程项目中引入其jar包，即可将探针插入应用代码的各个角落。通过<a href="">与应用使用不同的类加载实现环境隔离</a>，让人有种Java Agent是吸附在应用上运行的错觉。</p>
<h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>由父类加载器加载的类，不能引用子类加载器加载的类，否则会抛出NoClassDefFoundError。</p>
<p>JDK提供的<code>java.*</code>类都由启动类加载器加载。如果我们在<code>java agent</code>中修改<code>java.*</code>包下的类，插入调用logback打印日记的代码，结果会怎样？由于<code>java agent</code>包下的logback由AppClassLoader加载，而加载<code>java.*</code>包下的类是BootClassLoader(AppClassLoader的父类加载器)，在<code>java.*</code>包下的类中插入调用logback打印日记的代码，首先在加载<code>java.*</code>包下的类时，jvm会查看BootClassLoader有没有加载过这个类，如果没有加载过尝试加载，但BootClassLoader加载不了logback包的类，而启动类加载器不会向子类加载器去询问，即使子类加载器加载了这个类。所以就会出现NoClassDefFoundError。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>如果非要修改java包下的类，且非要在java包下的类中访问项目中我们编写的类或者第三方jar包提供的类、或者我们编写的javaagent包下的类，如何避免NoClassDefFoundError呢？</p>
<p>研究下Arthas:</p>
<ul>
<li>用于接收埋点代码上报事件的类（Spy）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Spy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method beforMethod;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method completeMethod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(String className, String methodName, String descriptor, Object[] params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beforMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforMethod.invoke(<span class="keyword">null</span>, className, methodName, descriptor, params);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object returnValueOrThrowable, String className, String methodName, String descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (completeMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                completeMethod.invoke(<span class="keyword">null</span>, returnValueOrThrowable, className, methodName, descriptor);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>before：方法执行之前上报；</p>
<p>complete：方法return之前或者抛出异常之前上报，当方法抛出异常时，第一个参数为异常，否则第一个参数为返回值</p>
<p>methodName: 上报方法</p>
</blockquote>
<ul>
<li>将Spy放在一个独立的jar包下，在premain、agentmain方法中调用Instrumentation的appendToBootstrapClassLoaderSearch方法，将Spy类所在的jar包交由启动类加载器扫描加载，如下代码所示。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; agent-spy.jar</span><br><span class="line">String agentSpyJar &#x3D; jarPath[1];</span><br><span class="line">File spyJarFile &#x3D; new File(agentSpyJar);</span><br><span class="line">instrumentation.appendToBootstrapClassLoaderSearch(new JarFile(spyJarFile));</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在Spy类中打印类加载器，如果打印的结果为null，则说明Spy类是由启动类加载器加载的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final class Spy &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Spy class loader is &quot; + Spy.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Agent与应用环境隔离"><a href="#实现Agent与应用环境隔离" class="headerlink" title="实现Agent与应用环境隔离"></a>实现Agent与应用环境隔离</h2><p>隔离是避免Agent污染应用自身，使开发Java Agent无需考虑引入的jar包是否与目标应用引入的jar包冲突。</p>
<h3 id="与springboot隔离失败原因"><a href="#与springboot隔离失败原因" class="headerlink" title="与springboot隔离失败原因"></a>与springboot隔离失败原因</h3><p>Java Agent与Spring Boot应用相遇时会发生什么？</p>
<p>Spring Boot应用打包后，将Agent附着到应用启动可能会抛出醒目的NoClassDefFoundError异常，背后的原因是<a href="">Agent与打包后的Spring Boot应用使用了不同的类加载器</a>。</p>
<ul>
<li>Agent的jar包由AppClassLoader加载。我们可能会在Agent中调用被监控的SpringBoot应用的代码，也可能调用Agent依赖的第三方jar包的API，而这些jar包恰好在SpringBoot应用中也有导入，就可能会出现NoClassDefFoundError。</li>
<li>SpringBoot应用打包后，JVM进程启动入口不再是我们写的main方法，而是SpringBoot生成的启动类。SpringBoot使用自定义的类加载器（LaunchedClassLoader）加载jar中的类和第三方jar包中的类，该类加载器的父类加载器为AppClassLoader。也就是说，SpringBoot应用打包后，加载java agent包下的类加载器是SpringBoot的类加载器的父类。</li>
</ul>
<blockquote>
<p>疑惑？这在IDEA中测试是不会发生的</p>
<p>因为在IDEA中，项目的class文件和第三方库是通过AppClassLoader加载的，而使用-javaagent指定的jar也是通过AppClassLoader加载，所以在idea中测试不会遇到这个问题。</p>
</blockquote>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>让加载agent包不使用AppClassLoader加载器加载，而是使用自定义的类加载器加载。</p>
<p>参考Alibaba开源的Arthas的实现，自定义URLClassLoader加载agent包以及agent依赖的第三方jar包。</p>
<p>由于premain或者agentmain方法所在的类由jvm使用AppClassLoader所加载，所以必须将agent拆分为两个jar包。核心功能放在agent-core包下，premain或者agentmain方法所在的类放在agent-boot包下。在premain或者agentmain方法中使用自定义的URLClassLoader类加载器加载agent-core。</p>
<ul>
<li>自定义类加载器OnionClassLoader，继承URLClassLoader，如下代码所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnionClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnionClassLoader</span><span class="params">(URL[] urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(urls, ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (loadedClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadedClass;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优先从parent（SystemClassLoader）里加载系统类，避免抛出ClassNotFoundException</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; (name.startsWith(<span class="string">&quot;sun.&quot;</span>) || name.startsWith(<span class="string">&quot;java.&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> aClass;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在构造方法中指定OnionClassLoader的父类加载器为AppClassLoader的父类加载器。</p>
<p><code>ClassLoader.getSystemClassLoader()</code>：获取系统类加载器（AppClassLoader）</p>
<ul>
<li>在premain或者agentmain方法中使用OnionClassLoader类加载器加载agent-core。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File agentJarFile = <span class="keyword">new</span> File(agentJar);</span><br><span class="line"><span class="keyword">final</span> ClassLoader agentLoader = <span class="keyword">new</span> OnionClassLoader(<span class="keyword">new</span> URL[]&#123;agentJarFile.toURI().toURL()&#125;);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; transFormer = agentLoader.loadClass(<span class="string">&quot;com.msyc.agent.core.OnionClassFileTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt; constructor = transFormer.getConstructor(String.class);</span><br><span class="line">Object instance = constructor.newInstance(opsParams);</span><br><span class="line"></span><br><span class="line">instrumentation.addTransformer((ClassFileTransformer) instance);</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>根据agent-core.jar所在绝对路径构造OnionClassLoader；</li>
<li>加载agent-core.jar下的ClassFileTransformer；</li>
<li>使用反射创建ClassFileTransformer实例；</li>
<li>将ClassFileTransformer添加到Instrumentation;</li>
</ul>
</blockquote>
<p>OnionClassFileTransformer类所依赖的agent-core包下的类，自然也会被使用OnionClassLoader类加载器加载，包括agent-core依赖的第三方jar包。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/yibbONzdtFf2t8JVXHNXRpibzSgFAqUAMkfyP8gypoicPR23f3cqb0icdKtGjjAicYowOAHJr07HqlV9YPbqqqPE4qg/640" alt="图片"></p>
<h2 id="适配webmvc框架"><a href="#适配webmvc框架" class="headerlink" title="适配webmvc框架"></a><strong>适配webmvc框架</strong></h2><p>生成分布式调用链日记的难点在于方法埋点和方法调用日记串连。</p>
<p>分布式调用链日记串连的方式有多种，笔者采用的是最简单的方式：打点id+打点时间。</p>
<ul>
<li>对于同进程内的同线程，可用打点id将调用的方法串连起来，根据打点时间与一个累加器的值排序方法调用日记。</li>
<li>对于不同进程，通过传递打点id可将不同应用的打点日记串连起来，根据打点时间排序。</li>
</ul>
<p>例如，适配webmvc框架的目的是从请求头获取调用来源传递过来的打点ID(事务ID)。对DispatcherServlet#doDispatch方法插桩，从HttpServletRequest参数获取请求头“S-Tid”。“S-Tid”是自定义的请求头参数，用于传递打点ID。</p>
<p>笔者在实现适配webmvc和openfeign时都遇到了同样的问题，如在适配webmvc时，修改DispatcherServlet的doDispatch方法时，asm框架抛出java.lang.TypeNotPresentException。</p>
<ul>
<li>java.lang.TypeNotPresentException：当应用程序试图使用表示类型名称的字符串对类型进行访问，但无法找到带有指定名称的类型定义时，抛出该异常。</li>
</ul>
<p>其原因是，使用asm框架改写DispatcherServlet类时，asm会使用Class.forName方法加载符号引用的类，如果加载不到目标类则抛出TypeNotPresentException。</p>
<p>默认asm会使用加载自身的类加载器去尝试加载当前改写类所依赖的一些类，而加载asm框架使用的类加载器与加载agent-core包使用的是同一个类加载器，DispatcherServlet则由SpringBoot的LaunchedClassLoader类加载器所加载。</p>
<p>好在ClassFileTransformer#transform方法传递了用于加载当前类的类加载器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class OnionClassFileTransformer implements ClassFileTransformer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public byte[] transform(ClassLoader loader, String className,                             Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                            ProtectionDomain protectionDomain,                             byte[] classfileBuffer) &#123;</span><br><span class="line">             &#x2F;&#x2F; ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>如果当前需要改写的类是DispatcherServlet，则transform方法的第一个参数为即将用于加载DispatcherServlet类的类加载器；</li>
</ul>
<p>我们只需要指定asm使用ClassFileTransformer#transform方法传递进来的类加载器加载DispatcherServlet依赖的类即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassWriter classWriter &#x3D; new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES) &#123;</span><br><span class="line">       @Override</span><br><span class="line">       protected ClassLoader getClassLoader() &#123;</span><br><span class="line">            return loader;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>如代码所示，我们重写asm的ClassWriter类的getClassLoader方法，返回的类加载器是ClassFileTransformer#transform方法传递进来的类加载器。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-01/" class="post-title-link" itemprop="url">kafka-分析与调优</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 12:34:40" itemprop="dateCreated datePublished" datetime="2021-05-21T12:34:40+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Kafka报-IO-Exception-many-open-files"><a href="#Kafka报-IO-Exception-many-open-files" class="headerlink" title="Kafka报 IO Exception(many open files)"></a>Kafka报 IO Exception(many open files)</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><hr>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVd71ajm8l4SQibTbQic73zsFR1OryAj6gpuVAfviaTAyQzKmMNK1y5et2w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>首先我们要能看懂Kafka-manager上的一些监控指标，topic列表中关于topic的信息项如下所示：</p>
<ul>
<li><p>Brokers Spread %<br>该topic中队列在Broker中的使用率，例如集群中有5个broker，但topic只在４个broker上创建了队列，那使用率为80％。</p>
</li>
<li><p>Brokers Skew %<br>topic的队列倾斜率。如果集群中存在5个broker节点，topic的总分区数量为4,副本因子为2，但这些队列只分布在其中的４台broker中。那topic的<strong>broker使用率(Broker Spread)为80%**。<br>众所周知，引入多节点的目的就是负载均衡，队列在broker中的分配自然是希望越均衡越好，期望每台broker上存储2个队列(副本因子为2，总共８个队列)，表示没有发生倾斜，如果一台broker中的存在３个队列，而另外一个broker上１个队列，那说明发生了倾斜，</strong>计算公式为超过平均队列数的broker节点个数除以总所在Broker数量**，其Brokers Skew等于(1/3)=33%。  <!--队列就是：分区 + 副本--></p>
</li>
<li><p>Brokers Leader Skew %<br>topic分区中Leader分区的倾斜率。在Kafka中，<strong>只有分区的Leader节点具有读写权限</strong>，真正影响读写性能的是Leader分区是否均衡，试想一下，如果一个topic有6个分区，但所有的Leader分区只分布在一两个Broker节点上，这个<strong>topic的写入、读取性能将受到制约，这个值建议维持在0％</strong>。</p>
</li>
<li><p>Replicas<br>副本数、副本因子，即一个分区数据存储的份数，该数值包含Leader分区。</p>
</li>
<li><p>Under Replicated %<br>没有跟上复制进度的副本比例，在Kafka的复制模型中，主分区负责读写，该复制组内的其他副本从主节点同步数据，如果跟不上主节点的复制进度，将被提出ISR，被剔除ISR的副本不具备选举Leader的资格，<strong>这个数据如果长期或频繁高于0，说明集群一定出现了问题</strong>。</p>
</li>
</ul>
<p>Producer Message/Sec<br>消息发送实时TPS，通过JMX采集，需要在kafka-manager中开启如下参数：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVibB9l70MzWAEFyUMZIvia0bxQrJYlciaeCmPBFNwWjJI95TiaUV293sX5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li>Summed Recent Offsets<br>该主题当前最大的消息偏移量。</li>
</ul>
<p>经过对Topic列表观察，发现开发环境存在大量的topic都只有一个队列，并且都分布在第一节点上，其截图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVRdFRpiaHaB1GsEt8uibID722MYlxAurdoJnTK6EcIKrtDzGZjkqL5vjA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">在这里插入图片描述</p>
<p>从界面上对应的指标：Brokers Spread即Broker的利用率只有３分之一，抽取几个数据量大的主题，判断其路由信息，得知都分布在第一个Broker节点上，这样就导致其中一个节点大量出现文章开头部分提到的错误：<strong>Too many open files</strong>。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><hr>
<h5 id="3-1-扩分区"><a href="#3-1-扩分区" class="headerlink" title="3.1 扩分区"></a>3.1 扩分区</h5><p>问题定位出来了，由于Broker利用率不均匀，大量topic只创建了一个队列，并且还集中落到了第一个节点。</p>
<p>针对这种情况，首先想到的方案：扩分区。</p>
<h5 id="3-1-1-通过Kafka-manager"><a href="#3-1-1-通过Kafka-manager" class="headerlink" title="3.1.1 通过Kafka-manager"></a>3.1.1 通过Kafka-manager</h5><p>Step1：在Kafka-manager的topic列表，点击具体的topic，进入详情页面，点击[add Partitions]，如图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVPXLfzpo8iaZoYQarg7ws4SczYTMFxic6YCNvJoYFmLs4kLl6Qwad1Ekg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>Step2：点击增加分区，弹出如下框：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVfuicI2KEPBO13zgMaw4Qbrcoe8meRTz2vyCDkx4QeicY8k9bYHZxk6oQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>说明如下：</p>
<ul>
<li>Partitions<br>扩容后的总分区个数，并不是本次增加的分区个数。</li>
<li>Brokers<br>分区需要分布的Broker，建议全选，充分利用整个集群的性能。</li>
</ul>
<h5 id="3-1-2-运维命令"><a href="#3-1-2-运维命令" class="headerlink" title="3.1.2 运维命令"></a>3.1.2 运维命令</h5><p>可以通过Kafka提供的kafka-topics命令，修改topic的分区，具体参考如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVzjZFWZ47UpkVb3iaNkWMHqenWIXsCBjuGW1T1e42cRiaWiby6sQf4lJzQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<blockquote>
<p>温馨提示：对这些运维命令不熟悉没关系，基本都提供了–help</p>
</blockquote>
<h5 id="3-2-分区移动"><a href="#3-2-分区移动" class="headerlink" title="3.2 分区移动"></a>3.2 分区移动</h5><p>由于存在大量的只有一个分区的topic，并且这些topic都分布到了第一个节点，是不是可以将某些topic的分区移动到其他节点呢？</p>
<p>接下来介绍一下分区移动如何操作。</p>
<h5 id="3-2-1-kafka-manager"><a href="#3-2-1-kafka-manager" class="headerlink" title="3.2.1 kafka-manager"></a>3.2.1 kafka-manager</h5><p>Step1：进入topic详情页面，点击[Generate Partition Assignments]，如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVm6ibJZh43iaVwh40jX6Fz3AsbnibricqkmBWbOHRVhdMH5UiaMRhicPQic3Hw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>Step2：进入页面后，选择需要迁移到的brroker，还可以改变topic的副本因子，最后点击[Generate Partition Assignments]，如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVa0Z8umQiaib5DRzibX2I0icvPyMdiaEm3Px6F8ERyGFy9cBziaQEwIN0QzGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>Step3：点击完成后，此时只是生成了分区迁移计划，并没有真正的执行，需要点击[Reassign Parttions]按钮。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVAceM0RH9Ktq7URs2FpdA404icN4qExz8ib0u0kJiaFNCHHz9QcZqDMVHg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h5 id="3-2-2-运维命令"><a href="#3-2-2-运维命令" class="headerlink" title="3.2.2 运维命令"></a>3.2.2 运维命令</h5><p>Step1：首先我们需要准备需要执行迁移的topic信息，例如将如下信息保存在文件dw_test_kafka_040802-topics-to-move.json中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;topics&quot;:</span><br><span class="line">    [</span><br><span class="line">        &#123;&quot;topic&quot;:&quot;dw_test_kafka_040802&quot;&#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Step2：使用kafka提供的kafka-reassign-partitions.sh命令生成执行计划</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVAUy43eHQT4wodWDoyINRX7icKnHesVuh6korWVXqjf3VrtYBZGU9gTw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>上面的参数其实对照kafka-manager的图理解起来会更快，点出如下关键点：</p>
<ul>
<li>–broker-list<br>分区需要分布的broker。如果多个，使用双引号，例如 “0,1,2”。</li>
<li>–topics-to-move-json-file<br>需要执行迁移的topic列表。</li>
<li>–generate<br>表示生成执行计划(并不真正执行)</li>
</ul>
<p>执行成功后会输出当前的分区分布计划与新的执行计划，通常我们可以先将当前的执行计划存储到一个备份目录中，将新生成的计划存储到一个文件中。</p>
<p>Step3：使用kafka提供的kafka-reassign-partitions.sh命令执行分区迁移计划</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVianvMtHR60SJxxBeHga7AZ7IsibjuAtTQL02R7hmFRy8wWgVv49brWGA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>其关键点如下：</p>
<ul>
<li>–reassignment-json-file<br>指定上一步骤生成的执行计划。</li>
</ul>
<p>执行成功过后输出Successfully，重分区是一个非常复杂的过程，命令执行完成后，并不会真正执行完成，可以通过查询主题的详细信息来判断是否真正迁移成功。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvox3eJ4x9luN4F8S7KTYgVDGxJwcvfIUpiaxrjI16DiaEL9FR3HzmvjzeoPAOGvLwZhRpDHqpjwpOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h4 id="进阶与架构思维"><a href="#进阶与架构思维" class="headerlink" title="进阶与架构思维"></a>进阶与架构思维</h4><hr>
<p>通过kafka-reassign-partitions.sh对分区进行迁移，会影响业务方的正常使用吗？即会影响消息的消费与发送吗？</p>
<p>我们需要对分区迁移的实现原理做进一步探究，本文暂不从源码角度详细剖析，只是举例阐述一下分区迁移的实现机制。</p>
<p>需求：一个TopicA的其中一个分区p0，分布在broker id为1,2,3上，目前要将其迁移到brokerId为4,5,6。</p>
<p>在介绍迁移过程之前，我们先定义三个变量：</p>
<ul>
<li>OAR<br>迁移前分区的分布情况。</li>
<li>RAR<br>迁移后的分区分布情况</li>
<li>AR<br>当前运行过程中的分区分布情况</li>
</ul>
<p>结合上述例子，其整个迁移步骤如下：</p>
<table>
<thead>
<tr>
<th align="center">AR</th>
<th align="center">Leader(ISR)</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{1,2,3}</td>
<td align="center">1{1,2,3}</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">1{1,2,3}</td>
<td align="left">首先基于RAR集合(迁移后的新broker)上创建对应的分区，并开始从Leader同步数据</td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">1{1,2,3,4,5,6}</td>
<td align="left">新创建的副本追上主节点的进度，并进入ISR集合</td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">4{1,2,3,4,5,6}</td>
<td align="left">如果Leader不在RAR所在的集合中，则发起一次选举，将Leader变更为RAR中其中一台。</td>
</tr>
<tr>
<td align="center">{1,2,3,4,5,6}</td>
<td align="center">4{4,5,6}</td>
<td align="left">将OAR中的副本状态设置为OfflineReplica(下线)，将其从ISR中剔除</td>
</tr>
<tr>
<td align="center">{4,5,6}</td>
<td align="center">4{4,5,6}</td>
<td align="left">删除下线的副本，完成整个迁移操作</td>
</tr>
</tbody></table>
<p>从上面这个过程，只有在Leader选举期间会对消息发送、消息消费造成影响，但通过Zookeeper实现Leader选举可在秒级别响应，结合Kafka消息发送端的缓冲队列、重试机制，在理论上可以做到对业务无影响。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%8A%80%E6%9C%AF/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%8A%80%E6%9C%AF/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-01/" class="post-title-link" itemprop="url">分库分表-01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 09:21:40" itemprop="dateCreated datePublished" datetime="2021-05-21T09:21:40+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/q_MMXEphKl56ngLy8R6jmg">https://mp.weixin.qq.com/s/q_MMXEphKl56ngLy8R6jmg</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-01/" class="post-title-link" itemprop="url">分布式事务一致性引擎-01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 09:17:23" itemprop="dateCreated datePublished" datetime="2021-05-21T09:17:23+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="分布式事务从入门到放弃-二-–详述DT引擎一致性原理及设计"><a href="#分布式事务从入门到放弃-二-–详述DT引擎一致性原理及设计" class="headerlink" title="分布式事务从入门到放弃(二)–详述DT引擎一致性原理及设计"></a>分布式事务从入门到放弃(二)–详述DT引擎一致性原理及设计</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dFmxdLtPFCXIR73gg2d1UA">https://mp.weixin.qq.com/s/dFmxdLtPFCXIR73gg2d1UA</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;mid=2650000675&amp;idx=1&amp;sn=f411dcfdf6135409b94963cbb45b4b0c&amp;chksm=882fa783bf582e950184684cb74ca701cde6618068a31b4a07773dc3c7f5d7afd400178df2c1&amp;cur_album_id=1579057632903004162&amp;scene=189#rd">https://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;mid=2650000675&amp;idx=1&amp;sn=f411dcfdf6135409b94963cbb45b4b0c&amp;chksm=882fa783bf582e950184684cb74ca701cde6618068a31b4a07773dc3c7f5d7afd400178df2c1&amp;cur_album_id=1579057632903004162&amp;scene=189#rd</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zAgR8Axo_nTiwvVEkVMM9w">https://mp.weixin.qq.com/s/zAgR8Axo_nTiwvVEkVMM9w</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-02/" class="post-title-link" itemprop="url">分布式事务一致性引擎-01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 09:17:23" itemprop="dateCreated datePublished" datetime="2021-05-21T09:17:23+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="分布式事务从入门到放弃–数据一致性引擎概览"><a href="#分布式事务从入门到放弃–数据一致性引擎概览" class="headerlink" title="分布式事务从入门到放弃–数据一致性引擎概览"></a>分布式事务从入门到放弃–数据一致性引擎概览</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Ow2HWBEgeqHdbMw3XNeyoA">https://mp.weixin.qq.com/s/Ow2HWBEgeqHdbMw3XNeyoA</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-03/" class="post-title-link" itemprop="url">分布式事务一致性引擎-01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 09:17:23" itemprop="dateCreated datePublished" datetime="2021-05-21T09:17:23+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="在所依赖存储不授信的场景下实现柔性事务降级"><a href="#在所依赖存储不授信的场景下实现柔性事务降级" class="headerlink" title="在所依赖存储不授信的场景下实现柔性事务降级"></a>在所依赖存储不授信的场景下实现柔性事务降级</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zAgR8Axo_nTiwvVEkVMM9w">https://mp.weixin.qq.com/s/zAgR8Axo_nTiwvVEkVMM9w</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring-%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring-%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">spring-06-事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 08:07:39" itemprop="dateCreated datePublished" datetime="2021-05-21T08:07:39+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-11-28 22:07:34" itemprop="dateModified" datetime="2022-11-28T22:07:34+08:00">2022-11-28</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="事务的应用"><a href="#事务的应用" class="headerlink" title="事务的应用"></a>事务的应用</h1><h2 id="数据库的事务"><a href="#数据库的事务" class="headerlink" title="数据库的事务"></a>数据库的事务</h2><blockquote>
<p>数据库事务（Transaction，简写为 TX）是数据库管理系统执行过程中的一个逻辑单位，是可以提交或回滚的工作的原子单元。当事务对数据库进行多次更改时，要么在提交事务时所有更改都成功，要么在回滚事务时所有更改都被撤消。</p>
</blockquote>
<h2 id="Mysql-中的事务"><a href="#Mysql-中的事务" class="headerlink" title="Mysql 中的事务"></a>Mysql 中的事务</h2><ul>
<li><code>START TRANSACTION</code>或 <code>BEGIN</code>开始新事务。</li>
<li><code>COMMIT</code> 提交当前事务。</li>
<li><code>ROLLBACK</code> 回滚当前事务。</li>
<li><code>SET autocommit</code> 禁用或启用当前会话的默认自动提交模式。</li>
</ul>
<p><strong>默认情况下，Mysql 是自动提交的模式，所有语句会立即提交</strong></p>
<h2 id="JDBC-中的事务"><a href="#JDBC-中的事务" class="headerlink" title="JDBC 中的事务"></a>JDBC 中的事务</h2><p><strong>JDBC</strong> 是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了查询和更新数据库中数据的方法。JDBC 也是 Sun Microsystems 的商标（现在属于 Oracle），是面向关系型数据库的。</p>
<p>上面说到，Mysql 是默认自动提交的，所以 JDBC 中事务事务的第一步，需要<strong>禁用自动提交：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.setAutoCommit(false);</span><br></pre></td></tr></table></figure>

<p><strong>提交事务：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.commit();</span><br></pre></td></tr></table></figure>

<p><strong>回滚事务：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.rollback();</span><br></pre></td></tr></table></figure>

<p><strong>一个完整流程的例子（摘自 Oracle JDBC 文档）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCoffeeSales</span><span class="params">(HashMap&lt;String, Integer&gt; salesForWeek)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    PreparedStatement updateSales = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement updateTotal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    String updateString =</span><br><span class="line">        <span class="string">&quot;update &quot;</span> + dbName + <span class="string">&quot;.COFFEES &quot;</span> +</span><br><span class="line">        <span class="string">&quot;set SALES = ? where COF_NAME = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String updateStatement =</span><br><span class="line">        <span class="string">&quot;update &quot;</span> + dbName + <span class="string">&quot;.COFFEES &quot;</span> +</span><br><span class="line">        <span class="string">&quot;set TOTAL = TOTAL + ? &quot;</span> +</span><br><span class="line">        <span class="string">&quot;where COF_NAME = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        con.setAutoCommit(<span class="keyword">false</span>); <span class="comment">//第一步</span></span><br><span class="line">        updateSales = con.prepareStatement(updateString);</span><br><span class="line">        updateTotal = con.prepareStatement(updateStatement);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : salesForWeek.entrySet()) &#123;</span><br><span class="line">            updateSales.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">            updateSales.setString(<span class="number">2</span>, e.getKey());</span><br><span class="line">            updateSales.executeUpdate();</span><br><span class="line">            updateTotal.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">            updateTotal.setString(<span class="number">2</span>, e.getKey());</span><br><span class="line">            updateTotal.executeUpdate();</span><br><span class="line">            con.commit(); <span class="comment">//第二步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e ) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">        <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.err.print(<span class="string">&quot;Transaction is being rolled back&quot;</span>);</span><br><span class="line">                con.rollback(); <span class="comment">//第三步</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(SQLException excep) &#123;</span><br><span class="line">                JDBCTutorialUtilities.printSQLException(excep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (updateSales != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateSales.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (updateTotal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateTotal.close();</span><br><span class="line">        &#125;</span><br><span class="line">        con.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-事务管理器简介"><a href="#Spring-事务管理器简介" class="headerlink" title="Spring 事务管理器简介"></a>Spring 事务管理器简介</h2><p>Spring 为事务管理提供了统一的抽象，有以下优点：<!--注意：Spring只提供抽象，不提供实现--></p>
<ul>
<li>跨不同事务 API（例如 Java 事务 API（JTA），JDBC，Hibernate，Java 持久性 API（JPA）和 Java 数据对象（JDO））的一致编程模型。</li>
<li>支持声明式事务管理（注解形式）</li>
<li>与 JTA 之类的复杂事务 API 相比， 用于程序化事务管理的 API 更简单</li>
<li>和 Spring 的 Data 层抽象集成方便（比如 Spring - Hibernate/Jdbc/Mybatis/Jpa…）</li>
</ul>
<p><a href="">Spring 的事务管理器只是一个接口 / 抽象，不同的 DB 层框架（其实不光是 DB 类框架，支持事务模型的理论上都可以使用这套抽象） 可能都需要实现此标准才可以更好的工作</a>， </p>
<p>核心接口是<code>org.springframework.transaction.support.AbstractPlatformTransactionManager</code>，其代码位于<code>spring-tx</code>模块中，比如 Hibernate 中的实现为：<code>org.springframework.orm.hibernate4.HibernateTransactionManager</code></p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>事务，自然是控制业务的，在一个业务流程内，往往希望保证原子性，要么全成功要么全失败。</p>
<p>所以事务一般是加载<code>@Service</code>层，一个 Service方法内调用了多个数据库操作（比如 Dao），在 Service 结束后事务自动提交，如有异常抛出则事务回滚。</p>
<p>这也是 Spring 事务管理的基本使用原则。</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>在被 Spring 管理的类头上增加<code>@Transactional</code>注解，即可对该类下的所有方法开启事务管理。事务开启后，方法内的操作无需手动开启 / 提交 / 回滚事务，一切交给 Spring 管理即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxTestService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepo orderRepo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        orderRepo.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以只在方法上配置，方法配置的优先级是大于类的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxTestService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepo orderRepo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        orderRepo.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TransactionTemplate"><a href="#TransactionTemplate" class="headerlink" title="TransactionTemplate"></a>TransactionTemplate</h4><p>TransactionTemplate 这中方式，其实和使用注解形式的区别不大，其核心功能也是由 TransactionManager 实现的，这里只是换了个入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(TransactionCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.transactionManager <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((CallbackPreferringPlatformTransactionManager) <span class="keyword">this</span>.transactionManager).execute(<span class="keyword">this</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取事务信息</span></span><br><span class="line">        TransactionStatus status = <span class="keyword">this</span>.transactionManager.getTransaction(<span class="keyword">this</span>);</span><br><span class="line">        T result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行业务代码</span></span><br><span class="line">            result = action.doInTransaction(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理异常回滚</span></span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="comment">// Transactional code threw application exception -&gt; rollback</span></span><br><span class="line">            rollbackOnException(status, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">            <span class="comment">// Transactional code threw error -&gt; rollback</span></span><br><span class="line">            rollbackOnException(status, err);</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// Transactional code threw unexpected exception -&gt; rollback</span></span><br><span class="line">            rollbackOnException(status, ex);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(ex, <span class="string">&quot;TransactionCallback threw undeclared checked exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        <span class="keyword">this</span>.transactionManager.commit(status);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="XML-配置-tx-advice"><a href="#XML-配置-tx-advice" class="headerlink" title="XML 配置 tx:advice"></a>XML 配置 tx:advice</h4><p>过于古老，不做解释</p>
<h3 id="隔离级别-Isolation-Level"><a href="#隔离级别-Isolation-Level" class="headerlink" title="隔离级别 (Isolation Level)"></a>隔离级别 (Isolation Level)</h3><p>事务隔离级别是数据库最重要的特性之一，他保证了脏读 / 幻读等问题不会发生。作为一个事务管理框架自然也是支持此配置的，在 @Transactional 注解中有一个 isolation 配置，可以很方便的配置各个事务的隔离级别，等同于<code>connection.setTransactionIsolation()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Isolation &#123;</span><br><span class="line">    DEFAULT(-1),</span><br><span class="line">    READ_UNCOMMITTED(1),</span><br><span class="line">    READ_COMMITTED(2),</span><br><span class="line">    REPEATABLE_READ(4),</span><br><span class="line">    SERIALIZABLE(8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h3><p>传播行为和数据库功能无关，只是事务管理器为了处理复杂业务而设计的一个机制。</p>
<p>比如现在有这样一个调用场景，<code>A Service -&gt; B Service -&gt; C Service</code>，但是希望 A/B 在一个事务内，C 是一个独立的事务，同时 C 如果出错，不影响 AB 所在的事务。</p>
<p>此时，就可以通过传播行为来处理；将 C Service 的事务配置为<code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code>即可</p>
<p>Spring 支持以下几种传播行为：</p>
<table>
<thead>
<tr>
<th align="left"><strong>PROPAGATION TYPE</strong></th>
<th align="left"><strong>DESCRIPTION</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>PROPAGATION_REQUIRED</strong></td>
<td align="left">支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 如果正要执行的事务不在另外一个事务里，那么就起一个新的事务; 比如说，<code>ServiceB.methodB</code>的事务级别定义为PROPAGATION_<code>REQUIRED</code>, 那么由于执行<code>ServiceA.methodA</code>的时候， <code>ServiceA.methodA</code>已经起了事务，这时调用<code>ServiceB.methodB</code>，<code>ServiceB.methodB</code>看到自己已经运行在<code>ServiceA.methodA</code> 的事务内部，就不再起新的事务。而假如<code>ServiceA.methodA</code>运行的时<code>候ServiceB.method</code>B发现自己没有在事务中，他就会为自己新建一个事务。 这样，在<code>ServiceA.methodA</code>或者在<code>ServiceB.methodB</code>内的任何地方出现异常，事务都会被回滚。即使<code>ServiceB.methodB</code>的事务已经被提交，但是<code>ServiceA.methodA</code>在接下来fail要回滚，<code>ServiceB.methodB</code>也要回滚。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_SUPPORTS</strong></td>
<td align="left">支持当前事务，如果当前没有事务，就以非事务方式执行。 如果当前在事务中，即以事务的形式运行，如果当前不在一个事务中，那么就以非事务的形式运行。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_MANDATORY</strong></td>
<td align="left">支持当前事务，如果当前没有事务，就抛出异常。 必须在一个事务中运行，也就是说，他只能被一个父事务调用。否则，他就要抛出异常。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_REQUIRES_NEW</strong></td>
<td align="left">新建事务，如果当前存在事务，把当前事务挂起。 比如我们设计<code>ServiceA.methodA</code>的事务级别为PROPAGATION_<code>REQUIRED</code>，<code>ServiceB.methodB</code>的事务级别为PROPAGATION_<code>REQUIRES_NEW</code>，那么当执行到<code>ServiceB.methodB</code>的时候，<code>ServiceA.methodA</code>所在的事务就会挂起，<code>ServiceB.methodB</code>会起一个新的事务，等待<code>ServiceB.methodB</code>的事务完成以后，他才继续执行。他与PROPAGATION_<code>REQUIRED </code>的事务区别在于事务的回滚程度了。因为<code>ServiceB.methodB</code>是新起一个事务，那么就是存在两个不同的事务。如果<code>ServiceB.methodB</code>已经提交，那么<code>ServiceA.methodA</code>失败回滚，<code>ServiceB.methodB</code>是不会回滚的。如果<code>ServiceB.methodB</code>失败回滚，如果他抛出的异常被<code>ServiceA.methodA</code>捕获，<code>ServiceA.methodA</code>事务仍然可能提交。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_NOT_SUPPORTED</strong></td>
<td align="left">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 不支持当前事务。比如<code>ServiceA.methodA</code>的事务级别是PROPAGATION_<code>REQUIRED</code>，而<code>ServiceB.methodB</code>的事务级别是PROPAGATION_<code>NOT_SUPPORTED</code>，那么当执行到<code>ServiceB.methodB</code>时，<code>ServiceA.methodA</code>的事务挂起，而<code>ServiceB.methodB</code>则以非事务的方式运行完，再继续<code>ServiceA.methodA</code>的事务。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_NEVER</strong></td>
<td align="left">以非事务方式执行，如果当前存在事务，则抛出异常。 不能在事务中运行。假设<code>ServiceA.methodA</code>的事务级别是PROPAGATION_<code>REQUIRED</code>，而ServiceB.methodB的事务级别是PROPAGATION_<code>NEVER</code>， 那么<code>ServiceB.methodB</code>就要抛出异常了。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_NESTED</strong></td>
<td align="left">支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 理解Nested的关键是savepoint。他与PROPAGATION_<code>REQUIRES_NEW</code>的区别是，PROPAGATION_<code>REQUIRES_NEW</code>另起一个事务，将会与他的父事务相互独立，而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。 而<code>Nested</code>事务的好处也是他有一个savepoint。</td>
</tr>
</tbody></table>
<h3 id="回滚策略"><a href="#回滚策略" class="headerlink" title="回滚策略"></a>回滚策略</h3><p>@Transactional 中有 4 个配置回滚策略的属性，分为 Rollback 策略，和 NoRollback 策略</p>
<p><strong>默认情况下，RuntimeException 和 Error 这两种异常会导致事务回滚，普通的 Exception（需要 Catch 的）异常不会回滚。</strong></p>
<h4 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h4><p>配置需要回滚的异常类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 异常类Class</span><br><span class="line">Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;</span><br><span class="line"># 异常类ClassName，可以是FullName&#x2F;SimpleName</span><br><span class="line">String[] rollbackForClassName() default &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="NoRollback"><a href="#NoRollback" class="headerlink" title="NoRollback"></a>NoRollback</h4><p>针对一些要特殊处理的业务逻辑，比如插一些日志表，或者不重要的业务流程，希望就算出错也不影响事务的提交。</p>
<p>可以通过配置 NoRollbackFor 来实现，让某些异常不影响事务的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 异常类Class</span><br><span class="line">Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;</span><br><span class="line"># 异常类ClassName，可以是FullName&#x2F;SimpleName</span><br><span class="line">String[] noRollbackForClassName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="只读控制"><a href="#只读控制" class="headerlink" title="只读控制"></a>只读控制</h3><p>设置当时事务的只读标示，等同于<code>connection.setReadOnly()</code></p>
<h3 id="关键名词解释"><a href="#关键名词解释" class="headerlink" title="关键名词解释"></a>关键名词解释</h3><table>
<thead>
<tr>
<th>名词</th>
<th>概念</th>
</tr>
</thead>
<tbody><tr>
<td>PlatformTransactionManager</td>
<td>事务管理器，管理事务的各生命周期方法，简称 TxMgr</td>
</tr>
<tr>
<td>TransactionAttribute</td>
<td>事务属性, 包含隔离级别，传播行为, 是否只读等信息，简称 TxAttr</td>
</tr>
<tr>
<td>TransactionStatus</td>
<td>事务状态，包含当前事务、挂起等信息，简称 TxStatus</td>
</tr>
<tr>
<td>TransactionInfo</td>
<td>事务信息，内含 TxMgr, TxAttr, TxStatus 等信息，简称 TxInfo</td>
</tr>
<tr>
<td>TransactionSynchronization</td>
<td>事务同步回调，内含多个钩子方法，简称 TxSync / transaction synchronization</td>
</tr>
<tr>
<td>TransactionSynchronizationManager</td>
<td>事务同步管理器，维护当前线程事务资源，信息以及 TxSync 集合</td>
</tr>
</tbody></table>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void execute(TxCallback txCallback)&#123;</span><br><span class="line">    &#x2F;&#x2F;获取连接</span><br><span class="line">    Connection connection &#x3D; acquireConnection();</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F;执行业务代码</span><br><span class="line">        doInService();</span><br><span class="line">        &#x2F;&#x2F;提交事务</span><br><span class="line">        connection.commit();</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        &#x2F;&#x2F;回滚事务</span><br><span class="line">        rollback(connection);</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        &#x2F;&#x2F;释放连接</span><br><span class="line">        releaseConnection(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 事务管理的基本原理就是以上代码，获取连接 -&gt; 执行代码 -&gt; 提交 / 回滚事务。Spring 只是将这个流程给抽象出来了，所有事务相关的操作都交由 TransactionManager 去实现，然后封装一个<strong>模板形式的入口</strong>来执行</p>
<p>比如<code>org.springframework.transaction.support.TransactionTemplate</code>的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException &#123;</span><br><span class="line">      if (this.transactionManager instanceof CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line">          return ((CallbackPreferringPlatformTransactionManager) this.transactionManager).execute(this, action);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          &#x2F;&#x2F;通过事务管理器获取事务</span><br><span class="line">          TransactionStatus status &#x3D; this.transactionManager.getTransaction(this);</span><br><span class="line">          T result;</span><br><span class="line">          try &#123;</span><br><span class="line">              &#x2F;&#x2F;执行业务代码</span><br><span class="line">              result &#x3D; action.doInTransaction(status);</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;处理异常回滚</span><br><span class="line">          catch (RuntimeException ex) &#123;</span><br><span class="line">              &#x2F;&#x2F; Transactional code threw application exception -&gt; rollback</span><br><span class="line">              rollbackOnException(status, ex);</span><br><span class="line">              throw ex;</span><br><span class="line">          &#125;</span><br><span class="line">          catch (Error err) &#123;</span><br><span class="line">              &#x2F;&#x2F; Transactional code threw error -&gt; rollback</span><br><span class="line">              rollbackOnException(status, err);</span><br><span class="line">              throw err;</span><br><span class="line">          &#125;</span><br><span class="line">          catch (Exception ex) &#123;</span><br><span class="line">              &#x2F;&#x2F; Transactional code threw unexpected exception -&gt; rollback</span><br><span class="line">              rollbackOnException(status, ex);</span><br><span class="line">              throw new UndeclaredThrowableException(ex, &quot;TransactionCallback threw undeclared checked exception&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;提交事务</span><br><span class="line">          this.transactionManager.commit(status);</span><br><span class="line">          return result;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注解形式的事务（@Transactional），实现机制也是一样，基于 Spring 的 AOP，将上面 Template 的模式换成了自动的 AOP，在 AOP 的 Interceptor（<code>org.springframework.transaction.interceptor.TransactionInterceptor</code>）中来执行这套流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the transaction attribute is null, the method is non-transactional.</span><br><span class="line">        final TransactionAttribute txAttr &#x3D; getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">        &#x2F;&#x2F;获取事务管理器</span><br><span class="line">        final PlatformTransactionManager tm &#x3D; determineTransactionManager(txAttr);</span><br><span class="line">        final String joinpointIdentification &#x3D; methodIdentification(method, targetClass);</span><br><span class="line"></span><br><span class="line">        if (txAttr &#x3D;&#x3D; null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Standard transaction demarcation with getTransaction and commit&#x2F;rollback calls.</span><br><span class="line">            &#x2F;&#x2F;创建事务</span><br><span class="line">            TransactionInfo txInfo &#x3D; createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">            Object retVal &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; This is an around advice: Invoke the next interceptor in the chain.</span><br><span class="line">                &#x2F;&#x2F; This will normally result in a target object being invoked.</span><br><span class="line">                &#x2F;&#x2F;执行被“AOP”的代码</span><br><span class="line">                retVal &#x3D; invocation.proceedWithInvocation();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; target invocation exception</span><br><span class="line">                &#x2F;&#x2F;处理异常回滚</span><br><span class="line">                completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                &#x2F;&#x2F;清除资源</span><br><span class="line">                cleanupTransactionInfo(txInfo);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;提交事务</span><br><span class="line">            commitTransactionAfterReturning(txInfo);</span><br><span class="line">            return retVal;</span><br><span class="line">        &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="复杂流程下的事务传播-保持相同事务的关键："><a href="#复杂流程下的事务传播-保持相同事务的关键：" class="headerlink" title="复杂流程下的事务传播 / 保持相同事务的关键："></a>复杂流程下的事务传播 / 保持相同事务的关键：</h3><ul>
<li>对于复杂一些的业务流程，会出现各种类之间的调用，Spring 是如何做到保持同一个事务的？<ul>
<li>其实基本原理很简单，只需要将当前事务（Connection）隐式的保存至事务管理器内，后续方法在执行 JDBC 操作前，从事务管理器内获取即可：</li>
<li>比如<code>HibernateTemplate</code>中的<code>SessionFactory</code>中的<code>getCurrentSession</code>，这里的<code>getCurrentSession</code>就是从（可能是间接的）Spring 事务管理器中获取的</li>
<li><strong>Spring 事务管理器将处理事务时的相关临时资源（Connection 等）存在<code>org.springframework.transaction.support.TransactionSynchronizationManager</code>中，通过 ThreadLocal 维护</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(TransactionSynchronizationManager.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;Map&lt;Object, Object&gt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt;(<span class="string">&quot;Transaction synchronizations&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;String&gt;(<span class="string">&quot;Current transaction name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;Boolean&gt;(<span class="string">&quot;Current transaction read-only status&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;Integer&gt;(<span class="string">&quot;Current transaction isolation level&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;Boolean&gt;(<span class="string">&quot;Actual transaction active&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对一些复杂场景，嵌套事务 + 独立事务，涉及到挂起（suspend），恢复（resume）的情况，相关资源也是存储在**<code>TransactionSynchronizationManager</code>** 中的，方便嵌套事务的处理。</p>
<p>比如 A-&gt;B 时，A 方法已经开启了事务，并将当前事务资源绑定在**<code>TransactionSynchronizationManager</code>，<strong>那么执行 B 之前，会检测当前是否已经存在事务；检测方式就是从</strong><code>TransactionSynchronizationManager</code>**查找并检测状态，如果已经在事务内，那么就根据不同的传播行为配置来执行不同的逻辑，对于 REQUIRES_NEW 等传播行为的处理会麻烦一些，会涉及到 “挂起（suspend）” 和恢复 (resume) 的操作。</p>
<h1 id="事务失效的4种场景"><a href="#事务失效的4种场景" class="headerlink" title="事务失效的4种场景"></a>事务失效的4种场景</h1><h2 id="Transactional注解的方法为非public"><a href="#Transactional注解的方法为非public" class="headerlink" title="@Transactional注解的方法为非public"></a>@Transactional注解的方法为非public</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>TestServiceImpl#insertTestWrongModifier()虽然被@Transactional修饰，但是不是public访问符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTestWrongModifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   TestServiceImpl testService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testInvoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//调用@Transactional标注的默认访问符方法</span></span><br><span class="line">        testService.insertTestWrongModifier();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的访问方式，导致事务没开启，因此在方法抛出异常时，testMapper.insert(new Test(10,20,30));操作不会进行回滚。如果<code>TestServiceImpl#insertTestWrongModifier</code>方法改为public的话将会正常开启事务，testMapper.insert(new Test(10,20,30));将会进行回滚。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p><code>@Transactional</code>是基于动态代理实现的，在bean初始化过程中，对含有<code>@Transactional</code>标注的bean实例创建代理对象，标注<code>@Transactional</code>的方法如果修饰符不是public，那么将不会对bean进行代理对象创建或者不会对方法进行代理调用。</p>
<p><code>@Transactional</code>注解实现原理中，介绍了如何判定一个bean是否创建代理对象，大概逻辑是：</p>
<blockquote>
<p>根据spring创建的一个aop切点<code>BeanFactoryTransactionAttributeSourceAdvisor</code>实例，遍历当前bean的class的方法对象，判断方法上面的注解信息是否包含<code>@Transactional</code>，如果当前bean的任何一个方法包含<code>@Transactional</code>注解信息，那么就是适配这个<code>BeanFactoryTransactionAttributeSourceAdvisor</code>切点。则当前bean需要创建代理对象，然后代理对象为我们管理事务开闭逻辑。</p>
</blockquote>
<p>spring源码中，在拦截bean的创建过程，寻找bean适配的切点时，运用到<code>AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class&lt;?&gt;, boolean)</code>的方法，目的就是寻找方法上面的@Transactional信息，如果有，就表示切点BeanFactoryTransactionAttributeSourceAdvisor能够应用（canApply）到bean中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">   Assert.notNull(pc, <span class="string">&quot;Pointcut must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">   <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">      <span class="comment">// No need to iterate the methods if we&#x27;re matching any method anyway...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历class的方法对象</span></span><br><span class="line">   Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">   classes.add(targetClass);</span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">      Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||</span><br><span class="line">             <span class="comment">//适配查询方法上的@Transactional注解信息  </span></span><br><span class="line">             methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在上面的方法打断点，最终上面的代码还会调用如下方法来判断。在下面的方法上断点，回头看看方法调用堆栈也是不错的方式跟踪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractFallbackTransactionAttributeSource#getTransactionAttribute</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">   <span class="comment">//非public 方法，返回@Transactional信息一律是null</span></span><br><span class="line">   <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后面省略.......</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>以一开始的测试代码为例，如果正常的修饰符的testService是经过cglib创建的代理对象</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufWFWRfYhnMbqZeQOpFticE0Axp7cJAbcFdWiackBtAejpe4iaDLb15vrtU7c62ibuvFNPVo80qLOvczQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li>如果class中的方法都是非public的那么将不是代理对象</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufWFWRfYhnMbqZeQOpFticE0oDNLPEFoUyIDeAad2EpRbgActMzE1SfRbRPqXEBJINbLLsVAnv6fYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><p>考虑一种情况，如下面代码所示。两个方法都被@Transactional注解标注，但是一个有public修饰符一个没有，那么这种情况一定会创建代理对象，因为至少有一个public修饰符的@Transactional注解标注方法。</p>
<p>创建了代理对象，insertTestWrongModifier就会开启事务吗？答案是不会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    TestMapper testMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTestWrongModifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因是在动态代理对象进行代理逻辑调用时，在cglib创建的代理对象的拦截函数中<code>CglibAopProxy.DynamicAdvisedInterceptor#intercept</code>，有一个逻辑如下，目的是获取当前被代理对象的当前需要执行的method适配的aop逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; chain &#x3D; this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br></pre></td></tr></table></figure>

<p>而针对@Transactional注解查找aop逻辑过程，相似地，也是执行一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractFallbackTransactionAttributeSource#getTransactionAttribute</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</code></li>
</ul>
<p>也就是说还需要找一个方法上的@Transactional注解信息，没有的话就不执行代理@Transactional对应的代理逻辑，直接执行方法。没有了@Transactional注解代理逻辑，就无法开启事务，这也是上一篇已经讲到的。</p>
<h2 id="在类内部调用内部-Transactional标注的方法"><a href="#在类内部调用内部-Transactional标注的方法" class="headerlink" title="在类内部调用内部@Transactional标注的方法"></a>在类内部调用内部@Transactional标注的方法</h2><p>入口为 main 方法，在 testTx 方法中配置了 @Transactional 注解，同时在插入数据后抛出 RuntimeException 异常，但是方法执行后插入的数据并没有回滚，竟然插入成功了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> xxxService&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//内部调用事务方法</span></span><br><span class="line">        testTx();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UrlMappingEntity urlMappingEntity = <span class="keyword">new</span> UrlMappingEntity();</span><br><span class="line">        urlMappingEntity.setUrl(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        urlMappingRepository.save(urlMappingEntity);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不生效的原因是因为入口的方法 / 类没有增加 @Transaction 注解，由于 Spring 的事务管理器也是基于 AOP 实现的，不管是 Cglib(ASM) 还是 Jdk 的动态代理，本质上也都是子类机制；在同类之间的方法调用会直接调用本类代码，不会执行动态代理曾的代码；由于入口方法<code>main</code>没有增加代理注解，所以<code>textTx</code>方法上增加的事务注解并不会生效</p>
<p>解决方法：</p>
<ol>
<li><p>方法testTx是一个内部方法，使用手动开始事务，不能用注解</p>
</li>
<li><p>通过在方法内部获得当前类代理对象的方式，通过代理对象调用方法B</p>
<ul>
<li><p>springboot启动类加上注解:<code>@EnableAspectJAutoProxy(exposeProxy = true)</code></p>
</li>
<li><p>方法test内部获取代理对象调用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">		xxxServiceImpl proxyObj = (xxxServiceImpl) AopContext.currentProxy();</span><br><span class="line">    proxyObj.testTx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>xxxService维护一个自己的xxxService，这样就有代理对象了。<!--注意使用延迟加载避免循环依赖--></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowire</span><br><span class="line">private xxxService service;</span><br><span class="line"></span><br><span class="line">public void main()&#123;</span><br><span class="line">    &#x2F;&#x2F;内部调用事务方法</span><br><span class="line">    service.testTx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h3><p>既然事务管理是基于动态代理对象的代理逻辑实现的，那么如果在类内部调用类内部的事务方法，这个调用事务方法的过程并不是通过代理对象来调用的，而是直接通过this对象来调用方法，绕过的代理对象，肯定就是没有代理逻辑了。</p>
<h2 id="异步-跨线程后，事务失效"><a href="#异步-跨线程后，事务失效" class="headerlink" title="异步/跨线程后，事务失效"></a>异步/跨线程后，事务失效</h2><p>比如在一个事务方法中，开启了子线程操作库，那么此时子线程的事务和主线程事务是不同的。</p>
<p>因为在 Spring 的事务管理器中，事务相关的资源（连接，session，事务状态之类）都是存放在 TransactionSynchronizationManager 中的，通过 ThreadLocal 存放，如果跨线程的话就无法保证一个事务了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># TransactionSynchronizationManager.java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Transaction synchronizations&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Current transaction name&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Current transaction read-only status&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Current transaction isolation level&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Actual transaction active&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="事务方法内部捕捉了异常，但没有throw-Runtime-Exception或者Error"><a href="#事务方法内部捕捉了异常，但没有throw-Runtime-Exception或者Error" class="headerlink" title="事务方法内部捕捉了异常，但没有throw Runtime Exception或者Error"></a>事务方法内部捕捉了异常，但没有throw Runtime Exception或者Error</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.transaction.UnexpectedRollbackException: </span><br><span class="line">Transaction silently rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure>

<p>这个异常是由于在同一个事务内，多个事务方法之间调用，子方法抛出异常，但又被父方法忽略了导致的。</p>
<p>因为子方法抛出了异常，Spring 事务管理器会将当前事务标为失败状态，准备进行回滚，可是当子方法执行完毕出栈后，父方法又忽略了此异常，待方法执行完毕后正常提交时，事务管理器会检查回滚状态，若有回滚标示则抛出此异常。具体可以参考<code>org.springframework.transaction.support.AbstractPlatformTransactionManager#processCommit</code></p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B</span><br><span class="line"># A Service(@Transactional):</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTx</span><span class="params">()</span></span>&#123;</span><br><span class="line">    urlMappingRepo.deleteById(<span class="number">98l</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        txSubService.testSubTx();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      	<span class="comment">//捕获异常，但是没有抛出</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># B Service(@Transactional)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubTx</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h3><p>Traditional默认是捕捉Runtime Exception和Error的，如果程序之运行时发生的异常不是Runtime Exception或者Error，是不会被回滚的，所以要rollbackfor exception</p>
<h1 id="Spring对事务异常的处理"><a href="#Spring对事务异常的处理" class="headerlink" title="Spring对事务异常的处理"></a>Spring对事务异常的处理</h1><p>java阿里巴巴规范提示：方法【edit】需要在Transactional注解指定rollbackFor或者在方法中显示的rollback。</p>
<h2 id="jdk异常分类"><a href="#jdk异常分类" class="headerlink" title="jdk异常分类"></a>jdk异常分类</h2><h2 id="Transactional-正确的写法"><a href="#Transactional-正确的写法" class="headerlink" title="@Transactional 正确的写法"></a>@Transactional 正确的写法</h2><ul>
<li><p>Spring默认对unchecked exceptions (RuntimeException及其子类和Error) 回滚。</p>
</li>
<li><p>如果是 checked Exception，分4种情况：</p>
<ul>
<li>catch了不做任何异常抛出，Spring没有捕获到显然不用回滚；</li>
<li>catch了又抛出RuntimeException，Spring捕获到肯定会回滚；</li>
<li>catch了但又抛出了unchecked Exception，Spring默认不回滚；</li>
<li>不catch直接抛出unchecked Exception,  Spring默认也是不回滚。</li>
</ul>
</li>
</ul>
<p>Spring框架的事务基础架构代码将默认地只在抛出Runtime Exception和unchecked exceptions时才标识事务回滚。从事务方法中抛出的Checked exceptions将不被标识进行事务回滚。</p>
<ol>
<li>让checked例外也回滚：在整个方法前加上 <code>@Transactional(rollbackFor=Exception.class)</code></li>
<li>让unchecked例外不回滚：<code>@Transactional(notRollbackFor=RunTimeException.class)</code></li>
<li>不需要事务管理的(只查询的)方法：<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code></li>
</ol>
<p>注意：如果异常被 <code>try &#123;&#125; catch &#123;&#125;</code> 了，事务就不回滚了，如果想让事务回滚必须再往外抛 <code>try &#123;&#125; catch &#123;throw Exception&#125;</code> 。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。</p>
<p>你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）</p>
<p>2、@Transactional 注解标识的方法，处理过程尽量的简单。</p>
<p>尤其是带锁的事务方法，能不放在事务里面的最好不要放在事务里面。</p>
<p>可以将常规的数据库查询操作放在事务前面进行，而事务内进行增、删、改、加锁查询等操作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
