<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>BootFei&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="BootFei&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BootFei&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-分布式系统/分布式-事务/一致性/分布式事务一致性引擎-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-02/" class="article-date">
  <time datetime="2021-05-21T01:17:23.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-02/">分布式事务一致性引擎-01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="分布式事务从入门到放弃–数据一致性引擎概览"><a href="#分布式事务从入门到放弃–数据一致性引擎概览" class="headerlink" title="分布式事务从入门到放弃–数据一致性引擎概览"></a>分布式事务从入门到放弃–数据一致性引擎概览</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Ow2HWBEgeqHdbMw3XNeyoA">https://mp.weixin.qq.com/s/Ow2HWBEgeqHdbMw3XNeyoA</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-02/" data-id="cm6lrrho1004tnsdl5b1ugmaj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-事务/一致性/分布式事务一致性引擎-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-01/" class="article-date">
  <time datetime="2021-05-21T01:17:23.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-01/">分布式事务一致性引擎-01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="分布式事务从入门到放弃-二-–详述DT引擎一致性原理及设计"><a href="#分布式事务从入门到放弃-二-–详述DT引擎一致性原理及设计" class="headerlink" title="分布式事务从入门到放弃(二)–详述DT引擎一致性原理及设计"></a>分布式事务从入门到放弃(二)–详述DT引擎一致性原理及设计</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dFmxdLtPFCXIR73gg2d1UA">https://mp.weixin.qq.com/s/dFmxdLtPFCXIR73gg2d1UA</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;mid=2650000675&amp;idx=1&amp;sn=f411dcfdf6135409b94963cbb45b4b0c&amp;chksm=882fa783bf582e950184684cb74ca701cde6618068a31b4a07773dc3c7f5d7afd400178df2c1&amp;cur_album_id=1579057632903004162&amp;scene=189#rd">https://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;mid=2650000675&amp;idx=1&amp;sn=f411dcfdf6135409b94963cbb45b4b0c&amp;chksm=882fa783bf582e950184684cb74ca701cde6618068a31b4a07773dc3c7f5d7afd400178df2c1&amp;cur_album_id=1579057632903004162&amp;scene=189#rd</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zAgR8Axo_nTiwvVEkVMM9w">https://mp.weixin.qq.com/s/zAgR8Axo_nTiwvVEkVMM9w</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-01/" data-id="cm6lrrho1004vnsdl3epv0q6g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-事务/一致性/分布式事务一致性引擎-03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-03/" class="article-date">
  <time datetime="2021-05-21T01:17:23.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-03/">分布式事务一致性引擎-01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="在所依赖存储不授信的场景下实现柔性事务降级"><a href="#在所依赖存储不授信的场景下实现柔性事务降级" class="headerlink" title="在所依赖存储不授信的场景下实现柔性事务降级"></a>在所依赖存储不授信的场景下实现柔性事务降级</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zAgR8Axo_nTiwvVEkVMM9w">https://mp.weixin.qq.com/s/zAgR8Axo_nTiwvVEkVMM9w</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%BC%95%E6%93%8E-03/" data-id="cm6lrrho1004xnsdl32o97wdv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编程语言/Java/spring/spring-事务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring-%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time datetime="2021-05-21T00:07:39.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring-%E4%BA%8B%E5%8A%A1/">spring-06-事务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="事务的应用"><a href="#事务的应用" class="headerlink" title="事务的应用"></a>事务的应用</h1><h2 id="数据库的事务"><a href="#数据库的事务" class="headerlink" title="数据库的事务"></a>数据库的事务</h2><blockquote>
<p>数据库事务（Transaction，简写为 TX）是数据库管理系统执行过程中的一个逻辑单位，是可以提交或回滚的工作的原子单元。当事务对数据库进行多次更改时，要么在提交事务时所有更改都成功，要么在回滚事务时所有更改都被撤消。</p>
</blockquote>
<h2 id="Mysql-中的事务"><a href="#Mysql-中的事务" class="headerlink" title="Mysql 中的事务"></a>Mysql 中的事务</h2><ul>
<li><code>START TRANSACTION</code>或 <code>BEGIN</code>开始新事务。</li>
<li><code>COMMIT</code> 提交当前事务。</li>
<li><code>ROLLBACK</code> 回滚当前事务。</li>
<li><code>SET autocommit</code> 禁用或启用当前会话的默认自动提交模式。</li>
</ul>
<p><strong>默认情况下，Mysql 是自动提交的模式，所有语句会立即提交</strong></p>
<h2 id="JDBC-中的事务"><a href="#JDBC-中的事务" class="headerlink" title="JDBC 中的事务"></a>JDBC 中的事务</h2><p><strong>JDBC</strong> 是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了查询和更新数据库中数据的方法。JDBC 也是 Sun Microsystems 的商标（现在属于 Oracle），是面向关系型数据库的。</p>
<p>上面说到，Mysql 是默认自动提交的，所以 JDBC 中事务事务的第一步，需要<strong>禁用自动提交：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.setAutoCommit(false);</span><br></pre></td></tr></table></figure>

<p><strong>提交事务：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.commit();</span><br></pre></td></tr></table></figure>

<p><strong>回滚事务：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.rollback();</span><br></pre></td></tr></table></figure>

<p><strong>一个完整流程的例子（摘自 Oracle JDBC 文档）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCoffeeSales</span><span class="params">(HashMap&lt;String, Integer&gt; salesForWeek)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    PreparedStatement updateSales = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement updateTotal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    String updateString =</span><br><span class="line">        <span class="string">&quot;update &quot;</span> + dbName + <span class="string">&quot;.COFFEES &quot;</span> +</span><br><span class="line">        <span class="string">&quot;set SALES = ? where COF_NAME = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String updateStatement =</span><br><span class="line">        <span class="string">&quot;update &quot;</span> + dbName + <span class="string">&quot;.COFFEES &quot;</span> +</span><br><span class="line">        <span class="string">&quot;set TOTAL = TOTAL + ? &quot;</span> +</span><br><span class="line">        <span class="string">&quot;where COF_NAME = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        con.setAutoCommit(<span class="keyword">false</span>); <span class="comment">//第一步</span></span><br><span class="line">        updateSales = con.prepareStatement(updateString);</span><br><span class="line">        updateTotal = con.prepareStatement(updateStatement);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : salesForWeek.entrySet()) &#123;</span><br><span class="line">            updateSales.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">            updateSales.setString(<span class="number">2</span>, e.getKey());</span><br><span class="line">            updateSales.executeUpdate();</span><br><span class="line">            updateTotal.setInt(<span class="number">1</span>, e.getValue().intValue());</span><br><span class="line">            updateTotal.setString(<span class="number">2</span>, e.getKey());</span><br><span class="line">            updateTotal.executeUpdate();</span><br><span class="line">            con.commit(); <span class="comment">//第二步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e ) &#123;</span><br><span class="line">        JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">        <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.err.print(<span class="string">&quot;Transaction is being rolled back&quot;</span>);</span><br><span class="line">                con.rollback(); <span class="comment">//第三步</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(SQLException excep) &#123;</span><br><span class="line">                JDBCTutorialUtilities.printSQLException(excep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (updateSales != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateSales.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (updateTotal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateTotal.close();</span><br><span class="line">        &#125;</span><br><span class="line">        con.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-事务管理器简介"><a href="#Spring-事务管理器简介" class="headerlink" title="Spring 事务管理器简介"></a>Spring 事务管理器简介</h2><p>Spring 为事务管理提供了统一的抽象，有以下优点：<!--注意：Spring只提供抽象，不提供实现--></p>
<ul>
<li>跨不同事务 API（例如 Java 事务 API（JTA），JDBC，Hibernate，Java 持久性 API（JPA）和 Java 数据对象（JDO））的一致编程模型。</li>
<li>支持声明式事务管理（注解形式）</li>
<li>与 JTA 之类的复杂事务 API 相比， 用于程序化事务管理的 API 更简单</li>
<li>和 Spring 的 Data 层抽象集成方便（比如 Spring - Hibernate/Jdbc/Mybatis/Jpa…）</li>
</ul>
<p><a href="">Spring 的事务管理器只是一个接口 / 抽象，不同的 DB 层框架（其实不光是 DB 类框架，支持事务模型的理论上都可以使用这套抽象） 可能都需要实现此标准才可以更好的工作</a>， </p>
<p>核心接口是<code>org.springframework.transaction.support.AbstractPlatformTransactionManager</code>，其代码位于<code>spring-tx</code>模块中，比如 Hibernate 中的实现为：<code>org.springframework.orm.hibernate4.HibernateTransactionManager</code></p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>事务，自然是控制业务的，在一个业务流程内，往往希望保证原子性，要么全成功要么全失败。</p>
<p>所以事务一般是加载<code>@Service</code>层，一个 Service方法内调用了多个数据库操作（比如 Dao），在 Service 结束后事务自动提交，如有异常抛出则事务回滚。</p>
<p>这也是 Spring 事务管理的基本使用原则。</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>在被 Spring 管理的类头上增加<code>@Transactional</code>注解，即可对该类下的所有方法开启事务管理。事务开启后，方法内的操作无需手动开启 / 提交 / 回滚事务，一切交给 Spring 管理即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxTestService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepo orderRepo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        orderRepo.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以只在方法上配置，方法配置的优先级是大于类的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxTestService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepo orderRepo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        orderRepo.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TransactionTemplate"><a href="#TransactionTemplate" class="headerlink" title="TransactionTemplate"></a>TransactionTemplate</h4><p>TransactionTemplate 这中方式，其实和使用注解形式的区别不大，其核心功能也是由 TransactionManager 实现的，这里只是换了个入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(TransactionCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.transactionManager <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((CallbackPreferringPlatformTransactionManager) <span class="keyword">this</span>.transactionManager).execute(<span class="keyword">this</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取事务信息</span></span><br><span class="line">        TransactionStatus status = <span class="keyword">this</span>.transactionManager.getTransaction(<span class="keyword">this</span>);</span><br><span class="line">        T result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行业务代码</span></span><br><span class="line">            result = action.doInTransaction(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理异常回滚</span></span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="comment">// Transactional code threw application exception -&gt; rollback</span></span><br><span class="line">            rollbackOnException(status, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">            <span class="comment">// Transactional code threw error -&gt; rollback</span></span><br><span class="line">            rollbackOnException(status, err);</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// Transactional code threw unexpected exception -&gt; rollback</span></span><br><span class="line">            rollbackOnException(status, ex);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(ex, <span class="string">&quot;TransactionCallback threw undeclared checked exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        <span class="keyword">this</span>.transactionManager.commit(status);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="XML-配置-tx-advice"><a href="#XML-配置-tx-advice" class="headerlink" title="XML 配置 tx:advice"></a>XML 配置 tx:advice</h4><p>过于古老，不做解释</p>
<h3 id="隔离级别-Isolation-Level"><a href="#隔离级别-Isolation-Level" class="headerlink" title="隔离级别 (Isolation Level)"></a>隔离级别 (Isolation Level)</h3><p>事务隔离级别是数据库最重要的特性之一，他保证了脏读 / 幻读等问题不会发生。作为一个事务管理框架自然也是支持此配置的，在 @Transactional 注解中有一个 isolation 配置，可以很方便的配置各个事务的隔离级别，等同于<code>connection.setTransactionIsolation()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Isolation &#123;</span><br><span class="line">    DEFAULT(-1),</span><br><span class="line">    READ_UNCOMMITTED(1),</span><br><span class="line">    READ_COMMITTED(2),</span><br><span class="line">    REPEATABLE_READ(4),</span><br><span class="line">    SERIALIZABLE(8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h3><p>传播行为和数据库功能无关，只是事务管理器为了处理复杂业务而设计的一个机制。</p>
<p>比如现在有这样一个调用场景，<code>A Service -&gt; B Service -&gt; C Service</code>，但是希望 A/B 在一个事务内，C 是一个独立的事务，同时 C 如果出错，不影响 AB 所在的事务。</p>
<p>此时，就可以通过传播行为来处理；将 C Service 的事务配置为<code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code>即可</p>
<p>Spring 支持以下几种传播行为：</p>
<table>
<thead>
<tr>
<th align="left"><strong>PROPAGATION TYPE</strong></th>
<th align="left"><strong>DESCRIPTION</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>PROPAGATION_REQUIRED</strong></td>
<td align="left">支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 如果正要执行的事务不在另外一个事务里，那么就起一个新的事务; 比如说，<code>ServiceB.methodB</code>的事务级别定义为PROPAGATION_<code>REQUIRED</code>, 那么由于执行<code>ServiceA.methodA</code>的时候， <code>ServiceA.methodA</code>已经起了事务，这时调用<code>ServiceB.methodB</code>，<code>ServiceB.methodB</code>看到自己已经运行在<code>ServiceA.methodA</code> 的事务内部，就不再起新的事务。而假如<code>ServiceA.methodA</code>运行的时<code>候ServiceB.method</code>B发现自己没有在事务中，他就会为自己新建一个事务。 这样，在<code>ServiceA.methodA</code>或者在<code>ServiceB.methodB</code>内的任何地方出现异常，事务都会被回滚。即使<code>ServiceB.methodB</code>的事务已经被提交，但是<code>ServiceA.methodA</code>在接下来fail要回滚，<code>ServiceB.methodB</code>也要回滚。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_SUPPORTS</strong></td>
<td align="left">支持当前事务，如果当前没有事务，就以非事务方式执行。 如果当前在事务中，即以事务的形式运行，如果当前不在一个事务中，那么就以非事务的形式运行。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_MANDATORY</strong></td>
<td align="left">支持当前事务，如果当前没有事务，就抛出异常。 必须在一个事务中运行，也就是说，他只能被一个父事务调用。否则，他就要抛出异常。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_REQUIRES_NEW</strong></td>
<td align="left">新建事务，如果当前存在事务，把当前事务挂起。 比如我们设计<code>ServiceA.methodA</code>的事务级别为PROPAGATION_<code>REQUIRED</code>，<code>ServiceB.methodB</code>的事务级别为PROPAGATION_<code>REQUIRES_NEW</code>，那么当执行到<code>ServiceB.methodB</code>的时候，<code>ServiceA.methodA</code>所在的事务就会挂起，<code>ServiceB.methodB</code>会起一个新的事务，等待<code>ServiceB.methodB</code>的事务完成以后，他才继续执行。他与PROPAGATION_<code>REQUIRED </code>的事务区别在于事务的回滚程度了。因为<code>ServiceB.methodB</code>是新起一个事务，那么就是存在两个不同的事务。如果<code>ServiceB.methodB</code>已经提交，那么<code>ServiceA.methodA</code>失败回滚，<code>ServiceB.methodB</code>是不会回滚的。如果<code>ServiceB.methodB</code>失败回滚，如果他抛出的异常被<code>ServiceA.methodA</code>捕获，<code>ServiceA.methodA</code>事务仍然可能提交。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_NOT_SUPPORTED</strong></td>
<td align="left">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 不支持当前事务。比如<code>ServiceA.methodA</code>的事务级别是PROPAGATION_<code>REQUIRED</code>，而<code>ServiceB.methodB</code>的事务级别是PROPAGATION_<code>NOT_SUPPORTED</code>，那么当执行到<code>ServiceB.methodB</code>时，<code>ServiceA.methodA</code>的事务挂起，而<code>ServiceB.methodB</code>则以非事务的方式运行完，再继续<code>ServiceA.methodA</code>的事务。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_NEVER</strong></td>
<td align="left">以非事务方式执行，如果当前存在事务，则抛出异常。 不能在事务中运行。假设<code>ServiceA.methodA</code>的事务级别是PROPAGATION_<code>REQUIRED</code>，而ServiceB.methodB的事务级别是PROPAGATION_<code>NEVER</code>， 那么<code>ServiceB.methodB</code>就要抛出异常了。</td>
</tr>
<tr>
<td align="left"><strong>PROPAGATION_NESTED</strong></td>
<td align="left">支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 理解Nested的关键是savepoint。他与PROPAGATION_<code>REQUIRES_NEW</code>的区别是，PROPAGATION_<code>REQUIRES_NEW</code>另起一个事务，将会与他的父事务相互独立，而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。 而<code>Nested</code>事务的好处也是他有一个savepoint。</td>
</tr>
</tbody></table>
<h3 id="回滚策略"><a href="#回滚策略" class="headerlink" title="回滚策略"></a>回滚策略</h3><p>@Transactional 中有 4 个配置回滚策略的属性，分为 Rollback 策略，和 NoRollback 策略</p>
<p><strong>默认情况下，RuntimeException 和 Error 这两种异常会导致事务回滚，普通的 Exception（需要 Catch 的）异常不会回滚。</strong></p>
<h4 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h4><p>配置需要回滚的异常类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 异常类Class</span><br><span class="line">Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;</span><br><span class="line"># 异常类ClassName，可以是FullName&#x2F;SimpleName</span><br><span class="line">String[] rollbackForClassName() default &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="NoRollback"><a href="#NoRollback" class="headerlink" title="NoRollback"></a>NoRollback</h4><p>针对一些要特殊处理的业务逻辑，比如插一些日志表，或者不重要的业务流程，希望就算出错也不影响事务的提交。</p>
<p>可以通过配置 NoRollbackFor 来实现，让某些异常不影响事务的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 异常类Class</span><br><span class="line">Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;</span><br><span class="line"># 异常类ClassName，可以是FullName&#x2F;SimpleName</span><br><span class="line">String[] noRollbackForClassName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="只读控制"><a href="#只读控制" class="headerlink" title="只读控制"></a>只读控制</h3><p>设置当时事务的只读标示，等同于<code>connection.setReadOnly()</code></p>
<h3 id="关键名词解释"><a href="#关键名词解释" class="headerlink" title="关键名词解释"></a>关键名词解释</h3><table>
<thead>
<tr>
<th>名词</th>
<th>概念</th>
</tr>
</thead>
<tbody><tr>
<td>PlatformTransactionManager</td>
<td>事务管理器，管理事务的各生命周期方法，简称 TxMgr</td>
</tr>
<tr>
<td>TransactionAttribute</td>
<td>事务属性, 包含隔离级别，传播行为, 是否只读等信息，简称 TxAttr</td>
</tr>
<tr>
<td>TransactionStatus</td>
<td>事务状态，包含当前事务、挂起等信息，简称 TxStatus</td>
</tr>
<tr>
<td>TransactionInfo</td>
<td>事务信息，内含 TxMgr, TxAttr, TxStatus 等信息，简称 TxInfo</td>
</tr>
<tr>
<td>TransactionSynchronization</td>
<td>事务同步回调，内含多个钩子方法，简称 TxSync / transaction synchronization</td>
</tr>
<tr>
<td>TransactionSynchronizationManager</td>
<td>事务同步管理器，维护当前线程事务资源，信息以及 TxSync 集合</td>
</tr>
</tbody></table>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void execute(TxCallback txCallback)&#123;</span><br><span class="line">    &#x2F;&#x2F;获取连接</span><br><span class="line">    Connection connection &#x3D; acquireConnection();</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F;执行业务代码</span><br><span class="line">        doInService();</span><br><span class="line">        &#x2F;&#x2F;提交事务</span><br><span class="line">        connection.commit();</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        &#x2F;&#x2F;回滚事务</span><br><span class="line">        rollback(connection);</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        &#x2F;&#x2F;释放连接</span><br><span class="line">        releaseConnection(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 事务管理的基本原理就是以上代码，获取连接 -&gt; 执行代码 -&gt; 提交 / 回滚事务。Spring 只是将这个流程给抽象出来了，所有事务相关的操作都交由 TransactionManager 去实现，然后封装一个<strong>模板形式的入口</strong>来执行</p>
<p>比如<code>org.springframework.transaction.support.TransactionTemplate</code>的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException &#123;</span><br><span class="line">      if (this.transactionManager instanceof CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line">          return ((CallbackPreferringPlatformTransactionManager) this.transactionManager).execute(this, action);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          &#x2F;&#x2F;通过事务管理器获取事务</span><br><span class="line">          TransactionStatus status &#x3D; this.transactionManager.getTransaction(this);</span><br><span class="line">          T result;</span><br><span class="line">          try &#123;</span><br><span class="line">              &#x2F;&#x2F;执行业务代码</span><br><span class="line">              result &#x3D; action.doInTransaction(status);</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;处理异常回滚</span><br><span class="line">          catch (RuntimeException ex) &#123;</span><br><span class="line">              &#x2F;&#x2F; Transactional code threw application exception -&gt; rollback</span><br><span class="line">              rollbackOnException(status, ex);</span><br><span class="line">              throw ex;</span><br><span class="line">          &#125;</span><br><span class="line">          catch (Error err) &#123;</span><br><span class="line">              &#x2F;&#x2F; Transactional code threw error -&gt; rollback</span><br><span class="line">              rollbackOnException(status, err);</span><br><span class="line">              throw err;</span><br><span class="line">          &#125;</span><br><span class="line">          catch (Exception ex) &#123;</span><br><span class="line">              &#x2F;&#x2F; Transactional code threw unexpected exception -&gt; rollback</span><br><span class="line">              rollbackOnException(status, ex);</span><br><span class="line">              throw new UndeclaredThrowableException(ex, &quot;TransactionCallback threw undeclared checked exception&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;提交事务</span><br><span class="line">          this.transactionManager.commit(status);</span><br><span class="line">          return result;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注解形式的事务（@Transactional），实现机制也是一样，基于 Spring 的 AOP，将上面 Template 的模式换成了自动的 AOP，在 AOP 的 Interceptor（<code>org.springframework.transaction.interceptor.TransactionInterceptor</code>）中来执行这套流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the transaction attribute is null, the method is non-transactional.</span><br><span class="line">        final TransactionAttribute txAttr &#x3D; getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">        &#x2F;&#x2F;获取事务管理器</span><br><span class="line">        final PlatformTransactionManager tm &#x3D; determineTransactionManager(txAttr);</span><br><span class="line">        final String joinpointIdentification &#x3D; methodIdentification(method, targetClass);</span><br><span class="line"></span><br><span class="line">        if (txAttr &#x3D;&#x3D; null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Standard transaction demarcation with getTransaction and commit&#x2F;rollback calls.</span><br><span class="line">            &#x2F;&#x2F;创建事务</span><br><span class="line">            TransactionInfo txInfo &#x3D; createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">            Object retVal &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; This is an around advice: Invoke the next interceptor in the chain.</span><br><span class="line">                &#x2F;&#x2F; This will normally result in a target object being invoked.</span><br><span class="line">                &#x2F;&#x2F;执行被“AOP”的代码</span><br><span class="line">                retVal &#x3D; invocation.proceedWithInvocation();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; target invocation exception</span><br><span class="line">                &#x2F;&#x2F;处理异常回滚</span><br><span class="line">                completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                &#x2F;&#x2F;清除资源</span><br><span class="line">                cleanupTransactionInfo(txInfo);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;提交事务</span><br><span class="line">            commitTransactionAfterReturning(txInfo);</span><br><span class="line">            return retVal;</span><br><span class="line">        &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="复杂流程下的事务传播-保持相同事务的关键："><a href="#复杂流程下的事务传播-保持相同事务的关键：" class="headerlink" title="复杂流程下的事务传播 / 保持相同事务的关键："></a>复杂流程下的事务传播 / 保持相同事务的关键：</h3><ul>
<li>对于复杂一些的业务流程，会出现各种类之间的调用，Spring 是如何做到保持同一个事务的？<ul>
<li>其实基本原理很简单，只需要将当前事务（Connection）隐式的保存至事务管理器内，后续方法在执行 JDBC 操作前，从事务管理器内获取即可：</li>
<li>比如<code>HibernateTemplate</code>中的<code>SessionFactory</code>中的<code>getCurrentSession</code>，这里的<code>getCurrentSession</code>就是从（可能是间接的）Spring 事务管理器中获取的</li>
<li><strong>Spring 事务管理器将处理事务时的相关临时资源（Connection 等）存在<code>org.springframework.transaction.support.TransactionSynchronizationManager</code>中，通过 ThreadLocal 维护</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(TransactionSynchronizationManager.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;Map&lt;Object, Object&gt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt;(<span class="string">&quot;Transaction synchronizations&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;String&gt;(<span class="string">&quot;Current transaction name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;Boolean&gt;(<span class="string">&quot;Current transaction read-only status&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;Integer&gt;(<span class="string">&quot;Current transaction isolation level&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;Boolean&gt;(<span class="string">&quot;Actual transaction active&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对一些复杂场景，嵌套事务 + 独立事务，涉及到挂起（suspend），恢复（resume）的情况，相关资源也是存储在**<code>TransactionSynchronizationManager</code>** 中的，方便嵌套事务的处理。</p>
<p>比如 A-&gt;B 时，A 方法已经开启了事务，并将当前事务资源绑定在**<code>TransactionSynchronizationManager</code>，<strong>那么执行 B 之前，会检测当前是否已经存在事务；检测方式就是从</strong><code>TransactionSynchronizationManager</code>**查找并检测状态，如果已经在事务内，那么就根据不同的传播行为配置来执行不同的逻辑，对于 REQUIRES_NEW 等传播行为的处理会麻烦一些，会涉及到 “挂起（suspend）” 和恢复 (resume) 的操作。</p>
<h1 id="事务失效的4种场景"><a href="#事务失效的4种场景" class="headerlink" title="事务失效的4种场景"></a>事务失效的4种场景</h1><h2 id="Transactional注解的方法为非public"><a href="#Transactional注解的方法为非public" class="headerlink" title="@Transactional注解的方法为非public"></a>@Transactional注解的方法为非public</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>TestServiceImpl#insertTestWrongModifier()虽然被@Transactional修饰，但是不是public访问符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTestWrongModifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   TestServiceImpl testService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testInvoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//调用@Transactional标注的默认访问符方法</span></span><br><span class="line">        testService.insertTestWrongModifier();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的访问方式，导致事务没开启，因此在方法抛出异常时，testMapper.insert(new Test(10,20,30));操作不会进行回滚。如果<code>TestServiceImpl#insertTestWrongModifier</code>方法改为public的话将会正常开启事务，testMapper.insert(new Test(10,20,30));将会进行回滚。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p><code>@Transactional</code>是基于动态代理实现的，在bean初始化过程中，对含有<code>@Transactional</code>标注的bean实例创建代理对象，标注<code>@Transactional</code>的方法如果修饰符不是public，那么将不会对bean进行代理对象创建或者不会对方法进行代理调用。</p>
<p><code>@Transactional</code>注解实现原理中，介绍了如何判定一个bean是否创建代理对象，大概逻辑是：</p>
<blockquote>
<p>根据spring创建的一个aop切点<code>BeanFactoryTransactionAttributeSourceAdvisor</code>实例，遍历当前bean的class的方法对象，判断方法上面的注解信息是否包含<code>@Transactional</code>，如果当前bean的任何一个方法包含<code>@Transactional</code>注解信息，那么就是适配这个<code>BeanFactoryTransactionAttributeSourceAdvisor</code>切点。则当前bean需要创建代理对象，然后代理对象为我们管理事务开闭逻辑。</p>
</blockquote>
<p>spring源码中，在拦截bean的创建过程，寻找bean适配的切点时，运用到<code>AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class&lt;?&gt;, boolean)</code>的方法，目的就是寻找方法上面的@Transactional信息，如果有，就表示切点BeanFactoryTransactionAttributeSourceAdvisor能够应用（canApply）到bean中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">   Assert.notNull(pc, <span class="string">&quot;Pointcut must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">   <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">      <span class="comment">// No need to iterate the methods if we&#x27;re matching any method anyway...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历class的方法对象</span></span><br><span class="line">   Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">   classes.add(targetClass);</span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">      Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||</span><br><span class="line">             <span class="comment">//适配查询方法上的@Transactional注解信息  </span></span><br><span class="line">             methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在上面的方法打断点，最终上面的代码还会调用如下方法来判断。在下面的方法上断点，回头看看方法调用堆栈也是不错的方式跟踪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractFallbackTransactionAttributeSource#getTransactionAttribute</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">   <span class="comment">//非public 方法，返回@Transactional信息一律是null</span></span><br><span class="line">   <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//后面省略.......</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>以一开始的测试代码为例，如果正常的修饰符的testService是经过cglib创建的代理对象</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufWFWRfYhnMbqZeQOpFticE0Axp7cJAbcFdWiackBtAejpe4iaDLb15vrtU7c62ibuvFNPVo80qLOvczQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li>如果class中的方法都是非public的那么将不是代理对象</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufWFWRfYhnMbqZeQOpFticE0oDNLPEFoUyIDeAad2EpRbgActMzE1SfRbRPqXEBJINbLLsVAnv6fYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><p>考虑一种情况，如下面代码所示。两个方法都被@Transactional注解标注，但是一个有public修饰符一个没有，那么这种情况一定会创建代理对象，因为至少有一个public修饰符的@Transactional注解标注方法。</p>
<p>创建了代理对象，insertTestWrongModifier就会开启事务吗？答案是不会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    TestMapper testMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTestWrongModifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因是在动态代理对象进行代理逻辑调用时，在cglib创建的代理对象的拦截函数中<code>CglibAopProxy.DynamicAdvisedInterceptor#intercept</code>，有一个逻辑如下，目的是获取当前被代理对象的当前需要执行的method适配的aop逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; chain &#x3D; this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br></pre></td></tr></table></figure>

<p>而针对@Transactional注解查找aop逻辑过程，相似地，也是执行一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractFallbackTransactionAttributeSource#getTransactionAttribute</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</code></li>
</ul>
<p>也就是说还需要找一个方法上的@Transactional注解信息，没有的话就不执行代理@Transactional对应的代理逻辑，直接执行方法。没有了@Transactional注解代理逻辑，就无法开启事务，这也是上一篇已经讲到的。</p>
<h2 id="在类内部调用内部-Transactional标注的方法"><a href="#在类内部调用内部-Transactional标注的方法" class="headerlink" title="在类内部调用内部@Transactional标注的方法"></a>在类内部调用内部@Transactional标注的方法</h2><p>入口为 main 方法，在 testTx 方法中配置了 @Transactional 注解，同时在插入数据后抛出 RuntimeException 异常，但是方法执行后插入的数据并没有回滚，竟然插入成功了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> xxxService&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//内部调用事务方法</span></span><br><span class="line">        testTx();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UrlMappingEntity urlMappingEntity = <span class="keyword">new</span> UrlMappingEntity();</span><br><span class="line">        urlMappingEntity.setUrl(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        urlMappingRepository.save(urlMappingEntity);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不生效的原因是因为入口的方法 / 类没有增加 @Transaction 注解，由于 Spring 的事务管理器也是基于 AOP 实现的，不管是 Cglib(ASM) 还是 Jdk 的动态代理，本质上也都是子类机制；在同类之间的方法调用会直接调用本类代码，不会执行动态代理曾的代码；由于入口方法<code>main</code>没有增加代理注解，所以<code>textTx</code>方法上增加的事务注解并不会生效</p>
<p>解决方法：</p>
<ol>
<li><p>方法testTx是一个内部方法，使用手动开始事务，不能用注解</p>
</li>
<li><p>通过在方法内部获得当前类代理对象的方式，通过代理对象调用方法B</p>
<ul>
<li><p>springboot启动类加上注解:<code>@EnableAspectJAutoProxy(exposeProxy = true)</code></p>
</li>
<li><p>方法test内部获取代理对象调用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">		xxxServiceImpl proxyObj = (xxxServiceImpl) AopContext.currentProxy();</span><br><span class="line">    proxyObj.testTx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>xxxService维护一个自己的xxxService，这样就有代理对象了。<!--注意使用延迟加载避免循环依赖--></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowire</span><br><span class="line">private xxxService service;</span><br><span class="line"></span><br><span class="line">public void main()&#123;</span><br><span class="line">    &#x2F;&#x2F;内部调用事务方法</span><br><span class="line">    service.testTx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h3><p>既然事务管理是基于动态代理对象的代理逻辑实现的，那么如果在类内部调用类内部的事务方法，这个调用事务方法的过程并不是通过代理对象来调用的，而是直接通过this对象来调用方法，绕过的代理对象，肯定就是没有代理逻辑了。</p>
<h2 id="异步-跨线程后，事务失效"><a href="#异步-跨线程后，事务失效" class="headerlink" title="异步/跨线程后，事务失效"></a>异步/跨线程后，事务失效</h2><p>比如在一个事务方法中，开启了子线程操作库，那么此时子线程的事务和主线程事务是不同的。</p>
<p>因为在 Spring 的事务管理器中，事务相关的资源（连接，session，事务状态之类）都是存放在 TransactionSynchronizationManager 中的，通过 ThreadLocal 存放，如果跨线程的话就无法保证一个事务了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># TransactionSynchronizationManager.java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Transaction synchronizations&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Current transaction name&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Current transaction read-only status&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Current transaction isolation level&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Actual transaction active&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="事务方法内部捕捉了异常，但没有throw-Runtime-Exception或者Error"><a href="#事务方法内部捕捉了异常，但没有throw-Runtime-Exception或者Error" class="headerlink" title="事务方法内部捕捉了异常，但没有throw Runtime Exception或者Error"></a>事务方法内部捕捉了异常，但没有throw Runtime Exception或者Error</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.transaction.UnexpectedRollbackException: </span><br><span class="line">Transaction silently rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure>

<p>这个异常是由于在同一个事务内，多个事务方法之间调用，子方法抛出异常，但又被父方法忽略了导致的。</p>
<p>因为子方法抛出了异常，Spring 事务管理器会将当前事务标为失败状态，准备进行回滚，可是当子方法执行完毕出栈后，父方法又忽略了此异常，待方法执行完毕后正常提交时，事务管理器会检查回滚状态，若有回滚标示则抛出此异常。具体可以参考<code>org.springframework.transaction.support.AbstractPlatformTransactionManager#processCommit</code></p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B</span><br><span class="line"># A Service(@Transactional):</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTx</span><span class="params">()</span></span>&#123;</span><br><span class="line">    urlMappingRepo.deleteById(<span class="number">98l</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        txSubService.testSubTx();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      	<span class="comment">//捕获异常，但是没有抛出</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># B Service(@Transactional)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubTx</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h3><p>Traditional默认是捕捉Runtime Exception和Error的，如果程序之运行时发生的异常不是Runtime Exception或者Error，是不会被回滚的，所以要rollbackfor exception</p>
<h1 id="Spring对事务异常的处理"><a href="#Spring对事务异常的处理" class="headerlink" title="Spring对事务异常的处理"></a>Spring对事务异常的处理</h1><p>java阿里巴巴规范提示：方法【edit】需要在Transactional注解指定rollbackFor或者在方法中显示的rollback。</p>
<h2 id="jdk异常分类"><a href="#jdk异常分类" class="headerlink" title="jdk异常分类"></a>jdk异常分类</h2><h2 id="Transactional-正确的写法"><a href="#Transactional-正确的写法" class="headerlink" title="@Transactional 正确的写法"></a>@Transactional 正确的写法</h2><ul>
<li><p>Spring默认对unchecked exceptions (RuntimeException及其子类和Error) 回滚。</p>
</li>
<li><p>如果是 checked Exception，分4种情况：</p>
<ul>
<li>catch了不做任何异常抛出，Spring没有捕获到显然不用回滚；</li>
<li>catch了又抛出RuntimeException，Spring捕获到肯定会回滚；</li>
<li>catch了但又抛出了unchecked Exception，Spring默认不回滚；</li>
<li>不catch直接抛出unchecked Exception,  Spring默认也是不回滚。</li>
</ul>
</li>
</ul>
<p>Spring框架的事务基础架构代码将默认地只在抛出Runtime Exception和unchecked exceptions时才标识事务回滚。从事务方法中抛出的Checked exceptions将不被标识进行事务回滚。</p>
<ol>
<li>让checked例外也回滚：在整个方法前加上 <code>@Transactional(rollbackFor=Exception.class)</code></li>
<li>让unchecked例外不回滚：<code>@Transactional(notRollbackFor=RunTimeException.class)</code></li>
<li>不需要事务管理的(只查询的)方法：<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code></li>
</ol>
<p>注意：如果异常被 <code>try &#123;&#125; catch &#123;&#125;</code> 了，事务就不回滚了，如果想让事务回滚必须再往外抛 <code>try &#123;&#125; catch &#123;throw Exception&#125;</code> 。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。</p>
<p>你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）</p>
<p>2、@Transactional 注解标识的方法，处理过程尽量的简单。</p>
<p>尤其是带锁的事务方法，能不放在事务里面的最好不要放在事务里面。</p>
<p>可以将常规的数据库查询操作放在事务前面进行，而事务内进行增、删、改、加锁查询等操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring-%E4%BA%8B%E5%8A%A1/" data-id="cm6lrrho7006knsdl9zya51sq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-锁/分布式锁-01-redis实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-01-redis%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2021-05-20T03:42:40.000Z" itemprop="datePublished">2021-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-01-redis%E5%AE%9E%E7%8E%B0/">分布式锁-01-redis实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><h2 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109</span><br><span class="line">	at org.redisson.RedissonLock.unlock(RedissonLock.java:366)</span><br></pre></td></tr></table></figure>

<h2 id="排查原因"><a href="#排查原因" class="headerlink" title="排查原因"></a>排查原因</h2><ul>
<li><p>先检查项目中是否确保了 <strong>redissonClient 的单例</strong>。</p>
<ul>
<li>定位依据：我还没想到，因为用spring都是单例</li>
</ul>
</li>
<li><p>redissonClient 虽然是单例的静态成员变量，但初始化时未加锁，而是简单使用  （本次报错原因）</p>
<ul>
<li><p>定位依据：不需要改代码甚至debug，只需要搜索日志里是否有两行，打印两次版本信息说明肯定初始化了两次 Redisson。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13:58:07.972 [main] INFO org.redisson.Version - Redisson 2.8.2</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static RedissonClient redisson &#x3D; null;</span><br><span class="line">      </span><br><span class="line">public static RedissonClient getRedisson()&#123;</span><br><span class="line">  if(redisson &#x3D;&#x3D; null)&#123;</span><br><span class="line">      RedissonManager.init(); &#x2F;&#x2F;初始化</span><br><span class="line">  &#125;</span><br><span class="line">  return redisson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>加锁解锁没有同一个 lock，而是每次都使用<code>getRedisson().getLock(key)</code> 获取lock1和lock2两个不同的lock对象。导致解锁时从另一个 redissonClient 并没有获取到锁。换言之，报错里的<code>not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109</code> 其实关键问题在于<code>by node id</code> ，而不是线程id。<ul>
<li>定位依据：加锁和解锁时，打印lock对象，对象信息不一致，说明是两个对象。</li>
</ul>
</li>
<li>解锁时，当前线程不是锁的持有者，关键问题在于<code>by current thread</code> ，而不是 node id。<ul>
<li>定位依据：使用lock.isHeldByCurrentThread()判断，如果不是被当前线程持有锁，当前线程释放释放锁肯定报这个异常</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-01-redis%E5%AE%9E%E7%8E%B0/" data-id="cm6lrrhnq001unsdlfdhfax5a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/开源项目/身份认证/shiro应用-04-缓存管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-04-%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2021-05-19T11:13:10.000Z" itemprop="datePublished">2021-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-04-%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86/">shiro应用-04-缓存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在每一次请求需要权限的时候总是会调用授权的方法查询数据库，这样的话性能很低，因此我们可以使用缓存管理器，来达到这种要求，在Shiro中有一个内存缓存管理器，内部就是使用Map实现的，但是这种缓存并不能实现跨JVM（分布式），因此我们可以使用Redis自定义一个缓存管理器，步骤如下：</p>
<h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><h3 id="实现RedisCache，用于实现对授权信息的缓存"><a href="#实现RedisCache，用于实现对授权信息的缓存" class="headerlink" title="实现RedisCache，用于实现对授权信息的缓存"></a>实现RedisCache，用于实现对授权信息的缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis的Cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储在redis中的hash中的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String COMMON_NAME=<span class="string">&quot;shiro-demo&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">RedisCache</span><span class="params">(RedisTemplate redisTemplate, String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">         <span class="keyword">this</span>.name=COMMON_NAME+<span class="string">&quot;:&quot;</span>+name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定的key的缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CacheException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">     		<span class="keyword">return</span> (V) redisTemplate.opsForHash().get(name,k);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CacheException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">         redisTemplate.opsForHash().put(name, k, v);</span><br><span class="line">         <span class="comment">//设置过期时间</span></span><br><span class="line">         <span class="keyword">return</span> v;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定key的缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 默认是principle对象，在AuthorizingRealm中设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">         V v = <span class="keyword">this</span>.get(k);</span><br><span class="line">         redisTemplate.opsForHash().delete(name, k);</span><br><span class="line">         <span class="keyword">return</span> v;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除所有的缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">     		redisTemplate.delete(name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     		<span class="keyword">return</span> redisTemplate.opsForHash().size(name).intValue();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     		<span class="keyword">return</span> redisTemplate.opsForHash().keys(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     		<span class="keyword">return</span> redisTemplate.opsForHash().values(name);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现RedisManager"><a href="#实现RedisManager" class="headerlink" title="实现RedisManager"></a>实现RedisManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis的CacheManager</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> &lt;K, V&gt; <span class="function">Cache&lt;K, V&gt; <span class="title">getCache</span><span class="params">(String s)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">     		<span class="keyword">return</span> <span class="keyword">new</span> RedisCache&lt;K,V&gt;(redisTemplate, s);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在配置类中配置上缓存管理器，需要设置到SecurityManager中才能生效"><a href="#在配置类中配置上缓存管理器，需要设置到SecurityManager中才能生效" class="headerlink" title="在配置类中配置上缓存管理器，需要设置到SecurityManager中才能生效"></a>在配置类中配置上缓存管理器，需要设置到SecurityManager中才能生效</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置缓存管理器，使用自定义的Redis缓存管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="keyword">new</span> RedisCacheManager();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置安全管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">     DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(userRealm());</span><br><span class="line">     <span class="comment">//设置缓存管理器</span></span><br><span class="line">     securityManager.setCacheManager(cacheManager());</span><br><span class="line">     <span class="keyword">return</span> securityManager;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a><strong>清除缓存</strong></h2><ul>
<li>在CachingRelam中有一个清除缓存的方法<code>org.apache.shiro.realm.CachingRealm#clearCache</code>，在我们自定义的Realm中覆盖该方法即可，这样就能在<strong>退出或者在业务逻辑中用户的权限改变</strong>的时候能够清除缓存的数据，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除CacheManager中的缓存，可以在用户权限改变的时候调用，这样再次需要权限的时候就会重新查询数据库不走缓存了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Subject subject = SecurityUtils.getSubject();</span><br><span class="line">    <span class="comment">//调用父类的清除缓存的方法</span></span><br><span class="line">    <span class="keyword">super</span>.clearCache(subject.getPrincipals());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>除了重写或者覆盖CachingRelam中的方法，根据源码可以知道，真正起作用的方法是<code>AuthorizingRealm</code>中的方法<code>clearCachedAuthorizationInfo</code>，因此我们也可以重写或者覆盖这个方法，这里不再演示。</strong></li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h2><ul>
<li>在Shiro中一旦有地方调用<code>Subject.hasRole</code>等校验权限的地方，那么就会检测授权信息，在<code>org.apache.shiro.realm.AuthorizingRealm#getAuthorizationInfo</code>的方法中会先缓存中查询是否存在，否则调用授权的方法从数据库中查询，查询之后放入缓存中，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">getAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (principals == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       AuthorizationInfo info = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">           log.trace(<span class="string">&quot;Retrieving AuthorizationInfo for principals [&quot;</span> + principals + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">//获取可用的缓存管理器</span></span><br><span class="line">       Cache&lt;Object, AuthorizationInfo&gt; cache = getAvailableAuthorizationCache();</span><br><span class="line">       <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">               log.trace(<span class="string">&quot;Attempting to retrieve the AuthorizationInfo from cache.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//获取缓存的key，这里获取的就是principal主体信息</span></span><br><span class="line">           Object key = getAuthorizationCacheKey(principals);</span><br><span class="line">           <span class="comment">//从缓存中获取数据</span></span><br><span class="line">           info = cache.get(key);</span><br><span class="line">           <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   log.trace(<span class="string">&quot;No AuthorizationInfo found in cache for principals [&quot;</span> + principals + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   log.trace(<span class="string">&quot;AuthorizationInfo found in cache for principals [&quot;</span> + principals + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果缓存中没有查到</span></span><br><span class="line">       <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//调用重写的授权方法，从数据库中查询</span></span><br><span class="line">           info = doGetAuthorizationInfo(principals);</span><br><span class="line">       <span class="comment">//如果查询到了，添加到缓存中</span></span><br><span class="line">           <span class="keyword">if</span> (info != <span class="keyword">null</span> &amp;&amp; cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                   log.trace(<span class="string">&quot;Caching authorization info for principals: [&quot;</span> + principals + <span class="string">&quot;].&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//获取缓存的key</span></span><br><span class="line">               Object key = getAuthorizationCacheKey(principals);</span><br><span class="line">               <span class="comment">//放入缓存</span></span><br><span class="line">               cache.put(key, info);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> info;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-04-%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="cm6lrrhoh009mnsdl7hup15sm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/开源项目/身份认证/shiro应用-03-会话管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-03-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2021-05-19T09:16:08.000Z" itemprop="datePublished">2021-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-03-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/">shiro应用-03-会话管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。</p>
<p>Shiro在开启Web功能的时候默认的会话管理器是DefaultWebSessionManager，这种管理器是针对cookie进行存储的，将sessionId存储在cookie中，但是现在的主流方向是前后端分离，我们不能再依赖Cookie，因此我们必须自定义的会话管理器，实现跨JVM，前后端分离。</p>
<h2 id="自定义SessionMananger"><a href="#自定义SessionMananger" class="headerlink" title="自定义SessionMananger"></a><strong>自定义SessionMananger</strong></h2><ul>
<li>在原有的DefaultWebSessionManager进行扩展，否则从头实现将会要写大量代码。默认的Web的会话管理器是从cookie中获取SessionId，我们只需要重写其中的方法即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的会话管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionManager</span> <span class="keyword">extends</span> <span class="title">DefaultWebSessionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前后端分离不存在cookie，因此需要重写getSessionId的逻辑，从请求参数中获取</span></span><br><span class="line"><span class="comment">     * 此处的逻辑：在登录成功之后会将sessionId作为一个token返回，下次请求的时候直接带着token即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">getSessionId</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取上传的token,这里的token就是sessionId</span></span><br><span class="line">        <span class="keyword">return</span> request.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写该方法，在SessionManager中只要涉及到Session的操作都会获取Session，获取Session主要是从缓存中获取，父类的该方法执行逻辑如下：</span></span><br><span class="line"><span class="comment">     *  1、先从RedisCache中获取，调用get方法</span></span><br><span class="line"><span class="comment">     *  2、如果RedisCache中不存在，在从SessionDao中获取，调用get方法</span></span><br><span class="line"><span class="comment">     *  优化：我们只需要从SessionDao中获取即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionKey Session的Key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Session <span class="title">retrieveSession</span><span class="params">(SessionKey sessionKey)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</span><br><span class="line">        <span class="comment">//获取SessionId</span></span><br><span class="line">        Serializable sessionId = getSessionId(sessionKey);</span><br><span class="line">        <span class="keyword">if</span> (sessionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Unable to resolve session ID from SessionKey [&#123;&#125;].  Returning null to indicate a &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;session could not be found.&quot;</span>, sessionKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接调用SessionDao中的get方法获取</span></span><br><span class="line">        Session session = ((RedisSessionDao) sessionDAO).doReadSession(sessionId);</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//session ID was provided, meaning one is expected to be found, but we couldn&#x27;t find one:</span></span><br><span class="line">            String msg = <span class="string">&quot;Could not find session with ID [&quot;</span> + sessionId + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownSessionException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法是作用是当访问指定的uri的时候会更新Session中的执行时间，用来动态的延长失效时间。</span></span><br><span class="line"><span class="comment">     * 在父类的实现方法会直接调用SessionDao中的更新方法更新缓存中的Session</span></span><br><span class="line"><span class="comment">     * 此处并没有其他的逻辑，后续可以补充</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">touch</span><span class="params">(SessionKey key)</span> <span class="keyword">throws</span> InvalidSessionException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.touch(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="自定义SessionDao"><a href="#自定义SessionDao" class="headerlink" title="自定义SessionDao"></a><strong>自定义SessionDao</strong></h2><ul>
<li>SessionDao的作用是Session持久化的手段，默认的SessionDao是缓存在内存中的，此处使用Redis作为缓存的工具，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义RedisSessionDao，继承CachingSessionDAO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionDao</span> <span class="keyword">extends</span> <span class="title">CachingSessionDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doUpdate方法&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(session.getId(), session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doDelete方法&quot;</span>);</span><br><span class="line">        redisTemplate.delete(session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个Session，添加到缓存中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session Session信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创建的SessionId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">doCreate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doCreate方法&quot;</span>);</span><br><span class="line">        Serializable sessionId = generateSessionId(session);</span><br><span class="line">        assignSessionId(session, sessionId);</span><br><span class="line">        redisTemplate.opsForValue().set(session.getId(), session);</span><br><span class="line">        <span class="keyword">return</span> sessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Session <span class="title">doReadSession</span><span class="params">(Serializable sessionId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doReadSession方法&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> (Session) redisTemplate.opsForValue().get(sessionId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义SessionId生成策略"><a href="#自定义SessionId生成策略" class="headerlink" title="自定义SessionId生成策略"></a><strong>自定义SessionId生成策略</strong></h2><ul>
<li>默认的Shiro的生成策略是JavaUuidSessionIdGenerator，此处也可以自定义自己的生成策略，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的SessionId的生成策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionIdGenerator</span> <span class="keyword">implements</span> <span class="title">SessionIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Serializable <span class="title">generateId</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义Session监听器"><a href="#自定义Session监听器" class="headerlink" title="自定义Session监听器"></a><strong>自定义Session监听器</strong></h2><ul>
<li>Session监听器能够监听Session的生命周期，包括开始、过期、失效（停止），如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Session监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionListener</span> <span class="keyword">implements</span> <span class="title">SessionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Session无效【停止了，stopTime！=null】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;session失效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExpiration</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;超时&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="完成上述配置"><a href="#完成上述配置" class="headerlink" title="完成上述配置"></a><strong>完成上述配置</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置SessionDao，使用自定义的Redis缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionDAO <span class="title">sessionDAO</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RedisSessionDao sessionDao = <span class="keyword">new</span> RedisSessionDao();</span><br><span class="line">        <span class="comment">//设置自定义的Id生成策略</span></span><br><span class="line">        sessionDao.setSessionIdGenerator(<span class="keyword">new</span> RedisSessionIdGenerator());</span><br><span class="line">        <span class="keyword">return</span> sessionDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置会话监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionListener <span class="title">sessionListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisSessionListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置会话管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionManager <span class="title">sessionManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultWebSessionManager sessionManager = <span class="keyword">new</span> RedisSessionManager();</span><br><span class="line">        <span class="comment">//设置session的过期时间</span></span><br><span class="line">        sessionManager.setGlobalSessionTimeout(<span class="number">60000</span>);</span><br><span class="line">        <span class="comment">//设置SessionDao</span></span><br><span class="line">        sessionManager.setSessionDAO(sessionDAO());</span><br><span class="line">        <span class="comment">//设置SessionListener</span></span><br><span class="line">        sessionManager.setSessionListeners(Lists.newArrayList(sessionListener()));</span><br><span class="line">        <span class="keyword">return</span> sessionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置安全管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(userRealm());</span><br><span class="line">        <span class="comment">//设置缓存管理器</span></span><br><span class="line">        securityManager.setCacheManager(cacheManager());</span><br><span class="line">        <span class="comment">//设置会话管理器</span></span><br><span class="line">        securityManager.setSessionManager(sessionManager());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a><strong>优化</strong></h2><ul>
<li>在源码中可以看到<code>AbstractSessionDAO</code>中的增删改查方法的执行逻辑使用的双层缓存的，还设计到查询CacheManager中的缓存，但是我们的SessionDao既然是实现了Redis的缓存，那么是没必要查询两次的，因此需要重写其中的方法，此时我们自己需要写一个抽象类覆盖其中的增删改查方法即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RedisSessionDao的抽象类，重写其中的增删改查方法，原因如下：</span></span><br><span class="line"><span class="comment"> *  1、AbstractSessionDAO中的默认方法是写查询CacheManager中的缓存，既然SessionDao实现了Redis的缓存</span></span><br><span class="line"><span class="comment"> *      那么就不需要重复查询两次，因此重写了方法，直接使用RedisSessionDao查询即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRedisSessionDao</span> <span class="keyword">extends</span> <span class="title">AbstractSessionDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写creat方法，直接执行sessionDao的方法，不再执行cacheManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Serializable <span class="title">create</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        Serializable sessionId = doCreate(session);</span><br><span class="line">        <span class="keyword">if</span> (sessionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;sessionId returned from doCreate implementation is null.  Please verify the implementation.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写删除操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        doDelete(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写update方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnknownSessionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Session session)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</span><br><span class="line">        doUpdate(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写查找方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnknownSessionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Session <span class="title">readSession</span><span class="params">(Serializable sessionId)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</span><br><span class="line">        Session s = doReadSession(sessionId);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownSessionException(<span class="string">&quot;There is no session with id [&quot;</span> + sessionId + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(Session session)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">(Session session)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>此时的上面的RedisSessionDao直接继承我们自定义的抽象类即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义RedisSessionDao，继承AbstractRedisSessionDao，达到只查一层缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionDao</span> <span class="keyword">extends</span> <span class="title">AbstractRedisSessionDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String HASH_NAME=<span class="string">&quot;shiro_user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doUpdate方法&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().put(HASH_NAME, session.getId(), session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doDelete方法&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().delete(HASH_NAME, session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个Session，添加到缓存中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session Session信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创建的SessionId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">doCreate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doCreate方法&quot;</span>);</span><br><span class="line">        Serializable sessionId = generateSessionId(session);</span><br><span class="line">        assignSessionId(session, sessionId);</span><br><span class="line">        redisTemplate.opsForHash().put(HASH_NAME, session.getId(),session);</span><br><span class="line">        <span class="keyword">return</span> sessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Session <span class="title">doReadSession</span><span class="params">(Serializable sessionId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doReadSession方法&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> (Session) redisTemplate.opsForHash().get(HASH_NAME,sessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有的Session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Session&gt; <span class="title">getActiveSessions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List values = redisTemplate.opsForHash().values(HASH_NAME);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(values))&#123;</span><br><span class="line">            <span class="keyword">return</span> values;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h2><ul>
<li><p>Shiro默认是在当前用户访问页面的时候检查Session是否停止或者过期，如果过期和停止了会调用的SessionDao中的相关方法删除缓存，但是如果这是在用户名操作的情况下，如果用户一直未操作，那么Session已经失效了，但是缓存中并没有删除，这样一来将会有大量无效的Session堆积，因此我们必须定时清理失效的Session。</p>
</li>
<li><p>清理会话，有如下两种方法：</p>
</li>
<li><ul>
<li>自己写一个定时器，每隔半小时或者几分钟清除清除缓存</li>
<li>自定义SessionValidationScheduler</li>
<li>使用已经实现的ExecutorServiceSessionValidationScheduler</li>
</ul>
</li>
</ul>
<ul>
<li>在Shiro中默认会开启ExecutorServiceSessionValidationScheduler，执行时间是一个小时，但是如果想要使用定时器定时清除的话，那么需要关闭默认的清除器，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//禁用Session清除器，使用定时器清除</span></span><br><span class="line">sessionManager.setSessionValidationSchedulerEnabled(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>







<h3 id="如何的Session是失效的"><a href="#如何的Session是失效的" class="headerlink" title="如何的Session是失效的"></a><strong>如何的Session是失效的</strong></h3><ul>
<li><p>Session是如何保活的？</p>
</li>
<li><ul>
<li><p>在<code>org.apache.shiro.web.servlet.AbstractShiroFilter#doFilterInternal</code>中的一个<code>updateSessionLastAccessTime(request, response);</code>方法用来更新Session的最后执行时间为当前时间，最终调用的就是<code>org.apache.shiro.session.mgt.SimpleSession#touch</code>。</p>
</li>
<li><p>在每次请求验证Session的时候实际调用的是<code>org.apache.shiro.session.mgt.AbstractValidatingSessionManager#doValidate</code>方法，在其中真正调用的是<code>org.apache.shiro.session.mgt.SimpleSession#validate</code>来验证是否过期或者停止</p>
</li>
<li><ul>
<li>核心逻辑就是验证当前的时间和最后执行时间的差值是否在设置的过期时间的范围内</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="何时是失效的"><a href="#何时是失效的" class="headerlink" title="何时是失效的"></a><strong>何时是失效的</strong></h3><ul>
<li><p>Session失效目前通过读源码总结出如下三点：</p>
</li>
<li><ul>
<li><p>isValid判断，这个会在访问请求的时候shiro会自动验证，并且设置进去</p>
</li>
<li><p>用户长期不请求，此时的isValid并不能验证出来，此时需要比较最后执行的时间和开始时间比较</p>
</li>
<li><p>没有登录就访问的也会在redis中生成一个Session，但是此时的Session中是没有两个属性的，以下的两个属性只有在认证成功之后才会设置查到Session中</p>
</li>
<li><ul>
<li>org.apache.shiro.subject.support.DefaultSubjectContext#PRINCIPALS_SESSION_KEY</li>
<li>org.apache.shiro.subject.support.DefaultSubjectContext#AUTHENTICATED_SESSION_KEY</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>通过上面的分析，此时就能写出从缓存中删除失效Session的代码，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * session过期有三种可能，如下：</span></span><br><span class="line"><span class="comment">     *  1、isValid判断，这个会在访问请求的时候shiro会自动验证，并且设置进去</span></span><br><span class="line"><span class="comment">     *  2、用户长期不请求，此时的isValid并不能验证出来，此时需要比较最后执行的时间和开始时间</span></span><br><span class="line"><span class="comment">     *  3、没有登录就访问的也会在redis中生成一个Session，但是此时的Session中是没有两个属性的</span></span><br><span class="line"><span class="comment">     *      1、org.apache.shiro.subject.support.DefaultSubjectContext#PRINCIPALS_SESSION_KEY</span></span><br><span class="line"><span class="comment">     *      2、org.apache.shiro.subject.support.DefaultSubjectContext#AUTHENTICATED_SESSION_KEY</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearExpireSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取所有的Session</span></span><br><span class="line">        Collection&lt;Session&gt; sessions = redisSessionDao.getActiveSessions();</span><br><span class="line">        sessions.forEach(s-&gt;&#123;</span><br><span class="line">            SimpleSession session= (SimpleSession) s;</span><br><span class="line">            <span class="comment">//第一种可能</span></span><br><span class="line">            Boolean status1=!session.isValid();</span><br><span class="line">            <span class="comment">//第二种可能用开始时间和过期时间比较</span></span><br><span class="line">            Boolean status2=session.getLastAccessTime().getTime()+session.getTimeout()&lt;<span class="keyword">new</span> Date().getTime();</span><br><span class="line">            <span class="comment">//第三种可能</span></span><br><span class="line">            Boolean status3= Objects.isNull(session.getAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY))&amp;&amp;Objects.isNull(session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY));</span><br><span class="line">            <span class="keyword">if</span> (status1||status2||status3)&#123;</span><br><span class="line">                <span class="comment">//清楚session</span></span><br><span class="line">                redisSessionDao.delete(session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-03-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/" data-id="cm6lrrhoi009onsdlbqpu7dg9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-database/Mybatis/Mybatis-PageHelper插件实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/19/database/Mybatis/Mybatis-PageHelper%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2021-05-19T07:30:42.000Z" itemprop="datePublished">2021-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/19/database/Mybatis/Mybatis-PageHelper%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0/">Mybatis-PageHelper插件实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/19/database/Mybatis/Mybatis-PageHelper%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0/" data-id="cm6lrrhng0004nsdl6rqk8rnc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/开源项目/软件设计/设计模式/健壮后端服务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%81%A5%E5%A3%AE%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time datetime="2021-05-17T11:37:33.000Z" itemprop="datePublished">2021-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%81%A5%E5%A3%AE%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1/">健壮后端服务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如何避免故障？一句话概括 : 怀疑第三方，防备使用方，做好自己。</p>
<h2 id="怀疑第三方"><a href="#怀疑第三方" class="headerlink" title="怀疑第三方"></a>怀疑第三方</h2><p>坚持一条信念：“所有第三方服务都不可靠”，不管第三方什么天花乱坠的承诺。</p>
<h3 id="接口备份-数据备份，制定好业务降级方案"><a href="#接口备份-数据备份，制定好业务降级方案" class="headerlink" title="接口备份+ 数据备份，制定好业务降级方案"></a>接口备份+ 数据备份，制定好业务降级方案</h3><p>第三方提供了两种方式：1）一种是消息通知服务，只发送变更后的数据；2）一种是 HTTP 服务，需要我们自己主动调用获取数据。我们一开始选择消息同步的方式，因为实时性更高，但是之后就遭遇到消息迟迟发送不过来的问题，而且也没什么异常，等我们发现一天时间已过去，问题已然升级为故障。合理的方式应该两个同步方案都使用，消息方式用于实时更新，HTTP 主动同步方式定时触发（比如1小时）用于兜底，即使消息出了问题，通过主动同步也能保证一小时一更新。</p>
<p>有些时候第三方服务表面看起来正常，但是返回的数据是被污染的。这时需要每隔一段时间，对数据进行备份，方便在数据被污染时做回滚</p>
<h3 id="设置超时时间，保障快速失败"><a href="#设置超时时间，保障快速失败" class="headerlink" title="设置超时时间，保障快速失败"></a>设置超时时间，保障快速失败</h3><p>某服务调用的一个第三方接口正常响应时间是 50 ms，某天该第三方接口出现问题，大约有 15% 的请求响应时间超过 2s，没过多久服务 load 飙高到 10 以上，响应时间也非常缓慢，即第三方服务将我们服务拖垮了。为什么会被拖垮？没设置超时！我们采用的是同步调用方式，使用了一个线程池，该线程池里最大线程数设置了 50，如果所有线程都在忙，多余的大量请求就堆在队列里中。</p>
<p>正确的做法是和第三方商量确定个较短的超时时间比如 200 ms，这样即使他们服务出现问题也不会对我们服务产生很大影响。</p>
<h3 id="慎重选择重试机制"><a href="#慎重选择重试机制" class="headerlink" title="慎重选择重试机制"></a>慎重选择重试机制</h3><p>需要结合自己的业务以及异常来仔细斟酌是否使用重试机制。</p>
<h2 id="防备使用方"><a href="#防备使用方" class="headerlink" title="防备使用方"></a>防备使用方</h2><p>这里又要坚持一条信念：“所有的使用方都不靠谱”，</p>
<h3 id="设计一个好的-API（RPC、Restful）避免误用"><a href="#设计一个好的-API（RPC、Restful）避免误用" class="headerlink" title="设计一个好的 API（RPC、Restful）避免误用"></a>设计一个好的 API（RPC、Restful）避免误用</h3><p>过去两年间看过不少故障，直接或间接原因来自于糟糕的接口。如果你的接口让很多人误用，那要好好反思自己的接口设计了，接口设计虽然看着简单，但是学问很深，建议大家好好看看 Joshua Bloch 的演讲《How to Design a Good API &amp; Why it Matters（如何设计一个好的 API 及为什么这很重要）》以及《Java API 设计清单》。</p>
<h3 id="流量控制和限制"><a href="#流量控制和限制" class="headerlink" title="流量控制和限制"></a>流量控制和限制</h3><p>生活给了我们答案：比如老式电闸都安装了保险丝，一旦有人使用超大功率的设备，保险丝就会烧断以保护各个电器不被强电流给烧坏。同理我们的接口也需要安装上“保险丝”，以防止非预期的请求对系统压力过大而引起的系统瘫痪，当流量过大时，可以采取拒绝或者引流等机制</p>
<h2 id="做好自己"><a href="#做好自己" class="headerlink" title="做好自己"></a>做好自己</h2><p>做好自己是个非常大的话题，从需求分析、架构设计 、代码编写、测试、code review、上线、线上服务运维等阶段都可以重点展开介绍，这次简单分享下架构设计、代码编写上的几条经验原则。</p>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>略<!--我一直坚持的原则--></p>
<h3 id="控制资源的使用"><a href="#控制资源的使用" class="headerlink" title="控制资源的使用"></a>控制资源的使用</h3><p>写代码脑子一定要绷紧一根弦，认知到我们所在的机器资源是有限的。机器资源有哪些？CPU、内存、网络、磁盘等，如果不做好保护控制工作，一旦某一资源满负荷，很容易导致出现线上问题。</p>
<p><strong>CPU 资源怎么限制</strong></p>
<ul>
<li>计算算法优化。</li>
<li>锁。对于很多服务而言，没有那么多耗费计算资源的算法，但 CPU 使用率也很高，这个时候需要看看锁的使用情况，我的建议是如无必要，尽量不用显式使用锁。</li>
<li>习惯问题。比如写循环的时候，千万要检查看看是否能正确退出，有些时候一不小心，在某些条件下就成为死循环</li>
<li>尽量使用线程池。通过线程池来限制线程的数目，避免线程过多造成的线程上下文切换的开销。</li>
<li>JVM 参数调优。</li>
</ul>
<p><strong>内存资源怎么限制</strong></p>
<ul>
<li>JVM 参数设置。有一篇朋友写的好文可以参考《Linux 与 JVM 的内存关系分析》。</li>
<li>初始化 Java 集合类大小。使用 Java 集合类的时候尽量初始化大小，在长连接服务等耗费内存资源的服务中这种优化非常重要。</li>
<li>使用内存池/对象池</li>
<li>使用线程池的时候一定要设置队列的最大长度。之前看过好多起故障都是由于队列最大长度没有限制最后导致内存溢出。</li>
<li>如果数据较大避免使用本地缓存。如果数据量较大，可以考虑放置到分布式缓存如 Redis、Tair 等，不然 gc 都可能把自己服务卡死。</li>
<li>对缓存数据进行压缩。比如之前做推荐相关服务时，需要保存用户偏好数据，如果直接保存可能有 12G，后来采用短文本压缩算法直接压缩到 6G，不过这时一定要考虑好压缩解压缩算法的 cpu 使用率、效率与压缩率的平衡，一些压缩率很高但是性能很差的算法，也不适合线上实时调用。有些时候直接使用 probuf 来序列化之后保存，这样也能节省内存空间。</li>
</ul>
<p><strong>网络资源怎么限制</strong></p>
<ul>
<li>减少调用的次数。经常看到有同学在循环里用 redis/tair 的 get，如果意识到这里面的网络开销的话就应该使用批量处理；又如在推荐服务中经常遇到要去多个地方去取数据，一般采用多线程并行去取数据，这个时候不仅耗费cpu资源，也耗费网络资源，一种在实际中常常采用的方法就是先将很多数据离线存储到一块 ，这时候线上服务只要一个请求就能将所有数据获取。</li>
<li>减少传输的数据量。一种方法是压缩后传输，还有一种就是按需传输，比如经常遇到的 getData(int id)，如果我们返回该 id 对应的 Data 所有信息，一来人家不需要，二来数据量传输太大，这个时候可以改为 getData(int id, Listfields)，使用方传输相应的字段过来，服务端只返回使用方需要的字段即可。</li>
</ul>
<p><strong>磁盘资源怎么限制</strong></p>
<p>打日志要控制量，并定期清理。</p>
<h3 id="避免单点"><a href="#避免单点" class="headerlink" title="避免单点"></a>避免单点</h3><p>从大层次上讲服务可以多机房部署、异地多活；从自己设计角度上讲，服务应该能做到水平扩展。</p>
<ul>
<li>对于很多无状态的服务，通过 nginx、zookeeper 能轻松实现水平扩展；</li>
<li>对一些 job 类型的服务，怎么避免单点呢，毕竟只能在一个节点上运行，可以参考《Quartz应用与集群原理分析》一文；对数据服务来说，怎么避免单点呢？简而言之、可以通过分片、分层等方式来实现</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%81%A5%E5%A3%AE%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1/" data-id="cm6lrrhoi009vnsdl6a0j4s9g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/开源项目/资源池化技术/资源池化技术-01-数据库连接池" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%B5%84%E6%BA%90%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" class="article-date">
  <time datetime="2021-05-13T01:17:35.000Z" itemprop="datePublished">2021-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%B5%84%E6%BA%90%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">数据库连接池</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="每次请求建立连接"><a href="#每次请求建立连接" class="headerlink" title="每次请求建立连接"></a>每次请求建立连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">FindAllUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//1、装载sqlserver驱动对象</span></span><br><span class="line">  DriverManager.registerDriver(<span class="keyword">new</span> SQLServerDriver());             </span><br><span class="line">  <span class="comment">//2、通过JDBC建立数据库连接</span></span><br><span class="line">  Connection con =DriverManager.getConnection(<span class="string">&quot;jdbc:sqlserver://192.168.2.6:1433;DatabaseName=customer&quot;</span>, <span class="string">&quot;sa&quot;</span>, <span class="string">&quot;123&quot;</span>);            </span><br><span class="line">  <span class="comment">//3、创建状态</span></span><br><span class="line">  Statement state =con.createStatement();           </span><br><span class="line">  <span class="comment">//4、查询数据库并返回结果</span></span><br><span class="line">  ResultSet result =state.executeQuery(<span class="string">&quot;select * from users&quot;</span>);           </span><br><span class="line">  <span class="comment">//5、输出查询结果</span></span><br><span class="line">  <span class="keyword">while</span>(result.next())&#123;</span><br><span class="line">    System.out.println(result.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">  &#125;            </span><br><span class="line">  <span class="comment">//6、断开数据库连接</span></span><br><span class="line">  result.close();</span><br><span class="line">  state.close();</span><br><span class="line">  con.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>每一次web请求都要建立一次数据库连接。每次都得花费0.05s～1s的时间，而且系统还要分配内存资源</li>
<li>对于每一次数据库连接，使用完后都得断开。否则如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏</li>
<li>不能控制被创建的连接对象数，连接过多可能导致内存泄漏</li>
</ul>
<h3 id="每次请求访问连接池"><a href="#每次请求访问连接池" class="headerlink" title="每次请求访问连接池"></a>每次请求访问连接池</h3><p>改进：</p>
<ul>
<li>预先在缓冲池中放入一定数量的连接。</li>
<li>查询完数据库后，不关闭连接，而是暂时存放起来，当别人使用时，把这个连接给他们使用。</li>
</ul>
<p>优点：</p>
<ul>
<li>避免了一次建立数据库连接和断开的操作时间消耗</li>
<li>通过设定连接池最大连接数来防止系统无限地与数据库连接。</li>
<li>通过连接池的管理机制监视数据库的连接的数量﹑使用情况，为系统开发﹑测试及性能调整提供依据。</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="DataSource作用"><a href="#DataSource作用" class="headerlink" title="DataSource作用"></a>DataSource作用</h3><p>DataSource是javax.sql包中的类，是Java原生rt.jar包中的类。<!--就是Bootstrap Class Loader加载的jar包--></p>
<p>javax.sql.DataSource定义的是抽象方法，通过Java JNDI的方式将具体实现开放给各个厂商、个人自己实现。</p>
<p>在Spring框架中，通过DataSource + 配置的方式，来定义具体的数据库源。并向Spring框架提供数据源的Connection服务。</p>
<blockquote>
<p>在Spring中若想实现多数据源，那么就需要在DataSource下手</p>
</blockquote>
<h3 id="Connection作用"><a href="#Connection作用" class="headerlink" title="Connection作用"></a>Connection作用</h3><ul>
<li>connection可以当成是服务器和数据库的一个会话</li>
<li>statemant用来在会话的上下文中执行sql以及返回结果。一个connection可以包含多个statement</li>
<li>在两者中间存在事务的概念。在java语言中，connection类本身提供了对事务的ACID特性的支持，可以通过设置connection的autocommit属性为false 然后显式的调用commit或rollback方法来实现。但要高效的进行connection复用，就必须提供相应的事务支持机制。<a href="">可采用每一个事务独占一个连接来实现</a>，这种方法可以大大降低事务管理的复杂性。</li>
</ul>
<!--这句话不严谨，其实一个Connection只能被一个线程独享，即只有当某一线程完成了本次数据操作，将连接放回到连接池之后，其他线程才能够再次获取该Connection并使用-->

<blockquote>
<p>一个连接对应一个事务，多个连接的事务是不一样的</p>
</blockquote>
<h4 id="连接池代码"><a href="#连接池代码" class="headerlink" title="连接池代码"></a>连接池代码</h4><ul>
<li>编写class 实现DataSource 接口</li>
<li>在class构造器一次性创建10个连接，将连接保存LinkedList中</li>
<li>实现getConnection 从 LinkedList中返回一个连接 <!--注意：这里原作者写的有问题，实际上这个连接是被某个线程独享的--></li>
<li>提供将连接放回连接池中方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">  <span class="comment">//链表 --- 实现栈结构</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Connection&gt; dataSources = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化连接数量</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一次性创建10个连接</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//1、装载sqlserver驱动对象</span></span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> SQLServerDriver());</span><br><span class="line">        <span class="comment">//2、通过JDBC建立数据库连接</span></span><br><span class="line">        Connection con =DriverManager.getConnection(</span><br><span class="line">          <span class="string">&quot;jdbc:sqlserver://192.168.2.6:1433;DatabaseName=customer&quot;</span>, <span class="string">&quot;sa&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//3、将连接加入连接池中</span></span><br><span class="line">        dataSources.add(con);  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="keyword">synchronized</span> <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dataSources.removeFirst(); <span class="comment">// 删除第一个连接返回</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将连接放回连接池</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">    dataSources.add(conn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询所有用户</span></span><br><span class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">FindAllUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、使用连接池建立数据库连接</span></span><br><span class="line">    MyDataSource dataSource = <span class="keyword">new</span> MyDataSource();</span><br><span class="line">    Connection conn =dataSource.getConnection();        </span><br><span class="line">    <span class="comment">//2、创建状态</span></span><br><span class="line">    Statement state =con.createStatement();           </span><br><span class="line">    <span class="comment">//3、查询数据库并返回结果</span></span><br><span class="line">    ResultSet result =state.executeQuery(<span class="string">&quot;select * from users&quot;</span>);           </span><br><span class="line">    <span class="comment">//4、输出查询结果</span></span><br><span class="line">    <span class="keyword">while</span>(result.next())&#123;</span><br><span class="line">      System.out.println(result.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    &#125;            </span><br><span class="line">    <span class="comment">//5、断开数据库连接</span></span><br><span class="line">    result.close();</span><br><span class="line">    state.close();</span><br><span class="line">    <span class="comment">//6、归还数据库连接给连接池</span></span><br><span class="line">    dataSource.releaseConnection(conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="ThreadLocal作用"><a href="#ThreadLocal作用" class="headerlink" title="ThreadLocal作用"></a>ThreadLocal作用</h3><h4 id="ThreadLocal能存共享变量么？"><a href="#ThreadLocal能存共享变量么？" class="headerlink" title="ThreadLocal能存共享变量么？"></a><strong>ThreadLocal能存共享变量么？</strong></h4><p>存肯定能存，但不建议，因为将Connection set进ThreadLocalMap，也其实是保存一个内存对象的地址引用而已，真正使用的时候，还是唯一的那个对象在起作用。</p>
<p><a href=""><em>ThreadLocal最常用的功能，是为了避免层层传递而提供了对象保存和获取方法，把同一个数据库连接“分享”给同一个线程的不同调用方法。</em></a></p>
<h4 id="ThreadLocal完成数据库连接隔离的功能，需要怎么做"><a href="#ThreadLocal完成数据库连接隔离的功能，需要怎么做" class="headerlink" title="ThreadLocal完成数据库连接隔离的功能，需要怎么做?"></a>ThreadLocal完成数据库连接隔离的功能，需要怎么做?</h4><p>如果非要用ThreadLocal实现这个连接隔离的功能，那么，只能是为每个线程创建新的连接，然后保存在Threadlocal中，这样，每个线程在自己的生命周期范围内只会使用这个连接，即可实现线程隔离。</p>
<h4 id="druid、zdal中，threadlocal的作用体现在哪里呢？"><a href="#druid、zdal中，threadlocal的作用体现在哪里呢？" class="headerlink" title="druid、zdal中，threadlocal的作用体现在哪里呢？"></a>druid、zdal中，threadlocal的作用体现在哪里呢？</h4><p>druid、zdal等优秀的中间件，可不止是数据库连接池这一个作用，<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&mid=2650001189&idx=1&sn=87606749ae2be031a9171d272fd73819&scene=21#wechat_redirect">阿里数据库中间件zdal源码解析</a> 文中也有提及。</p>
<p>就以zdal为例，因为阿里的数据库规模基本都非常大，但又有一套完备的数据库库表拆分规范，因此，分库键、分表键、主键、虚拟表名等在设计和存储时需要遵循规范，而zdal中的解析操作，也需要与之相匹配。这个解析工作是相对复杂且繁重的，然而，针对同一用户的操作，通常库表的路由是相对固定的，因此，当我们解析过一次sql，通过各个字段和配置规则，计算出了库表路由</p>
<p>===&gt; (划重点) 那么，<a href="">可以直接put进线程上下文，供本次请求的后续数据库操作使用</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parse</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    SimpleCondition simpleCondition = <span class="keyword">new</span> SimpleCondition();</span><br><span class="line">    simpleCondition.setVirtualTableName(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    simpleCondition.put(<span class="string">&quot;age&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    ThreadLocalMap.put(ThreadLocalString.ROUTE_CONDITION, simpleCondition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 后续操作()&#123;</span><br><span class="line">   RouteCondition rc = (RouteCondition) ThreadLocalMap.get(ThreadLocalString.ROUTE_CONDITION);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//不走解析SQL，由ThreadLocal传入的指定对象（RouteCondition），决定库表目的地</span></span><br><span class="line">       metaData = sqlDispatcher.getDBAndTables(rc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 通过解析SQL来分库分表</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          metaData = sqlDispatcher.getDBAndTables(originalSql, parameters);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ZdalCheckedExcption e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个也正好是对前面ThreadLocal正确使用方法的补充</p>
<h2 id="开源数据库连接池的原理"><a href="#开源数据库连接池的原理" class="headerlink" title="开源数据库连接池的原理"></a>开源数据库连接池的原理</h2><p><strong>zdal的连接池管理源码一览：</strong></p>
<ul>
<li>druid维护一个数组来存放连接</li>
<li>同时维护了多个变量来检测连接池的状态，其中poolingCount用来表示池中连接的数量</li>
<li>当有线程来获取连接时，需要先加锁，对数量进行减一操作。</li>
<li>当获取连接时发现数量为0 ，则返回为空</li>
<li>当连接关闭时，会将连接资源放回数组，并对数量做加一操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">InternalManagedConnectionPool</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">     <span class="comment">//构造函数中，初始化了连接池大小和信号量大小</span></span><br><span class="line">     connectionListeners = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.maxSize);</span><br><span class="line">      permits = <span class="keyword">new</span> InternalSemaphore(<span class="keyword">this</span>.maxSize);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取连接</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ConnectionListener <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//信号量尝试获取许可</span></span><br><span class="line">   <span class="keyword">if</span> (permits.tryAcquire(poolParams.blockingTimeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">         ConnectionListener cl = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">         <span class="comment">//加锁资源池</span></span><br><span class="line">         <span class="keyword">synchronized</span> (connectionListeners) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (connectionListeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//获取list的最后一个</span></span><br><span class="line">                cl = (ConnectionListener) connectionListeners.remove(connectionListeners.size() - <span class="number">1</span>);</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">//最大连接数 减去 正在工作的信号量 </span></span><br><span class="line">                <span class="keyword">int</span> size = (maxSize - permits.availablePermits());</span><br><span class="line">                <span class="keyword">if</span> (size &gt; maxUsedConnections)&#123;</span><br><span class="line">                     maxUsedConnections = size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> cl;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">while</span>(connectionListeners.size() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//OK, 在连接池中找不到正在工作的连接了. 那就创建个新的</span></span><br><span class="line">      createNewConnection()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.maxSize == <span class="keyword">this</span>.maxUsedConnections) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ResourceException(</span><br><span class="line">         <span class="string">&quot;数据源最大连接数已满，并且在超时时间范围内没有新的连接释放,poolName = &quot;</span></span><br><span class="line">         + poolName</span><br><span class="line">         + <span class="string">&quot; blocking timeout=&quot;</span></span><br><span class="line">         + poolParams.blockingTimeout +</span><br><span class="line">         <span class="string">&quot;(ms)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>volatile 标识的maxUsedConnections用来完成线程间数据可见</li>
<li>隶属于AQS系列的Semaphone，用来控制共享资源并发访问量。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>假设同一时间多个线程从数据库连接池获取连接，那肯定拿的是不同的连接，当前线程和别的线程拿的连接不一样，那当前线程在crud的时候，和其他线程不在一个事务之内。</li>
<li><del>假设不同时间的多个线程要从数据库连接池后获取连接，那这个时候就可能拿到的是同一个连接了，那多个线程线程拿到的是同一个连接，也就是说在多个线程在同一个事务之内。</del>“<del>为了避免不同时间的多个线程可能是同一个连接，那么引入了threadlocal后，每个线程之间都会创建独立的连接副本，将collection各自copy一份，这样就互相不干扰了。</del>“ <strong>这句话是错误的</strong>，<a href="">因为threadLocal只保留同一个connection内存对象的不同引用，线程操作的对象其实还是同一个</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%B5%84%E6%BA%90%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" data-id="cm6lrrhoh009cnsdlg6o9dne0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/8/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/">juc</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/oom/">oom</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/oom/">oom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/spring/">spring</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/" rel="tag">JDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/annotation/" rel="tag">annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cluster/" rel="tag">cluster</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jstack/" rel="tag">jstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock/" rel="tag">lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/net/" rel="tag">net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/next/" rel="tag">next</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/" rel="tag">reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-starter/" rel="tag">spring starter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/startup/" rel="tag">startup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transaction/" rel="tag">transaction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtual-machine/" rel="tag">virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vm/" rel="tag">vm</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDK/" style="font-size: 11.11px;">JDK</a> <a href="/tags/annotation/" style="font-size: 10px;">annotation</a> <a href="/tags/cluster/" style="font-size: 10px;">cluster</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/hexo/" style="font-size: 12.22px;">hexo</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/jstack/" style="font-size: 14.44px;">jstack</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/lock/" style="font-size: 10px;">lock</a> <a href="/tags/mysql/" style="font-size: 16.67px;">mysql</a> <a href="/tags/net/" style="font-size: 10px;">net</a> <a href="/tags/next/" style="font-size: 11.11px;">next</a> <a href="/tags/redis/" style="font-size: 15.56px;">redis</a> <a href="/tags/reflect/" style="font-size: 10px;">reflect</a> <a href="/tags/spring-starter/" style="font-size: 10px;">spring starter</a> <a href="/tags/springboot/" style="font-size: 18.89px;">springboot</a> <a href="/tags/startup/" style="font-size: 17.78px;">startup</a> <a href="/tags/transaction/" style="font-size: 11.11px;">transaction</a> <a href="/tags/virtual-machine/" style="font-size: 12.22px;">virtual machine</a> <a href="/tags/vm/" style="font-size: 13.33px;">vm</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%A1%86%E6%9E%B6-04-bean%E5%8C%85-Bean/">spring框架-04-bean包-Bean</a>
          </li>
        
          <li>
            <a href="/2022/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-HashMap/">JDK-util-HashMap</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E5%9C%BA%E6%99%AF/">mysql - 常见事务问题解决方案</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">mysql - 面试问题</a>
          </li>
        
          <li>
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">交换排序-冒泡排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 Fei Qi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>