<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">218</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/23/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/AC%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/23/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/AC%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">AC算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-23 13:29:54 / Modified: 13:31:48" itemprop="dateCreated datePublished" datetime="2021-06-23T13:29:54+08:00">2021-06-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="AC算法在美团上单系统的应用"><a href="#AC算法在美团上单系统的应用" class="headerlink" title="AC算法在美团上单系统的应用"></a><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/06/09/ac-algorithm-in-meituan-order-system-practice.html">AC算法在美团上单系统的应用</a></h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>在美团，为了保证单子质量，需要对上单系统创建的每一个产品进行审核。为了提高效率，审核人员积累提炼出了一套关键词库，先基于该词库进行自动审核过滤，对于不包括这些关键词的产品信息不再需要进行人工审核。因此，如何在页面中快速的检测是否包含了这些关键词就变得非常重要。</p>
<p>对于上述问题我们描述为如下的形式：</p>
<ul>
<li>给定关键词集合P={p1,p2,……,pk}，在目标串T[1…m]中找到出现了哪些关键词。</li>
</ul>
<p>很容易想到的方法就是针对每个单词去匹配一遍，最后总结出都哪些单词匹配成功。</p>
<p>考虑KMP算法，单个关键词匹配的时间复杂度是O(|pk|+m)，所以，所有关键词都匹配一遍的时间复杂度为O(|p1|+m+|p2|+m+…+|pk|+m)。令n=|p1|+…+|pk|，上式化简为O(n+km)，因此，当关键词的数量变得非常多时，这种算法就变得无法忍受了。</p>
<p>Alfred V.Aho和Margaret J.Corasick在1974年提出了一个经典的多模式匹配算法-AC算法，这个算法可以保证对于给定的长度为n的文本，和模式集合P{p1,p2,…pm}，在O(n)的时间复杂度内找到文本中的所有目标模式，而与模式集合的规模m无关。</p>
<h2 id="2-AC算法详解"><a href="#2-AC算法详解" class="headerlink" title="2.AC算法详解"></a>2.AC算法详解</h2><p>AC算法的具体实现方法就是创建一棵前缀树，根据被查找的目标字符串，从树的根节点开始往叶子节点逐字符匹配。在这个过程中，如果发生失配，要根据失配跳转点进行跳转，如果找到匹配的模式串则进行打印输出。AC算法在扫描文本时完全不需要回溯，如果只考虑匹配的过程，该算法的时间复杂度为O(n)，也就是只跟待匹配文本的长度相关。</p>
<p>AC算法的实现可以由如下三个步骤构成：</p>
<ol>
<li>构造前缀树</li>
<li>设置每个节点的失配跳转并收集每个节点的所有匹配模式串</li>
<li>对目标字符串进行搜索匹配</li>
</ol>
<p>其间共用到三个函数：goto，fail，output。</p>
<h3 id="步骤一：构造前缀树"><a href="#步骤一：构造前缀树" class="headerlink" title="步骤一：构造前缀树"></a>步骤一：构造前缀树</h3><p>这里我们考虑模式集合P={“he”,”she”,”his”,”hers”}。</p>
<p>首先是goto函数的建立，该函数决定了对于当前状态S和条件C，如何得到下一状态S’。为了构建goto函数，我们需要建立一个状态转移图，开始，这个图只包含一个状态0，然后通过添加一条从起始状态出发的路径的方式，依次向图中输入每个关键字keyword，新的顶点和边被加入到图表中，这样就产生了一条能拼写出关键字keyword的路径。</p>
<p>添加第一个关键词“he”得到下图，其中从状态0到状态2的路径就拼写出了关键字“he”；</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/7fe93be9.gif" alt="img"></p>
<p>接着添加第二个关键字“she”得到下图，输出“she”和状态5相关联；</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/3d902714.gif" alt="img"></p>
<p>增加第三个关键字“his”得到下图，当我们增加“his”时，因为已经存在一条从状态0在输入h的条件下到达状态1的边，因此我们这里不需要另外添加一条同样的边。这个输出的“his”是和状态7相关联的；</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/ec9d47b8.gif" alt="img"></p>
<p>最后我们添加“hers”得到下图，输出“hers”和状态9相关联，最后对除了h和s外的每个字符都增加一个从状态0到0的循环；</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/b649e48a.gif" alt="img"></p>
<p>经由上面一系列添加过程，就构造了整个模式集合的状态转移图，这个图也就代表了转向函数goto。 我们利用伪代码将goto函数表示如下，同时我们在这一步骤中构造了output函数，但这个函数并不是完整的，需要在步骤二中继续完善：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">     newstate ← 0</span><br><span class="line">     for i ← 1 util k do enter(yi)</span><br><span class="line">     for all a such that goto(0,a) &#x3D;&#x3D; fail do goto(0,a) ← 0</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">procedure enter(a1a2…am):</span><br><span class="line">begin</span><br><span class="line">     state ← 0</span><br><span class="line">     j ← 1</span><br><span class="line">     while goto(state, aj) ≠ fail do</span><br><span class="line">          begin</span><br><span class="line">               state ← goto(state, aj)</span><br><span class="line">               j ← j+1</span><br><span class="line">          end</span><br><span class="line">     for p ← j util m do</span><br><span class="line">          begin</span><br><span class="line">               newstate ← newstate + 1</span><br><span class="line">               goto(state, ap) ← newstate</span><br><span class="line">               state ← newstate</span><br><span class="line">          end</span><br><span class="line">     output(state) ← &#123;a1a2…am&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="步骤二：设置每个节点的失配跳转"><a href="#步骤二：设置每个节点的失配跳转" class="headerlink" title="步骤二：设置每个节点的失配跳转"></a>步骤二：设置每个节点的失配跳转</h3><p>失效函数fail决定了当goto函数得到的下一个状态无效时，应该回退到哪一个状态。在构造fail函数时，我们首先定义状态转移图中状态S的深度为从状态0到状态S的最短路径。以我们上面构造的状态转移图为例，起始状态的深度为0，状态1和3的深度是1，状态2、6、4的深度是2，依次类推。计算失效函数的思路是这样的：首先计算深度为1 的状态的失效函数值，然后是深度为2的，以此类推，直到所有状态的失效函数值都被计算出。同时，我们规定所有深度为1的状态的fail值为0，假设所有深度小于d的状态的fail值都已经计算出，考虑每个深度为d-1的状态r，基于这些已经被计算出的深度为d-1的fail值，我们是可以得到深度为d的fail值的。</p>
<p>令L(Si)为从根节点到Si节点的路径上的所有边的值的序列，我们从树的根节点开始遍历计算fail值，如果L(Sj)是L(Si)的一个后缀，并且是最长后缀，那么，fail(Si) = Sj。假设当前状态为S1，现在要求fail(S1)，S1的前一状态我们记为S2，而S2跳到S1的条件为C，也就是S1 = goto(S2,C)，而S2的fail值是已知的，记为S3，也即S3 = fail(S2)，则L(S3)是L(S2)的一个最长后缀，假设S4 = goto(S3,C)存在，那么fail(S1) = S4，如果不存在则测试S5 = goto(fail(S3),C)，直到得到一个有效的状态为止。这个计算的过程是这样的：</p>
<ol>
<li>对于所有的字符a，如果goto(r,a) = fail，那么什么也不做（当r为我们上面构造的trie树的叶子节点时，就符合这种情况）</li>
<li>如果goto(r,a) == s，我们记state = fail®，执行state = f(state)零次或者若干次，直到使得goto(state,a) != fail，因为goto(0,a) != fail，所以这个状态是一定存在的。</li>
<li>记fail(s) = goto(state,a)。</li>
</ol>
<p>我们还是以上面构造出的状态转移图为例，计算每个节点的fail值，根据规定，fail(1) = fail(3) = 0，因为1和3是深度为1的状态。</p>
<blockquote>
<p>考虑深度为2的状态2、6、4： * 计算fail(2)，令state = fail(1) = 0，由于goto(0，e) = 0，所以fail(2) = 0 * 计算fail(4)，令state = fail(3) = 0，由于goto(0，h) = 1，所以fail(4) = 1 * 计算fail(6)，令state = fail(1) = 0，由于goto(0，i) = 0，所以fail(6) = 0</p>
<p>考虑深度为3的节点8、7、5： * 计算fail(8)，令state = fail(2) = 0，因为goto(0，r) = 0，所以fail(8) = 0 * 计算fail(7)，令state = fail(6) = 0，因为goto(0，s) = 3，所以fail(7) = 3 * 计算fail(5)，令state = fail(4) = 1，因为goto(1，e) = 2，所以fail(5) = 2</p>
<p>最后考虑深度为4的节点9： * 计算fail(9)，令state = fail(8) = 0，因为goto(0，s) = 3，所以fail(9) = 3</p>
</blockquote>
<p>这样一来我们构造的fail表如下：</p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">4</th>
<th align="left">5</th>
<th align="left">6</th>
<th align="left">7</th>
<th align="left">8</th>
<th align="left">9</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fail值</td>
<td align="left">None</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">0</td>
<td align="left">3</td>
</tr>
</tbody></table>
<p>失效函数创建的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">     queue ← empty</span><br><span class="line">     for each a such that goto(0,a) &#x3D; s ≠ fail do</span><br><span class="line">          begin</span><br><span class="line">               queue ← queue U &#123;s&#125;</span><br><span class="line">               fail(s) ← 0</span><br><span class="line">          end</span><br><span class="line">     while queue ≠ empty do</span><br><span class="line">     begin</span><br><span class="line">          let r be the next state in queue</span><br><span class="line">          queue ← queue - &#123;r&#125;</span><br><span class="line">          for each a such that goto(r,a) &#x3D; s ≠ fail do</span><br><span class="line">               begin</span><br><span class="line">                    queue ← queue U &#123;s&#125;</span><br><span class="line">                    state ← fail(r)</span><br><span class="line">                    while goto(state,a) &#x3D; fail do state ← fail(state)</span><br><span class="line">                    fail(s) ← goto(state,a)</span><br><span class="line">                    output(s) ← output(s) U output(fail(s))</span><br><span class="line">               end</span><br><span class="line">     end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="步骤三：对目标字符串进行搜索匹配"><a href="#步骤三：对目标字符串进行搜索匹配" class="headerlink" title="步骤三：对目标字符串进行搜索匹配"></a>步骤三：对目标字符串进行搜索匹配</h3><p>上面两个步骤都完成了之后就可以开始对目标串进行搜索了，只需对目标串从头到尾线性扫描，且没有回溯。搜索之前先记录树的当前节点node，初始时，树的当前节点node为根节点Root。从目标串的第一个字符开始，和Root的孩子节点进行匹配，如果不匹配，则目标字符串往后挪一个字符，继续在Root的孩子节点中查找匹配。如果找到匹配的孩子，则目标字符串往后挪一个字符，node变为匹配上的孩子节点。在接下来的匹配过程中，如果失配将跳转到node节点的fail值处继续进行匹配。在树上每次往孩子节点方向走一步都要检查该孩子节点的匹配模式串信息，如果有匹配的模式串信息，则应记录找到了哪些能够匹配的模式串。</p>
<p>整体的匹配过程如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">     state ← 0</span><br><span class="line">     for i ← 1 until n do</span><br><span class="line">          begin</span><br><span class="line">               while goto(state,ai) &#x3D; fail do state &#x3D; fail(state)</span><br><span class="line">               state ← goto(state,ai)</span><br><span class="line">               if output(state) ≠ empty then</span><br><span class="line">                    begin</span><br><span class="line">                         print output(state)</span><br><span class="line">                    end</span><br><span class="line">          end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="3-上单系统中的实现"><a href="#3-上单系统中的实现" class="headerlink" title="3.上单系统中的实现"></a>3.上单系统中的实现</h2><p>在美团上单系统中，待匹配的关键词根据产品类别进行分组，不同品类之间的关键词具有重叠。如果针对每个品类生成一棵状态转移树固然可行，但是随着品类的增多，对内存的使用也会随之增高。考虑到AC算法的时间复杂度与关键词的数量无关，因此可以考虑将所有品类的关键词构造在同一棵状态转移树中，每次进行匹配时，在output函数中对该关键词是否属于该品类做判断。在上单系统中，关键词用Keyword类表示，该类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keyword</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; categoryTypeMap;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; categories; <span class="comment">//当前的关键词属于哪几个分类</span></span><br><span class="line"> </span><br><span class="line">    getter and setter ...</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        Keyword keyword = (Keyword) o;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (id != <span class="keyword">null</span> ? !id.equals(keyword.id) : keyword.id != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id != <span class="keyword">null</span> ? id.hashCode() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，categoryTypeMap属性用来标识该关键词在不同品类中所代表的类型，当匹配命中时，根据类型信息指出其可能违反了哪些条款。</p>
<p>我们用一个Node类来代表状态转移树的一个节点，同时，将goto信息、fail信息和output信息封装到里面，这样，这个类的定义就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state;                    <span class="comment">//自动机的状态，也就是节点数字</span></span><br><span class="line">    <span class="keyword">char</span> character = <span class="number">0</span>;           <span class="comment">//指向当前节点的字符，也即条件</span></span><br><span class="line">    Node failureNode;             <span class="comment">//匹配失败时，下一个节点</span></span><br><span class="line">    List&lt;Keyword&gt; keywords;       <span class="comment">//匹配成功时，当前节点对应的关键词</span></span><br><span class="line">    List&lt;Node&gt; children;          <span class="comment">//当前节点的子节点</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用Patterns类来表示整个待匹配的模式串，它是对Node的进一步封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Patterns</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Node root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Node&gt; tree;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Patterns</span><span class="params">(List&lt;Keyword&gt; keywords)</span> </span>&#123;</span><br><span class="line">        tree = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        tree.add(root);</span><br><span class="line">        <span class="keyword">for</span>(Keyword keyword : keywords)&#123;</span><br><span class="line">            addKeyword(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">        setFailNode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addKeyword</span><span class="params">(Keyword keyword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] wordCharArr = keyword.getWord().toCharArray();</span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> currentChar : wordCharArr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.containsChild(currentChar))&#123;</span><br><span class="line">                current = current.getChild(currentChar);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node node = <span class="keyword">new</span> Node(table.size(), currentChar, root);</span><br><span class="line">                current.addChild(node);</span><br><span class="line">                current = node;</span><br><span class="line">                tree.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        current.addKeyword(keyword);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFailNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        Node node = root;</span><br><span class="line">        <span class="keyword">for</span> (Node d1 : node.children)</span><br><span class="line">            queue.offer(d1);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node curNode : node.children) &#123;</span><br><span class="line">                    queue.offer(curNode);</span><br><span class="line">                    Node failNode = node.failureNode;</span><br><span class="line">                    <span class="keyword">while</span> (!failNode.containsChild(curNode.character)) &#123;</span><br><span class="line">                        failNode = failNode.failureNode;</span><br><span class="line">                        <span class="keyword">if</span> (failNode.state == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (failNode.containsChild(curNode.character)) &#123;</span><br><span class="line">                        curNode.failureNode = failNode.getChild(curNode.character);</span><br><span class="line">                        curNode.addKeywords(curNode.failureNode.keywords);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上单系统中对关键词的匹配需要传递一个categoryId，当匹配成功时，我们需要根据传递的类别信息判断是否应该保存当前关键词：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Keyword&gt; <span class="title">searchKeyword</span><span class="params">(String data, Integer category)</span> </span>&#123;</span><br><span class="line">    Set&lt;Keyword&gt; matchResult = <span class="keyword">new</span> HashSet&lt;Keyword&gt;();</span><br><span class="line">    Node node = patterns.getRoot();</span><br><span class="line">    <span class="keyword">char</span>[] chs = data.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; chs.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!node.containsChild(chs[i])) &#123;</span><br><span class="line">            node = node.failureNode;</span><br><span class="line">            <span class="keyword">if</span> (node.state == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.containsChild(chs[i]))&#123;</span><br><span class="line">            node = node.getChild(chs[i]);</span><br><span class="line">            <span class="keyword">if</span>(node.keywords != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Keyword pattern : node.keywords)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (category == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        matchResult.add(pattern);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (pattern.getCategories().contains(category)) &#123;</span><br><span class="line">                            matchResult.add(pattern);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法的测试结果如下：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/272631ae.png" alt="img"></p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/fbebb381.png" alt="img"></p>
<p>在第二张图中，有一个因素没有考虑进去，就是同样关键词数量，当关键词在文本中出现的次数较多时，因为需要遍历找出对应该品类的词，所以花费的时间会增加，但整体上还是符合预期的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/23/database/hbase/hbase-01-%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/23/database/hbase/hbase-01-%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">hbase-01-单机安装</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-23 11:25:41" itemprop="dateCreated datePublished" datetime="2021-06-23T11:25:41+08:00">2021-06-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/pinpoint-01-%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/pinpoint-01-%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">pinpoint-01-安装</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-22 19:45:45" itemprop="dateCreated datePublished" datetime="2021-06-22T19:45:45+08:00">2021-06-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>Download, Configure, and Start HBase</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;hbase&#x2F;2.3.5&#x2F;hbase-2.3.5-bin.tar.gz</span><br><span class="line">$ tar xzvf hbase-x.x.x-bin.tar.gz</span><br><span class="line">$ cd hbase-x.x.x&#x2F;</span><br><span class="line">$ .&#x2F;bin&#x2F;start-hbase.sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果启动之后，使用<code>jps</code>命令可以看到hbase进程，并且可以打开<a href="http://localhost:16010查看Hbase的Web">http://localhost:16010查看Hbase的Web</a> UI</p>
</blockquote>
<p><em>通过$HBASE_HOME/conf/hbase-env.sh文件设置一些环境变量：</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home</span><br><span class="line"><span class="built_in">export</span> HBASE_OPTS=<span class="string">&quot;-XX:+UseConcMarkSweepGC&quot;</span></span><br><span class="line"><span class="built_in">export</span> SERVER_GC_OPTS=<span class="string">&quot;-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/Users/zhuzhi/hbase124/logs/jdk8.log&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何找到jdk安装路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">which java</span><br><span class="line">ls -lrt &#x2F;usr&#x2F;bin&#x2F;java</span><br><span class="line">ls -lrt &#x2F;etc&#x2F;alternatives&#x2F;java</span><br></pre></td></tr></table></figure>
</blockquote>
<p>See <a target="_blank" rel="noopener" href="https://github.com/pinpoint-apm/pinpoint/tree/master/hbase/scripts">scripts</a> and Run.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;bin&#x2F;hbase shell hbase-create.hbase</span><br></pre></td></tr></table></figure>



<h3 id="Pinpoint-Collector"><a href="#Pinpoint-Collector" class="headerlink" title="Pinpoint Collector"></a>Pinpoint Collector</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/pinpoint-apm/pinpoint/releases/download/v2.2.2/pinpoint-collector-boot-2.2.2.jar</span><br><span class="line"></span><br><span class="line">java -jar -Dpinpoint.zookeeper.address=localhost pinpoint-collector-boot-2.2.2.jar</span><br></pre></td></tr></table></figure>





<h3 id="Pinpoint-Web"><a href="#Pinpoint-Web" class="headerlink" title="Pinpoint Web"></a>Pinpoint Web</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;pinpoint-apm&#x2F;pinpoint&#x2F;releases&#x2F;download&#x2F;v2.2.2&#x2F;pinpoint-web-boot-2.2.2.jar</span><br><span class="line"></span><br><span class="line">java -jar -Dpinpoint.zookeeper.address&#x3D;localhost pinpoint-web-boot-2.2.2.jar</span><br></pre></td></tr></table></figure>



<h3 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h3><h4 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h4><p>In order to build Pinpoint, the following requirements must be met:</p>
<ul>
<li>JDK 8 installed</li>
</ul>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/pinpoint-apm/pinpoint/releases/download/v2.2.2/pinpoint-agent-2.2.2.tar.gz</span><br><span class="line"></span><br><span class="line">tar xvzf pinpoint-agent-2.2.2.tar.gz</span><br></pre></td></tr></table></figure>



<h4 id="使用官方的quick-start项目测试"><a href="#使用官方的quick-start项目测试" class="headerlink" title="使用官方的quick-start项目测试"></a>使用官方的quick-start项目测试</h4><p>Download Pinpoint with <code>git clone https://github.com/pinpoint-apm/pinpoint.git</code> or <a target="_blank" rel="noopener" href="https://github.com/pinpoint-apm/pinpoint/archive/master.zip">download</a> the project as a zip file and unzip.</p>
<p>Change to the pinpoint directory, and build.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd pinpoint</span><br><span class="line">$ .&#x2F;mvnw install -DskipTests&#x3D;true </span><br></pre></td></tr></table></figure>

<p>Change to the quickstart testapp directory, and build. Let’s build and run.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd quickstart&#x2F;testapp</span><br><span class="line">$ .&#x2F;mvnw clean package</span><br></pre></td></tr></table></figure>

<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>Change to the pinpoint directory, and run.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ../../</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -jar -javaagent:agent/target/pinpoint-agent-2.2.2/pinpoint-bootstrap.jar -Dpinpoint.agentId=test-agent -Dpinpoint.applicationName=TESTAPP quickstart/testapp/target/pinpoint-quickstart-testapp-2.2.2.jar</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot’s embedded Apache Tomcat server is acting as a webserver and is listening for requests on localhost port 8082. Open your browser and in the address bar at the top enter <a target="_blank" rel="noopener" href="http://localhost:8082/">http://localhost:8082</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/18/database/Mybatis/mybatis-01-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/18/database/Mybatis/mybatis-01-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">mybatis-01-整体架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-18 13:39:49" itemprop="dateCreated datePublished" datetime="2021-06-18T13:39:49+08:00">2021-06-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-22 10:18:06" itemprop="dateModified" datetime="2021-06-22T10:18:06+08:00">2021-06-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文主要讲解JDBC怎么演变到Mybatis的渐变过程，<strong>重点讲解了为什么要将JDBC封装成Mybaits这样一个持久层框架</strong> 。再而论述Mybatis作为一个数据持久层框架本身有待改进之处。</p>
<h2 id="JDBC实现查询分析"><a href="#JDBC实现查询分析" class="headerlink" title="JDBC实现查询分析"></a>JDBC实现查询分析</h2><p>我们先看看我们最熟悉也是最基础的通过JDBC查询数据库数据，一般需要以下七个步骤：</p>
<blockquote>
<ol>
<li>加载JDBC驱动；</li>
<li>建立并获取数据库连接；</li>
<li>创建 JDBC Statements 对象；</li>
<li>设置SQL语句的传入参数；</li>
<li>执行SQL语句并获得查询结果；</li>
<li>对查询结果进行转换处理并将处理结果返回；</li>
<li>释放相关资源（关闭Connection，关闭Statement，关闭ResultSet）；</li>
</ol>
</blockquote>
<p>以下是具体的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Map&lt;String,Object&gt;&gt; queryForList()&#123;</span><br><span class="line">    Connection connection &#x3D; null;</span><br><span class="line">    ResultSet rs &#x3D; null;</span><br><span class="line">    PreparedStatement stmt &#x3D; null;</span><br><span class="line">    List&lt;Map&lt;String,Object&gt;&gt; resultList &#x3D; new ArrayList&lt;Map&lt;String,Object&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 加载JDBC驱动</span><br><span class="line">        Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;).newInstance();</span><br><span class="line">        String url &#x3D; &quot;jdbc:oracle:thin:@localhost:1521:ORACLEDB&quot;;</span><br><span class="line"></span><br><span class="line">        String user &#x3D; &quot;trainer&quot;;</span><br><span class="line">        String password &#x3D; &quot;trainer&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取数据库连接</span><br><span class="line">        connection &#x3D; DriverManager.getConnection(url,user,password);</span><br><span class="line"></span><br><span class="line">        String sql &#x3D; &quot;select * from userinfo where user_id &#x3D; ? &quot;;</span><br><span class="line">        &#x2F;&#x2F; 创建Statement对象（每一个Statement为一次数据库执行请求）</span><br><span class="line">        stmt &#x3D; connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置传入参数</span><br><span class="line">        stmt.setString(1, &quot;zhangsan&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行SQL语句</span><br><span class="line">        rs &#x3D; stmt.executeQuery();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 处理查询结果（将查询结果转换成List&lt;Map&gt;格式）</span><br><span class="line">        ResultSetMetaData rsmd &#x3D; rs.getMetaData();</span><br><span class="line">        int num &#x3D; rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line">        while(rs.next())&#123;</span><br><span class="line">            Map map &#x3D; new HashMap();</span><br><span class="line">            for(int i &#x3D; 0;i &lt; num;i++)&#123;</span><br><span class="line">                String columnName &#x3D; rsmd.getColumnName(i+1);</span><br><span class="line">                map.put(columnName,rs.getString(columnName));</span><br><span class="line">            &#125;</span><br><span class="line">            resultList.add(map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 关闭结果集</span><br><span class="line">            if (rs !&#x3D; null) &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">                rs &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 关闭执行</span><br><span class="line">            if (stmt !&#x3D; null) &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">                stmt &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection !&#x3D; null) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">                connection &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDBC需要优化之处"><a href="#JDBC需要优化之处" class="headerlink" title="JDBC需要优化之处"></a>JDBC需要优化之处</h2><h3 id="连接获取和释放"><a href="#连接获取和释放" class="headerlink" title="连接获取和释放"></a>连接获取和释放</h3><p>1、 <strong>问题描述：</strong></p>
<p>数据库连接频繁的开启和关闭本身就造成了<strong>资源的浪费，影响系统的性能</strong> 。</p>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>数据库连接的获取和关闭我们<strong>可以使用数据库连接池来解决资源浪费的问题</strong> 。通过连接池就可以反复利用已经建立的连接去访问数据库了。减少连接的开启和关闭的时间。</p>
</blockquote>
<p>2、<strong>问题描述：</strong></p>
<p>但是现在<strong>连接池多种多样，可能存在变化</strong> ，有可能采用DBCP的连接池，也有可能采用容器本身的JNDI数据库连接池。</p>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>我们可以<strong>通过DataSource进行隔离解耦</strong> ，我们统一从DataSource里面获取数据库连接，<strong>DataSource具体由DBCP实现还是由容器的JNDI实现都可以</strong> ，所以我们将DataSource的具体实现通过让用户配置来应对变化。</p>
</blockquote>
<h3 id="SQL统一存取"><a href="#SQL统一存取" class="headerlink" title="SQL统一存取"></a>SQL统一存取</h3><p>1、<strong>问题描述：</strong></p>
<p>我们使用JDBC进行操作数据库时，<strong>SQL语句基本都散落在各个JAVA类中</strong> ，这样有三个不足之处：</p>
<blockquote>
<p>第一，可读性很差，不利于维护以及做性能调优。</p>
</blockquote>
<blockquote>
<p>第二，改动Java代码需要重新编译、打包部署。</p>
</blockquote>
<blockquote>
<p>第三，不利于取出SQL在数据库客户端执行（取出后还得删掉中间的Java代码，编写好的SQL语句写好后还得通过＋号在Java进行拼凑）。</p>
</blockquote>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>我们可以考虑不把SQL语句写到Java代码中，那么把SQL语句放到哪里呢？首先需要有一个统一存放的地方，我们可以将这些<strong>SQL语句统一集中放到配置文件或者数据库里面（以key-value的格式存放）</strong> 。然后通过SQL语句的key值去获取对应的SQL语句。</p>
</blockquote>
<blockquote>
<p>既然我们将SQL语句都统一放在配置文件或者数据库中，<strong>那么这里就涉及一个SQL语句的加载问题</strong> 。</p>
</blockquote>
<h3 id="第三步优化：传入参数映射和动态SQL"><a href="#第三步优化：传入参数映射和动态SQL" class="headerlink" title="第三步优化：传入参数映射和动态SQL"></a>第三步优化：传入参数映射和动态SQL</h3><p>1、<strong>问题描述：</strong></p>
<p>很多情况下，我们都可以通过在SQL语句中设置占位符来达到使用传入参数的目的，这种方式本身就有一定局限性，它是按照一定顺序传入参数的，要与占位符一一匹配。但是，如果我们<strong>传入的参数是不确定的</strong> （比如列表查询，根据用户填写的查询条件不同，传入查询的参数也是不同的，有时是一个参数、有时可能是三个参数），那么我们就得<strong>在后台代码中自己根据请求的传入参数去拼凑相应的SQL语句</strong> ，这样的话还是<strong>避免不了在Java代码里面写SQL语句的命运</strong> 。既然我们已经把SQL语句统一存放在配置文件或者数据库中了，<strong>怎么做到能够根据前台传入参数的不同，动态生成对应的SQL语句呢？</strong></p>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>第一，我们先解决这个动态问题，<strong>按照我们正常的程序员思维是，通过if和else这类的判断来进行是最直观的</strong> ，能不能将这类的标签引入到SQL语句中呢？假设可以，那么我们这里就需要一个专门的SQL解析器来解析这样的SQL语句，但是，if判断的变量来自于哪里呢？传入的值本身是可变的，那么我们得为这个值定义一个不变的变量名称，而且这个变量名称必须和对应的值要有对应关系，可以通过这个变量名称找到对应的值，这个时候我们想到了key-value的Map。解析的时候根据变量名的具体值来判断。</p>
</blockquote>
<blockquote>
<p>假如前面可以判断没有问题，那么假如判断的结果是true，那么就需要输出的标签里面的SQL片段，但是怎么解决在标签里面使用变量名称的问题呢？这里我们需要<strong>使用一种有别于SQL的语法来嵌入变量（比如使用＃变量名＃）</strong> 。这样，SQL语句经过解析后就可以动态的生成符合上下文的SQL语句。</p>
</blockquote>
<blockquote>
<p>还有，<strong>怎么区分开占位符变量和非占位变量？</strong> 有时候我们单单使用占位符是满足不了的，占位符只能为查询条件占位，SQL语句其他地方使用不了。<strong>这里我们可以使用#变量名#表示占位符变量，使用变量名表示非占位符变量</strong> 。</p>
</blockquote>
<h3 id="第四步优化：结果映射和结果缓存"><a href="#第四步优化：结果映射和结果缓存" class="headerlink" title="第四步优化：结果映射和结果缓存"></a>第四步优化：结果映射和结果缓存</h3><p>1、<strong>问题描述：</strong></p>
<p>执行SQL语句、获取执行结果、对执行结果进行转换处理、释放相关资源是一整套下来的。假如是执行查询语句，那么执行SQL语句后，返回的是一个ResultSet结果集，<strong>这个时候我们就需要将ResultSet对象的数据取出来，不然等到释放资源时就取不到这些结果信息了</strong> 。我们从前面的优化来看，以及将获取连接、设置传入参数、执行SQL语句、释放资源这些都封装起来了，只剩下结果处理这块还没有进行封装，如果能封装起来，每个数据库操作都不用自己写那么一大堆Java代码，直接调用一个封装的方法就可以搞定了。</p>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>我们分析一下，一般对执行结果的有哪些处理，<strong>有可能将结果不做任何处理就直接返回，也有可能将结果转换成一个JavaBean对象返回、一个Map返回、一个List返回等</strong> `，结果处理可能是多种多样的。从这里看，我们必须告诉SQL处理器两点：<strong>第一，需要返回什么类型的对象；第二，需要返回的对象的数据结构怎么跟执行的结果映射</strong> ，这样才能将具体的值copy到对应的数据结构上。</p>
</blockquote>
<blockquote>
<p>接下来，<strong>我们可以进而考虑对SQL执行结果的缓存来提升性能</strong> 。缓存数据都是key-value的格式，那么这个key怎么来呢？怎么保证唯一呢？即使同一条SQL语句几次访问的过程中由于传入参数的不同，得到的执行SQL语句也是不同的。那么缓存起来的时候是多对。<strong>但是SQL语句和传入参数两部分合起来可以作为数据缓存的key值</strong> 。</p>
</blockquote>
<h3 id="第五步优化：解决重复SQL语句问题"><a href="#第五步优化：解决重复SQL语句问题" class="headerlink" title="第五步优化：解决重复SQL语句问题"></a>第五步优化：解决重复SQL语句问题</h3><p>1、<strong>问题描述：</strong></p>
<p>由于我们将所有SQL语句都放到配置文件中，<strong>这个时候会遇到一个SQL重复的问题</strong> ，几个功能的SQL语句其实都差不多，有些可能是SELECT后面那段不同、有些可能是WHERE语句不同。有时候表结构改了，那么我们就需要改多个地方，不利于维护。</p>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>当我们的代码程序出现重复代码时怎么办？<strong>将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用</strong> 。对于SQL重复的问题，我们也可以采用这种方式，通过将SQL片段模块化，<strong>将重复的SQL片段独立成一个SQL块，然后在各个SQL语句引用重复的SQL块</strong> ，这样需要修改时只需要修改一处即可。</p>
</blockquote>
<h2 id="Mybaits有待改进之处"><a href="#Mybaits有待改进之处" class="headerlink" title="Mybaits有待改进之处"></a>Mybaits有待改进之处</h2><p>1、<strong>问题描述：</strong></p>
<p>Mybaits所有的数据库操作都是基于SQL语句，<strong>导致什么样的数据库操作都要写SQL语句</strong> 。一个应用系统要写的SQL语句实在太多了。</p>
<p><strong>改进方法：</strong></p>
<p>我们对数据库进行的操作大部分都是对表数据的增删改查，很多都是对单表的数据进行操作，由这点我们可以想到一个问题：<strong>单表操作可不可以不写SQL语句，通过JavaBean的默认映射器生成对应的SQL语句</strong> ，比如：一个类UserInfo对应于USER_INFO表， userId属性对应于USER_ID字段。<strong>这样我们就可以通过反射可以获取到对应的表结构了，拼凑成对应的SQL语句显然不是问题</strong> 。</p>
<h2 id="MyBatis框架整体设计"><a href="#MyBatis框架整体设计" class="headerlink" title="MyBatis框架整体设计"></a>MyBatis框架整体设计</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpqQ3RfkR2a6WSvKG9JiawNZ3Ezl6UUP4cUrJicWD8Lxkwr36sc3q9ATJw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>MyBatis框架整体设计</p>
<h3 id="接口层-和数据库交互的方式"><a href="#接口层-和数据库交互的方式" class="headerlink" title="接口层-和数据库交互的方式"></a>接口层-和数据库交互的方式</h3><h4 id="方式1：MyBatis的传统API（废弃）"><a href="#方式1：MyBatis的传统API（废弃）" class="headerlink" title="方式1：MyBatis的传统API（废弃）"></a>方式1：MyBatis的传统API（废弃）</h4><p><strong>这是传统的传递Statement Id 和查询参数给 SqlSession 对象，使用 SqlSession对象完成和数据库的交互</strong> ；MyBatis提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作，以及对数据库连接信息和MyBatis 自身配置信息的维护操作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpynovGbEGB8UlwFxIcic6QjaibJ5pStaPtP8u7IaFehgyicLhajr1OAMJA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<blockquote>
<p>上述使用MyBatis 的方法，是<strong>创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库</strong> ，这种方式固然很简单和实用，但是<strong>它不符合面向对象语言的概念和面向接口编程的编程习惯</strong> 。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用MyBatis 支持接口（Interface）调用方式。</p>
</blockquote>
<h4 id="方式2：使用Mapper接口"><a href="#方式2：使用Mapper接口" class="headerlink" title="方式2：使用Mapper接口"></a>方式2：使用Mapper接口</h4><p><strong>MyBatis 将配置文件中的每一个节点抽象为一个 Mapper 接口：</strong></p>
<blockquote>
<p><strong>这个接口中声明的方法和节点中的&lt;select|update|delete|insert&gt; 节点项对应</strong> ，即&lt;select|update|delete|insert&gt; 节点的id值为Mapper 接口中的方法名称，<strong>parameterType 值表示Mapper 对应方法的入参类型</strong> ，而<strong>resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型</strong> 。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JprLuWsU1bUMrLQjkSZIUB6SNjk6KHUCPg5tCVoemHBth6aISwkg0tHw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<blockquote>
<p><strong>根据MyBatis 的配置规范配置好后，通过SqlSession.getMapper(XXXMapper.class)方法，MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个Mapper 实例</strong> ，我们使用Mapper接口的某一个方法时，MyBatis会根据这个方法的方法名和参数类型，确定Statement Id，底层还是通过SqlSession.select(“statementId”,parameterObject);或者SqlSession.update(“statementId”,parameterObject); 等等来实现对数据库的操作，<strong>MyBatis引用Mapper 接口这种调用方式，纯粹是为了满足面向接口编程的需要</strong> 。（其实还有一个原因是在于，面向接口的编程，使得用户在接口上可以使用注解来配置SQL语句，这样就可以脱离XML配置文件，实现“0配置”）。</p>
</blockquote>
<h3 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h3><p><strong>数据处理层可以说是MyBatis的核心</strong> ，从大的方面上讲，它要完成两个功能：</p>
<blockquote>
<ol>
<li>通过传入参数构建动态SQL语句；</li>
<li>SQL语句的执行以及封装查询结果集成List；</li>
</ol>
</blockquote>
<h4 id="参数映射和动态SQL语句生成"><a href="#参数映射和动态SQL语句生成" class="headerlink" title="参数映射和动态SQL语句生成"></a>参数映射和动态SQL语句生成</h4><p>动态语句生成可以说是MyBatis框架非常优雅的一个设计，<strong>MyBatis 通过传入的参数值，使用 Ognl 来动态地构造SQL语句</strong> ，使得MyBatis 有很强的灵活性和扩展性。</p>
<p><strong>参数映射指的是对于java 数据类型和jdbc数据类型之间的转换：</strong> 这里有包括两个过程：<strong>查询阶段</strong> ，我们要将java类型的数据，转换成jdbc类型的数据，通过 preparedStatement.setXXX() 来设值；另一个就是<strong>对resultset查询结果集的jdbcType 数据转换成java 数据类型</strong> 。</p>
<h4 id="SQL语句的执行以及封装查询结果集成List"><a href="#SQL语句的执行以及封装查询结果集成List" class="headerlink" title="SQL语句的执行以及封装查询结果集成List"></a>SQL语句的执行以及封装查询结果集成List</h4><p>动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List列表。<strong>MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换</strong> ，并且有两种支持方式，<strong>一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询</strong> 。</p>
<h3 id="框架支撑层"><a href="#框架支撑层" class="headerlink" title="框架支撑层"></a>框架支撑层</h3><p>1、事务管理机制</p>
<p><strong>事务管理机制对于ORM框架而言是不可缺少的一部分</strong> ，事务管理机制的质量也是考量一个ORM框架是否优秀的一个标准。</p>
<p>2、连接池管理机制</p>
<p>由于创建一个数据库连接所占用的资源比较大，<strong>对于数据吞吐量大和访问量非常大的应用而言，连接池的设计就显得非常重要</strong> 。</p>
<p>3、缓存机制</p>
<p>为了提高数据利用率和减小服务器和数据库的压力，<strong>MyBatis 会对于一些查询提供会话级别的数据缓存</strong> ，会将对某一次查询，放置到SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis会直接将缓存结果返回给用户，而不用再到数据库中查找。</p>
<p>4、SQL语句的配置方式</p>
<p>传统的MyBatis 配置SQL语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，<strong>为了支持面向接口的编程，MyBatis 引入了Mapper接口的概念，面向接口的引入，对使用注解来配置SQL语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了</strong> ，但是，目前的MyBatis 只是对注解配置SQL语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。</p>
<h3 id="5-4-引导层"><a href="#5-4-引导层" class="headerlink" title="5.4 引导层"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">5.4 引导层</a></h3><p><strong>引导层是配置和启动MyBatis配置信息的方式</strong> 。MyBatis 提供两种方式来引导MyBatis ：<strong>基于XML配置文件的方式和基于Java API 的方式</strong>。</p>
<h3 id="5-5-主要构件及其相互关系"><a href="#5-5-主要构件及其相互关系" class="headerlink" title="5.5 主要构件及其相互关系"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">5.5 主要构件及其相互关系</a></h3><p>从MyBatis代码实现的角度来看，MyBatis的主要的核心部件有以下几个：</p>
<blockquote>
<p><strong>SqlSession：</strong> 作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能；</p>
<p><strong>Executor：</strong> MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护；</p>
<p><strong>StatementHandler：</strong> 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。</p>
<p><strong>ParameterHandler：</strong> 负责对用户传递的参数转换成JDBC Statement 所需要的参数；</p>
<p><strong>ResultSetHandler：</strong> 负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</p>
<p><strong>TypeHandler：</strong> 负责java数据类型和jdbc数据类型之间的映射和转换；</p>
<p><strong>MappedStatement：</strong> MappedStatement维护了一条&lt;select|update|delete|insert&gt;节点的封装；</p>
<p><strong>SqlSource：</strong> 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回；</p>
<p><strong>BoundSql：</strong> 表示动态生成的SQL语句以及相应的参数信息；</p>
<p><strong>Configuration：</strong> MyBatis所有的配置信息都维持在Configuration对象之中；</p>
</blockquote>
<p><strong>它们的关系如下图所示：</strong></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpF41DhLROCCDSw4J8fgRYk56wOvDsf7FxUkaQ7OzThb9QFAjqjLnNWA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>MyBatis主要构件关系如图</p>
<h2 id="6-SqlSession工作过程分析"><a href="#6-SqlSession工作过程分析" class="headerlink" title="6 SqlSession工作过程分析"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">6 SqlSession工作过程分析</a></h2><p>1、<strong>开启一个数据库访问会话—创建SqlSession对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession &#x3D; factory.openSession();</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></a></p>
<p>MyBatis封装了对数据库的访问，把对数据库的会话和事务控制放到了SqlSession对象中</p>
<p>2、<strong>为SqlSession传递一个配置的Sql语句的Statement Id和参数，然后返回结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; result &#x3D; sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;,params);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述的”com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary”，是配置在EmployeesMapper.xml 的Statement ID，params是传递的查询参数。</p>
</blockquote>
<p>让我们来看一下sqlSession.selectList()方法的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123;</span><br><span class="line">    return this.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;1.根据Statement Id，在mybatis 配置对象Configuration中查找和配置文件相对应的MappedStatement</span><br><span class="line">        MappedStatement ms &#x3D; configuration.getMappedStatement(statement);</span><br><span class="line">        &#x2F;&#x2F;2. 将查询任务委托给MyBatis 的执行器 Executor</span><br><span class="line">        List&lt;E&gt; result &#x3D; executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MyBatis在初始化的时候，会将MyBatis的配置信息全部加载到内存中，<strong>使用org.apache.ibatis.session.Configuration实例来维护</strong> 。使用者可以使用sqlSession.getConfiguration()方法来获取。<strong>MyBatis的配置文件中配置信息的组织格式和内存中对象的组织格式几乎完全对应的</strong> 。</p>
</blockquote>
<p>上述例子中的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectByMinSalary&quot; resultMap&#x3D;&quot;BaseResultMap&quot; parameterType&#x3D;&quot;java.util.Map&quot; &gt;</span><br><span class="line">   select</span><br><span class="line">       EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY</span><br><span class="line">   from LOUIS.EMPLOYEES</span><br><span class="line">   &lt;if test&#x3D;&quot;min_salary !&#x3D; null&quot;&gt;</span><br><span class="line">       where SALARY &lt; #&#123;min_salary,jdbcType&#x3D;DECIMAL&#125;</span><br><span class="line">   &lt;&#x2F;if&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>加载到内存中会生成一个对应的MappedStatement对象，然后会以key=”com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary” ，value为MappedStatement对象的形式维护到Configuration的一个Map中</strong> 。当以后需要使用的时候，只需要通过Id值来获取就可以了。</p>
</blockquote>
<p>从上述的代码中我们可以看到SqlSession的职能是：<strong>SqlSession根据Statement ID, 在mybatis配置对象Configuration中获取到对应的MappedStatement对象，然后调用mybatis执行器来执行具体的操作</strong> 。</p>
<p>3、<strong>MyBatis执行器Executor根据SqlSession传递的参数执行query()方法（由于代码过长，读者只需阅读我注释的地方即可）：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * BaseExecutor 类部分代码</span><br><span class="line">   *</span><br><span class="line">   *&#x2F;</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">      &#x2F;&#x2F; 1. 根据具体传入的参数，动态地生成需要执行的SQL语句，用BoundSql对象表示</span><br><span class="line">      BoundSql boundSql &#x3D; ms.getBoundSql(parameter);</span><br><span class="line">      &#x2F;&#x2F; 2. 为当前的查询创建一个缓存Key</span><br><span class="line">      CacheKey key &#x3D; createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">      return query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">       ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());</span><br><span class="line">       if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">       if (queryStack &#x3D;&#x3D; 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">           clearLocalCache();</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;E&gt; list;</span><br><span class="line">       try &#123;</span><br><span class="line">           queryStack++;</span><br><span class="line">           list &#x3D; resultHandler &#x3D;&#x3D; null ? (List&lt;E&gt;) localCache.getObject(key) : null;</span><br><span class="line">           if (list !&#x3D; null) &#123;</span><br><span class="line">               handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; 3.缓存中没有值，直接从数据库中读取数据</span><br><span class="line">               list &#x3D; queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           queryStack--;</span><br><span class="line">       &#125;</span><br><span class="line">       if (queryStack &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           for (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">               deferredLoad.load();</span><br><span class="line">           &#125;</span><br><span class="line">           deferredLoads.clear(); &#x2F;&#x2F; issue #601</span><br><span class="line">           if (configuration.getLocalCacheScope() &#x3D;&#x3D; LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">               clearLocalCache(); &#x2F;&#x2F; issue #482</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">      List&lt;E&gt; list;</span><br><span class="line">      localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;4. 执行查询，返回List 结果，然后    将查询的结果放入缓存之中</span><br><span class="line">          list &#x3D; doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          localCache.removeObject(key);</span><br><span class="line">      &#125;</span><br><span class="line">      localCache.putObject(key, list);</span><br><span class="line">      if (ms.getStatementType() &#x3D;&#x3D; StatementType.CALLABLE) &#123;</span><br><span class="line">          localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">      &#125;</span><br><span class="line">      return list;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">   *</span><br><span class="line">   * SimpleExecutor类的doQuery()方法实现</span><br><span class="line">   *</span><br><span class="line">   *&#x2F;</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">      Statement stmt &#x3D; null;</span><br><span class="line">      try &#123;</span><br><span class="line">          Configuration configuration &#x3D; ms.getConfiguration();</span><br><span class="line">          &#x2F;&#x2F;5. 根据既有的参数，创建StatementHandler对象来执行查询操作</span><br><span class="line">          StatementHandler handler &#x3D; configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">          &#x2F;&#x2F;6. 创建java.Sql.Statement对象，传递给StatementHandler对象</span><br><span class="line">          stmt &#x3D; prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">          &#x2F;&#x2F;7. 调用StatementHandler.query()方法，返回List结果集</span><br><span class="line">          return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           closeStatement(stmt);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的Executor.query()方法几经转折，<strong>最后会创建一个StatementHandler对象，然后将必要的参数传递给StatementHandler</strong> ，使用StatementHandler来完成对数据库的查询，最终返回List结果集。</p>
<p><strong>从上面的代码中我们可以看出，Executor的功能和作用是：</strong></p>
<blockquote>
<ol>
<li>根据传递的参数，完成SQL语句的动态解析，生成BoundSql对象，供StatementHandler使用；</li>
<li>为查询创建缓存，以提高性能；</li>
<li>创建JDBC的Statement连接对象，传递给StatementHandler对象，返回List查询结果；</li>
</ol>
</blockquote>
<p>4、<strong>StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回：</strong></p>
<p>接着上面的Executor第六步，看一下：prepareStatement() 方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   *</span><br><span class="line">   * SimpleExecutor类的doQuery()方法实现</span><br><span class="line">   *</span><br><span class="line">   *&#x2F;</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">      Statement stmt &#x3D; null;</span><br><span class="line">      try &#123;</span><br><span class="line">          Configuration configuration &#x3D; ms.getConfiguration();</span><br><span class="line">          StatementHandler handler &#x3D; configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">          &#x2F;&#x2F; 1.准备Statement对象，并设置Statement对象的参数</span><br><span class="line">          stmt &#x3D; prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">          &#x2F;&#x2F; 2. StatementHandler执行query()方法，返回List结果</span><br><span class="line">          return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          closeStatement(stmt);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">      Statement stmt;</span><br><span class="line">      Connection connection &#x3D; getConnection(statementLog);</span><br><span class="line">      stmt &#x3D; handler.prepare(connection);</span><br><span class="line">      &#x2F;&#x2F;对创建的Statement对象设置参数，即设置SQL 语句中 ? 设置为指定的参数</span><br><span class="line">      handler.parameterize(stmt);</span><br><span class="line">      return stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上我们可以总结StatementHandler对象主要完成两个工作：</p>
<blockquote>
<ol>
<li>对于JDBC的PreparedStatement类型的对象，创建的过程中，我们使用的是SQL语句字符串会包含 若干个? 占位符，我们其后再对占位符进行设值。<strong>StatementHandler通过parameterize(statement)方法对Statement进行设值；</strong></li>
<li>StatementHandler通过Listquery(Statement statement, ResultHandler resultHandler)方法来完成执行Statement，和将Statement对象返回的resultSet封装成List；</li>
</ol>
</blockquote>
<p>5、<strong>StatementHandler 的parameterize(statement) 方法的实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * StatementHandler 类的parameterize(statement) 方法实现</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void parameterize(Statement statement) throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用ParameterHandler对象来完成对Statement的设值</span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">   *</span><br><span class="line">   * ParameterHandler类的setParameters(PreparedStatement ps) 实现</span><br><span class="line">   * 对某一个Statement进行设置参数</span><br><span class="line">   *&#x2F;</span><br><span class="line">public void setParameters(PreparedStatement ps) throws SQLException &#123;</span><br><span class="line">      ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">      List&lt;ParameterMapping&gt; parameterMappings &#x3D; boundSql.getParameterMappings();</span><br><span class="line">      if (parameterMappings !&#x3D; null) &#123;</span><br><span class="line">          for (int i &#x3D; 0; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">              ParameterMapping parameterMapping &#x3D; parameterMappings.get(i);</span><br><span class="line">              if (parameterMapping.getMode() !&#x3D; ParameterMode.OUT) &#123;</span><br><span class="line">                  Object value;</span><br><span class="line">                  String propertyName &#x3D; parameterMapping.getProperty();</span><br><span class="line">                  if (boundSql.hasAdditionalParameter(propertyName)) &#123; &#x2F;&#x2F; issue #448 ask first for additional params</span><br><span class="line">                      value &#x3D; boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                  &#125; else if (parameterObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">                      value &#x3D; null;</span><br><span class="line">                  &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                      value &#x3D; parameterObject;</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      MetaObject metaObject &#x3D; configuration.newMetaObject(parameterObject);</span><br><span class="line">                      value &#x3D; metaObject.getValue(propertyName);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  &#x2F;&#x2F; 每一个Mapping都有一个TypeHandler，根据TypeHandler来对preparedStatement进行设置参数</span><br><span class="line">                  TypeHandler typeHandler &#x3D; parameterMapping.getTypeHandler();</span><br><span class="line">                  JdbcType jdbcType &#x3D; parameterMapping.getJdbcType();</span><br><span class="line">                  if (value &#x3D;&#x3D; null &amp;&amp; jdbcType &#x3D;&#x3D; null) jdbcType &#x3D; configuration.getJdbcTypeForNull();</span><br><span class="line">                  &#x2F;&#x2F; 设置参数</span><br><span class="line">                  typeHandler.setParameter(ps, i + 1, value, jdbcType);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上述的代码可以看到,StatementHandler的parameterize(Statement) 方法调用了 ParameterHandler的setParameters(statement) 方法，<strong>ParameterHandler的setParameters(Statement)方法负责 根据我们输入的参数，对statement对象的 ? 占位符处进行赋值。</strong></p>
</blockquote>
<p>6、<strong>StatementHandler 的Listquery(Statement statement, ResultHandler resultHandler)方法的实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">    * PreParedStatement类的query方法实现</span><br><span class="line">    *&#x2F;</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">      &#x2F;&#x2F;1.调用preparedStatemnt。execute()方法，然后将resultSet交给ResultSetHandler处理</span><br><span class="line">      PreparedStatement ps &#x3D; (PreparedStatement) statement;</span><br><span class="line">      ps.execute();</span><br><span class="line">      &#x2F;&#x2F;2. 使用ResultHandler来处理ResultSet</span><br><span class="line">      return resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上述代码我们可以看出，StatementHandler 的Listquery(Statement statement, ResultHandler resultHandler)方法的实现，是调用了ResultSetHandler的handleResultSets(Statement) 方法。<strong>ResultSetHandler的handleResultSets(Statement) 方法会将Statement语句执行后生成的resultSet 结果集转换成List结果集</strong> ：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * ResultSetHandler类的handleResultSets()方法实现</span><br><span class="line">   *</span><br><span class="line">   *&#x2F;</span><br><span class="line">public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123;</span><br><span class="line">      final List&lt;Object&gt; multipleResults &#x3D; new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">      int resultSetCount &#x3D; 0;</span><br><span class="line">      ResultSetWrapper rsw &#x3D; getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">      List&lt;ResultMap&gt; resultMaps &#x3D; mappedStatement.getResultMaps();</span><br><span class="line">      int resultMapCount &#x3D; resultMaps.size();</span><br><span class="line">      validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line"></span><br><span class="line">      while (rsw !&#x3D; null &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">          ResultMap resultMap &#x3D; resultMaps.get(resultSetCount);</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;将resultSet</span><br><span class="line">          handleResultSet(rsw, resultMap, multipleResults, null);</span><br><span class="line">          rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">          cleanUpAfterHandlingResultSet();</span><br><span class="line">          resultSetCount++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String[] resultSets &#x3D; mappedStatement.getResulSets();</span><br><span class="line">      if (resultSets !&#x3D; null) &#123;</span><br><span class="line">          while (rsw !&#x3D; null &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">              ResultMapping parentMapping &#x3D; nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">              if (parentMapping !&#x3D; null) &#123;</span><br><span class="line">                  String nestedResultMapId &#x3D; parentMapping.getNestedResultMapId();</span><br><span class="line">                  ResultMap resultMap &#x3D; configuration.getResultMap(nestedResultMapId);</span><br><span class="line">                  handleResultSet(rsw, resultMap, null, parentMapping);</span><br><span class="line">              &#125;</span><br><span class="line">              rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">              cleanUpAfterHandlingResultSet();</span><br><span class="line">              resultSetCount++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MyBatis初始化机制"><a href="#MyBatis初始化机制" class="headerlink" title="MyBatis初始化机制"></a>MyBatis初始化机制</h2><h3 id="MyBatis的初始化做了什么"><a href="#MyBatis的初始化做了什么" class="headerlink" title="MyBatis的初始化做了什么"></a>MyBatis的初始化做了什么</h3><p><strong>任何框架的初始化，无非是加载自己运行时所需要的配置信息。</strong> MyBatis的配置信息，大概包含以下信息，其高层级结构如下：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6Jpd0YczNFt9C59JO4a4N7wErMlEoeXhwXFfdicyUCQmED8waP5pCpw1Lw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>MyBatis配置信息结构图</p>
<p><strong>MyBatis的上述配置信息会配置在XML配置文件中，那么，这些信息被加载进入MyBatis内部，MyBatis是怎样维护的呢？</strong></p>
<p>MyBatis采用了一个非常直白和简单的方式—<strong>使用 org.apache.ibatis.session.Configuration对象作为一个所有配置信息的容器，Configuration对象的组织结构和XML配置文件的组织结构几乎完全一样</strong> （当然，Configuration对象的功能并不限于此，它还负责创建一些MyBatis内部使用的对象，如Executor等，这将在后续的文章中讨论）。如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpBne4eIxEggmH7EgW8L4AOOA8TKk94zQjlxurPjGkhaDnN6T2cJSQnA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>Configuration对象的组织结构和XML配置文件的组织结构几乎完全一样</p>
<p>MyBatis根据初始化好Configuration信息，这时候用户就可以使用MyBatis进行数据库操作了。<strong>可以这么说，MyBatis初始化的过程，就是创建 Configuration对象的过程</strong> 。</p>
<p><strong>MyBatis的初始化可以有两种方式：</strong></p>
<blockquote>
<p><strong>基于XML配置文件：</strong> 基于XML配置文件的方式是将MyBatis的所有配置信息放在XML文件中，MyBatis通过加载并XML配置文件，将配置文信息组装成内部的Configuration对象。</p>
<p><strong>基于Java API：</strong> 这种方式不使用XML配置文件，需要MyBatis使用者在Java代码中，手动创建Configuration对象，然后将配置参数set 进入Configuration对象中。</p>
</blockquote>
<p>接下来我们将通过 基于XML配置文件方式的MyBatis初始化，深入探讨MyBatis是如何通过配置文件构建Configuration对象，并使用它。</p>
<h3 id="7-2-基于XML配置文件创建Configuration对象"><a href="#7-2-基于XML配置文件创建Configuration对象" class="headerlink" title="7.2 基于XML配置文件创建Configuration对象"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">7.2 基于XML配置文件创建Configuration对象</a></h3><p>现在就从使用MyBatis的简单例子入手，深入分析一下MyBatis是怎样完成初始化的，都初始化了什么。看以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">List list &#x3D; sqlSession.selectList(&quot;com.foo.bean.BlogMapper.queryAllBlogInfo&quot;);</span><br></pre></td></tr></table></figure>

<p>有过MyBatis使用经验的读者会知道，上述语句的作用是执行com.foo.bean.BlogMapper.queryAllBlogInfo 定义的SQL语句，返回一个List结果集。总的来说，上述代码经历了<strong>mybatis初始化 –&gt;创建SqlSession –&gt;执行SQL语句</strong> 返回结果三个过程。</p>
<p>上述代码的功能是根据配置文件mybatis-config.xml  配置文件，创建SqlSessionFactory对象，然后产生SqlSession，执行SQL语句。<strong>而mybatis的初始化就发生在第三句：SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</strong> 现在就让我们看看第三句到底发生了什么。</p>
<p>1、<strong>MyBatis初始化基本过程：</strong></p>
<p>SqlSessionFactoryBuilder根据传入的数据流生成Configuration对象，然后根据Configuration对象创建默认的SqlSessionFactory实例。</p>
<p><strong>初始化的基本过程如下序列图所示：</strong></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpFl85Ij5u2Enx13oHBe8Mco8Lojteth36c9JGsxMmncYZnWamaT3R1g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>MyBatis初始化序列图</p>
<p><strong>由上图所示，mybatis初始化要经过简单的以下几步：</strong></p>
<blockquote>
<ol>
<li>调用SqlSessionFactoryBuilder对象的build(inputStream)方法；</li>
<li>SqlSessionFactoryBuilder会根据输入流inputStream等信息创建XMLConfigBuilder对象;</li>
<li>SqlSessionFactoryBuilder调用XMLConfigBuilder对象的parse()方法；</li>
<li>XMLConfigBuilder对象返回Configuration对象；</li>
<li>SqlSessionFactoryBuilder根据Configuration对象创建一个DefaultSessionFactory对象；</li>
<li>SqlSessionFactoryBuilder返回 DefaultSessionFactory对象给Client，供Client使用。</li>
</ol>
</blockquote>
<p><strong>SqlSessionFactoryBuilder相关的代码如下所示：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream)  &#123;</span><br><span class="line">      return build(inputStream, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties)  &#123;</span><br><span class="line">      try  &#123;</span><br><span class="line">          &#x2F;&#x2F;2. 创建XMLConfigBuilder对象用来解析XML配置文件，生成Configuration对象</span><br><span class="line">          XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">          &#x2F;&#x2F;3. 将XML配置文件内的信息解析成Java对象Configuration对象</span><br><span class="line">          Configuration config &#x3D; parser.parse();</span><br><span class="line">          &#x2F;&#x2F;4. 根据Configuration对象创建出SqlSessionFactory对象</span><br><span class="line">          return build(config);</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">          try &#123;</span><br><span class="line">              inputStream.close();</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              &#x2F;&#x2F; Intentionally ignore. Prefer previous error.</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从此处可以看出，MyBatis内部通过Configuration对象来创建SqlSessionFactory,用户也可以自己通过API构造好Configuration对象，调用此方法创SqlSessionFactory</span><br><span class="line">public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">      return new DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的初始化过程中，涉及到了以下几个对象：</p>
<blockquote>
<p><strong>SqlSessionFactoryBuilder ：</strong> SqlSessionFactory的构造器，用于创建SqlSessionFactory，采用了Builder设计模式</p>
<p><strong>Configuration ：</strong> 该对象是mybatis-config.xml文件中所有mybatis配置信息</p>
<p><strong>SqlSessionFactory：</strong> SqlSession工厂类，以工厂形式创建SqlSession对象，采用了Factory工厂设计模式</p>
<p><strong>XMLConfigBuilder ：</strong> 负责将mybatis-config.xml配置文件解析成Configuration对象，共SqlSessonFactoryBuilder使用，创建SqlSessionFactory</p>
</blockquote>
<p>2、<strong>创建Configuration对象的过程：</strong>接着上述的 MyBatis初始化基本过程讨论，<strong>当SqlSessionFactoryBuilder执行build()方法，调用了XMLConfigBuilder的parse()方法，然后返回了Configuration对象</strong> 。那么parse()方法是如何处理XML文件，生成Configuration对象的呢？</p>
<ul>
<li><p>（1）XMLConfigBuilder会<strong>将XML配置文件的信息转换为Document对象</strong> ，而XML配置定义文件<strong>DTD转换成XMLMapperEntityResolver对象</strong> ，然后<strong>将二者封装到XpathParser对象中，XpathParser的作用是提供根据Xpath表达式获取基本的DOM节点Node信息的操作</strong> 。如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpsnGfGA3ozcXt7xDJE76icYA9Y9QOvGb3H5JRjvHwiaN04jW1MNvgeicrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>XpathParser组成结构图和生成图</p>
</li>
<li><p>（2）之后XMLConfigBuilder调用parse()方法：<strong>会从XPathParser中取出节点对应的Node对象，然后解析此Node节点的子Node</strong> ：properties, settings, typeAliases,typeHandlers, objectFactory, objectWrapperFactory, plugins, environments,databaseIdProvider, mappers：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() &#123;</span><br><span class="line">     if (parsed) &#123;</span><br><span class="line">         throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     parsed &#x3D; true;</span><br><span class="line">     &#x2F;&#x2F;源码中没有这一句，只有parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br><span class="line">     &#x2F;&#x2F;为了让读者看得更明晰，源码拆分为以下两句</span><br><span class="line">     XNode configurationNode &#x3D; parser.evalNode(&quot;&#x2F;configuration&quot;);</span><br><span class="line">     parseConfiguration(configurationNode);</span><br><span class="line">     return configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * 解析 &quot;&#x2F;configuration&quot;节点下的子节点信息，然后将解析的结果设置到Configuration对象中</span><br><span class="line">  *&#x2F;</span><br><span class="line">private void parseConfiguration(XNode root) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         &#x2F;&#x2F;1.首先处理properties 节点</span><br><span class="line">         propertiesElement(root.evalNode(&quot;properties&quot;)); &#x2F;&#x2F;issue #117 read properties first</span><br><span class="line">         &#x2F;&#x2F;2.处理typeAliases</span><br><span class="line">         typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">         &#x2F;&#x2F;3.处理插件</span><br><span class="line">         pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">         &#x2F;&#x2F;4.处理objectFactory</span><br><span class="line">         objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">         &#x2F;&#x2F;5.objectWrapperFactory</span><br><span class="line">         objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">         &#x2F;&#x2F;6.settings</span><br><span class="line">         settingsElement(root.evalNode(&quot;settings&quot;));</span><br><span class="line">         &#x2F;&#x2F;7.处理environments</span><br><span class="line">         environmentsElement(root.evalNode(&quot;environments&quot;)); &#x2F;&#x2F; read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">         &#x2F;&#x2F;8.database</span><br><span class="line">         databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">         &#x2F;&#x2F;9.typeHandlers</span><br><span class="line">         typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">         &#x2F;&#x2F;10.mappers</span><br><span class="line">         mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意：在上述代码中，还有一个非常重要的地方，<strong>就是解析XML配置文件子节点的方法mapperElements(root.evalNode(“mappers”)), 它将解析我们配置的Mapper.xml配置文件，Mapper配置文件可以说是MyBatis的核心</strong> ，MyBatis的特性和理念都体现在此Mapper的配置和设计上。</p>
<ul>
<li><p>（3）<strong>然后将这些值解析出来设置到Configuration对象中：</strong></p>
<p>解析子节点的过程这里就不一一介绍了，用户可以参照MyBatis源码仔细揣摩，<strong>我们就看上述的environmentsElement(root.evalNode(“environments”)); 方法是如何将environments的信息解析出来，设置到Configuration对象中的：</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * 解析environments节点，并将结果设置到Configuration对象中</span><br><span class="line">  * 注意：创建envronment时，如果SqlSessionFactoryBuilder指定了特定的环境（即数据源）；</span><br><span class="line">  *      则返回指定环境（数据源）的Environment对象，否则返回默认的Environment对象；</span><br><span class="line">  *      这种方式实现了MyBatis可以连接多数据源</span><br><span class="line">  *&#x2F;</span><br><span class="line">private void environmentsElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">         if (environment &#x3D;&#x3D; null)</span><br><span class="line">         &#123;</span><br><span class="line">             environment &#x3D; context.getStringAttribute(&quot;default&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         for (XNode child : context.getChildren())</span><br><span class="line">         &#123;</span><br><span class="line">              String id &#x3D; child.getStringAttribute(&quot;id&quot;);</span><br><span class="line">              if (isSpecifiedEnvironment(id))</span><br><span class="line">              &#123;</span><br><span class="line">                  &#x2F;&#x2F;1.创建事务工厂 TransactionFactory</span><br><span class="line">                  TransactionFactory txFactory &#x3D; transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));</span><br><span class="line">                  DataSourceFactory dsFactory &#x3D; dataSourceElement(child.evalNode(&quot;dataSource&quot;));</span><br><span class="line">                  &#x2F;&#x2F;2.创建数据源DataSource</span><br><span class="line">                  DataSource dataSource &#x3D; dsFactory.getDataSource();</span><br><span class="line">                  &#x2F;&#x2F;3. 构造Environment对象</span><br><span class="line">                  Environment.Builder environmentBuilder &#x3D; new Environment.Builder(id)</span><br><span class="line">             .transactionFactory(txFactory)</span><br><span class="line">             .dataSource(dataSource);</span><br><span class="line">                  &#x2F;&#x2F;4. 将创建的Envronment对象设置到configuration 对象中</span><br><span class="line">                  configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private boolean isSpecifiedEnvironment(String id)</span><br><span class="line">&#123;</span><br><span class="line">      if (environment &#x3D;&#x3D; null)</span><br><span class="line">      &#123;</span><br><span class="line">           throw new BuilderException(&quot;No environment specified.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (id &#x3D;&#x3D; null)</span><br><span class="line">      &#123;</span><br><span class="line">           throw new BuilderException(&quot;Environment requires an id attribute.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (environment.equals(id))</span><br><span class="line">      &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>（4）<strong>返回Configuration对象：</strong></p>
<p>将上述的MyBatis初始化基本过程的序列图细化：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></a></p>
<p>基于XML配置创建Configuration对象的过程</p>
</li>
</ul>
<h3 id="7-3-基于Java-API手动加载XML配置文件创建Configuration对象，并使用SqlSessionFactory对象"><a href="#7-3-基于Java-API手动加载XML配置文件创建Configuration对象，并使用SqlSessionFactory对象" class="headerlink" title="7.3 基于Java API手动加载XML配置文件创建Configuration对象，并使用SqlSessionFactory对象##"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">7.3 基于Java API手动加载XML配置文件创建Configuration对象，并使用SqlSessionFactory对象##</a></h3><p>我们可以使用XMLConfigBuilder手动解析XML配置文件来创建Configuration对象，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">&#x2F;&#x2F; 手动创建XMLConfigBuilder，并解析创建Configuration对象</span><br><span class="line">XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, null,null);</span><br><span class="line">Configuration configuration&#x3D;parse();</span><br><span class="line">&#x2F;&#x2F; 使用Configuration对象创建SqlSessionFactory</span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(configuration);</span><br><span class="line">&#x2F;&#x2F; 使用MyBatis</span><br><span class="line">SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">List list &#x3D; sqlSession.selectList(&quot;com.foo.bean.BlogMapper.queryAllBlogInfo&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="7-4-涉及到的设计模式"><a href="#7-4-涉及到的设计模式" class="headerlink" title="7.4 涉及到的设计模式"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">7.4 涉及到的设计模式</a></h3><p>初始化的过程涉及到创建各种对象，所以会使用一些创建型的设计模式。<strong>在初始化的过程中，Builder模式运用的比较多</strong> 。</p>
<h4 id="7-4-1-Builder模式应用1：SqlSessionFactory的创建"><a href="#7-4-1-Builder模式应用1：SqlSessionFactory的创建" class="headerlink" title="7.4.1 Builder模式应用1：SqlSessionFactory的创建"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">7.4.1 Builder模式应用1：SqlSessionFactory的创建</a></h4><p>对于创建SqlSessionFactory时，会<strong>根据情况提供不同的参数，其参数组合可以有以下几种</strong> ：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></a></p>
<p>根据情况提供不同的参数，创建SqlSessionFactory</p>
<p>由于构造时参数不定，可以为其创建一个构造器Builder，<strong>将SqlSessionFactory的构建过程和表示分开</strong> ：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></a></p>
<p>MyBatis将SqlSessionFactoryBuilder和SqlSessionFactory相互独立</p>
<h4 id="7-4-2-Builder模式应用2：数据库连接环境Environment对象的创建"><a href="#7-4-2-Builder模式应用2：数据库连接环境Environment对象的创建" class="headerlink" title="7.4.2 Builder模式应用2：数据库连接环境Environment对象的创建"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">7.4.2 Builder模式应用2：数据库连接环境Environment对象的创建</a></h4><p>在构建Configuration对象的过程中，XMLConfigBuilder解析 mybatis XML配置文件节点节点时，会有以下相应的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void environmentsElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context !&#x3D; null) &#123;</span><br><span class="line">        if (environment &#x3D;&#x3D; null) &#123;</span><br><span class="line">            environment &#x3D; context.getStringAttribute(&quot;default&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (XNode child : context.getChildren()) &#123;</span><br><span class="line">            String id &#x3D; child.getStringAttribute(&quot;id&quot;);</span><br><span class="line">            &#x2F;&#x2F;是和默认的环境相同时，解析之</span><br><span class="line">            if (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">                TransactionFactory txFactory &#x3D; transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));</span><br><span class="line">                DataSourceFactory dsFactory &#x3D; dataSourceElement(child.evalNode(&quot;dataSource&quot;));</span><br><span class="line">                DataSource dataSource &#x3D; dsFactory.getDataSource();</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;使用了Environment内置的构造器Builder，传递id 事务工厂和数据源</span><br><span class="line">                Environment.Builder environmentBuilder &#x3D; new Environment.Builder(id)</span><br><span class="line">                .transactionFactory(txFactory)</span><br><span class="line">                .dataSource(dataSource);</span><br><span class="line">                configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Environment内部，定义了静态内部Builder类：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public final class Environment &#123;</span><br><span class="line">    private final String id;</span><br><span class="line">    private final TransactionFactory transactionFactory;</span><br><span class="line">    private final DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    public Environment(String id, TransactionFactory transactionFactory, DataSource dataSource) &#123;</span><br><span class="line">        if (id &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Parameter &#39;id&#39; must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (transactionFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Parameter &#39;transactionFactory&#39; must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        if (dataSource &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Parameter &#39;dataSource&#39; must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.transactionFactory &#x3D; transactionFactory;</span><br><span class="line">        this.dataSource &#x3D; dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        private String id;</span><br><span class="line">        private TransactionFactory transactionFactory;</span><br><span class="line">        private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">        public Builder(String id) &#123;</span><br><span class="line">            this.id &#x3D; id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder transactionFactory(TransactionFactory transactionFactory) &#123;</span><br><span class="line">            this.transactionFactory &#x3D; transactionFactory;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder dataSource(DataSource dataSource) &#123;</span><br><span class="line">            this.dataSource &#x3D; dataSource;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String id() &#123;</span><br><span class="line">            return this.id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Environment build() &#123;</span><br><span class="line">            return new Environment(this.id, this.transactionFactory, this.dataSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TransactionFactory getTransactionFactory() &#123;</span><br><span class="line">        return this.transactionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DataSource getDataSource() &#123;</span><br><span class="line">        return this.dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-02-%E6%9C%8D%E5%8A%A1%E5%AE%95%E6%9C%BA%E5%BC%95%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-02-%E6%9C%8D%E5%8A%A1%E5%AE%95%E6%9C%BA%E5%BC%95%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8/" class="post-title-link" itemprop="url">kafka-分析与调优-02-服务宕机引发高可用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-17 13:53:27" itemprop="dateCreated datePublished" datetime="2021-06-17T13:53:27+08:00">2021-06-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-07 18:41:13" itemprop="dateModified" datetime="2021-09-07T18:41:13+08:00">2021-09-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kafka宕机引发的高可用问题"><a href="#Kafka宕机引发的高可用问题" class="headerlink" title="Kafka宕机引发的高可用问题"></a>Kafka宕机引发的高可用问题</h1><p>最近系统测试人员常反馈偶有Kafka消费者收不到消息的情况，登陆管理界面发现三个节点中有一个节点宕机挂掉了。但是按照高可用的理念，三个节点还有两个节点可用怎么就引起了整个集群的消费者都接收不到消息呢？</p>
<p>要解决这个问题，就要从Kafka的高可用实现开始讲起。</p>
<h1 id="Kafka的多副本冗余设计"><a href="#Kafka的多副本冗余设计" class="headerlink" title="Kafka的多副本冗余设计"></a>Kafka的多副本冗余设计</h1><ul>
<li><strong>物理模型</strong></li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5d9831010e641d9a296a0277255f9f3~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li><strong>逻辑模型</strong></li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd93eab29efa465c898d91c809226f0b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li><strong>Broker</strong>（节点）：Kafka服务节点，简单来说一个<code>Broker</code>就是一台Kafka服务器，一个物理节点。</li>
<li><strong>Topic</strong>（主题）：在Kafka中消息以主题为单位进行归类，每个主题都有一个<code>Topic Name</code>，生产者根据Topic Name将消息发送到特定的Topic，消费者则同样根据Topic Name从对应的Topic进行消费。</li>
<li><strong>Partition</strong>（分区）：<code>Topic</code>（主题）是消息归类的一个单位，但每一个主题还能再细分为一个或多个<code>Partition</code>（分区），一个分区只能属于一个主题。主题和分区都是逻辑上的概念，举个例子，消息1和消息2都发送到主题1，它们可能进入同一个分区也可能进入不同的分区（所以同一个主题下的不同分区包含的消息是不同的），之后便会发送到分区对应的Broker节点上。</li>
<li><strong>Offset</strong>（偏移量）：分区可以看作是一个只进不出的队列（Kafka只保证一个分区内的消息是有序的），消息会往这个队列的尾部追加，每个消息进入分区后都会有一个偏移量，标识该消息在该分区中的位置，消费者要消费该消息就是通过偏移量来识别。</li>
</ul>
<p>其实，根据上述的几个概念，是不是也多少猜到了Kafka的多副本冗余设计实现了？别急，咱继续往下看。</p>
<p>在Kafka 0.8版本以前，是没有多副本冗余机制的，一旦一个节点挂掉，那么这个节点上的所有<code>Partition</code>的数据就无法再被消费。这就等于发送到Topic的有一部分数据丢失了。</p>
<p>在0.8版本后引入副本则很好地解决宕机后数据丢失的问题。副本是以<code>Topic</code>中每个<code>Partition</code>的数据为单位，每个Partition的数据会同步到其他物理节点上，形成多个副本。</p>
<p>每个<code>Partition</code>的副本都包括一个<code>Leader</code>副本和多个<code>Follower</code>副本，Leader由所有的副本共同选举得出，其他副本则都为Follower副本。在生产者写或者消费者读的时候，都只会与Leader打交道，在写入数据后Follower就会来拉取数据进行数据同步。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69aa10bb5786447ea5d716ef5bc015ab~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>就这么简单？是的，基于上面这张多副本架构图就实现了Kafka的高可用。当某个<code>Broker</code>挂掉了，甭担心，这个<code>Broker</code>上的<code>Partition</code>在其他<code>Broker</code>节点上还有副本。你说如果挂掉的是<code>Leader</code>怎么办？那就在<code>Follower</code>中在选举出一个<code>Leader</code>即可，生产者和消费者又可以和新的<code>Leader</code>愉快地玩耍了，这就是高可用。</p>
<p>你可能还有疑问，那要多少个副本才算够用？Follower和Leader之间没有完全同步怎么办？一个节点宕机后Leader的选举规则是什么？</p>
<p>直接抛结论:</p>
<p><strong>多少个副本才算够用？</strong> 副本肯定越多越能保证Kafka的高可用，但越多的副本意味着网络、磁盘资源的消耗更多，性能会有所下降，通常来说副本数为3即可保证高可用，极端情况下将<code>replication-factor</code>参数调大即可。</p>
<p><strong>Follower和Lead之间没有完全同步怎么办？</strong> Follower和Leader之间并不是完全同步，但也不是完全异步，而是采用一种<code>ISR</code>机制（<code>In-Sync Replica</code>）。每个Leader会动态维护一个ISR列表，该列表里存储的是和Leader基本同步的Follower。如果有Follower由于网络、GC等原因而没有向Leader发起拉取数据请求，此时Follower相对于Leader是不同步的，则会被踢出ISR列表。所以说，ISR列表中的Follower都是跟得上Leader的副本。</p>
<p><strong>一个节点宕机后Leader的选举规则是什么？</strong> 分布式相关的选举规则有很多，像Zookeeper的<code>Zab</code>、<code>Raft</code>、<code>Viewstamped Replication</code>、微软的<code>PacificA</code>等。而Kafka的Leader选举思路很简单，基于我们上述提到的<code>ISR</code>列表，当宕机后会从所有副本中顺序查找，如果查找到的副本在ISR列表中，则当选为Leader。另外还要保证前任Leader已经是退位状态了，否则会出现脑裂情况（有两个Leader）。怎么保证？Kafka通过设置了一个controller来保证只有一个Leader。</p>
<h1 id="Ack参数决定了可靠程度"><a href="#Ack参数决定了可靠程度" class="headerlink" title="Ack参数决定了可靠程度"></a>Ack参数决定了可靠程度</h1><p>另外，这里补充一个面试考Kafka高可用必备知识点：<code>request.required.acks</code>参数。</p>
<p>Acks这个参数是生产者客户端的重要配置，发送消息的时候就可设置这个参数。该参数有三个值可配置：<strong>0、1、All</strong>。</p>
<p><strong>第一种是设为0</strong>，意思是生产者把消息发送出去之后，之后这消息是死是活咱就不管了，有那么点发后即忘的意思，说出去的话就不负责了。不负责自然这消息就有可能丢失，那就把可用性也丢失了。</p>
<p><strong>第二种是设为1</strong>，意思是生产者把消息发送出去之后，这消息只要顺利传达给了Leader，其他Follower有没有同步就无所谓了。存在一种情况，Leader刚收到了消息，Follower还没来得及同步Broker就宕机了，但生产者已经认为消息发送成功了，那么此时消息就丢失了。注意，<strong>设为1是Kafka的默认配置</strong>！！！可见Kafka的默认配置也不是那么高可用，而是对高可用和高吞吐量做了权衡折中。</p>
<p><strong>第三种是设为All（或者-1）</strong>，意思是生产者把消息发送出去之后，不仅Leader要接收到，ISR列表中的Follower也要同步到，生产者才会任务消息发送成功。</p>
<p>进一步思考，<code>Acks=All</code>就不会出现丢失消息的情况吗？答案是否。当ISR列表只剩Leader的情况下，<code>Acks=All</code>相当于<code>Acks=1</code>，这种情况下如果节点宕机了，还能保证数据不丢失吗？因此只有在<code>Acks=All</code>并且有ISR中有两个副本的情况下才能保证数据不丢失。</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>绕了一大圈，了解了Kafka的高可用机制，终于回到我们一开始的问题本身，<code>Kafka</code>的一个节点宕机后为什么不可用？</p>
<p>我在开发测试环境配置的<code>Broker</code>节点数是3，<code>Topic</code>是副本数为3，<code>Partition</code>数为6，<code>Asks</code>参数为1。</p>
<p>当三个节点中某个节点宕机后，集群首先会怎么做？没错，正如我们上面所说的，集群发现有Partition的Leader失效了，这个时候就要从ISR列表中重新选举Leader。如果ISR列表为空是不是就不可用了？并不会，而是从Partition存活的副本中选择一个作为Leader，不过这就有潜在的数据丢失的隐患了。</p>
<p>所以，只要将Topic副本个数设置为和Broker个数一样，Kafka的多副本冗余设计是可以保证高可用的，不会出现一宕机就不可用的情况（不过需要注意的是Kafka有一个保护策略，当一半以上的节点不可用时Kafka就会停止）。那仔细一想，Kafka上是不是有副本个数为1的Topic？</p>
<p>问题出在了<code>__consumer_offset</code>上，<code>__consumer_offset</code>是一个Kafka自动创建的<code>Topic</code>，用来存储消费者消费的<code>offset</code>（偏移量）信息，默认<code>Partition</code>数为50。而就是这个Topic，它的默认副本数为1。如果所有的<code>Partition</code>都存在于同一台机器上，那就是很明显的单点故障了！当将存储<code>__consumer_offset</code>的Partition的Broker给Kill后，会发现所有的消费者都停止消费了。</p>
<p>这个问题怎么解决？</p>
<p><strong>第一点</strong>，需要将<code>__consumer_offset</code>删除，注意这个Topic时Kafka内置的Topic，无法用命令删除，我是通过将<code>logs</code>删了来实现删除。</p>
<p><strong>第二点</strong>，需要通过设置<code>offsets.topic.replication.factor</code>为3来将<code>__consumer_offset</code>的副本数改为3。</p>
<p>通过将<code>__consumer_offset</code>也做副本冗余后来解决某个节点宕机后消费者的消费问题。</p>
<p>最后，关于为什么<code>__consumer_offset</code>的Partition会出现只存储在一个Broker上而不是分布在各个Broker上感到困惑，如果有朋友了解的烦请指教~</p>
<blockquote>
<p>在 Kafka 0.11 之前，当 Kafka 自动创建__consumer_offset topic时，它会综合考虑当前运行的 Broker 台数和 Broker 端参数 offsets.topic.replication.factor 值，然后取两者的较小值作为该主题的副本数。 在 0.11 版本之后，社区修正了这个问题。Kafka 会严格遵守 offsets.topic.replication.factor 值。如果当前运行的 Broker 数量小于 offsets.topic.replication.factor 值，Kafka 会创建主题失败并显式抛出异常。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%88%A9%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%88%A9%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">分布式事务-利用消息队列实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-16 13:54:39" itemprop="dateCreated datePublished" datetime="2021-06-16T13:54:39+08:00">2021-06-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="消息队列中：消息可靠性、重复消息、消息积压、利用消息实现分布式事务"><a href="#消息队列中：消息可靠性、重复消息、消息积压、利用消息实现分布式事务" class="headerlink" title="消息队列中：消息可靠性、重复消息、消息积压、利用消息实现分布式事务"></a>消息队列中：消息可靠性、重复消息、消息积压、利用消息实现分布式事务</h2><h2 id="一、如何确保消息不丢失？"><a href="#一、如何确保消息不丢失？" class="headerlink" title="一、如何确保消息不丢失？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">一、如何确保消息不丢失？</a></h2><h3 id="1、检测消息丢失的方法"><a href="#1、检测消息丢失的方法" class="headerlink" title="1、检测消息丢失的方法"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">1、检测消息丢失的方法</a></h3><p>可以利用消息队列的有序性来验证是否有消息丢失。在Producer端给每个发出的消息附加一个连续递增的序号，然后在Consumer端来检查这个序号的连续性。如果没有消息丢失，Consumer收到消息的序号必然是连续递增的，如果检测到序号不连续，那就是丢消息了。还可以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因</p>
<p>大多数消息队列的 客户端都支持拦截器机制，可以利用这个拦截器机制，在Producer发送消息之前的拦截器中将序号注入到消息中，在Consumer收到消息的拦截器中检测序号的连续性</p>
<p>如果是在一个分布式系统中实现这个检测方法，有几个问题需要注意：</p>
<p>首先，像Kafka和RocketMQ这样的消息队列，是不保证Topic上的严格顺序的，只能保证分区上的消息是有序的，所以在发消息的时候必须指定分区，并且，在每个分区单独检测消息序号的连续性</p>
<p>如果系统中Producer是多实例的，由于并不好协调多个Producer之间的发送顺序，所以也需要每个Producer分别生成各自的消息序号，并且需要附加上Producer的标识，在Consumer端按照每个Producer分别来检测序号的连续性</p>
<p>Consumer实例的数量最好和分区数量一致，做到Consumer和分区一一对应，这样会比较方便地在Consumer内检测消息序号的连续性</p>
<h3 id="2、确保消息可靠传递"><a href="#2、确保消息可靠传递" class="headerlink" title="2、确保消息可靠传递"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">2、确保消息可靠传递</a></h3><p>一条消息从生产到消费完成这个过程，可以划分为三个阶段：<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhldRGTKuL7mOTr9F8POSo0rNfIsSlviaZSPWV6LibCwI6SzoA4OYIR8V7w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li>生产阶段：在这个阶段，从消息在Producer创建出来，经过网络传输发送到Broker端</li>
<li>存储阶段：在这个阶段，消息在Broker端存储，如果是集群，消息会在这个阶段被复制到其他的副本上</li>
<li>消费阶段：在这个阶段，Consumer从Broker上拉取消息，经过网络传输发送到Consumer上</li>
</ul>
<p>1）、生产阶段</p>
<p>在生产阶段，消息队列通过最常用的请求确认机制，来保证消息的可靠传递：当在代码中调用发送消息方法时，消息队列的客户端会把消息发送到Broker，Broker收到消息后，会给客户端返回一个确认响应，表明消息已经收到了。客户端收到响应后，完成了一次正常消息的发送</p>
<p>只要Producer收到了Broker的确认响应就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会以返回值或者异常的方式告知用户</p>
<p>在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失</p>
<p>以Kafka为例：</p>
<p>同步发送时，只要注意捕获异常即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    producer.send(record).get();</span><br><span class="line">    System.out.println(&quot;消息发送成功&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    System.out.println(&quot;消息发送失败&quot;);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步发送时，则需要在回调方法里进行检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">producer.send(record, new Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCompletion(RecordMetadata metadata, Exception exception) &#123;</span><br><span class="line">        if (metadata !&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;消息发送成功&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;消息发送失败&quot;);</span><br><span class="line">            System.out.println(exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">producer.send(record, (metadata, exception) -&gt; &#123;</span><br><span class="line">    if (metadata !&#x3D; null) &#123;</span><br><span class="line">        System.out.println(&quot;消息发送成功&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;消息发送失败&quot;);</span><br><span class="line">        System.out.println(exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2）、存储阶段</p>
<p>在存储阶段正常情况下，只要Broker在正常运行，就不会出现丢失消息的问题，但是如果Broker出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失消息的</p>
<p>如果对消息的可靠性要求非常高，可以通过配置Broker参数来避免因为宕机丢消息</p>
<p>对于单个节点的Broker，需要配置Broker参数，在收到消息后，将消息写入磁盘后再给Producer返回确认响应，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消息，恢复后还可以继续消费。例如，在RocketMQ中，需要将刷盘方式flushDiskType配置为SYNC_FLUSH同步刷盘</p>
<p>如果Broker是由多个节点组成的集群，需要将Broker集群配置成：至少将消息发送到2个以上的节点，再给客户端回复发送确认响应。这样当某个Broker宕机后，其他的Broker可以替代宕机的Broker，也不会发生消息丢失</p>
<p>3）、消费阶段</p>
<p>消费阶段采用和生产阶段类似的确认机制来保证消息的可靠传递，客户端从Broker拉取消息后，执行用户的消费业务逻辑，成功后，才会给Broker发送消费确认响应。如果Broker没有收到消费确认响应，下次拉消息的时候还会返回同一条消息，确认消息不会在网络传输过程中丢失，也不会因为客户端在执行消费逻辑中出错导致丢失</p>
<p>在编写消费代码时需要注意的是，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认</p>
<p>以SpringBoot整合RabbitMQ为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(bindings &#x3D; @QueueBinding(</span><br><span class="line">        value &#x3D; @Queue(value &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.queue.name&#125;&quot;,</span><br><span class="line">                durable &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.queue.durable&#125;&quot;),</span><br><span class="line">        exchange &#x3D; @Exchange(value &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.exchange.name&#125;&quot;,</span><br><span class="line">                durable &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.exchange.durable&#125;&quot;,</span><br><span class="line">                type &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.exchange.type&#125;&quot;,</span><br><span class="line">                ignoreDeclarationExceptions &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.exchange.ignoreDeclarationExceptions&#125;&quot;),</span><br><span class="line">        key &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.key&#125;&quot;</span><br><span class="line">))</span><br><span class="line">@RabbitHandler</span><br><span class="line">&#x2F;&#x2F;Order需要实现序列化接口</span><br><span class="line">public void onMessage(@Payload Order order, @Headers Map&lt;String, Object&gt; headers, Channel channel) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;处理业务逻辑</span><br><span class="line">    System.out.println(&quot;消费端:&quot; + order);</span><br><span class="line">    &#x2F;&#x2F;手工ACK</span><br><span class="line">    Long deliveryTag &#x3D; (Long) headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">    channel.basicAck(deliveryTag, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">3、小结</a></h3><ul>
<li>在生产阶段，需要捕获消息发送的错误，并重发消息</li>
<li>在存储阶段，可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个Broker宕机或者磁盘损坏而丢失</li>
<li>在消费阶段，需要在处理完全部消费业务逻辑之后，再发送消费确认</li>
</ul>
<h2 id="二、如何处理消费过程中的重复消息？"><a href="#二、如何处理消费过程中的重复消息？" class="headerlink" title="二、如何处理消费过程中的重复消息？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">二、如何处理消费过程中的重复消息？</a></h2><h3 id="1、消息重复的情况必然存在"><a href="#1、消息重复的情况必然存在" class="headerlink" title="1、消息重复的情况必然存在"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">1、消息重复的情况必然存在</a></h3><p>在MQTT协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：</p>
<ul>
<li>At most once：至多一次。消息在传递时，最多会被送达一次。也就是说，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失</li>
<li>At least once：至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现</li>
<li>Exactly once：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级</li>
</ul>
<p>这个服务质量标准不仅适用于MQTT，对所有的消息队列都是适用的。现在常用的绝大部分消息队列提供的服务质量都是At least once，包括RocketMQ、RabbitMQ和Kafka都是这样。也就是说，消息队列很难保证消息不重复</p>
<h3 id="2、用幂等性解决重复消息问题"><a href="#2、用幂等性解决重复消息问题" class="headerlink" title="2、用幂等性解决重复消息问题"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">2、用幂等性解决重复消息问题</a></h3><p>一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备幂等性</p>
<p>一个幂等操作的特点是，其任意多次执行所产生的影响均与一次执行的影响相同。一个幂等的方法使用同样的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的。所以，对于幂等的方法，不用担心重复执行会对系统造成任何改变</p>
<p>从对系统的影响结果来说：At least once+幂等消费=Exactly once</p>
<p>几种常用的设计幂等操作的方法：</p>
<p>1）、利用数据库的唯一约束实现幂等</p>
<p>举个例子：将账户X的余额加100元。可以通过改造业务逻辑，让它具备幂等性</p>
<p>首先，可以限定对于每个转账单每个账户只可以执行一次变更操作，最简单的是在数据库建一张转账流水表，这个表有三个字段：转账单ID、账户ID和变更金额，然后给转账单ID和账户ID这两个字段联合起来创建一个唯一约束，这样对于相同的转账单ID和账户ID，表里至多只能存在一条记录</p>
<p>这样，消费消息的逻辑可以变为：在转账流水表中增加一条转账记录，然后再根据转账记录，异步操作更新用户余额即可。在转账流水表增加一条转账记录这个操作中，由于在这个表中预先定义了账户ID转账单ID的唯一索引，对于同一个转账单同一个账户只能插入一条记录，后续重复的插入操作都会失败，这样就实现了一个幂等的操作</p>
<p>只要是支持类似INSERT IF NOT EXIST语义的存储类系统都可以用于实现幂等，比如，可以用Redis的SETNX命令来替代数据库中的唯一约束，来实现幂等消费</p>
<p>2）、为更新的数据设置前置条件</p>
<p>另外一种实现幂等的思路是，给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据。这样，重复执行这个操作时，由于第一次更新数据的时候已经变更了前置条件中需要判断的数据，不满足前置条件，则不会重复执行更新数据操作</p>
<p>比如，将账户X的余额增加100元这个操作并不满足幂等性，可以把这个操作加上一个前置条件，变为：如果账户X当前的月为500元，将余额加100元，这个操作就具备了幂等性。对应到消息队列中的使用时，可以在发消息时在消息体中带上当前的余额，在消费的时候判断数据库中当前余额是否与消息中的余额相等，只有相等才执行变更操作</p>
<p>更加通用的方法是，给数据增加一个版本号属性，每次更新数据前，比较当前数据的版本号是否和消息中的版本号一直，如果不一致就拒绝更新数据，更新数据的同时将版本号+1，一样可以实现幂等更新</p>
<p>3）、记录并检查操作</p>
<p>还有一种通用性最强的实现幂等性方法：记录并检查操作，也称为Token机制或者GUID（全局唯一ID）机制，实现思路：在执行数据更新操作之前，先检查一下是否执行过这个更新操作</p>
<p>具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的ID，消费时，先根据这个ID检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费</p>
<p>但在分布式系统中，这个方法非常难以实现。首先，给每个消息指定一个全局唯一的ID就是一件不那么简单的事情，方法有很多，但都不太好同时满足简单、高可用和高性能，或多或少都要有些牺牲。更加麻烦的是，检查消费状态，然后更新数据并且设置消费状态这三个操作必须作为一组操作保证原子性，才能真正实现幂等，否则就会出现Bug</p>
<h2 id="三、消息积压了该如何处理？"><a href="#三、消息积压了该如何处理？" class="headerlink" title="三、消息积压了该如何处理？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">三、消息积压了该如何处理？</a></h2><p>消息积压的直接原因一定是系统中的某个部分出现了性能问题，来不及处理上游发送的消息，才会导致消息积压</p>
<h3 id="1、优化性能来避免消息积压"><a href="#1、优化性能来避免消息积压" class="headerlink" title="1、优化性能来避免消息积压"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">1、优化性能来避免消息积压</a></h3><p>1）、发送端性能优化</p>
<p>对于发送消息的业务逻辑，只需要设置合适的并发和批量大小，就可以达到很多的发送性能</p>
<p>Producer发送消息的过程包括：Producer发送消息给Broker，Broker收到消息返回确认响应。假设这一次交互的平均时延是1ms，这1ms包括了下面这些步骤的耗时：</p>
<ul>
<li>发送端准备数据、序列化消息、构造请求等逻辑的时间，也就是发送端在网络请求之前的耗时</li>
<li>发送消息和返回响应在网络传输中的耗时</li>
<li>Broker处理消息的时延</li>
</ul>
<p>如果是单线程发送，每次只发送1条消息，那么每秒只能发送1000ms/1ms*1条/ms=1000条消息。无论是增加每次发送消息的批量大小，还是增加并发都能成倍地提升发送性能</p>
<p>比如说，消息发送端主要接收RPC请求处理在线业务，因为所有RPC框架都是多线程支持多并发的，自然就实现了并行发送消息。并且在线业务比较在意的是请求响应时延，选择批量发送会影响RPC服务的时延</p>
<p>如果是一个离线系统，它在性能上更注重整个系统的吞吐量，发送端的数据都是来自于数据库，这种情况就更适合批量发送。可以批量从数据库读取数据，然后批量来发送消息，同样用少量的并发就可以获得非常高的吞吐量</p>
<p>2）、消费端性能优化</p>
<p>使用消息队列的时候，大部分的性能问题都出现在消费端，如果消费的速度跟不上发送生产消息的速度，就会造成消息积压。如果这种性能倒挂的问题只是暂时的，只要消费单的性能恢复之后，超过发送端的性能，那积压的消息是可以逐渐被消化掉的</p>
<p>要是消费速度一直比生产速度慢，时间长了，整个系统就会出现问题，要么，消息队列的存储被填满无法提供服务，要么消息丢失，这对于整个系统来说都是严重故障</p>
<p>在设计系统的时候，一定要保证消费端的消费性能要高于生产端的发送性能</p>
<p>消费端的性能优化除了优化消费业务逻辑之外，也可以通过水平扩容，增加消费端的并发数来提升总体的消费性能。在扩容Consumer的实例数量的同时，必须同步扩容主题中的分区数量，确保Consumer的实例数和分区数量是相等的。如果Consumer的实例数量超过分区数量，这样的扩容是无效的</p>
<h3 id="2、消息积压了该如何处理？"><a href="#2、消息积压了该如何处理？" class="headerlink" title="2、消息积压了该如何处理？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">2、消息积压了该如何处理？</a></h3><p>还有一种消息积压的情况是，日常系统正常运转的时候，没有积压或者只有少量积压很快就消费掉了，但是某一时刻，突然就开始积压消息并且积压持续上涨。这种情况下需要在短时间内找到消息积压的原因，迅速解决问题</p>
<p>能导致积压突然增加，最粗粒度的原因，只有两种：要么是发送变快了，要么是消费变慢了</p>
<p>大部分消息队列都内置了监控的功能，只要通过监控数据，很容易确定是哪种原因。如果是单位事件发送的消息增多，比如说是赶上大促或者抢购，短时间内不太可能优化消费端的代码来提升消费性能，唯一的方法是通过扩容消费端的实例来提升总体的消费能力</p>
<p>如果短时间内没有足够的服务器资源进行扩容，没办法的办法是将系统降级，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务</p>
<p>还有一种不太常见的情况，通过监控发现，无论是发送消息的速度还是消费消息的速度和原来都没什么变化，这时候需要检查一下消费端是不是消费失败导致的一条消息发福消费这种情况比较多，这种情况也会拖垮整个系统的消费速度</p>
<h2 id="四、如何利用事务消息实现分布式事务？"><a href="#四、如何利用事务消息实现分布式事务？" class="headerlink" title="四、如何利用事务消息实现分布式事务？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">四、如何利用事务消息实现分布式事务？</a></h2><p>消息队列中的事务主要解决的是消息生产者和消息消费者的数据一致性问题</p>
<p>拿电商来举个例子，一般来说，用户在电商APP上购物时，先把商品加到购物车里，然后几件商品一起下单，最后支付，完成购物流程，就可以等待收货了。这个过程中有一个需要用到消息队列的步骤，订单系统创建订单后，发消息给购物车系统，将已下单的商品从购物车中删除。因为从购物车删除已下单商品这个步骤，并不是用户下单支付这个主要流程中必需的步骤，使用消息队里来异步清理购物车是更加合理的设计<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlGMbnCeRktibY94szIPr8E6nUjqeQKMxKgPPS0161jyokCYOfB7YyIhQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">对于订单系统来说，它创建订单的过程中实际上执行了2个步骤的操作：</p>
<ul>
<li>在订单库中插入一条订单数据，创建订单</li>
<li>发消息给消息队列，消息的内容就是刚刚创建的订单</li>
</ul>
<p>购物车系统订阅相应的主题，接收订单创建的消息，然后清理购物车，在购物车中删除订单中的商品</p>
<p>问题的关键点集中在订单系统，创建订单和发送消息这两个步骤要么都操作成功，要么都操作失败，不允许一个成功而另一个失败的情况出现</p>
<h3 id="1、什么是分布式事务？"><a href="#1、什么是分布式事务？" class="headerlink" title="1、什么是分布式事务？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">1、什么是分布式事务？</a></h3><p>事务的4个特性（ACID）：</p>
<ul>
<li>原子性：指一个事务操作不可分割，要么成功，要么失败，不能有一半成功一半失败的情况</li>
<li>一致性：指这些数据在事务执行完成这个时间点之前，读到的一定是更新前的数据，之后读到的一定是更新后的数据，不应该存在一个时刻，让用户读到更新过程中的数据</li>
<li>隔离性：指一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对正在进行的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</li>
<li>持久性：指一个事务一旦完成提交，后续的其他操作和故障都不会对事务的结果产生任何影响</li>
</ul>
<p>事务消息适用的场景主要是那些需要异步更新数据，并且对数据实时性要求不太高的场景。比如订单系统的例子，在创建订单后，如果出现短暂的几秒，购物车里的商品没有及时情况，也不是完全不可接受的，只要最终购物车的数据和订单数据保持一致就可以了</p>
<h3 id="2、消息队列是如何实现分布式事务的？"><a href="#2、消息队列是如何实现分布式事务的？" class="headerlink" title="2、消息队列是如何实现分布式事务的？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">2、消息队列是如何实现分布式事务的？</a></h3><p>回到订单和购物车这个例子，来看下如何用消息队列来实现分布式事务<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlV5BRd0XsIByhpibicozM73wK0ja32LPdjaQTQicM1gdNiadojWpL7sYxgQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">首先，订单系统在消息队列上开启了一个事务。然后订单系统给消息服务器发送一个半消息，这个半消息包含的内容是完整的消息内容，和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的</p>
<p>半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。然后根据本地事务的执行结果决定提交或者回滚事务消息。如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。这样就基本实现了要么都成功，要么都失败的一致性要求</p>
<p>如果在第四步提交事务消息时失败了，Kafka会直接抛出异常，让用户自行处理，可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿</p>
<h3 id="3、RocketMQ中的分布式事务实现"><a href="#3、RocketMQ中的分布式事务实现" class="headerlink" title="3、RocketMQ中的分布式事务实现"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">3、RocketMQ中的分布式事务实现</a></h3><p>在RocketMQ中的事务实现中，增加了事务反查的机制来解决事务消息提交失败的问题。如果Producer也就是订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ的Broker没有收到提交或者回滚的请求，Broker会定期去Producer上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务</p>
<p>为了支撑这个事务反查机制，业务代码中需要实现一个反查本地事务状态的接口，告知RocketMQ本地事务是成功还是失败</p>
<p>在订单系统的例子中，反查本地事务的逻辑只要根据消息中的订单ID，在订单库中查询这个订单是否存在即可，如果订单存在则返回成功，否则返回失败。RocketMQ会自动根据事务反查的结果提交或者回滚事务消息</p>
<p>这个反查本地事务的实现，并不依赖消息的发送方，也就是订单服务的某个实例节点上的任何数据。这种情况下，即使是发送事务消息的那个订单服务节点宕机了，RocketMQ依然可以通过其他订单服务的节点来执行反查，确保事务的完整性</p>
<p>使用RocketMQ事务消息功能实现分布式事务的流程如下图：<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlTamIm2YNibZSckOAQXA2vs1TpUU2U0mZzicFs6FExqdiaZVrUFwIKIasQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/15/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E8%B0%83%E7%94%A8-01-%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/15/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E8%B0%83%E7%94%A8-01-%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">服务之间调用总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-15 13:50:34" itemprop="dateCreated datePublished" datetime="2021-06-15T13:50:34+08:00">2021-06-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在微服务架构中，需要调用很多服务才能完成一项功能。服务之间如何互相调用就变成微服务架构中的一个关键问题。</p>
<p>服务调用有3种方式，</p>
<ul>
<li>RPC方式</li>
<li>事件驱动（Event-driven）方式，也就是发消息方式。</li>
<li>Http方式(SpringCloud OpenFeign)</li>
</ul>
<p>消息方式是松耦合方式，比紧耦合的RPC方式要优越，但RPC方式如果用在适合的场景也有它的一席之地。</p>
<p><strong>耦合的种类：</strong></p>
<p><strong>时间耦合：</strong> 客户端和服务端必须同时上线才能工作。发消息时，接受消息队列必须运行，但后台处理程序暂时不工作也不影响。</p>
<p><strong>容量耦合：</strong> 客户端和服务端的处理容量必须匹配。发消息时，如果后台处理能力不足也不要紧，消息队列会起到缓冲的作用。 注意：如果你对回复有时间要求，那么消息队列的缓冲功能作用不大，因为你希望及时响应。</p>
<p><strong>接口耦合：</strong> RPC调用有函数标签，而消息队列只是一个消息。例如买了商品之后要调用发货服务，如果是发消息，那么就只需发送一个商品被买消息。</p>
<p><strong>发送方式耦合：</strong> RPC是点对点方式，需要知道对方是谁，它的好处是能够传回返回值。消息既可以点对点，也可以用广播的方式，这样减少了耦合，但也使返回值比较困难。</p>
<h2 id="事件驱动（Event-Driven）方式"><a href="#事件驱动（Event-Driven）方式" class="headerlink" title="事件驱动（Event-Driven）方式"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">事件驱动（Event-Driven）方式</a></h2><p>Martin Fowler把事件驱动分成四种方式(What do you mean by “Event-Driven”)，简化之后本质上只有两种方式。一种就是我们熟悉的的事件通知（Event Notification），另一种是事件溯源（Event Sourcing）。</p>
<p>事件通知就是微服务之间不直接调用，而是通过发消息来进行合作。事件溯源有点像记账，它把所有的事件都记录下来，作为永久存储层，再在它的基础之上构建应用程序。</p>
<p>实际上从应用的角度来讲，它们并不应该分属一类，它们的用途完全不同。事件通知是微服务的调用（或集成）方式，应该和RPC分在一起。事件溯源是一种存储数据的方式，应该和数据库分在一起。</p>
<h3 id="事件通知（Event-Notification）方式"><a href="#事件通知（Event-Notification）方式" class="headerlink" title="事件通知（Event Notification）方式"></a><strong>事件通知（Event Notification）方式</strong></h3><p>让我们用具体的例子来看一下。在下面的例子中，有三个微服务，“Order Service”， “Customer Service” 和“Product Service”。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfd3uYXPKFZy3BT9ibWibmuialR5VwmUsvk0hCc0bCb8CapcqHZI82evhibPNYRmice2325OicgD8jKN11wg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>先说读数据，假设要创建一个“Order”，在这个过程中需要读取“Customer”的数据和“Product”数据。</p>
<p>如果用事件通知的方式就只能在“Order Service”本地也创建只读“Customer”和“Product”表，并把数据用消息的方式同步过来。</p>
<p>再说写数据，如果在创建一个“Order”时需要创建一个新的“Customer”或要修改“Customer”的信息，那么可以在界面上跳转到用户创建页面，然后在“Customer Service”创建用户之后再发”用户已创建“的消息，“Order Service”接到消息，更新本地“Customer”表。</p>
<p>这并不是一个很好的使用事件驱动的例子，因为事件驱动的优点就是不同的程序之间可以独立运行，没有绑定关系。但现在“Order Service”需要等待“Customer Service”创建完了之后才能继续运行，来完成整个创建“Order”的工作。主要是因为“Order”和“Customer”本身从逻辑上来讲就是紧耦合关系，没有“Customer”你是不能创建“Order”的。</p>
<p>在这种紧耦合的情况下，也可以使用RPC。你可以建立一个更高层级的管理程序来管理这些微服务之间的调用，这样“Order Service”就不必直接调用“Customer Service”了。</p>
<p>当然它从本质上来讲并没有解除耦合，只是把耦合转移到了上一层，但至少现在“order Service”和“Customer Service”可以互不影响了。之所以不能根除这种紧耦合关系是因为它们在业务上是紧耦合的。</p>
<p>再举一个购物的例子。用户选好商品之后进行“Checkout”，生成“Order”，然后需要“payment”，再从“Inventory”取货，最后由“Shipment”发货，它们每一个都是微服务。这个例子用RPC方式和事件通知方式都可以完成。</p>
<p>当用RPC方式时，由“Order”服务调用其他几个服务来完成整个功能。用事件通知方式时，“Checkout”服务完成之后发送“Order Placed”消息，“Payment”服务收到消息，接收用户付款，发送“Payment received”消息。</p>
<p>“Inventory”服务收到消息，从仓库里取货，并发送“Goods fetched”消息。“Shipment”服务得到消息，发送货物，并发送“Goods shipped”消息。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfd3uYXPKFZy3BT9ibWibmuialRsl4FibdCJ4l7RM2Vq2ibGd21x4XkaeIVgfJZEhY7L0FLX4fWjX2XricZA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>对这个例子来讲，使用事件驱动是一个不错的选择，因为每个服务发消息之后它不需要任何反馈，这个消息由下一个模块接收来完成下一步动作，时间上的要求也比上一个要宽松。用事件驱动的好处是降低了耦合度，坏处是你现在不能在程序里找到整个购物过程的步骤。</p>
<p>如果一个业务逻辑有它自己相对固定的流程和步骤，那么使用RPC或业务流程管理（BPM）能够更方便地管理这些流程。在这种情况下选哪种方案呢？在我看来好处和坏处是大致相当的。从技术上来讲要选事件驱动，从业务上来讲要选RPC。不过现在越来越多的人采用事件通知作为微服务的集成方式，它似乎已经成了微服务之间的标椎调用方式。</p>
<h3 id="事件溯源-Event-Sourcing"><a href="#事件溯源-Event-Sourcing" class="headerlink" title="事件溯源(Event Sourcing)"></a>事件溯源(Event Sourcing)</h3><p>这是一种具有颠覆性质的的设计，它把系统中所有的数据都以事件（Event）的方式记录下来，它的持久存储叫Event Store， 一般是建立在数据库或消息队列（例如Kafka）基础之上，并提供了对事件进行操作的接口，例如事件的读写和查询。事件溯源是由领域驱动设计(Domain-Driven Design)提出来的。</p>
<p>DDD中有一个很重要的概念，有界上下文（Bounded Context），可以用有界上下文来划分微服务，每个有界上下文都可以是一个微服务。下面是有界上下文的示例。下图中有两个服务“Sales”和“Support”。</p>
<p>有界上下文的一个关键是如何处理共享成员， 在图中是“Customer”和“Product”。在不同的有界上下文中，共享成员的含义、用法以及他们的对象属性都会有些不同，DDD建议这些共享成员在各自的有界上下文中都分别建自己的类（包括数据库表），而不是共享。可以通过数据同步的手段来保持数据的一致性。下面还会详细讲解。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfd3uYXPKFZy3BT9ibWibmuialR5CEKPCIOx0ibPF48IGvl5ZxjtxiancCggZQD0fFcof3o812Odv7Aeekg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>事件溯源是微服务的一种存储方式，它是微服务的内部实现细节。因此你可以决定哪些微服务采用事件溯源方式，哪些不采用，而不必所有的服务都变成事件溯源的。通常整个应用程序只有一个Event Store， 不同的微服务都通过向Event Store发送和接受消息而互相通信。</p>
<p>Event Store内部可以分成不同的stream（相当于消息队列中的Topic）， 供不同的微服务中的领域实体（Domain Entity）使用。</p>
<p>事件溯源的一个短板是数据查询，它有两种方式来解决。</p>
<ul>
<li><p>直接对stream进行查询，这只适合stream比较小并且查询比较简单的情况。</p>
</li>
<li><p>查询复杂的话，那就是建立一个只读数据库，把需要的数据放在库中进行查询。数据库中的数据通过监听Event Store中相关的事件来更新。</p>
</li>
</ul>
<p>数据库存储方式只能保存当前状态，而事件溯源则存储了所有的历史状态，因而能根据需要回放到历史上任何一点的状态，具有很大优势。但它也不是一点问题都没有。</p>
<p>第一，它的程序比较复杂，因为事件是一等公民，你必须把业务逻辑按照事件的方式整理出来，然后用事件来驱动程序。第二，如果你要想修改事件或事件的格式就比较麻烦，因为旧的事件已经存储在Event Store里了（事件就像日志，是只读的），没有办法再改。</p>
<p>由于事件溯源和事件通知表面上看起来很像，不少人都搞不清楚它们的区别。事件通知只是微服务的集成方式，程序内部是不使用事件溯源的，内部实现仍然是传统的数据库方式。</p>
<p>只有当要与其他微服务集成时才会发消息。而在事件溯源中，事件是一等公民，可以不要数据库，全部数据都是按照事件的方式存储的。</p>
<p>虽然事件溯源的践行者有不同的意见，但有不少人都认为事件溯源不是微服务的集成方式，而是微服务的一种内部实现方式。因此，在一个系统中，可以某些微服务用事件溯源，另外一些微服务用数据库。</p>
<p>当你要集成这些微服务时，你可以用事件通知的方式。注意现在有两种不同的事件需要区分开，一种是微服务的内部事件，是颗粒度比较细的，这种事件只发送到这个微服务的stream中，只被事件溯源使用。</p>
<p>另一种是其他微服务也关心的，是颗粒度比较粗的，这种事件会放到另外一个或几个stream中，被多个微服务使用，是用来做服务之间集成的。这样做的好处是限制了事件的作用范围，减少了不相关事件对程序的干扰。详见”Domain Events vs. Event Sourcing”。</p>
<p>有意思的是Kafka一直在推动它作为事件驱动的工具，也取得了很大的成功。但它却没有得到事件溯源圈内的认可。</p>
<p>多数事件溯源都使用一个叫evenstore的开源Event Store，或是基于某个数据库的Event Store，只有比较少的人用Kafka做Event Store。</p>
<p>但如果用Kafka实现事件通知就一点问题都没有。总的来说，对大多数公司来讲事件溯源是有一定挑战的，应用时需要找到合适的场景。如果你要尝试的话，可以先拿一个微服务试水。</p>
<p>事件溯源以前的适用场景只限于记账和源代码库，局限性较大。区块链可能会成为它的下一个机遇，因为它用的也是事件溯源技术。</p>
<h2 id="RPC方式"><a href="#RPC方式" class="headerlink" title="RPC方式"></a>RPC方式</h2><p>RPC的方式就是远程函数调用，像RESTFul，gRPC, DUBBO 都是这种方式。它一般是同步的，可以马上得到结果。在实际中，大多数应用都要求立刻得到结果，这时同步方式更有优势，代码也更简单。</p>
<h2 id="服务网关（API-Gateway）"><a href="#服务网关（API-Gateway）" class="headerlink" title="服务网关（API Gateway）"></a>服务网关（API Gateway）</h2><p>熟悉微服务的人可能都知道服务网关（API Gateway）。当UI需要调用很多微服务时，它需要了解每个服务的接口，这个工作量很大。</p>
<p>于是就用服务网关创建了一个Facade，把几个微服务封装起来，这样UI就只调用服务网关就可以了，不需要去对付每一个微服务。</p>
<p>服务网关（API Gateway）不是为了解决微服务之间调用的紧耦合问题，它主要是为了简化客户端的工作。其实它还可以用来降低函数之间的耦合度。</p>
<p>有了API Gateway之后，一旦服务接口修改，你可能只需要修改API Gateway， 而不必修改每个调用这个函数的客户端，这样就减少了程序的耦合性。</p>
<h2 id="降低紧耦合的影响"><a href="#降低紧耦合的影响" class="headerlink" title="降低紧耦合的影响"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">降低紧耦合的影响</a></h2><p>什么是紧耦合的主要问题呢？就是客户端和服务端的升级不同步。服务端总是先升级，客户端可能有很多，如果要求它们同时升级是不现实的。它们有各自的部署时间表，一般都会选择在下一次部署时顺带升级。</p>
<p>一般有两个办法可以解决这个问题：</p>
<ul>
<li><p>同时支持多个版本：这个工作量比较大，因此大多数公司都不会采用这种方式。</p>
</li>
<li><p>服务端向后兼容：这是更通用的方式。例如你要加一个新功能或有些客户要求给原来的函数增加一个新的参数，但别的客户不需要这个参数。这时你只好新建一个函数，跟原来的功能差不多，只是多了一个参数。这样新旧客户的需求都能满足。它的好处是向后兼容（当然这取决于你使用的协议）。</p>
<ul>
<li>它的坏处是当以后新的客户来了，看到两个差不多的函数就糊涂了，不知道该用那个。而且时间越长越严重，你的服务端可能功能增加的不多，但相似的函数却越来越多，无法选择。</li>
<li>它的解决办法就是使用一个支持向后兼容的RPC协议，现在最好的就是Protobuf gRPC，尤其是在向后兼容上。它给每个服务定义了一个接口，这个接口是与编程语言无关的中性接口，然后你可以用工具生成各个语言的实现代码，供不同语言使用。函数定义的变量都有编号，变量可以是可选类型的，这样就比较好地解决了函数兼容的问题。</li>
<li>就用上面的例子，当你要增加一个可选参数时，你就定义一个新的可选变量。由于它是可选的，原来的客户端不需要提供这个参数，因此不需要修改程序。而新的客户端可以提供这个参数。你只要在服务端能同时处理这两种情况就行了。这样服务端并没有增加新的函数，但用户的新需求满足了，而且还是向后兼容的。</li>
</ul>
</li>
</ul>
<h2 id="内部微服务设计"><a href="#内部微服务设计" class="headerlink" title="内部微服务设计"></a>内部微服务设计</h2><p>这种设计表面上看起来是一个单体程序，它只有一个源代码存储仓库，一个数据库，一个部署，但在程序内部可以按照微服务的思想来进行设计。它可以分成多个模块，每个模块是一个微服务，可以由不同的团队管理。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfd3uYXPKFZy3BT9ibWibmuialRYFLJ2giafSicsmOicu3HMnB8OEFjK7ZsGn5upx5H68rhjTZYSTHiaR3QmA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>用这张图做例子。这个图里的每个圆角方块大致是一个微服务，但我们可以把它作为一个单体程序来设计，内部有五个微服务。</p>
<p>每个模块都有自己的数据库表，它们都在一个数据库中，但模块之间不能跨数据库访问（不要建立模块之间数据库表的外键）。</p>
<p>“User”（在Conference Management模块中）是一个共享的类，但在不同的模块中的名字不同，含义和用法也不同，成员也不一样（例如，在“Customer Service”里叫“Customer”）。</p>
<p>DDD（Domain-Driven Design）建议不要共享这个类，而是在每一个有界上下文（模块）中都建一个新类，并拥有新的名字。</p>
<p>虽然它们的数据库中的数据应该大致相同，但DDD建议每一个有界上下文中都建一个新表，它们之间再进行数据同步。</p>
<p>这个所谓的“内部微服务设计”其实就是DDD，但当时还没有微服务，因此外表看起来是单体程序，但内部已经是微服务的设计了。</p>
<p>它的书在2003就出版了，当时就很有名。但它更偏重于业务逻辑的设计，践行起来也比较困难，因此大家谈论得很多，真正用的较少。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">结论</a></h2><p>微服务之间的调用有两种方式，RPC和事件驱动。事件驱动是更好的方式，因为它是松耦合的。但如果业务逻辑是紧耦合的，RPC方式也是可行的（它的好处是代码更简单），而且你还可以通过选取合适的协议（Protobuf gRPC）来降低这种紧耦合带来的危害。</p>
<p>由于事件溯源和事件通知的相似性，很多人把两者弄混了，但它们实际上是完全不同的东西。微服务的数量不宜太多，可以先创建比较大的微服务（更像是服务组合）。</p>
<p>如果你还是不能确定是否采用微服务架构，可以先从“内部微服务设计”开始，再逐渐拆分。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/15/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E8%B0%83%E7%94%A8-02-%E6%9C%8D%E5%8A%A1%E6%BC%94%E8%BF%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/15/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E8%B0%83%E7%94%A8-02-%E6%9C%8D%E5%8A%A1%E6%BC%94%E8%BF%9B/" class="post-title-link" itemprop="url">服务之间调用总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-15 13:50:34" itemprop="dateCreated datePublished" datetime="2021-06-15T13:50:34+08:00">2021-06-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>微服务是否适合小团队是个见仁见智的问题。</p>
<p>回归现象看本质，随着业务复杂度的提高，单体应用越来越庞大，就好像一个类的代码行越来越多，分而治之，切成多个类应该是更好的解决方法，所以一个庞大的单体应用分出多个小应用也更符合这种分治的思想。</p>
<p>当然微服务架构不应该是一个小团队一开始就该考虑的问题，而是慢慢演化的结果，谨慎过度设计尤为重要。</p>
<p>公司的背景是提供SaaS服务，对于大客户也会有定制开发以及私有化部署。经过2年不到的时间，技术架构经历了从单体到微服务再到容器化的过程。</p>
<h2 id="单体应用时代"><a href="#单体应用时代" class="headerlink" title="单体应用时代"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">单体应用时代</a></h2><p>多说一句，前后端分离也不一定就不能服务端渲染，例如电商系统或者一些匿名即可访问的系统，加一层薄薄的View层，无论是php还是用Thymeleaf都是不错的选择。</p>
<p>部署架构上，我们使用Nginx代理前端HTML资源，在接收请求时根据路径反向代理到server的8080端口实现业务。</p>
<p>[<img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlbgkXa228IFz1iazDgxyjrw8tYt9oICv7IlMklYjzGLLNialwiaCTWWdkA/640" alt="Image" style="zoom:67%;" /></p>
<h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">接口定义</a></h3><p>接口按照标准的Restful来定义，</p>
<ul>
<li>版本，统一跟在 /api/后面，例如 <code>/api/v2</code></li>
<li>以资源为中心，使用复数表述，例如<code>/api/contacts</code>，也可以嵌套，如<code>/api/groups/1/contacts/100</code></li>
<li>url中尽量不使用动词，实践中发现做到这一点真的比较难，每个研发人员的思路不一致，起的名字也千奇百怪，都需要在代码Review中覆盖。</li>
<li>动作支持，<code>POST / PUT / DELELE / GET</code> ，这里有一个坑，PUT和PATCH都是更新，但是PUT是全量更新而PATCH是部分更新，前者如果传入的字段是空（未传也视为空）那么也会被更新到数据库中。目前我们虽然是使用PUT但是忽略空字段和未传字段，本质上是一种部分更新，这也带来了一些问题，比如确有置空的业务需要特殊处理。</li>
<li>接口通过swagger生成文档供前端同事使用。</li>
</ul>
<h3 id="持续集成-CI"><a href="#持续集成-CI" class="headerlink" title="持续集成(CI)"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">持续集成(CI)</a></h3><p>团队初始成员之前都有在大团队共事的经历，所以对于质量管控和流程管理都有一些共同的要求。因此在开发之初就引入了集成测试的体系，可以直接开发针对接口的测试用例，统一执行并计算覆盖率。</p>
<p>一般来说代码自动执行的都是单元测试(Unit Test)，我们之所以叫集成测试是因为测试用例是针对API的，并且包含了数据库的读写，MQ的操作等等，除了外部服务的依赖基本都是符合真实生产场景，相当于把Jmeter的事情直接在Java层面做掉了。</p>
<p>这在开发初期为我们提供了非常大的便利性。但值得注意的是，由于数据库以及其他资源的引入，数据准备以及数据清理时要考虑的问题就会更多，例如如何控制并行任务之间的测试数据互不影响等等。</p>
<p>为了让这一套流程可以自动化的运作起来， 引入Jenkins也是理所当然的事情了。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlOdhGfEsNbPPiaCAtBC4jjVjkz7yMu5T828ko9c6ESBfcQibmC0oEJ9ng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>开发人员提交代码进入gerrit中，Jenkins被触发开始编译代码并执行集成测试，完成后生成测试报告，测试通过再由reviewer进行代码review。在单体应用时代这样的CI架构已经足够好用，由于有集成测试的覆盖，在保持API兼容性的前提下进行代码重构都会变得更有信心。</p>
<h2 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">微服务时代</a></h2><h3 id="服务拆分原则"><a href="#服务拆分原则" class="headerlink" title="服务拆分原则"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">服务拆分原则</a></h3><p>从数据层面看，最简单的方式就是看数据库的表之间是否有比较少的关联。例如最容易分离的一般来说都是用户管理模块。如果从领域驱动设计（DDD）看，其实一个服务就是一个或几个相关联的领域模型，通过少量数据冗余划清服务边界。</p>
<p>服务拆分是一个大工程，往往需要几个对业务以及数据最熟悉的人一起讨论，甚至要考虑到团队结构，最终的效果是服务边界清晰， 没有环形依赖和避免双向依赖。</p>
<h3 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">框架选择</a></h3><p>由于之前的单体服务使用的是spring boot，所以框架自然而的选择了spring cloud。其实个人认为微服务框架不应该限制技术与语言，但生产实践中发现无论dubbo还是spring cloud都具有侵入性，我们在将nodejs应用融入spring cloud体系时就发现了许多问题。也许未来的service mesh才是更合理的发展道路。</p>
<p>这是典型的Spring Cloud的使用方法</p>
<ul>
<li>zuul作为gateway，分发不同客户端的请求到具体service</li>
<li>erueka作为注册中心，完成了服务发现和服务注册</li>
<li>每个service包括gateway都自带了Hystrix提供的限流和熔断功能</li>
<li>service之间通过feign和ribbon互相调用，feign实际上是屏蔽了service对erueka的操作</li>
</ul>
<p>上文说的一旦要融入异构语言的service，那么服务注册，服务发现，服务调用，熔断和限流都需要自己处理。</p>
<p>再有关于zuul要多说几句，Sprin Cloud提供的zuul对Netflix版本的做了裁剪，去掉了动态路由功能（Groovy实现），另外一点就是zuul的性能一般，由于采用同步编程模型，对于IO密集型等后台处理时间长的链路非常容易将servlet的线程池占满，所以如果将zuul与主要service放置在同一台物理机上，在流量大的情况下，zuul的资源消耗非常大。</p>
<p>实际测试也发现经过zuul与直接调用service的性能损失在30%左右，并发压力大时更为明显。现在spring cloud gateway是pivotal的主推了，支持异步编程模型，后续架构优化也许会采用，或是直接使用Kong这种基于nginx的网关来提供性能。当然同步模型也有优点，编码更简单，后文将会提到使用ThreadLocal如何建立链路跟踪。</p>
<h3 id="架构改造"><a href="#架构改造" class="headerlink" title="架构改造"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">架构改造</a></h3><p>经过大半年的改造以及新需求的加入，单体服务被不断拆分，最终形成了10余个微服务，并且搭建了Spark用于BI。初步形成两大体系，微服务架构的在线业务系统(OLTP) + Spark大数据分析系统(OLAP)。数据源从只有Mysql增加到了ES和Hive。多数据源之间的数据同步也是值得一说的话题，但内容太多不在此文赘述。</p>
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlZLks9nIVHdtGHq3jKAO2Mibp4KfNouFa9icqd47MqicicRhMEcmvH9ETbw/640" alt="Image" style="zoom:67%;" />

<h3 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h3><p>与CI比起来，持续交付（CD）实现更为复杂，在资源不足的情况我们尚未实现CD，只是实现执行了自动化部署。</p>
<p>由于生产环境需要通过跳板机操作，所以我们通过Jenkins生成jar包传输到跳板机，之后再通过Ansible部署到集群。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlOweGzDvlgNpjyY80roRKrwprlP19WLSrgcUWbZ3kOqLrYghRZlfMdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>简单粗暴的部署方式在小规模团队开发时还是够用的，只是需要在部署前保证测试（人工测试 + 自动化测试）到位。</p>
<h3 id="链路跟踪"><a href="#链路跟踪" class="headerlink" title="链路跟踪"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">链路跟踪</a></h3><p>开源的全链路跟踪很多，比如<code>spring cloud sleuth + zipkin</code>，国内有美团的CAT等等。其目的就是当一个请求经过多个服务时，可以通过一个固定值获取整条请求链路的行为日志，基于此可以再进行耗时分析等，衍生出一些性能诊断的功能。不过对于我们而言，首要目的就是trouble shooting，出了问题需要快速定位异常出现在什么服务，整个请求的链路是怎样的。</p>
<p>为了让解决方案轻量，我们在日志中打印RequestId以及TraceId来标记链路。RequestId在gateway生成表示唯一一次请求，TraceId相当于二级路径，一开始与RequestId一样，但进入线程池或者消息队列后，TraceId会增加标记来标识唯一条路径。</p>
<p>举个例子，当一次请求会向MQ发送一个消息，那么这个消息可能会被多个消费者消费，此时每个消费线程都会自己生成一个TraceId来标记消费链路。加入TraceId的目的就是为了避免只用RequestId过滤出太多日志。实现如图所示，</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlzAbXCTKK3mgB8tTUo6iarzNNrmAUErQv5rLTO2zondavooqv9XcOBiag/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>简单的说，通过ThreadLocal存放APIRequestContext串联单服务内的所有调用，当跨服务调用时，将APIRequestContext信息转化为Http Header，被调用方获取到Http Header后再次构建APIRequestContext放入ThreadLocal，重复循环保证RequestId和TraceId不丢失即可。如果进入MQ，那么APIRequestContext信息转化为Message Header即可（基于Rabbitmq实现）。</p>
<p>当日志汇总到日志系统后，如果出现问题，只需要捕获发生异常的RequestId或是TraceId即可进行问题定位</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlyvc2T2yiaUjDHk4ibibJweZrsHQZJhOWpObb9Q8TsE4JVUwBAvt7bRYYA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<h3 id="运维监控"><a href="#运维监控" class="headerlink" title="运维监控"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">运维监控</a></h3><p>在容器化之前，采用<code>telegraf + influxdb + grafana</code>的方案。telegraf作为探针收集jvm，system，mysql等资源的信息，写入influxdb，最终通过grafana做数据可视化。<code>spring boot actuator</code>可以配合jolokia暴露jvm的endpoint。整个方案零编码，只需要花时间配置。</p>
<h2 id="容器化时代"><a href="#容器化时代" class="headerlink" title="容器化时代"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">容器化时代</a></h2><h3 id="架构改造-1"><a href="#架构改造-1" class="headerlink" title="架构改造"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">架构改造</a></h3><p>因为在做微服务之初就计划了容器化，所以架构并未大动，只是每个服务都会建立一个Dockerfile用于创建docker image</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhliaibvn0lkdvGdRQ5dXiazh9VTmtIeoPO2f9ZVTHBCibFCymdwnkibEAfNCg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>涉及变化的部分包括：</p>
<ol>
<li>CI中多了构建docker image的步骤</li>
<li>自动化测试过程中将数据库升级从应用中剥离单独做成docker image</li>
<li>生产中用k8s自带的service替代了eruka</li>
</ol>
<p>理由下文一一道来。</p>
<h3 id="Spring-Cloud与k8s的融合"><a href="#Spring-Cloud与k8s的融合" class="headerlink" title="Spring Cloud与k8s的融合"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">Spring Cloud与k8s的融合</a></h3><p>我们使用的是Redhat的Openshift，可以认为是k8s企业版，其本身就有service的概念。一个service下有多个pod，pod内即是一个可服务单元。service之间互相调用时k8s会提供默认的负载均衡控制，发起调用方只需要写被调用方的serviceId即可。这一点和spring cloud fegin使用ribbon提供的功能如出一辙。</p>
<p>也就是说服务治理可以通过k8s来解决，那么为什么要替换呢？其实上文提到了，Spring Cloud技术栈对于异构语言的支持问题，我们有许多BFF（Backend for Frontend）是使用nodejs实现的，这些服务要想融合到Spring Cloud中，服务注册，负载均衡，心跳检查等等都要自己实现。</p>
<p>如果以后还有其他语言架构的服务加入进来，这些轮子又要重造。基于此类原因综合考量后，决定采用Openshift所提供的网络能力替换eruka。</p>
<p>由于本地开发和联调过程中依然依赖eruka，所以只在生产上通过配置参数来控制，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eureka.client.enabled&#96; 设置为 false，停止各服务的eureka注册</span><br><span class="line">&#96;ribbon.eureka.enabled&#96; 设置为 false，让ribbon不从eureka获取服务列表</span><br><span class="line">以服务foo为例，&#96;foo.ribbon.listofservers&#96; 设置为 &#96;http:&#x2F;&#x2F;foo:8080&#96;，那么当一个服务需要使用服务foo的时候，就会直接调用到&#96;http:&#x2F;&#x2F;foo:8080</span><br></pre></td></tr></table></figure>

<h3 id="CI的改造"><a href="#CI的改造" class="headerlink" title="CI的改造"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">CI的改造</a></h3><p>CI的改造主要是多了一部编译docker image并打包到Harbor的过程，部署时会直接从Harbor拉取镜像。另一个就是数据库的升级工具。之前我们使用flyway作为数据库升级工具，当应用启动时自动执行SQL脚本。</p>
<p>随着服务实例越来越多，一个服务的多个实例同时升级的情况也时有发生，虽然flyway是通过数据库锁实现了升级过程不会有并发，但会导致被锁服务启动时间变长的问题。</p>
<p>从实际升级过程来看，将可能发生的并发升级变为单一进程可能更靠谱。此外后期分库分表的架构也会使随应用启动自动升级数据库变的困难。综合考量，我们将升级任务做了拆分，每个服务都有自己的升级项目并会做容器化。</p>
<p>在使用时，作为run once的工具来使用，即docker run -rm的方式。并且后续也支持了设定目标版本的功能，在私有化项目的跨版本升级中起到了非常好的效果。</p>
<p>至于自动部署，由于服务之间存在上下游关系，例如config，eureka等属于基本服务被其他服务依赖，部署也产生了先后顺序。基于Jenkins做pipeline可以很好的解决这个问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/golang%E5%BC%80%E5%8F%91%E6%90%AD%E5%BB%BA-01-idea%E9%9B%86%E6%88%90go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/golang%E5%BC%80%E5%8F%91%E6%90%AD%E5%BB%BA-01-idea%E9%9B%86%E6%88%90go/" class="post-title-link" itemprop="url">golang的利弊</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-15 13:41:14" itemprop="dateCreated datePublished" datetime="2021-06-15T13:41:14+08:00">2021-06-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-13 11:02:50" itemprop="dateModified" datetime="2021-11-13T11:02:50+08:00">2021-11-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>推荐教程：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/notebook/notebook-9gko2sjj.html">https://www.w3cschool.cn/notebook/notebook-9gko2sjj.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jpfss/p/11760012.html">https://www.cnblogs.com/jpfss/p/11760012.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/golang%E7%9A%84%E5%88%A9%E5%BC%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/golang%E7%9A%84%E5%88%A9%E5%BC%8A/" class="post-title-link" itemprop="url">golang的利弊</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-15 13:41:14 / Modified: 13:44:58" itemprop="dateCreated datePublished" datetime="2021-06-15T13:41:14+08:00">2021-06-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Go语言的优势"><a href="#Go语言的优势" class="headerlink" title="Go语言的优势"></a>Go语言的优势</h2><p>选择Go语言的原因可能会有很多，关于Go语言的特性、优势等，我们在之前的文档中也已经介绍了很多了。但是最主要的原因，应该是基于以下两方面的考虑：</p>
<p><strong>执行性能</strong></p>
<p>缩短API的响应时长，解决批量请求访问超时的问题。在Uwork的业务场景下，一次API批量请求，往往会涉及对另外接口服务的多次调用，而在之前的PHP实现模式下，要做到并行调用是非常困难的，串行处理却不能从根本上提高处理性能。而GO语言不一样，通过协程可以方便的实现API的并行处理，达到处理效率的最大化。依赖Golang的高性能HTTP Server，提升系统吞吐能力，由PHP的数百级别提升到数千里甚至过万级别。</p>
<p><strong>开发效率</strong></p>
<p>GO语言使用起来简单、代码描述效率高、编码规范统一、上手快。通过少量的代码，即可实现框架的标准化，并以统一的规范快速构建API业务逻辑。能快速的构建各种通用组件和公共类库，进一步提升开发效率，实现特定场景下的功能量产。</p>
<h2 id="Go语言的业务场景"><a href="#Go语言的业务场景" class="headerlink" title="Go语言的业务场景"></a>Go语言的业务场景</h2><ul>
<li><p>服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。</p>
</li>
<li><p>分布式系统、数据库代理器、中间件等，例如Etcd。</p>
</li>
<li><p>网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用，而且Go内置的net/http包基本上把我们平常用到的网络功能都实现了。</p>
</li>
<li><p>云平台，目前国外很多云平台在采用Go开发</p>
</li>
</ul>
<h2 id="国内外有哪些企业或项目使用Go语言"><a href="#国内外有哪些企业或项目使用Go语言" class="headerlink" title="国内外有哪些企业或项目使用Go语言"></a>国内外有哪些企业或项目使用Go语言</h2><p>Go发布之后，很多公司特别是云计算公司开始用Go重构他们的基础架构，很多都是直接采用Go进行了开发</p>
<p>使用 Go 语言开发的开源项目非常多。早期的 Go 语言开源项目只是通过 Go 语言与传统项目进行C语言库绑定实现，例如 Qt、Sqlite 等；后期的很多项目都使用 Go 语言进行重新原生实现，这个过程相对于其他语言要简单一些，这也促成了大量使用 Go 语言原生开发项目的出现。</p>
<p><strong>云计算基础设施领域</strong> 代表项目：docker、kubernetes、etcd、consul、cloudflare CDN、七牛云存储等。</p>
<p><strong>基础软件</strong> 代表项目：tidb、influxdb、cockroachdb等。</p>
<p><strong>微服务</strong> 代表项目：go-kit、micro、monzo bank的typhon、bilibili等。</p>
<p><strong>Docker</strong> Docker 是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间进行隔离，也可以称之为容器。Docker 可以在一台物理服务器上快速运行一个或多个实例。基于lxc的一个虚拟打包工具，能够实现PAAS平台的组建。例如，启动一个 CentOS 操作系统，并在其内部命令行执行指令后结束，整个过程就像自己在操作系统一样高效。</p>
<p>项目链接：<a target="_blank" rel="noopener" href="https://github.com/docker/docker">https://github.com/docker/docker</a></p>
<p><strong>go语言</strong> Go 语言自己的早期源码使用C语言和汇编语言写成。从 Go 1.5 版本后，完全使用 Go 语言自身进行编写。Go 语言的源码对了解 Go 语言的底层调度有极大的参考意义，建议希望对 Go 语言有深入了解的读者读一读。</p>
<p>项目链接：<a target="_blank" rel="noopener" href="https://github.com/golang/go">https://github.com/golang/go</a></p>
<p><strong>Kubernetes</strong> Google 公司开发的构建于 Docker 之上的容器调度服务，用户可以通过 Kubernetes 集群进行云端容器集群管理。</p>
<p>项目链接：<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes">https://github.com/kubernetes/kubernetes</a></p>
<p><strong>etcd</strong> 一款分布式、可靠的 KV 存储系统，可以快速进行云配置。</p>
<p>项目链接：<a target="_blank" rel="noopener" href="https://github.com/coreos/etcd">https://github.com/coreos/etcd</a></p>
<p><strong>beego</strong> beego 是一个类似 Python的 Tornado 框架，采用了 RESTFul 的设计思路，使用 Go 语言编写的一个极轻量级、高可伸缩性和高性能的 Web 应用框架。</p>
<p>项目链接：<a target="_blank" rel="noopener" href="https://github.com/astaxie/beego">https://github.com/astaxie/beego</a></p>
<p><strong>martini</strong> 一款快速构建模块化的 Web 应用的 Web 框架。项目链接：<a target="_blank" rel="noopener" href="https://github.com/go-martini/martini">https://github.com/go-martini/martini</a></p>
<p><strong>codis</strong> 国产的优秀分布式 Redis 解决方案。项目链接：<a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis">https://github.com/CodisLabs/codis</a></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>当然，一个技术能不能发展起来，关键还要看三点。</p>
<p><strong>有没有一个比较好的社区。</strong> 像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更为人气爆棚了，比如 Linux 的社区。</p>
<p><strong>有没有一个工业化的标准。</strong> 像 C、C++、Java 都是有标准化组织的。尤其是 Java，其在架构上还搞出了像 J2EE 这样的企业级标准。</p>
<p><strong>有没有一个或多个杀手级应用。</strong> C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个好的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。</p>
<p>上述的这三点是非常关键的，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java，是三点全占到了，所以，Java 的发展是如此好。当然，除了上面这三点重要的，还有一些其它的影响因素，比如：</p>
<p><strong>学习曲线是否低，上手是否快。</strong> 这点非常重要，C++ 在这点上越做越不好了。<strong>有没有一个不错的提高开发效率的开发框架。</strong> 如：Java 的 Spring 框架，C++ 的 STL 等。<strong>是否有一个或多个巨型的技术公司作为后盾。</strong> 如：Java 和 Linux 后面的 IBM、Sun……<strong>有没有解决软件开发中的痛点。</strong> 如：Java 解决了 C 和 C++ 的内存管理问题。</p>
<p>用这些标尺来量一下 Go 语言，我们可以清楚地看到：</p>
<ul>
<li>Go 语言容易上手；</li>
<li>Go 语言解决了并发编程和写底层应用开发效率的痛点；</li>
<li>Go 语言有 Google 这个世界一流的技术公司在后面；</li>
<li>Go 语言的杀手级应用是 Docker，而 Docker 的生态圈在这几年完全爆棚了。</li>
</ul>
<p>所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食主要的项目应该是中间层的项目，既不是非常底层也不会是业务层。</p>
<p>也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到高层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。</p>
<p>好了，我们再用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。</p>
<ul>
<li>Docker 上手很容易。</li>
<li>Docker 解决了运维中的环境问题以及服务调度的痛点。</li>
<li>Docker 的生态圈中有大公司在后面助力。比如 Google。</li>
<li>Docker 产出了工业界标准 OCI。</li>
<li>Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。……</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
