<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/10/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/10/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/15/database/redis/redis%E5%AE%9E%E8%B7%B5-01-%E5%AE%9E%E7%8E%B0%E7%A7%AF%E5%88%86%E6%8E%92%E8%A1%8C%E6%A6%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/15/database/redis/redis%E5%AE%9E%E8%B7%B5-01-%E5%AE%9E%E7%8E%B0%E7%A7%AF%E5%88%86%E6%8E%92%E8%A1%8C%E6%A6%9C/" class="post-title-link" itemprop="url">redis实践-01-实现积分排行榜</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-15 08:22:22 / Modified: 08:48:36" itemprop="dateCreated datePublished" datetime="2021-06-15T08:22:22+08:00">2021-06-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ZSet数据结构就很适合用于实现排行榜，但如何实现相同积分情况下再支持按时间排序呢？</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><blockquote>
<p>分布式ID雪花算法的原理，即用一个long类型变量存储多个信息。一个long类型长度为8个字节（64bit），雪花算法使用其中41bit记录时间戳，其余bit位存储机房id、机器id、序列号。</p>
</blockquote>
<p>Redis的ZSet支持分值为double类型，也是8字节，那么我们也可以使用41位存储时间戳，其实位存储用户的实际积分。</p>
<blockquote>
<p>在雪花算法中最高位是不用的，目的是不允许生成负数ID</p>
</blockquote>
<p>而在实现排行榜中没有这个限制，因为我们最终要的只是用户的积分，而不是加上时间戳的分值。只不过ZSet已经支持倒序获取，最高位是0是1无所谓，所以最高位我们依然不使用。</p>
<p>除去最高位和存储时间戳的41位后，剩余22位表示积分，这时我们还需要结合业务考虑，如果觉得22bit不够表示积分，那么还可以继续压缩时间戳占用的bit。</p>
<p>由于排行榜是周期性的，如周榜、月榜，所以我们没必要存储完整的时间戳，可以取当前时间与周期开始时间相差的毫秒数，这样就可以将41bit压缩到32bit、16bit、或者更低</p>
<p>如果是用41bit表示时间戳，22bit表示积分的话，那么score的组成就是这样的：<br>0（最高位不用）<code>|</code>0000000 00000000 0000000（22bit表示积分）<code>|</code>0<br>00000000 00000000 00000000 00000000 00000000（41bit表示时间戳）</p>
<p>因为排序首先按积分排再按时间排，所以积分在高位，时间戳在低位。</p>
<p>在积分相同的情况下，是不是时间戳越大64bit表示的数值就越大？而我们需要的是按时间升序排，也就是最先达到xx积分的用户排在最前面，所以我们不能单纯的使用41bit存储时间戳，而应该是存储一个随时间流逝而变小的数值。</p>
<p>由于排行榜都会有一个周期，如周榜是一周，月榜是一个月，所以我们使用41bit存储的是一个周期的结束时间<code>yyy-MM-dd 23:59:59</code>对应的时间戳与用户积分更新时间的时间戳的差值，这个值会随着时间的推移而变小，而且不会出现负数的情况，刚好能够达到目的。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>1.实现积分+时间戳差值转score</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; periodEndTimestamp: 当前周期结束时间的时间戳 </span><br><span class="line">&#x2F;&#x2F; 需确保point不会超过22bit所能表示的数值：2097151</span><br><span class="line">private static long toScore(int point, long periodEndTimestamp) &#123;</span><br><span class="line">    long score &#x3D; 0L;</span><br><span class="line">    score &#x3D; (score | point) &lt;&lt; 41;</span><br><span class="line">    score &#x3D; score | (periodEndTimestamp - TimestampUtils.currentTimeMillis());</span><br><span class="line">    return score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.实现从score中获取积分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static int getPoint(long score) &#123;</span><br><span class="line">     return (int) (score &gt;&gt; 41);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.更新积分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void updateRanking(Integer periodId, Long accountId, Integer addPoint) &#123;</span><br><span class="line">    String key &#x3D; String.format(RankingCacheKeys.REALTIME_POINT_RANKING_KEY, periodId);</span><br><span class="line">    Double score &#x3D; redisTemplate.opsForZSet().score(key, String.valueOf(accountId));</span><br><span class="line">    score &#x3D; (score &#x3D;&#x3D; null) ? 0d : score;</span><br><span class="line">    int curPoint &#x3D; getPoint(score.longValue());</span><br><span class="line">    long newScore &#x3D; toScore(curPoint + addPoint, getCurPeriodEndDateTimestamp(periodId));</span><br><span class="line">    redisTemplate.opsForZSet().add(key, String.valueOf(accountId), newScore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基于Redis ZSet实现积分排行榜（倒序）并支持按时间（升序）排序原理与注意事项：</p>
<ul>
<li>先按积分排序，再按时间排序，所以需要高位存储积分，低位存储时间戳，这样才能保证积分越高对应score越大；</li>
<li>同分值情况下按时间升序排序，必然让达到当前积分时间最早的score越大；</li>
<li>由于每次更新用户积分都需要重新计算score，updateRanking方法不能保证ZSet读和写复合操作命令的原子性，因此可能存在并发数据一致性问题</li>
</ul>
<h2 id="关于实现排行榜用到ZSet的几个命令"><a href="#关于实现排行榜用到ZSet的几个命令" class="headerlink" title="关于实现排行榜用到ZSet的几个命令"></a>关于实现排行榜用到ZSet的几个命令</h2><p>1.获取倒序排名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGEBYSCORE key min max offset count</span><br></pre></td></tr></table></figure>

<p>2.获取某个用户的score：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></table></figure>

<p>3.获取参与排名的总用户数（本期参与人数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure>

<p>4.获取某个用户的当前排名(倒序排序，从大到小的排名)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANK key member</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/zdal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/zdal/" class="post-title-link" itemprop="url">zdal</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-14 23:41:50" itemprop="dateCreated datePublished" datetime="2021-06-14T23:41:50+08:00">2021-06-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-08 18:32:32" itemprop="dateModified" datetime="2021-09-08T18:32:32+08:00">2021-09-08</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据库中间件应用场景"><a href="#数据库中间件应用场景" class="headerlink" title="数据库中间件应用场景"></a>数据库中间件应用场景</h1><p>数据库中间件可以理解为是一种具有连接池功能，但比连接池更高级的、带很多附加功能的辅助组件</p>
<h1 id="zdal整体架构"><a href="#zdal整体架构" class="headerlink" title="zdal整体架构"></a>zdal整体架构</h1><p>它提供分库分表，结果集合并，sql解析，数据库failover动态切换等数据访问层统一解决方案</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT530nUqCzH4yRGt1CU99NeiaIlsjBvGtjIvnBGkwo2aCk2RL8nkM3lOnYGUe7OiaviaD6tUvmmVSic5oc8g/640" alt="Image" style="zoom: 33%;" />



<p>如上图所示，zdal有四个重要的组成部分：</p>
<ul>
<li><strong>价值体现–客户端Client包</strong>。对外暴露基本操作接口，用于业务层简单黑盒的操作数据源；业务只和client交互，动态切换/路由等逻辑只需要进行规则配置，相关逻辑由zdal实现。</li>
<li><strong>核心功能–连接管理datasource包</strong>。最核心的能力，提供多种类型数据库的连接管理；</li>
<li><strong>关键能力–SQL解析parser包</strong>。基础SQL解析能力；解析sql类型、字段名称、数据库等等，配合规则进行路由</li>
<li><strong>扩展能力–库表路由rule包</strong>。根据parser解析出的字段确定逻辑库表和物理库表。</li>
</ul>
<p>组件图对整体架构和各组件及相互联系的理解可以起到很好的帮助。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT530nUqCzH4yRGt1CU99NeiaIlmiavmffCxvvYmNMSdJGm2ACSD6TaSia0NLzc1qJ7MoPib8ibia7YfVj3pwQ/640" alt="Image"></p>
<ul>
<li>Client对应用层暴露的数据源、负责监听配置动态变更的监听组件、负责加载组织各部分的配置组件、负责加载spring bean 和库表规则的配置组件；</li>
<li>Client中加载了规则组件，实现逻辑表和数据库的路由规则。</li>
<li>Client中的库表配置调用datasource中的数据源管理服务并构建连接池的连接池；</li>
<li>Client中的SqlDispatcher服务调用SQL解析组件实现SQL解析。</li>
</ul>
<h1 id="zdal运行原理"><a href="#zdal运行原理" class="headerlink" title="zdal运行原理"></a>zdal运行原理</h1><h2 id="配置加载和bean初始化"><a href="#配置加载和bean初始化" class="headerlink" title="配置加载和bean初始化"></a>配置加载和bean初始化</h2><p>大部分情况下，我们使用如mybatis这样的ORM框架来进行数据库操作，其实不管是ORM还是其他方式，应用层都需要对数据源进行配置。</p>
<p>所以，client对外暴露了一个符合JDBC标准的datasource数据源，用来满足应用层ORM等框架配置数据源的要求–<strong>ZdalDataSource</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT530nUqCzH4yRGt1CU99NeiaIlr3yDerBNFgibYWn2f1TysZXualq6yxgsVEvwoF1ickSDWiaibEIOibRmWBA/640" alt="Image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;只提供了一个init方法，这也是spring启动时时，必须要调用的初始化方法，所有功能，都从这里开始</span><br><span class="line">public class ZdalDataSource extends AbstractZdalDataSource implements DataSource&#123;</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.initZdalDataSource();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            CONFIG_LOGGER.error(&quot;...&quot;);</span><br><span class="line">            throw new ZdalClientException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>ZdalDataSource#init()</strong> 方法即为配置加载的核心入口，init中负责加载spring配置，根据配置初始化数据源，并创建连接池，同时，将逻辑表和物理库的对应关系都维护起来供后续路由调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;*父类的init方法*&#x2F;</span><br><span class="line">protected void initZdalDataSource() &#123;</span><br><span class="line">    &#x2F;*用FileSystemXmlApplicationContext方式加载配置文件中的数据源和规则，转化成zdalConfig对象*&#x2F;</span><br><span class="line">    this.zdalConfig &#x3D; ZdalConfigurationLoader.getInstance().getZdalConfiguration(appName,dbmode, appDsName, configPath);</span><br><span class="line">    this.dbConfigType &#x3D; zdalConfig.getDataSourceConfigType();</span><br><span class="line">   this.dbType &#x3D; zdalConfig.getDbType();</span><br><span class="line">   &#x2F;&#x2F;初始化数据源</span><br><span class="line">   this.initDataSources(zdalConfig);</span><br><span class="line">   this.inited.set(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的类图和这里的两个入口方法大概了解到zdal配置加载的启动流程。下面我们就来详细看一下，读写分离和分库分表的规则是怎么被加载，怎么起作用的。</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h3 id="读写分离配置的加载"><a href="#读写分离配置的加载" class="headerlink" title="读写分离配置的加载"></a>读写分离配置的加载</h3><p>首先，我们需要有数据源的相关配置，如下图：<img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT530nUqCzH4yRGt1CU99NeiaIlNXzP18BUjaOKovJbI1MGAzfvJJJfp8hncBuwAvE6QdkLicQwXE7B4icA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">此XML配置会在init方法被调用时，被初始化，解析成ZdalConfig类的属性，ZdalConfig类的主要成员见下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZdalConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** key=dsName;value=DataSourceParameter 所有物理数据源的配置项,比如用户名，密码，库名等 */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, DataSourceParameter&gt; dataSourceParameters = <span class="keyword">new</span> ConcurrentHashMap&lt;String, DataSourceParameter&gt;();</span><br><span class="line">    <span class="comment">/** 逻辑数据源和物理数据源的对应关系:key=logicDsName,value=physicDsName */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt;  logicPhysicsDsNames  = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">/** 数据源的读写规则，比如只读，或读写等配置*/</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; groupRules = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">/** 异常转移的数据源规则*/</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; failoverRules = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">//一份完整的读写分离和分库分表规则配置</span></span><br><span class="line">    <span class="keyword">private</span> AppRule appRootRule;</span><br></pre></td></tr></table></figure>

<p>可以看到，xml中的规则，被解析到xxxRules里。这里以groupRules为例，failover同理。</p>
<p>下一步则是通过解析得到的zdalConfig 来初始化数据源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected final void initDataSources(ZdalConfig zdalConfig) &#123;</span><br><span class="line">    &#x2F;&#x2F;DataSourceParameter中存的是数据源参数，如用户名密码，最大最小连接数等</span><br><span class="line">    for (Entry&lt;String, DataSourceParameter&gt; entry : zdalConfig.getDataSourceParameters().entrySet()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           &#x2F;&#x2F;初始化连接池</span><br><span class="line">           ZDataSource zDataSource &#x3D; new ZDataSource(&#x2F;*设置最大最小连接数*&#x2F;createDataSourceDO(entry.getValue(),zdalConfig.getDbType(), appDsName + &quot;.&quot; + entry.getKey()));</span><br><span class="line">           this.dataSourcesMap.put(entry.getKey(), zDataSource);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F;...</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#x2F;&#x2F;其他分支略，只看最简单的分组模式</span><br><span class="line">  if (dbConfigType.isGroup()) &#123;</span><br><span class="line">       &#x2F;&#x2F;读写配置赋值</span><br><span class="line">       this.rwDataSourcePoolConfig &#x3D; zdalConfig.getGroupRules();</span><br><span class="line">       &#x2F;&#x2F;初始化多份读库下的负载均衡</span><br><span class="line">       this.initForLoadBalance(zdalConfig.getDbType());</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;注册监听：为了满足动态切换</span><br><span class="line">  this.initConfigListener();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initForLoadBalance的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void initForLoadBalance(DBType dbType) &#123;</span><br><span class="line">    Map&lt;String, DBSelector&gt; dsSelectors &#x3D; this.buildRwDbSelectors(this.rwDataSourcePoolConfig);</span><br><span class="line">    this.runtimeConfigHolder.set(new ZdalRuntime(dsSelectors));</span><br><span class="line">    this.setDbTypeForDBSelector(dbType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，首先构建出了DB选择器，然后赋值给了runtimeConfigHolder供运行时获取。而构建DB选择器的时候，其实是按读写两个维度，把所有数据源都构建了一遍，即group_r和group_w下都包含5个数据源，只不过各自的权重不一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;比如按上面的配置写库只有一个，但是也会包含全数据源</span><br><span class="line"></span><br><span class="line">group_0_w_0 :&lt; bean:read0DataSource , writeWeight:0&gt;</span><br><span class="line">group_0_w_1 :&lt; bean:writeDataSource , writeWeight:10&gt;</span><br><span class="line">group_0_w_2 :&lt; bean:read1DataSource , writeWeight:0&gt;</span><br><span class="line">group_0_w_3 :&lt; bean:read2DataSource , writeWeight:0&gt;</span><br><span class="line">group_0_w_4 :&lt; bean:read3DataSource , writeWeight:0&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;上述就是写相关的DBSelecter的内容。</span><br></pre></td></tr></table></figure>

<h3 id="读写分离怎么起作用"><a href="#读写分离怎么起作用" class="headerlink" title="读写分离怎么起作用"></a>读写分离怎么起作用</h3><p>以delete为例，更新删除是要操作写库的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void delete(ZdalDataSource dataSource) &#123;</span><br><span class="line">    String deleteSql &#x3D; &quot;delete from test&quot;;</span><br><span class="line">    Connection conn &#x3D; null;</span><br><span class="line">    PreparedStatement pst &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">       conn &#x3D; dataSource.getConnection();</span><br><span class="line">       pst &#x3D; conn.prepareStatement(deleteSql);</span><br><span class="line">       pst.execute();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">           &#x2F;&#x2F;...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">          &#x2F;&#x2F;资源关闭</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getConnection会从上文中提到的runtimeConfigHolder中获取DBSelecter，然后执行execute方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> public boolean execute() throws SQLException &#123;</span><br><span class="line">    SqlType sqlType &#x3D; getSqlType(sql);</span><br><span class="line">    &#x2F;&#x2F; SELECT相关的就选择group_r对应的DBSelecter</span><br><span class="line">   if (sqlType &#x3D;&#x3D; SqlType.SELECT || sqlType &#x3D;&#x3D; SqlType.SELECT_FOR_UPDATE|| sqlType &#x3D;&#x3D; SqlType.SELECT_FROM_DUAL) &#123;</span><br><span class="line">     &#x2F;&#x2F;略</span><br><span class="line">    return true;</span><br><span class="line">    &#x2F;&#x2F;update&#x2F;delete相关的就选择group_w对应的DBSelecter</span><br><span class="line">  &#125; else if (sqlType &#x3D;&#x3D; SqlType.INSERT || sqlType &#x3D;&#x3D; SqlType.UPDATE|| sqlType &#x3D;&#x3D; SqlType.DELETE) &#123;</span><br><span class="line">       if (super.dbConfigType &#x3D;&#x3D; DataSourceConfigType.GROUP) &#123;</span><br><span class="line">           executeUpdate0();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           executeUpdate();</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是读取相关的，那就选_r的DBSelecter，如果是写相关的，那就选_W的DBSelecter。那么executeUpdate0中是怎么执行区分读写数据源的呢，其实就是把这一组的数据源根据权重筛选一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; WeightRandom#select(int[], java.lang.String[])</span><br><span class="line">private String select(int[] areaEnds, String[] keys) &#123;</span><br><span class="line">   &#x2F;&#x2F;这里的areaEnds数组，是一个累加范围值数据</span><br><span class="line">   &#x2F;&#x2F;比如三个库权重    10   9   8</span><br><span class="line">   &#x2F;&#x2F;那么areaEnds就是  10  19  27 是对每个权重的累加，最后一个值是总和</span><br><span class="line">   int sum &#x3D; areaEnds[areaEnds.length - 1];</span><br><span class="line">   &#x2F;&#x2F;这样随机出来的数，是符合权重分布的</span><br><span class="line">   int rand &#x3D; random.nextInt(sum);</span><br><span class="line">   for (int i &#x3D; 0; i &lt; areaEnds.length; i++) &#123;</span><br><span class="line">       if (rand &lt; areaEnds[i]) &#123;</span><br><span class="line">           return keys[i];</span><br><span class="line">   &#125;</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章，把阿里数据库中间件相关的组件和加载流程进行了总结，就一个最基本的分组读写分离的流程，对内部实现进行了阐述。看源码时，比如dubbo这些中间件其实是比较容易入手的，因为他们都依托于Spring进行JavaBean的装载，所有，对Spring容器暴露的那些init、load方法，就是很好的切入点。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8D%8F%E8%AE%AE/%E5%86%85%E6%A0%B8%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8D%8F%E8%AE%AE/%E5%86%85%E6%A0%B8%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">内核调优参数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-14 21:12:31 / Modified: 21:13:56" itemprop="dateCreated datePublished" datetime="2021-06-14T21:12:31+08:00">2021-06-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Linux作为一个强大的操作系统，提供了一系列内核参数供我们进行调优。光TCP的调优参数就有50多个。在和线上问题斗智斗勇的过程中，笔者积累了一些在内网环境应该进行调优的参数。在此分享出来，希望对大家有所帮助。</p>
<h2 id="调优清单"><a href="#调优清单" class="headerlink" title="调优清单"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nU31sYkEydL32T-qKvGNrg">调优清单</a></h2><p>好了，在这里先列出调优清单。请记住，这里只是笔者在内网进行TCP内核参数调优的经验，仅供参考。同时，笔者还会在余下的博客里面详细解释了为什么要进行这些调优！</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>内核参数</th>
<th align="left">值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1.1</td>
<td>/proc/sys/inet/ipv4/tcp_max_syn_backlog</td>
<td align="left">2048</td>
<td></td>
</tr>
<tr>
<td>1.2</td>
<td>/proc/sys/net/core/somaxconn</td>
<td align="left">2048</td>
<td></td>
</tr>
<tr>
<td>1.3</td>
<td>/proc/sys/net/ipv4/tcp_abort_on_overflow</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>2.1</td>
<td>/proc/sys/net/ipv4/tcp_tw_recycle</td>
<td align="left">0</td>
<td>NAT环境必须为0</td>
</tr>
<tr>
<td>2.2</td>
<td>/proc/sys/net/ipv4/tcp_tw_reuse</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>3.1</td>
<td>/proc/sys/net/ipv4/tcp_syn_retries</td>
<td align="left">3</td>
<td></td>
</tr>
<tr>
<td>3.2</td>
<td>/proc/sys/net/ipv4/tcp_retries2</td>
<td align="left">5</td>
<td></td>
</tr>
<tr>
<td>3.3</td>
<td>/proc/sys/net/ipv4/tcp_slow_start_after_idle</td>
<td align="left">0</td>
<td></td>
</tr>
</tbody></table>
<p>当然了，这里只列出TCP的部分内核参数，更多web性能上的建议，请看</p>
<p>Ad</p>
<h2 id="Web性能权威指南-图灵出品"><a href="#Web性能权威指南-图灵出品" class="headerlink" title="Web性能权威指南(图灵出品)"></a>Web性能权威指南(图灵出品)</h2><p>作者：[加]Ilya Grigorik</p>
<p>京东 </p>
<h2 id="tcp-max-syn-backlog-somaxconn-tcp-abort-on-overflow"><a href="#tcp-max-syn-backlog-somaxconn-tcp-abort-on-overflow" class="headerlink" title="tcp_max_syn_backlog,somaxconn,tcp_abort_on_overflow"></a>tcp_max_syn_backlog,somaxconn,tcp_abort_on_overflow</h2><p>tcp_max_syn_backlog,somaxconn,tcp_abort_on_overflow这三个参数是关于<br>内核TCP连接缓冲队列的设置。如果应用层来不及将已经三次握手建立成功的TCP连接从队列中取出,溢出了这个缓冲队列(全连接队列)之后就会丢弃这个连接。如下图所示:<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSqpvmGiboDDibLVnNtqicucDArlJbELjXP7pDLGcQMF2ialyjz2JIPMic6plJhUBQnwbGIQb5LSKpQcWA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>从而产生一些诡异的现象,这个现象诡异之处就在于，是在TCP第三次握手的时候丢弃连接<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSqpvmGiboDDibLVnNtqicucDAG76BTOc7VcteRFSibhI1UibmfUic6PibIKL7FD5QGKq3npUiahq973bHP7A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>就如图中所示,第二次握手的SYNACK发送给client端了。所以就会出现client端认为连接成功，而Server端确已经丢弃了这个连接的现象！由于无法感知到Server已经丢弃了连接。<br>所以如果没有心跳的话，只有在发出第一个请求后，Server才会发送一个reset端通知这个连接已经被丢弃了，建立连接后第二天再用，也会报错！所以我们要调大Backlog队列！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 2048 &gt; &#x2F;proc&#x2F;sys&#x2F;inet&#x2F;ipv4&#x2F;tcp_max_syn_backlog</span><br><span class="line">echo 2048 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn</span><br></pre></td></tr></table></figure>

<p>当然了，为了尽量避免第一笔调用失败问题，我们也同时要设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_abort_on_overflow</span><br></pre></td></tr></table></figure>

<p>设置这个值以后，Server端内核就会在这个连接被溢出之后发送一个reset包给client端。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSqpvmGiboDDibLVnNtqicucDAKKicAs5ziclVdpO8SQKSVaxjcPrKX7LrubWsv5cIFl1srm8Cf8tBb9QQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>如果我们的client端是NIO的话，就可以收到一个socket close的事件以感知到连接被关闭！<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSqpvmGiboDDibLVnNtqicucDAde9s8RMR11B71N2C7CAzfXUc1wuuibnicVgXyCeHMxxZj0thCUlDv6HA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h3 id="注意Java默认的Backlog是50"><a href="#注意Java默认的Backlog是50" class="headerlink" title="注意Java默认的Backlog是50"></a>注意Java默认的Backlog是50</h3><p>这个TCP Backlog的队列大小值是min(tcp_max_syn_backlog,somaxconn,应用层设置的backlog),而Java如果不做额外设置，Backlog默认值仅仅只有50。C语言在使用listen调用的时候需要传进Backlog参数。</p>
<h2 id="tcp-tw-recycle"><a href="#tcp-tw-recycle" class="headerlink" title="tcp_tw_recycle"></a>tcp_tw_recycle</h2><p>tcp_tw_recycle这个参数一般是用来抑制TIME_WAIT数量的,但是它有一个副作用。即在tcp_timestamps开启(Linux默认开启)，tcp_tw_recycle会经常导致下面这种现象。<br><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"><br>也即，如果你的Server开启了tcp_tw_recycle，那么别人如果通过NAT之类的调用你的Server的话，NAT后面的机器只有一台机器能正常工作，其它情况大概率失败。具体原因呢由下图所示:<br><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"><br>在tcp_tw_recycle=1同时tcp_timestamps(默认开启的情况下),对同一个IP的连接会做这样的限制，也即之前后建立的连接的时间戳必须要大于之前建立连接的最后时间戳，但是经过NAT的一个IP后面是不同的机器，时间戳相差极大，就会导致内核直接丢弃时间戳较低的连接的现象。由于这个参数导致的问题，高版本内核已经去掉了这个参数。如果考虑TIME_WAIT问题，可以考虑设置一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_tw_reuse</span><br></pre></td></tr></table></figure>

<h2 id="tcp-syn-retries"><a href="#tcp-syn-retries" class="headerlink" title="tcp_syn_retries"></a>tcp_syn_retries</h2><p>这个参数值得是client发送SYN如果server端不回复的话，重传SYN的次数。对我们的直接影响呢就是connet建立连接时的超时时间。当然Java通过一些C原生系统调用的组合使得我们可以进行超时时间的设置。在Linux里面默认设置是5,下面给出建议值3和默认值5之间的超时时间。</p>
<table>
<thead>
<tr>
<th>tcp_syn_retries</th>
<th>timeout</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>min(so_sndtimeo,3s)</td>
</tr>
<tr>
<td>2</td>
<td>min(so_sndtimeo,7s)</td>
</tr>
<tr>
<td>3</td>
<td>min(so_sndtimeo,15s)</td>
</tr>
<tr>
<td>4</td>
<td>min(so_sndtimeo,31s)</td>
</tr>
<tr>
<td>5</td>
<td>min(so_sndtimeo,63s)</td>
</tr>
</tbody></table>
<p>下图给出了，重传和超时情况的对应图:<br><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"><br>当然了，不同内核版本的超时时间可能不一样，因为初始RTO在内核小版本间都会有细微的变化。所以，有时候在抓包时候可能会出现（3,6,12……)这样的序列。当然Java的API有超时时间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java:</span><br><span class="line"> &#x2F;&#x2F; 函数调用中携带有超时时间</span><br><span class="line"> public void connect(SocketAddress endpoint, int timeout) ;</span><br></pre></td></tr></table></figure>

<p>所以，对于Java而言，这个内核参数的设置没有那么重要。但是，有些代码可能会有忘了设置timeout的情况，例如某个版本的Kafka就是，所以它在我们一些混沌测试的情况下，容灾恢复的时间会达到一分多钟，主要时间就是卡在connect上面-_-!，而这时我们的tcp_syn_retries设置的是5，也即超时时间63s。减少这个恢复时间的手段就是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_syn_retries</span><br></pre></td></tr></table></figure>

<h2 id="tcp-retries2"><a href="#tcp-retries2" class="headerlink" title="tcp_retries2"></a>tcp_retries2</h2><p>tcp_retries2这个参数表面意思是在传输过程中tcp的重传次数。但在某个版本之后Linux内核仅仅用这个tcp_retries2来计算超时时间，在这段时间的重传次数纯粹由RTO等环境因素决定，重传超时时间在5/15下的表现为:</p>
<table>
<thead>
<tr>
<th>tcp_retries2</th>
<th align="left">对端无响应</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td align="left">25.6s-51.2s根据动态rto定</td>
</tr>
<tr>
<td>15</td>
<td align="left">924.6s-1044.6s根据动态rto定</td>
</tr>
</tbody></table>
<p>如果我们在应用层设置的Socket所有ReadTimeout都很小的话(例如3s),这个内核参数调整是没有必要的。但是，笔者经常发现有的系统，因为一两个慢的接口或者SQL，所以将ReadTimeout设的很大的情况。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSqpvmGiboDDibLVnNtqicucDA2ccOvCYpgT8Xrm4JPB3sSibwYwh5icWeFacrNUzCNkpuBKt8tIt2rH3w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>平常这种情况是没有问题的，因为慢请求频率很低，不会对系统造成什么风险。但是，物理机突然宕机时候的情况就不一样了，由于ReadTimeOut设置的过大，导致所有落到这台宕机的机器都会在min(ReadTimeOut,(924.6s-1044.6s)(Linux默认tcp_retries2是15))后才能从read系统调用返回。假设ReadTimeout设置了个5min，系统总线程数是200，那么只要5min内有200个请求落到宕机的server就会使A系统失去响应！<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSqpvmGiboDDibLVnNtqicucDA7vKurFMDuicTZYibs18Nz9XfDlZUHtGKFrzqgkfKDCiaQGTLqZJv7L1SA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>但如果将tcp_retries2设置为5,那么超时返回时间即为min(ReadTimeOut 5min,25.6-51.2s),也就是30s左右，极大的缓解了这一情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 5 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_retries2</span><br></pre></td></tr></table></figure>

<p>但是针对这种现象，最好要做资源上的隔离,例如线程上的隔离或者机器级的隔离。<br><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></p>
<p>golang的goroutine调度模型就可以很好的解决线程资源不够的问题，但缺点是goroutine里面不能有阻塞的系统调用，不然也会和上面一样，但仅仅对于系统之间互相调用而言，都是非阻塞IO,所以golang做微服务还是非常Nice的。当然了我大Java用纯IO事件触发编写代码也不会有问题，就是对心智负担太高-_-!</p>
<h3 id="物理机突然宕机和进程宕不一样"><a href="#物理机突然宕机和进程宕不一样" class="headerlink" title="物理机突然宕机和进程宕不一样"></a>物理机突然宕机和进程宕不一样</h3><p>值得注意的是，物理机宕机和进程宕但内核还存在表现完全不一样。<br><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"><br>仅仅进程宕而内核存活，那么内核会立马发送reset给对端，从而不会卡住A系统的线程资源。</p>
<h2 id="tcp-slow-start-after-idle"><a href="#tcp-slow-start-after-idle" class="headerlink" title="tcp_slow_start_after_idle"></a>tcp_slow_start_after_idle</h2><p>还有一个可能需要调整的参数是tcp_slow_start_after_idle，Linux默认是1，即开启状态。开启这个参数后，我们的TCP拥塞窗口会在一个RTO时间空闲之后重置为初始拥塞窗口(CWND)大小，这无疑大幅的减少了长连接的优势。对应Linux源码为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void tcp_event_data_sent(struct tcp_sock *tp,</span><br><span class="line">                struct sk_buff *skb, struct sock *sk)&#123;</span><br><span class="line">    &#x2F;&#x2F; 如果开启了start_after_idle,而且这次发送的时间-上次发送的时间&gt;一个rto，就重置tcp拥塞窗口</span><br><span class="line">    if (sysctl_tcp_slow_start_after_idle &amp;&amp;</span><br><span class="line">        (!tp-&gt;packets_out &amp;&amp; (s32)(now - tp-&gt;lsndtime) &gt; icsk-&gt;icsk_rto))</span><br><span class="line">        tcp_cwnd_restart(sk, __sk_dst_get(sk));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"><br>关闭这个参数后，无疑会提高某些请求的传输速度(在带宽够的情况下)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_slow_start_after_idle</span><br></pre></td></tr></table></figure>

<p>当然了，Linux启用这个参数也是有理由的，如果我们的网络情况是时刻在变化的，例如拿个手机到处移动，那么将拥塞窗口重置确实是个不错的选项。但是就我们内网系统间调用而言，是不太必要的了。</p>
<h2 id="初始CWND大小"><a href="#初始CWND大小" class="headerlink" title="初始CWND大小"></a>初始CWND大小</h2><p>毫无疑问，新建连接之后的初始TCP拥塞窗口大小也直接影响到我们的请求速率。在Linux2.6.32源码中，其初始拥塞窗口是(2-4个)mss大小，对应于内网估计也就是(2.8-5.6K)(MTU 1500)，这个大小对于某些大请求可能有点捉襟见肘。<br>在Linux 2.6.39以上或者某些RedHat维护的小版本中已经把CWND<br>增大到RFC 6928所规定的的10段，也就是在内网里面估计14K左右(MTU 1500)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux 新版本</span><br><span class="line">&#x2F;* TCP initial congestion window *&#x2F;</span><br><span class="line">#define TCP_INIT_CWND        10</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Linux提供了一大堆内参参数供我们进行调优，其默认设置的参数在很多情况下并不是最佳实践，所以我们需要潜心研究，找到最适合当前环境的组合。    </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E5%88%86%E6%9E%90%E5%92%8C%E8%B0%83%E4%BC%98/%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8%E4%B8%8D%E5%9B%9E%E6%BB%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E5%88%86%E6%9E%90%E5%92%8C%E8%B0%83%E4%BC%98/%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8%E4%B8%8D%E5%9B%9E%E6%BB%9A/" class="post-title-link" itemprop="url">事务异常不回滚</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-14 21:02:50" itemprop="dateCreated datePublished" datetime="2021-06-14T21:02:50+08:00">2021-06-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-15 13:31:23" itemprop="dateModified" datetime="2021-06-15T13:31:23+08:00">2021-06-15</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="日常Bug排查-抛异常不回滚"><a href="#日常Bug排查-抛异常不回滚" class="headerlink" title="日常Bug排查-抛异常不回滚"></a>日常Bug排查-抛异常不回滚</h1><h2 id="Bug现场"><a href="#Bug现场" class="headerlink" title="Bug现场"></a>Bug现场</h2><p>最近有人反映java应用操作数据库的时候，抛异常不回滚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Transacion(value&#x3D;&quot;x&quot;) </span><br><span class="line">public void s1() throw MyException&#123; </span><br><span class="line">    update(1); </span><br><span class="line">    throwBusinessException();</span><br><span class="line">    update(2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍看上去没啥问题。</p>
<h2 id="翻下Spring源码"><a href="#翻下Spring源码" class="headerlink" title="翻下Spring源码"></a>翻下Spring源码</h2><p>Spring的源码，看下它在声明式事务中的处理逻辑到底是什么，于是翻到了这一段处理事务异常的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TransactionAspectSupport.java</span><br><span class="line">protected void completeTransactionAfterThrowing(TransactionInfo txInfo, Throwable ex) &#123;</span><br><span class="line">    if (txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F; We don&#39;t roll back on this exception.</span><br><span class="line">        &#x2F;&#x2F; Will still roll back if TransactionStatus.isRollbackOnly() is true.</span><br><span class="line">        &#x2F;&#x2F; 在checkedException的时候,不会被rollBack,会commit!!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public boolean rollbackOn(Throwable ex) &#123;</span><br><span class="line">    return (ex instanceof RuntimeException || ex instanceof Error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看代码逻辑就明白了，只有异常继承RuntimeException或者Error的时候才会回滚！</p>
<h1 id="遇到异常，应用该如何回滚"><a href="#遇到异常，应用该如何回滚" class="headerlink" title="遇到异常，应用该如何回滚"></a>遇到异常，应用该如何回滚</h1><h2 id="应用Commit报错并不一定回滚"><a href="#应用Commit报错并不一定回滚" class="headerlink" title="应用Commit报错并不一定回滚"></a>应用Commit报错并不一定回滚</h2><p>阐述一下当我们在事务Commit报错时候，数据库中的数据并不一定会是我们以为的回滚状态。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRTx1JrBPXUHGoBRoicHK5gNHiaLyDP0Z3m3atpmibPxNPZXt4jgSLF4jSDvictrMjyW5lxCIwQZVJyqlw/640" alt="图片"><br>在这种情况下，很明显的DB的数据肯定是处于已经提交的状态。而如果App认为是回滚状态，并基于这个信息去做操作的话，很明显会导致数据不一致。</p>
<h2 id="非-IO异常-or-超时异常-也不一定回滚"><a href="#非-IO异常-or-超时异常-也不一定回滚" class="headerlink" title="非 (IO异常 or 超时异常) 也不一定回滚"></a>非 (IO异常 or 超时异常) 也不一定回滚</h2><p>只有IO异常或者超时异常才会出现这种不一定回滚的问题呢？这里还真不一定，笔者在一次Case中，就发现Oracle在commit的时候返回死锁异常时候，数据库内部的commit竟然也成功了!这就牵涉到数据库内部的处理了。</p>
<h2 id="应用应该怎么做呢？"><a href="#应用应该怎么做呢？" class="headerlink" title="应用应该怎么做呢？"></a>应用应该怎么做呢？</h2><p>事实上，由于数据库保证了原子性。所以我们在遇到这种情况时候，需要从数据库中重建状态,而不是依赖现在应用里面的信息。所以遇到异常直接将流程结束，然后等定时任务、等补单操作是个比较简单安全的做法。<br>当然，数据库中重建状态时候，也要考虑到上一个相应的commit还在commit的过程中,只不过这个commit非常慢而已。由于我们更新数据或者最终判断的时候往往会锁住数据,而数据库一般都是采用了二阶段锁(S2PL)。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRTx1JrBPXUHGoBRoicHK5gNHkR7NgO8BrRiaenicYHGmaENN70MHSpYRdOjLGm3MiayPCet0syU1eSXLA/640" alt="图片"><br>在上一个commit成功提交之后，我们对相应数据的操作才会执行下去。所以只要小心的控制好锁的范围，数据一致性还是能保证的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%8D%E6%B6%88%E8%B4%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%8D%E6%B6%88%E8%B4%B9/" class="post-title-link" itemprop="url">消息不消费</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-14 20:59:54" itemprop="dateCreated datePublished" datetime="2021-06-14T20:59:54+08:00">2021-06-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="日常Bug排查-消息不消费"><a href="#日常Bug排查-消息不消费" class="headerlink" title="日常Bug排查-消息不消费"></a>日常Bug排查-消息不消费</h2><h2 id="Bug现场"><a href="#Bug现场" class="headerlink" title="Bug现场"></a>Bug现场</h2><p>某天下午，在笔者研究某个问题正high的时候。开发突然找到笔者，线上某个系统突然消费不了queue了。Queue不消费也算是日常问题了。淡定的先把流量切到另一个机房，让问题先恢复再说。</p>
<h2 id="消息累积"><a href="#消息累积" class="headerlink" title="消息累积"></a>消息累积</h2><p>然后就是看不消费的queue到哪去了，打开mq(消息中间件)控制台，全部累积到mq上了。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRRl5MlP774wCglMbQSgL5j9CicyAY4LQpibVzUtYDHos8UciaBicTIknamabPEYErCicMRwVTMUM3b3weg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>同时开发对笔者反映，只有这个queueu积累了，其它queue还是能正常消费的。</p>
<h2 id="出问题时间点"><a href="#出问题时间点" class="headerlink" title="出问题时间点"></a>出问题时间点</h2><p>这时笔者还得到了一个关键信息，此问题是DBA对其关联的数据库进行操作后才发生的。当时由于操作灌入的数据库过大，导致数据库主从切换，漂了VIP。从时间点判断，这个应该是问题的诱因。</p>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>既然卡住了，那么老办法，jstack一下，看看我们的mq消费线程在干嘛:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ActiveMQ Session Task-1234</span><br><span class="line">    at java.net.SocketInputStream.socketRead0</span><br><span class="line">    ......</span><br><span class="line">    at com.mysql.jdbc.MysqlIO.readFully</span><br><span class="line">    ......</span><br><span class="line">    at org.apache.activemq.ActiveMQMessageConsumer.dispatch</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>很明显的，都卡在MysqlIO.readFully也就是数据库读取上，再也不往下走了。</p>
<h2 id="没配超时"><a href="#没配超时" class="headerlink" title="没配超时"></a>没配超时</h2><p>这就肯定是没配超时了，排查了下他们的配置，确实没配。之前系统梳理过好多次，但没想到还是有这种漏网之鱼。这个问题分析本身是很简单的。不过在这里笔者想多聊一下，为什么数据主从切换会形成这样的现象。</p>
<h2 id="mha切换"><a href="#mha切换" class="headerlink" title="mha切换"></a>mha切换</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRRl5MlP774wCglMbQSgL5j99hd51zgMoGyZqqxbj2hMSgQVwL2QDj9ia8mDFuTFWcQ0iacTyiaicFyJFQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>如图所示，mha切换逻辑是将vip从DB旧主上摘掉，然后将vip挂到DB新主上面。为了观察这种行为，笔者写了个python程序进行测试。观察得知，在vip被摘掉的那一刻，双方的通信已经不正常了。但是tcp连接状态依旧是ESTABLISHED。</p>
<h2 id="为什么tcp状态依旧ESTABLISHED"><a href="#为什么tcp状态依旧ESTABLISHED" class="headerlink" title="为什么tcp状态依旧ESTABLISHED"></a>为什么tcp状态依旧ESTABLISHED</h2><p>因为ip摘掉并不会让已经存在的socket立马感知，那么socket什么时候能够感知到我们这个连接已经gg了呢。在当前这个场景下，应用没设置socket超时，会有这几种可能:</p>
<ol>
<li>如果这时候App正在发请求给此五元组</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRRl5MlP774wCglMbQSgL5j9hlTHWUHFuf0lul6XvjGTCRlDr7Rf8h0ttlPabRsh5HsdUEM1ib2ibhlQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ol>
<li>如果DB正在写回请求给此五元组<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRRl5MlP774wCglMbQSgL5j9MvaWDfk0vAvYqL4iaZF53foT01QibnAiaHaFPqZdu8B1FtoiaCxhTzMXSA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></li>
</ol>
<p>由上面两种情况，我们可以知道哪方作出发送动作，哪方就能够通过reset或者尝试次数过多来感知到这个连接已经gg了。<br>很明显的，由于我们的应用正卡在socket read,表明我们的App应用并没有发送数据，而是在等待MySQL的返回，那么在不设置超时的情况下，App怎么感知到连接实际上已经不好了呢。</p>
<h2 id="tcp保活定时器"><a href="#tcp保活定时器" class="headerlink" title="tcp保活定时器"></a>tcp保活定时器</h2><p>由于应用不做发送动作，那这时就轮到我们的tcp保活定时器tcp_keepalive出马了。linux下默认的内核参数为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_time 7200 两小时</span><br><span class="line">&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_probes 9 探测9次</span><br><span class="line">&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_intvl 75s 每次探测间隔75s</span><br></pre></td></tr></table></figure>

<p>tcp保活定时器默认在7200s也就是两小时后开启，探测9次，每次间隔75s，如果有明确失败或者9次都没返回则判定连接gg。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRRl5MlP774wCglMbQSgL5j9IZG7OGaeFPUsy1NOQm9eG7CiaYjhE8y7e3jG6TZuvY55fRb3qDfkHFQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>在我们的这个场景中，应用会在两个小时后开始保活，在第一次探测的时候对端发送reset从而应用感知到连接gg。这时候，应用才返回。也就是说，不设置超时时间，遇到这种情况，应用的线程要卡2小时！</p>
<h2 id="如果是DB进程宕or重启"><a href="#如果是DB进程宕or重启" class="headerlink" title="如果是DB进程宕or重启"></a>如果是DB进程宕or重启</h2><p>如果不是mha切换，而是DB进程重启或者宕的话，由于Linux内核没宕还存在着。内核会自动将DB进程所属的socket进行close也就是发FIN报文回去。那么应用就可以立马从socket read系统调用中返回了。</p>
<h2 id="物理机宕机"><a href="#物理机宕机" class="headerlink" title="物理机宕机"></a>物理机宕机</h2><p>物理机宕机而不漂VIP,应用在不设置超时的时候。如果是发送数据阶段，则tcp_reties2次重试后从socket read系统调用返回。如果不发送数据，和上面的描述基本一样，2个小时后开启保活定时器。唯一不同的是，这次是需要探活9次，所以需要会多花11分钟左右的时间感知。</p>
<h2 id="线下演练为什么不出问题"><a href="#线下演练为什么不出问题" class="headerlink" title="线下演练为什么不出问题"></a>线下演练为什么不出问题</h2><p>VIP漂移这种操作，我们在线下演练过，当时应用很快就切换完了。为什么到了线上就会卡住呢？这是因为，线下没有加上IO hang住导致SQL处理时间过长这一条件。SQL很快就返回了，所以我们线下的线程只有很小的概率卡在socket read上面。况且有几十个线程在消费，卡一两个无关大局。</p>
<p>而在我们这次上面，由于SQL处理时间超长，所以基本所有的线程都在VIP漂移的那一刻执行socket read即等待数据库返回阶段，就导致所有线程全部hang住等。这时候只能等待tcp_keepalive或者重启了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要保证高可用，任何远程调用都需要设置超时。否则就会导致应用长时间无法响应这样的现象。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/Netty-01-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/Netty-01-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Netty-01-心跳机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-14 20:44:36 / Modified: 20:50:17" itemprop="dateCreated datePublished" datetime="2021-06-14T20:44:36+08:00">2021-06-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="如何实现心跳"><a href="#如何实现心跳" class="headerlink" title="如何实现心跳"></a>如何实现心跳</h2><p>我们可以通过两种方式实现心跳机制:</p>
<ul>
<li>使用 TCP 协议层面的 keepalive 机制.</li>
<li>在应用层上实现自定义的心跳机制.</li>
</ul>
<p>虽然在 TCP 协议层面上, 提供了 keepalive 保活机制, 但是使用它有几个缺点:</p>
<ol>
<li>它不是 TCP 的标准协议, 并且是默认关闭的.</li>
<li>TCP keepalive 机制依赖于操作系统的实现, 默认的 keepalive 心跳时间是 两个小时, 并且对 keepalive 的修改需要系统调用(或者修改系统配置), 灵活性不够.</li>
<li>TCP keepalive 与 TCP 协议绑定, 因此如果需要更换为 UDP 协议时, keepalive 机制就失效了.</li>
</ol>
<p>虽然使用 TCP 层面的 keepalive 机制比自定义的应用层心跳机制节省流量, 但是基于上面的几点缺点, 一般的实践中, 人们大多数都是选择在应用层上实现自定义的心跳.</p>
<p>既然如此, 那么我们就来大致看看在在 Netty 中是怎么实现心跳的吧. 在 Netty 中, 实现心跳机制的关键是 IdleStateHandler, 它可以对一个 Channel 的 读/写设置定时器, 当 Channel 在一定事件间隔内没有数据交互时(即处于 idle 状态), 就会触发指定的事件.</p>
<h2 id="使用-Netty-实现心跳"><a href="#使用-Netty-实现心跳" class="headerlink" title="使用 Netty 实现心跳"></a><strong>使用 Netty 实现心跳</strong></h2><p>上面我们提到了, 在 Netty 中, 实现心跳机制的关键是 IdleStateHandler, 那么这个 Handler 如何使用呢? 我们来看看它的构造器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public IdleStateHandler(int readerIdleTimeSeconds, int writerIdleTimeSeconds, int allIdleTimeSeconds) &#123;</span><br><span class="line">    this((long)readerIdleTimeSeconds, (long)writerIdleTimeSeconds, (long)allIdleTimeSeconds, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化一个 IdleStateHandler 需要提供三个参数:</p>
<ul>
<li>readerIdleTimeSeconds, 读超时. 即当在指定的时间间隔内没有从 Channel 读取到数据时, 会触发一个 READER_IDLE 的 IdleStateEvent 事件.</li>
<li>writerIdleTimeSeconds, 写超时. 即当在指定的时间间隔内没有数据写入到 Channel 时, 会触发一个 WRITER_IDLE 的 IdleStateEvent 事件.</li>
<li>allIdleTimeSeconds, 读/写超时. 即当在指定的时间间隔内没有读或写操作时, 会触发一个 ALL_IDLE 的 IdleStateEvent 事件.</li>
</ul>
<p>为了展示具体的 IdleStateHandler 实现的心跳机制, 下面我们来构造一个具体的EchoServer 的例子, 这个例子的行为如下:</p>
<ol>
<li>在这个例子中, 客户端和服务器通过 TCP 长连接进行通信.</li>
<li>TCP 通信的报文格式是:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--------+-----+---------------+ </span><br><span class="line">| Length |Type |   Content     |</span><br><span class="line">|   17   |  1  |&quot;HELLO, WORLD&quot; |</span><br><span class="line">+--------+-----+---------------+</span><br></pre></td></tr></table></figure>

<ol>
<li>客户端每隔一个随机的时间后, 向服务器发送消息, 服务器收到消息后, 立即将收到的消息原封不动地回复给客户端.</li>
<li>若客户端在指定的时间间隔内没有读/写操作, 则客户端会自动向服务器发送一个 PING 心跳, 服务器收到 PING 心跳消息时, 需要回复一个 PONG 消息.</li>
</ol>
<h3 id="通用部分"><a href="#通用部分" class="headerlink" title="通用部分"></a>通用部分</h3><p>根据上面定义的行为, 我们接下来实现心跳的通用部分 CustomHeartbeatHandler:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CustomHeartbeatHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123;</span><br><span class="line">    public static final byte PING_MSG &#x3D; 1;</span><br><span class="line">    public static final byte PONG_MSG &#x3D; 2;</span><br><span class="line">    public static final byte CUSTOM_MSG &#x3D; 3;</span><br><span class="line">    protected String name;</span><br><span class="line">    private int heartbeatCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public CustomHeartbeatHandler(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext context, ByteBuf byteBuf) throws Exception &#123;</span><br><span class="line">        if (byteBuf.getByte(4) &#x3D;&#x3D; PING_MSG) &#123;</span><br><span class="line">            sendPongMsg(context);</span><br><span class="line">        &#125; else if (byteBuf.getByte(4) &#x3D;&#x3D; PONG_MSG)&#123;</span><br><span class="line">            System.out.println(name + &quot; get pong msg from &quot; + context.channel().remoteAddress());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handleData(context, byteBuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void sendPingMsg(ChannelHandlerContext context) &#123;</span><br><span class="line">        ByteBuf buf &#x3D; context.alloc().buffer(5);</span><br><span class="line">        buf.writeInt(5);</span><br><span class="line">        buf.writeByte(PING_MSG);</span><br><span class="line">        context.writeAndFlush(buf);</span><br><span class="line">        heartbeatCount++;</span><br><span class="line">        System.out.println(name + &quot; sent ping msg to &quot; + context.channel().remoteAddress() + &quot;, count: &quot; + heartbeatCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void sendPongMsg(ChannelHandlerContext context) &#123;</span><br><span class="line">        ByteBuf buf &#x3D; context.alloc().buffer(5);</span><br><span class="line">        buf.writeInt(5);</span><br><span class="line">        buf.writeByte(PONG_MSG);</span><br><span class="line">        context.channel().writeAndFlush(buf);</span><br><span class="line">        heartbeatCount++;</span><br><span class="line">        System.out.println(name + &quot; sent pong msg to &quot; + context.channel().remoteAddress() + &quot;, count: &quot; + heartbeatCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void handleData(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; IdleStateHandler 所产生的 IdleStateEvent 的处理逻辑.</span><br><span class="line">        if (evt instanceof IdleStateEvent) &#123;</span><br><span class="line">            IdleStateEvent e &#x3D; (IdleStateEvent) evt;</span><br><span class="line">            switch (e.state()) &#123;</span><br><span class="line">                case READER_IDLE:</span><br><span class="line">                    handleReaderIdle(ctx);</span><br><span class="line">                    break;</span><br><span class="line">                case WRITER_IDLE:</span><br><span class="line">                    handleWriterIdle(ctx);</span><br><span class="line">                    break;</span><br><span class="line">                case ALL_IDLE:</span><br><span class="line">                    handleAllIdle(ctx);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.err.println(&quot;---&quot; + ctx.channel().remoteAddress() + &quot; is active---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.err.println(&quot;---&quot; + ctx.channel().remoteAddress() + &quot; is inactive---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void handleReaderIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        System.err.println(&quot;---READER_IDLE---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void handleWriterIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        System.err.println(&quot;---WRITER_IDLE---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void handleAllIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        System.err.println(&quot;---ALL_IDLE---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 CustomHeartbeatHandler 负责心跳的发送和接收, 我们接下来详细地分析一下它的作用. 我们在前面提到, IdleStateHandler 是实现心跳的关键, 它会根据不同的 IO idle 类型来产生不同的 IdleStateEvent 事件, 而这个事件的捕获, 其实就是在 userEventTriggered 方法中实现的.</p>
<p>我们来看看 CustomHeartbeatHandler.userEventTriggered 的具体实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">    if (evt instanceof IdleStateEvent) &#123;</span><br><span class="line">        IdleStateEvent e &#x3D; (IdleStateEvent) evt;</span><br><span class="line">        switch (e.state()) &#123;</span><br><span class="line">            case READER_IDLE:</span><br><span class="line">                handleReaderIdle(ctx);</span><br><span class="line">                break;</span><br><span class="line">            case WRITER_IDLE:</span><br><span class="line">                handleWriterIdle(ctx);</span><br><span class="line">                break;</span><br><span class="line">            case ALL_IDLE:</span><br><span class="line">                handleAllIdle(ctx);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 userEventTriggered 中, 根据 IdleStateEvent 的 state() 的不同, 而进行不同的处理. 例如如果是读取数据 idle, 则 <code>e.state() == READER_IDLE</code>, 因此就调用 handleReaderIdle 来处理它.</p>
<p>CustomHeartbeatHandler 提供了三个 idle 处理方法: handleReaderIdle, handleWriterIdle, handleAllIdle, 这三个方法目前只有默认的实现, 它需要在子类中进行重写, 现在我们暂时略过它们, 在具体的客户端和服务器的实现部分时再来看它们.</p>
<p>知道了这一点后, 我们接下来看看数据处理部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void channelRead0(ChannelHandlerContext context, ByteBuf byteBuf) throws Exception &#123;</span><br><span class="line">    if (byteBuf.getByte(4) &#x3D;&#x3D; PING_MSG) &#123;</span><br><span class="line">        sendPongMsg(context);</span><br><span class="line">    &#125; else if (byteBuf.getByte(4) &#x3D;&#x3D; PONG_MSG)&#123;</span><br><span class="line">        System.out.println(name + &quot; get pong msg from &quot; + context.channel().remoteAddress());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        handleData(context, byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>CustomHeartbeatHandler.channelRead0</code> 中, 我们首先根据报文协议:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--------+-----+---------------+ </span><br><span class="line">| Length |Type |   Content     |</span><br><span class="line">|   17   |  1  |&quot;HELLO, WORLD&quot; |</span><br><span class="line">+--------+-----+---------------+</span><br></pre></td></tr></table></figure>

<p>来判断当前的报文类型, 如果是 PING_MSG 则表示是服务器收到客户端的 PING 消息, 此时服务器需要回复一个 PONG 消息, 其消息类型是 PONG_MSG.</p>
<p>扔报文类型是 PONG_MSG, 则表示是客户端收到服务器发送的 PONG 消息, 此时<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247491704&idx=1&sn=60738828c02e3cc2e4ada24a8a8bc07a&chksm=ebd5df54dca25642b6e71daa96c7780ac3a6208ecc1d002d8d558ef28a8c3b2d91688de9d66d&scene=21#wechat_redirect">打印一个 log</a> 即可.</p>
<h3 id="客户端部分"><a href="#客户端部分" class="headerlink" title="客户端部分"></a>客户端部分</h3><h4 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioEventLoopGroup workGroup &#x3D; new NioEventLoopGroup(4);</span><br><span class="line">        Random random &#x3D; new Random(System.currentTimeMillis());</span><br><span class="line">        try &#123;</span><br><span class="line">            Bootstrap bootstrap &#x3D; new Bootstrap();</span><br><span class="line">            bootstrap</span><br><span class="line">                    .group(workGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            ChannelPipeline p &#x3D; socketChannel.pipeline();</span><br><span class="line">                            p.addLast(new IdleStateHandler(0, 0, 5));</span><br><span class="line">                            p.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, -4, 0));</span><br><span class="line">                            p.addLast(new ClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            Channel ch &#x3D; bootstrap.remoteAddress(&quot;127.0.0.1&quot;, 12345).connect().sync().channel();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                String content &#x3D; &quot;client msg &quot; + i;</span><br><span class="line">                ByteBuf buf &#x3D; ch.alloc().buffer();</span><br><span class="line">                buf.writeInt(5 + content.getBytes().length);</span><br><span class="line">                buf.writeByte(CustomHeartbeatHandler.CUSTOM_MSG);</span><br><span class="line">                buf.writeBytes(content.getBytes());</span><br><span class="line">                ch.writeAndFlush(buf);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(random.nextInt(20000));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是 Netty 的客户端端的初始化代码, 使用过 Netty 的朋友对这个代码应该不会陌生. 别的部分我们就不再赘述, 我们来看看 <code>ChannelInitializer.initChannel</code> 部分即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">        ChannelPipeline p &#x3D; socketChannel.pipeline();</span><br><span class="line">        p.addLast(new IdleStateHandler(0, 0, 5));</span><br><span class="line">        p.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, -4, 0));</span><br><span class="line">        p.addLast(new ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们给 pipeline 添加了三个 Handler, IdleStateHandler 这个 handler 是心跳机制的核心, 我们为客户端端设置了读写 idle 超时, 时间间隔是5s, 即如果客户端在间隔 5s 后都没有收到服务器的消息或向服务器发送消息, 则产生 ALL_IDLE 事件.</p>
<p>接下来我们添加了 LengthFieldBasedFrameDecoder, 它是负责解析我们的 TCP 报文, 因为和本文的目的无关, 因此这里不详细展开.</p>
<p>最后一个 Handler 是 ClientHandler, 它继承于 CustomHeartbeatHandler, 是我们处理业务逻辑部分.</p>
<h4 id="客户端-Handler"><a href="#客户端-Handler" class="headerlink" title="客户端 Handler"></a>客户端 Handler</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ClientHandler extends CustomHeartbeatHandler &#123;</span><br><span class="line">    public ClientHandler() &#123;</span><br><span class="line">        super(&quot;client&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleData(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) &#123;</span><br><span class="line">        byte[] data &#x3D; new byte[byteBuf.readableBytes() - 5];</span><br><span class="line">        byteBuf.skipBytes(5);</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line">        String content &#x3D; new String(data);</span><br><span class="line">        System.out.println(name + &quot; get content: &quot; + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleAllIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        super.handleAllIdle(ctx);</span><br><span class="line">        sendPingMsg(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClientHandler 继承于 CustomHeartbeatHandler, 它重写了两个方法, 一个是 handleData, 在这里面实现 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247491704&idx=1&sn=60738828c02e3cc2e4ada24a8a8bc07a&chksm=ebd5df54dca25642b6e71daa96c7780ac3a6208ecc1d002d8d558ef28a8c3b2d91688de9d66d&scene=21#wechat_redirect">仅仅打印</a>收到的消息.</p>
<p>第二个重写的方法是 handleAllIdle. 我们在前面提到, 客户端负责发送心跳的 PING 消息, 当客户端产生一个 ALL_IDLE 事件后, 会导致父类的 CustomHeartbeatHandler.userEventTriggered 调用, 而 userEventTriggered 中会根据 e.state() 来调用不同的方法, 因此最后调用的是 ClientHandler.handleAllIdle, 在这个方法中, 客户端调用 sendPingMsg 向服务器发送一个 PING 消息.</p>
<h3 id="服务器部分"><a href="#服务器部分" class="headerlink" title="服务器部分"></a>服务器部分</h3><h4 id="服务器初始化"><a href="#服务器初始化" class="headerlink" title="服务器初始化"></a>服务器初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioEventLoopGroup bossGroup &#x3D; new NioEventLoopGroup(1);</span><br><span class="line">        NioEventLoopGroup workGroup &#x3D; new NioEventLoopGroup(4);</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerBootstrap bootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">            bootstrap</span><br><span class="line">                    .group(bossGroup, workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            ChannelPipeline p &#x3D; socketChannel.pipeline();</span><br><span class="line">                            p.addLast(new IdleStateHandler(10, 0, 0));</span><br><span class="line">                            p.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, -4, 0));</span><br><span class="line">                            p.addLast(new ServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            Channel ch &#x3D; bootstrap.bind(12345).sync().channel();</span><br><span class="line">            ch.closeFuture().sync();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器的初始化部分也没有什么好说的, 它也和客户端的初始化一样, 为 pipeline 添加了三个 Handler.</p>
<h4 id="服务器-Handler"><a href="#服务器-Handler" class="headerlink" title="服务器 Handler"></a>服务器 Handler</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ServerHandler extends CustomHeartbeatHandler &#123;</span><br><span class="line">    public ServerHandler() &#123;</span><br><span class="line">        super(&quot;server&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleData(ChannelHandlerContext channelHandlerContext, ByteBuf buf) &#123;</span><br><span class="line">        byte[] data &#x3D; new byte[buf.readableBytes() - 5];</span><br><span class="line">        ByteBuf responseBuf &#x3D; Unpooled.copiedBuffer(buf);</span><br><span class="line">        buf.skipBytes(5);</span><br><span class="line">        buf.readBytes(data);</span><br><span class="line">        String content &#x3D; new String(data);</span><br><span class="line">        System.out.println(name + &quot; get content: &quot; + content);</span><br><span class="line">        channelHandlerContext.write(responseBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleReaderIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        super.handleReaderIdle(ctx);</span><br><span class="line">        System.err.println(&quot;---client &quot; + ctx.channel().remoteAddress().toString() + &quot; reader timeout, close it---&quot;);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServerHandler 继承于 CustomHeartbeatHandler, 它重写了两个方法, 一个是 handleData, 在这里面实现 EchoServer 的功能: 即收到客户端的消息后, 立即原封不动地将消息回复给客户端.</p>
<p>第二个重写的方法是 handleReaderIdle, 因为服务器仅仅对客户端的读 idle 感兴趣, 因此只重新了这个方法. 若服务器在指定时间后没有收到客户端的消息, 则会触发 READER_IDLE 消息, 进而会调用 handleReaderIdle 这个方法.</p>
<p>我们在前面提到, 客户端负责发送心跳的 PING 消息, 并且服务器的 READER_IDLE 的超时时间是客户端发送 PING 消息的间隔的两倍, 因此当服务器 READER_IDLE 触发时, 就可以确定是客户端已经掉线了, 因此服务器直接关闭客户端连接即可.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>使用 Netty 实现心跳机制的关键就是利用 IdleStateHandler 来产生对应的 idle 事件.</li>
<li>一般是客户端负责发送心跳的 PING 消息, 因此客户端注意关注 ALL_IDLE 事件, 在这个事件触发后, 客户端需要向服务器发送 PING 消息, 告诉服务器”我还存活着”.</li>
<li>服务器是接收客户端的 PING 消息的, 因此服务器关注的是 READER_IDLE 事件, 并且服务器的 READER_IDLE 间隔需要比客户端的 ALL_IDLE 事件间隔大(例如客户端ALL_IDLE 是5s 没有读写时触发, 因此服务器的 READER_IDLE 可以设置为10s)</li>
<li>当服务器收到客户端的 PING 消息时, 会发送一个 PONG 消息作为回复. 一个 PING-PONG 消息对就是一个心跳交互.</li>
</ol>
<h2 id="实现客户端的断线重连"><a href="#实现客户端的断线重连" class="headerlink" title="实现客户端的断线重连"></a><strong>实现客户端的断线重连</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    private NioEventLoopGroup workGroup &#x3D; new NioEventLoopGroup(4);</span><br><span class="line">    private Channel channel;</span><br><span class="line">    private Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Client client &#x3D; new Client();</span><br><span class="line">        client.start();</span><br><span class="line">        client.sendData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendData() throws Exception &#123;</span><br><span class="line">        Random random &#x3D; new Random(System.currentTimeMillis());</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            if (channel !&#x3D; null &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                String content &#x3D; &quot;client msg &quot; + i;</span><br><span class="line">                ByteBuf buf &#x3D; channel.alloc().buffer(5 + content.getBytes().length);</span><br><span class="line">                buf.writeInt(5 + content.getBytes().length);</span><br><span class="line">                buf.writeByte(CustomHeartbeatHandler.CUSTOM_MSG);</span><br><span class="line">                buf.writeBytes(content.getBytes());</span><br><span class="line">                channel.writeAndFlush(buf);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(random.nextInt(20000));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            bootstrap &#x3D; new Bootstrap();</span><br><span class="line">            bootstrap</span><br><span class="line">                    .group(workGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            ChannelPipeline p &#x3D; socketChannel.pipeline();</span><br><span class="line">                            p.addLast(new IdleStateHandler(0, 0, 5));</span><br><span class="line">                            p.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, -4, 0));</span><br><span class="line">                            p.addLast(new ClientHandler(Client.this));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            doConnect();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doConnect() &#123;</span><br><span class="line">        if (channel !&#x3D; null &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelFuture future &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 12345);</span><br><span class="line"></span><br><span class="line">        future.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            public void operationComplete(ChannelFuture futureListener) throws Exception &#123;</span><br><span class="line">                if (futureListener.isSuccess()) &#123;</span><br><span class="line">                    channel &#x3D; futureListener.channel();</span><br><span class="line">                    System.out.println(&quot;Connect to server successfully!&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;Failed to connect to server, try connect after 10s&quot;);</span><br><span class="line"></span><br><span class="line">                    futureListener.channel().eventLoop().schedule(new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            doConnect();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, 10, TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中, 我们抽象出 doConnect 方法, 它负责客户端和服务器的 TCP 连接的建立, 并且当 TCP 连接失败时, doConnect 会 通过 <code>channel().eventLoop().schedule</code> 来延时10s 后尝试重新连接.</p>
<h3 id="客户端-Handler-1"><a href="#客户端-Handler-1" class="headerlink" title="客户端 Handler"></a>客户端 Handler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ClientHandler extends CustomHeartbeatHandler &#123;</span><br><span class="line">    private Client client;</span><br><span class="line">    public ClientHandler(Client client) &#123;</span><br><span class="line">        super(&quot;client&quot;);</span><br><span class="line">        this.client &#x3D; client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleData(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) &#123;</span><br><span class="line">        byte[] data &#x3D; new byte[byteBuf.readableBytes() - 5];</span><br><span class="line">        byteBuf.skipBytes(5);</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line">        String content &#x3D; new String(data);</span><br><span class="line">        System.out.println(name + &quot; get content: &quot; + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleAllIdle(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        super.handleAllIdle(ctx);</span><br><span class="line">        sendPingMsg(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        super.channelInactive(ctx);</span><br><span class="line">        client.doConnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断线重连的关键一点是检测连接是否已经断开. 因此我们改写了 ClientHandler, 重写了 channelInactive 方法. 当 TCP 连接断开时, 会回调 channelInactive 方法, 因此我们在这个方法中调用 client.doConnect() 来进行重连</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/Netty-00-%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/Netty-00-%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Netty-00-入门简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-14 20:44:36" itemprop="dateCreated datePublished" datetime="2021-06-14T20:44:36+08:00">2021-06-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-05-13 12:23:35" itemprop="dateModified" datetime="2024-05-13T12:23:35+08:00">2024-05-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="BIO-vs-NIO-vs-AIO"><a href="#BIO-vs-NIO-vs-AIO" class="headerlink" title="BIO vs  NIO vs AIO"></a>BIO vs  NIO vs AIO</h3><p><strong>BIO: 同步阻塞式IO</strong>  打个比喻您打了专车，在您没有到之前司机就在出发地等您上车。您上车之后司机专门送您到目的地。在这个例子中您扮演着IO中的网络事件，司机扮演着处理网络事件的线程。整个过程中您如果没有任何事件发生司机一直都在等待这就是同步阻塞﻿。</p>
<p><strong>NIO:同步非阻塞IO</strong>  银行柜员在等待人办理银行业务，人们去银行后首先要到取号机上取号然后等待对应的柜台叫号。在这个例子中银行柜员扮演着selector，办理银行业务的人扮演者网络事件，而取号机扮演者register的作用，银行柜台就是channel。整个过程中当没有人来办业务时，柜员是可以去做其他事情这就是非阻塞。</p>
<p><strong>AIO:异步非阻塞IO</strong>  您点外卖后就去忙其他的事情了，等骑手把外卖送达后打电话告诉您外卖放外卖柜子里了；您闲下来的时候去取外卖。在这个例子里您扮演着处理网络事件线的程，外卖是网络事件；在这个过程中您可以在外卖还没有送来的时候做些其他的事情，等外卖送达后只是向您发送了一个外卖送达的事件。这就是异步和非阻塞。﻿</p>
<p>通过网络服务端代码的编写来让我们直观感受一下他们的区别：</p>
<p>BIOServer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;  &#x2F;&#x2F;定义一个循环接收客户端的Socket连接请求。初始化一个线程池对象  private static ExecutorService poolHandler &#x3D; new ThreadPoolExecutor(5, 5,                120, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10));    public static void main(String[] args) &#123;        try &#123;            &#x2F;&#x2F; 注册端口            ServerSocket ss &#x3D; new ServerSocket(9999);            while (true) &#123;                Socket socket &#x3D; ss.accept();                &#x2F;&#x2F; 把Socket封装成一个任务对象交给线程池处理                Runnable target &#x3D; new ServerRunnable(socket);                poolHandler.execute(target);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;</span><br><span class="line">    public static class ServerRunnable implements Runnable &#123;      private Socket socket;      public ServerRunnable(Socket socket) &#123;          this.socket &#x3D; socket;      &#125;      @Override      public void run() &#123;          &#x2F;&#x2F; 处理接收的客户端Socket通信需求          try &#123;              InputStream is &#x3D; socket.getInputStream();              BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(is));              String msg;              while ((msg &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;处理数据的粘包拆包                &#x2F;&#x2F;对完整的数据包进行解码操作                &#x2F;&#x2F;得到客户端消息                &#x2F;&#x2F;触发各种统计类事件如心跳检测 信息统计                 &#x2F;&#x2F;处理客户端的消息                &#x2F;&#x2F;得到响应消息                &#x2F;&#x2F;对响应消息进行编码              &#125;          &#125; catch (IOException e) &#123;              e.printStackTrace();            &#x2F;&#x2F;处理网络断开事件            &#x2F;&#x2F;处理其他异常事件          &#125;      &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>NIOServer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;    public static void main(String[] args) throws IOException &#123;        &#x2F;&#x2F;获取ServerSocketChannel        ServerSocketChannel ssChannel &#x3D; ServerSocketChannel.open();        &#x2F;&#x2F;设置非阻塞模式        ssChannel.configureBlocking(false);        &#x2F;&#x2F;绑定端口        ssChannel.bind(new InetSocketAddress(9999));        &#x2F;&#x2F;获取选择器        Selector selector &#x3D; Selector.open();        &#x2F;&#x2F;将ServerSocketChannel注册到选择器上，并且监听建立连接事件        ssChannel.register(selector, SelectionKey.OP_ACCEPT);        &#x2F;&#x2F; 使用Selector选择器轮询已经就绪好的事件        while (selector.select() &gt; 0) &#123;            &#x2F;&#x2F; 获取选择器就绪事件            Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();            &#x2F;&#x2F;遍历事件            while (it.hasNext()) &#123;                SelectionKey sk &#x3D; it.next();                &#x2F;&#x2F;判断事件类型                if (sk.isAcceptable()) &#123;                    &#x2F;&#x2F; 获取客户端channel                    SocketChannel channel &#x3D; ssChannel.accept();                    &#x2F;&#x2F;切换非阻塞模式                    channel.configureBlocking(false);                    &#x2F;&#x2F;将该channel注册到选择器上                    channel.register(selector, SelectionKey.OP_READ);                &#125; else if (sk.isReadable()) &#123;                    &#x2F;&#x2F;获取channel                    SocketChannel sChannel &#x3D; (SocketChannel) sk.channel();                    &#x2F;&#x2F;读取网络数据                    ByteBuffer buf &#x3D; ByteBuffer.allocate(1024);                    int len &#x3D; 0;                    while ((len &#x3D; sChannel.read(buf)) &gt; 0) &#123;                        &#x2F;&#x2F;处理数据的粘包拆包                        &#x2F;&#x2F;对完整的数据包进行解码操作                        &#x2F;&#x2F;得到客户端消息                        &#x2F;&#x2F;触发各种统计类事件如心跳检测 信息统计                     &#125;                &#125;else if(sk.isWritable())&#123;                        &#x2F;&#x2F;得到响应消息                        &#x2F;&#x2F;对响应消息进行编码                &#125;                &#x2F;&#x2F; 15.取消选择键SelectionKey                it.remove();            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>用Netty进行网络编程时代码是这样的：</p>
<p>NettyServer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class NettyServer &#123;    public static void main(String[] args) throws Exception&#123;        &#x2F;&#x2F;设置接受网络连接线程池        NioEventLoopGroup bossGroup &#x3D; new NioEventLoopGroup(1);        &#x2F;&#x2F;设置处理网络除连接外所有事件线程的线程池        NioEventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();        ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">        serverBootstrap.group(bossGroup,workerGroup)                .channel(NioServerSocketChannel.class)&#x2F;&#x2F;设置Channel类型                .option(ChannelOption.SO_BACKLOG,1024)                .handler(new ChannelInitializer&lt;ServerSocketChannel&gt;() &#123;                    @Override                    protected void initChannel(ServerSocketChannel ch) throws Exception &#123;                      &#x2F;&#x2F;设置处理网络连接的Handler                        ch.pipeline().addLast(&quot;serverBindHandler&quot;,                         new NettyBindHandler(NettyTcpServer.this,serverStreamLifecycleListeners));                    &#125;                &#125;)                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;                    @Override                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;                        ch.pipeline()                                .addLast(&quot;protocolHandler&quot;, new NettyProtocolHandler())&#x2F;&#x2F;设置编解码器                                .addLast(&quot;serverIdleHandler&quot;,                                        new IdleStateHandler(0, 0, serverIdleTimeInSeconds))&#x2F;&#x2F;设置心跳检测                                .addLast(&quot;serverHandler&quot;,new NettyServerStreamHandler(NettyTcpServer.this, false,                                        serverStreamLifecycleListeners,                                          serverStreamMessageListeners));&#x2F;&#x2F;设置业务处理逻辑                    &#125;                &#125;);</span><br><span class="line">        ChannelFuture channelFuture &#x3D; serverBootstrap.bind(9000).sync();        channelFuture.channel().closeFuture().sync();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>BIO和NIO编程在网络事件发生后都需要进行处理数据的粘包拆包、对完整的数据包进行解码、触发各种统计类事件、对响应消息进行编码、监听各种网络异常、需要对底层网络和通信协议有一定的了解。﻿</p>
<p>用Netty编程时只需要设置Handler就能快速的进行业务开发而不用关心数据的读取及网络事件的分发处理.让开发者从底层网络通信中解放出来。</p>
<p>从这些对比中我们可以看出Netty开发网络程序要求低，使用者无需太多关心和业务无关的信息。</p>
<p><strong>定制能力强</strong></p>
<p><strong>通过ChannelHandler灵活扩展</strong></p>
<p>多数情况下我们自定义的Handler会有多个，那么他们是怎么进行协调合作的呢？接下一起探索handler之间的协调合作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dSPBDsriaSyCRnSzWNxvdXt7mnxoSZvspbP5mBLq87byzGa2F5vN9IZyQ/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">﻿﻿</p>
<p>通过上图我们可以知道我们定义的handler在Netty里是通过双向链表进行关联的。﻿</p>
<p>介绍一下读网络事件发生后Handler事件流：</p>
<ul>
<li>假如每个handler都会把读事件向下一个InboundHandler类型的节点进行传递，此时的调用链路为head-&gt;A-&gt;B-&gt;C-&gt;tail；</li>
<li>假如B业务handler处理数据后不把读事件继续向下传递,此时B可以在自己内部选择不向下一个节点传递读事件.此时调用链路变为head-&gt;A-&gt;B；</li>
</ul>
<p>当服务端有数据需要写入时又会发生什么呢？</p>
<ul>
<li>假如每个handler都会把读事件向下一个OutboundHandler类型的节点进行传递,当C业务handler发送响应数据时此时调用链路为C-&gt;B-&gt;head；</li>
<li>假如业务B是参数校验的的headler,当校验失败就响应客户端.此时调用的链路为B-&gt;head﻿；</li>
</ul>
<p>我们可以看出Netty通过控制InboundHandler节点的调用来决定读事件响应链路；通过控制OutboundHandler节点的调用来决定写事件调用链路。</p>
<p><strong>Handler强大</strong></p>
<p>Netty通过内置多种Handler让你在不了解底层网络、通信协议、编解码的背景下也可进行网络应用程序。它都内置有哪些Handler呢？</p>
<h3 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h3><p>当你通过Netty发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码，从字节转换为另一种格式（比如java对象）。如果是出站消息，它会被编码成字节。</p>
<h4 id="TCP粘包拆包"><a href="#TCP粘包拆包" class="headerlink" title="TCP粘包拆包"></a><strong>TCP粘包拆包</strong></h4><p>大多数基于Netty通信底层都会使用TCP进行的通信。TCP在发送数据流的时一定会把整条数据流单独发送吗？答案是否定的。TCP在发送数据包的时会存在拆包和粘包问题。什么是TCP的粘包和拆包呢？</p>
<p><strong>TCP拆包:</strong> 产生的原因就是消息体太大了,一个数据包里只能发送消息体的一部分；</p>
<p><strong>TCP粘包:</strong> 产生的原因就是有多条消息体需要发送,一个数据包可以存放多个消息体；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS4WVoHfAiaHuiaKicXmq9lhADmwAek4OXvYd4H5X5eqZvRXicCZgiadKUic9Q/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>由于篇幅有限关于TCP拆包和粘包只是大致说明了一些。</p>
<h4 id="编解码Handler"><a href="#编解码Handler" class="headerlink" title="编解码Handler"></a><strong>编解码Handler</strong></h4><p>Netty提供了三种解码器来解决TCP的拆包和粘包,他们分别是：</p>
<ul>
<li>LineBasedFrameDecoder(回车换行分包);</li>
<li>DelimiterBasedFrameDecoder(特殊分隔符分包);</li>
<li>FixedLengthFrameDecoder(固定长度报文来分包)</li>
</ul>
<p>此外Netty还提供了N：</p>
<ul>
<li>编解码字符串的StringEncoder和StringDecoder;</li>
<li>用于处理HTTP协议编解码HttpObjectDecoder和HttpObjectEncoder;</li>
<li>用于处理protobuf编解码ProtobufVarint32FrameDecoder和ProtobufDecoder；</li>
</ul>
<p>除了以上介绍的编解码Netty内部还有很多内置编解码器,当您使用Netty开发时如果有用到编解码的时候可以首先查询一下Netty内部是否有实现。</p>
<h3 id="支持多种主流协议"><a href="#支持多种主流协议" class="headerlink" title="支持多种主流协议"></a>支持多种主流协议</h3><p>从Netty源码包上可以看出Netty基本上覆盖了主流协议的编解码实现，如HTTP、Protobuf、WebSocket、二进制等主流协议。</p>
<h4 id=""><a href="#" class="headerlink" title="﻿﻿"></a>﻿﻿<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS0AOkj10sEic1TOgOU3Nz3OibVExRDnHl1Gc5PqH7Qic7s4qukyA1y1ibFg/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></h4><h3 id="idle-心跳检测"><a href="#idle-心跳检测" class="headerlink" title="idle(心跳检测)"></a>idle(心跳检测)</h3><p>当需要监听网络连接是否长时间没有数据交换（如发送心跳包、关闭连接等）就可以使用内置的IdleStateHandler。</p>
<p>IdleStateHandler接收三个参数：</p>
<ul>
<li>readerIdleTimeSeconds: 读取空闲时间，即从上次读取数据到现在的秒数。</li>
<li>writerIdleTimeSeconds: 写入空闲时间，即从上次写入数据到现在的秒数。</li>
<li>allIdleTimeSeconds: 读写都空闲的时间，即从上次读写数据到现在的秒数。</li>
</ul>
<p>当达到设定的空闲时间阈值时，IdleStateHandler会触发对应的IdleState事件，这些事件包括READ_IDLE、WRITE_IDLE和ALL_IDLE。你可以通过实现ChannelInboundHandler的channelIdle方法来监听这些事件，并在事件发生时执行相应的操作。</p>
<p><strong>高性能</strong></p>
<h3 id="一次网络通信都发生了什么"><a href="#一次网络通信都发生了什么" class="headerlink" title="一次网络通信都发生了什么"></a>一次网络通信都发生了什么</h3><p>1.客户端确定需要发送的数据；</p>
<p>2.数据从程序到系统然后通过网卡发送；</p>
<p>3.服务端收到读事件后把数据从系统读取到应用中；</p>
<p>4.应用处理客户端信息；</p>
<h3 id="Netty怎么提高通信性能"><a href="#Netty怎么提高通信性能" class="headerlink" title="Netty怎么提高通信性能"></a>Netty怎么提高通信性能</h3><ul>
<li>数据在系统中的存储Netty使用<strong>ByteBuf</strong>内存池来减少申请内存耗时；</li>
<li>数据在用户态到内核态的传输Netty采用了<strong>内存零拷贝</strong>（减少用户态到内核态的两次拷贝）来<strong>减少传输耗时；</strong></li>
</ul>
<p><strong><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dSQbtEAPTNMt5GICMyCvgGicuicHXZB4Htm75JHFaKs5xNgWE6JolgIGrQ/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></strong></p>
<ul>
<li>﻿﻿数据在网络中的传输  数据传输时间取决于数据传输速度、数据包数量。对于传输速度无法优化，Netty内置了许多<strong>编码器</strong>，可以选择对数据压缩比较好的解码器来减少数据包的数量，以此来减少耗时；</li>
<li>服务端对网络事件的处理Netty采用主次<strong>Reactor多线程模型来加快对网络事件的处理</strong>，传统的BIO不能支持太多网络连接以及对系统资源使用率比较低。传统的NIO当网络连接数超多时网络事件得不到快速响应,造成大量客户端进行重试。</li>
</ul>
<p>﻿﻿<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dSzWEibh5E65kPBoibdTKprwakA6RRX2DVyVZHqkMK1vFLC7pQHPeNzN1g/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><strong>reactor单线程模型：</strong> 有一个线程负责处理所有的网络事件。</p>
<p>﻿<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS1cl44RlPrA4W4061kHgS4FYgfJ3dHnnIjJOt1lHthlnUic4Wjz8rlow/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><strong>Reactor多线程模型：</strong>有一个线程单独处理建立网络事件，另外一个线程负责处理其他的网络事件。</p>
<p>﻿﻿<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dSZFCLWyVgA4OVRlBGy6BuyQM6ON49RQNWdH8bQ1FEr7icFnseLYOqiabg/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>主次<strong>Reactor多线程模型：</strong>有一个线程单独处理建立网络事件,把建立网络连接放到线程池中的某一个线程中，这个线程负责大量网络连接的其他请求.</p>
<p>从reactor线程模型上我们可以看出主次Reactor多线程模型可以快速对大量的网络事件进行响应,因此也会缩短网络事件处理时间.</p>
<ul>
<li>客户端消息处理上，Netty采用了无锁串行化设计思想结合volatile的大量使用;通过读写锁提升并发性能来大大缩短了消息处理时间。</li>
</ul>
<p>我们可以看到Netty针对网络传输的各个节点都做到了尽可能的缩短时间，这也是Netty高性能的原因所在。</p>
<p>Netty运行原理</p>
<p>通过以上对Netty是什么，优势有哪些已经有了初步了解。那么它内部是怎么工作的呢？接下来让我们一起看一下它内部的原理。</p>
<p><strong>整体结构</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS2zydhafxsdJySlGIC2LncGBcxCz9ibliaso4lIrr8KRmwzZJBjAuiaic4w/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>上面这张图就是在官网首页的架构图，我们从上到下分析一下。</p>
<ul>
<li><strong>Core</strong>核心层：核心层里Netty最精华的部分，它提供了底层网络通信的通用抽象和实现，包括事件模型、通用API、支持零拷贝的ByteBuf 等；</li>
<li><strong>Protocol Support 协议支持层</strong>：协议支持层基本上覆盖了主流协议的编解码实现，Netty 丰富的协议支持降低了用户的开发成本；</li>
<li><strong>Transport Service 传输服务层：</strong>传输服务层提供了网络传输能力的定义和实现方法。它支持 Socket、HTTP 隧道等传输方式。Netty 对 TCP、UDP 等数据传输做了抽象和封装，让开发者可以更聚焦在业务逻辑实现上，而不必关系底层数据传输的细节；</li>
</ul>
<p>以上可看出Netty的功能、协议、传输方式都比较全，比较强大。</p>
<p><strong>逻辑架构</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS72UajWyyFsVEePGL9BWFY9otrysdlXUNbhaRUJFF3mb3CCVfVgHgWA/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>从图中可以Netty通过网络通信层、事件调度层、服务编排层协调合作来运行程序</p>
<h3 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h3><p>网络通信层的职责是执行网络 I/O 的操作。当网络数据读取到内核缓冲区后，会触发各种网络事件。这些网络事件会分发给事件调度层进行处理。接下来分别看一下Netty服务端和客户端在网络通信层是怎么运行的：</p>
<ul>
<li>Netty服务端：程序启动时会生成一个ServerBootstrap对象，该对象会生成一个NioServerSocketChannel来监听某一个端口的建立网络连接的事件，当网络连接建立后会监听网络连接的各种事件并通知到事件调度层。</li>
<li>﻿Netty客户端：程序启动的时会生成一个Bootstrap对象，该对象会生成一个NioSocketChannel来与服务端建立网络连接的事件，当网络连接建立后会监听网络连接的各种事件并通知到事件调度层。</li>
</ul>
<h3 id="事件调度层"><a href="#事件调度层" class="headerlink" title="事件调度层"></a>事件调度层</h3><p>事件调度层的职责是通过 Reactor 线程模型对各类事件进行聚合处理，通过 Selector 主循环线程集成多种事件(I/O 事件,信号事件,定时事件等)，实际的业务处理逻辑是交由服务编排层中相关的 Handler 完成。事件调度层主要由EventLoopGroup和EventLoop构成。﻿</p>
<ul>
<li>EventLoop 负责处理 I/O 事件和调度任务。每一个NioEventLoop内部都有唯一一个Selector，通过这个Selector可以对注册的channel进行网络事件的读取；NioEventLoop 还有一个内部的任务队列，可以用来提交 Runnable 任务。这些任务会在 NioEventLoop 的线程上下文中执行，确保了任务的顺序执行。</li>
<li>EventLoopGroup  本质是一个线程池，负责管理EventLoop。其主要作用有从线程池挑选一个EventLoop进行channe的注册或者提交一个任务、关闭不再使用的 Channel、释放 Selector 和其他相关资源确保应用程序的干净退出。</li>
</ul>
<h3 id="服务编排层"><a href="#服务编排层" class="headerlink" title="服务编排层"></a>服务编排层</h3><p>服务编排层的职责是通过组装各类handler来实现网络数据流的处理。它是 Netty 的核心处理链，用以实现网络事件的动态编排和有序传播。</p>
<p>服务编排层的核心组件包括 <strong>ChannelHandler、ChannelHandlerContext、ChannelPipeline</strong>。他们之间的关系如下图所示：</p>
<p>﻿﻿<img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrkrXjImG2icPTKeiangL9dS3EkyiaKtmgjichNyttyDSG1OtHFibic2DKmKI1ibfP1FgJtGiba9cXzxibdgg/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li><p>﻿<strong>ChannelHandler</strong>主要分为两类，InboundHandler和OutboundHandler</p>
</li>
<li><p>InboundHandler用于处理从网络流入(inbound)的数据和事件。帮助我们处理接收的数据、连接建立、断开等事件。核心方法有channelActive(网络连接建立成功时会调用)、channelInactive(网络连接断连时调用)、channelRead(接受到数据时调用)、exceptionCaught(如果在处理事件或数据时发生异常，该方法会被调用。可以在这里捕获并处理异常，防止应用程序崩溃。)</p>
</li>
<li><p>OutboundHandler用于处理从应用程序流向网络的出站(outbound)操作,如写入数据,发起连接,关闭连接等核心方法有。</p>
<p>write(写入数据到channel时调用),flush(将缓冲区所有未写入数据立即发送出去),connect(尝试建立网络连接时调用)。</p>
</li>
<li><p>﻿<strong>ChannelHandlerContext</strong>是handler与Netty内部机制交互的主要方式，它使得 handler 可以在不直接访问其他handler的情况下，协同处理I/O事件和数据。同时也是每个ChannelHandler在处理事件时的上下文环境，可以获取到Pipeline、Channel、Allocator等对象。</p>
</li>
<li><p>﻿<strong>ChannelPipeline  Netty</strong>中的关键组件，是一个处理网络I/O事件和数据的有序链表。ChannelPipeline负责将入站（inbound）和出站（outbound）事件分发给链中的各个ChannelHandler，实现了事件驱动的网络编程模型。每个ChannelHandler都有一个唯一的ChannelHandlerContext，用于与ChannelPipeline交互。</p>
</li>
</ul>
<p><strong>运行流程</strong></p>
<p>我们已经从宏观上了解了Netty，接下来我们从服务端的视角简要的看一下Netty整个的运行流程。</p>
<p>1.服务端启动的时把ServerSocketChannel注册到boss EventLoopGroup中某一个EventLoop上，暂时把这个EventLoop叫做server EventLoop；</p>
<p>2.当 serverEventLoop中监听到有建立网络连接的事件后会把底层的SocketChannel和serverSocketChannel封装成为NioSocketChannel；</p>
<p>3.开始把自定义的ChannelHandler加载到NioSocketChannel 里的pipeline中，然后把该NioSocketChannel注册到worker EventLoopGroup中某一个EventLoop上，暂时把这个EventLoop叫做worker  EventLoop；</p>
<p>4.worker  EventLoop开始监听NioSocketChannel上所有网络事件；</p>
<p>5.当有读事件后就会调用pipeline中第一个InboundHandler的channelRead方法进行处理；</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li>Nettry入门：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/52iS3RxIO_to29IG_JoOpw">https://mp.weixin.qq.com/s/52iS3RxIO_to29IG_JoOpw</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-05-tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-05-tomcat/" class="post-title-link" itemprop="url">springboot-starter-05-tomcat</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-13 23:28:38 / Modified: 23:37:09" itemprop="dateCreated datePublished" datetime="2021-06-13T23:28:38+08:00">2021-06-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Spring-Boot是如何创建Tomcat的"><a href="#Spring-Boot是如何创建Tomcat的" class="headerlink" title="Spring Boot是如何创建Tomcat的"></a>Spring Boot是如何创建Tomcat的</h3><p>SpringBoot启动只有一个main方法的入口，只需要运行main方法就能把web项目部署到tomcat容器中，在main方法中，tomcat到底是如何启动的（本文基于SpringBoot 2.2.2.RELEASE） 我们从SpringBoot的main方法一路进去，就会进入到以下的run方法<img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-01.png" alt="img"></p>
<p>当Spring的环境和参数初始化设置好以后，创建ConfigurableApplicationContext成功后会调用refreshContext()方法来刷新上下文  <!--又是ApplicationContext的refresh()方法，果然是重中之重啊--><img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-02.png" alt="img"></p>
<p>发现里面还是继续调用了 onRefresh() 方法，我们进一步找到它的实现类 ServletWebServerApplicationContext，</p>
<p><img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-03.png" alt="img"></p>
<p>发现这里有一行代码：createWebServer();</p>
<p>很明显是创建Web服务器的意思，点进去查看<img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-04.png" alt="img"></p>
<p>我们来分析一下这一小段代码，如果webServer 和 serverletContext不存在，则从工厂中创建webServer</p>
<p>下面看一下webServer的创建过程，发现该方法有几个实现类，有TomcatServerlet、JettyServerlet、UndertowServlet，这里我们看一下Tomcat的实现<img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-05.png" alt="img"></p>
<p>Tomcat其实就是通过new出来的一个对象而已，然后给Tomcat进行一些参数的设置，启动Tomcat容器设置监听等待连接</p>
<h3 id="内嵌Tomcat的启动"><a href="#内嵌Tomcat的启动" class="headerlink" title="内嵌Tomcat的启动"></a>内嵌Tomcat的启动</h3><p>我们回到之前的onRefresh入口，容器刷新后，有一个完成刷新的finishRefresh()操作，这里就是容器启动的入口，如下图<img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-06.png" alt="img"></p>
<p>我们发现Tomcat里面也有这个完成刷新的finishRefresh()方法<img src="https://lenjor.github.io/images/posts/myBlog/2019-12-23-Spring-Boot-Tomcat-06.png" alt="img"></p>
<h3 id="手写main方法创建并启动Tomcat容器"><a href="#手写main方法创建并启动Tomcat容器" class="headerlink" title="手写main方法创建并启动Tomcat容器"></a>手写main方法创建并启动Tomcat容器</h3><p>SpringBoot也是通过new来创建Tomcat容器的，那么就意味着，我们可以不使用SpringBoot的run方法来启动web项目，我们自己也可以手写一个main方法来启动web项目，下面我们就来实现一下这个过程。</p>
<p>首先我们想一下，我们如果需要部署一个web项目，我们需要哪些操作：</p>
<ol>
<li>初始化Spring容器</li>
<li>扫描实例化Bean</li>
<li>配置DispatchServerlet，其实容器默认只有一个serverlet，就是DispatchServerlet，默认是 / ，自己写得Controller都是由DispatchServerlet进行分发的</li>
<li>使用main方法启动</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/07/database/Mybatis/mybatis-%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/07/database/Mybatis/mybatis-%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">mybatis-方法不能重载的原因</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-07 18:28:59 / Modified: 18:43:04" itemprop="dateCreated datePublished" datetime="2021-06-07T18:28:59+08:00">2021-06-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么不能重载？"><a href="#为什么不能重载？" class="headerlink" title="为什么不能重载？"></a>为什么不能重载？</h2><ul>
<li>Springboot与Mybatis会有一个启动器的自动配置类<code>MybatisAutoConfiguration</code>，其中有一段代码就是创建<code>sqlSessionFactory</code>，如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzIucG5n.jpg" alt="img"></li>
<li>既然是创建失败，那么肯定是这里出现异常了，这里的<strong>「大致思路」</strong>就是：</li>
</ul>
<blockquote>
<p>❝</p>
<p>解析<code>XML</code>文件和<code>Mapper</code>接口，将Mapper中的方法与XML文件中<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>等标签一一对应，那么Mapper中的方法如何与XML中<code>&lt;select&gt;</code>这些标签对应了，当然是唯一的<code>id</code>对应了，具体如何这个<code>id</code>的值是什么，如何对应？下面一一讲解。</p>
<p>❞</p>
</blockquote>
<ul>
<li>如上图的<code>SqlSessionFactory</code>的创建过程中，前面的部分代码都是设置一些配置，并没有涉及到解析XML的内容，因此答案肯定是在最后一行<code>return factory.getObject();</code>，于是此处打上断点，一点点看。于是一直到了<code>org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory</code>这个方法中，其中一段代码如下：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzMucG5n.jpg" alt="img"></li>
<li>略过不重要的代码，在<code>org.apache.ibatis.builder.xml.XMLMapperBuilder#configurationElement</code>这个方法中有一行重要的代码，如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzQucG5n.jpg" alt="img"></li>
<li>到<code>org.apache.ibatis.builder.MapperBuilderAssistant#addMappedStatement</code>这个方法返回值就是<code>MappedStatement</code>，不用多说，肯定是这个方法了，仔细一看，很清楚的看到了构建<code>id</code>的代码，如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzUucG5n.jpg" alt="img"></li>
<li>从上图可以知道，创建<code>id</code>的代码就是<code>id = applyCurrentNamespace(id, false);</code>，具体实现如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzYucG5n.jpg" alt="img"></li>
</ul>
<blockquote>
<p>❝</p>
<p>上图的代码已经很清楚了，<code>MappedStatement</code>中的<code>id=Mapper的全类名+&#39;.&#39;+方法名</code>。如果重载话，肯定会存在<code>id</code>相同的<code>MappedStatement</code>。</p>
<p>❞</p>
</blockquote>
<ul>
<li>到了这其实并不能说明方法不能重载啊，重复就重复呗，并没有冲突啊。这里需要看一个结构，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final Map&lt;String, MappedStatement&gt; mappedStatements &#x3D; new StrictMap&lt;MappedStatement&gt;(&quot;Mapped Statements collection&quot;)</span><br><span class="line">      .conflictMessageProducer((savedValue, targetValue) -&gt;</span><br><span class="line">          &quot;. please check &quot; + savedValue.getResource() + &quot; and &quot; + targetValue.getResource());</span><br></pre></td></tr></table></figure>

<ul>
<li>构建好的<code>MappedStatement</code>都会存入<code>mappedStatements</code>中，如下代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void addMappedStatement(MappedStatement ms) &#123;</span><br><span class="line">    &#x2F;&#x2F;key 是id</span><br><span class="line">    mappedStatements.put(ms.getId(), ms);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>StrictMap</code>的<code>put(k,v)</code>方法如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzcucG5n.jpg" alt="img"></li>
</ul>
<h2 id="如何找到XML中对应的SQL？"><a href="#如何找到XML中对应的SQL？" class="headerlink" title="如何找到XML中对应的SQL？"></a>如何找到XML中对应的SQL？</h2><ul>
<li>在使用Mybatis的时候只是简单的调用Mapper中的方法就可以执行SQL，如下代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserInfo&gt; userInfos &#x3D; userMapper.selectList(Arrays.asList(&quot;192&quot;,&quot;198&quot;));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一行简单的调用到底如何找到对应的SQL呢？其实就是根据<code>id</code>从<code>Map&lt;String, MappedStatement&gt; mappedStatements</code>中查找对应的<code>MappedStatement</code>。</p>
</blockquote>
<ul>
<li>在<code>org.apache.ibatis.session.defaults.DefaultSqlSession#selectList</code>方法有这一行代码如下图：<br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2dpdGVlLmNvbS9jaGVuamlhYmluZzY2Ni9CbG9nLWZpbGUvcmF3L21hc3Rlci9NeWJhaXRzJUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUI4JUJBJUU0JUJCJTgwJUU0JUI5JTg4JUU0JUI4JThEJUU4JTgzJUJEJUU5JTg3JThEJUU4JUJEJUJEJUVGJUJDJTlGLzgucG5n.jpg" alt="img"></li>
<li><code>MappedStatement ms = configuration.getMappedStatement(statement);</code>这行代码就是根据<code>id</code>从<code>mappedStatements</code>获取对应的<code>MappedStatement</code>，源码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public MappedStatement getMappedStatement(String id) &#123;</span><br><span class="line">    return this.getMappedStatement(id, true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%B9%82%E7%AD%89%E6%80%A7-02-%E7%8A%B6%E6%80%81%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%B9%82%E7%AD%89%E6%80%A7-02-%E7%8A%B6%E6%80%81%E6%9C%BA/" class="post-title-link" itemprop="url">幂等性-02-状态机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-02 14:51:01" itemprop="dateCreated datePublished" datetime="2021-06-02T14:51:01+08:00">2021-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>状态机幂等</strong></p>
<p>在支付场景中，创建了一个支付订单，发起了一个支付请求，这个订单不论多少次重复请求，都应该保证最多只扣款一次。即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相同支付订单ID（幂等条件） —&gt; 最多一次扣款（期望结果）</span><br></pre></td></tr></table></figure>

<p>为了实现这个目标，可以考虑使用有限状态机。</p>
<p>有限状态机(Finite-state machine FSM)，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。用于处理复杂的状态转换。</p>
<p>在这个支付的例子中，为了化简，不考虑退款、取消订单等复杂的状态，只考虑未支付和已支付两种状态之间的转换。</p>
<p><img src="https://img.toutiao.io/c/f217e1df139ab9e614398a401c624131" alt="img"></p>
<p>由上面的状态转换图可以看到，相同支付订单ID从未支付状态，要不就是支付不成功停留在未支付状态，要不就是支付成功，状态转移为已支付。此状态转移过程不可逆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public enum OrderStateEnum &#123;</span><br><span class="line">    UNPAID &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public OrderStateEnum changeState() &#123;</span><br><span class="line">            if (doPay()) &#123;</span><br><span class="line">                return PAID;</span><br><span class="line">            &#125;</span><br><span class="line">            return UNPAID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    PAID &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public OrderStateEnum changeState() &#123;</span><br><span class="line">            return PAID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    public abstract OrderStateEnum changeState();</span><br><span class="line">    public boolean doPay() &#123;</span><br><span class="line">        &#x2F;&#x2F;这里是逻辑伪代码,可以是发起下游调用请求支付通道等</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个java版本的简单状态机实现。状态机里定义了一个未支付状态和其行为changeState。changeState又定义了一个未支付状态和其行为changeState。</p>
<p>利用状态机来实现这个幂等支付请求的设计流程图如下：</p>
<p><img src="https://img.toutiao.io/c/34edb771f6045f3df4f30baeda3bbd33" alt="img"></p>
<p>参考状态机实现和上图可知，相同支付ID的请求，支付状态只能进行一次从未支付到已支付的转换。从而保证了其幂等性。</p>
<p><strong>按目标幂等</strong></p>
<p>先来回答一个小学生的问题：</p>
<p>定了一个会议，参加人数为10人。发现会议室的椅子只有5把。3个提前来到会议室的同学热心的去其他地方搬椅子进来。问：每人要搬几把椅子？</p>
<p>有人要说这不是把简单的问题复杂了吗？大家看到椅子不够就去搬，看够10把椅子了就不搬就可以了。对了，这其实是一个很好的解题思路，完全可以用在设计当中，就是按目标幂等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相同会议ID（幂等条件） —&gt; 总数10把椅子（期望结果）</span><br></pre></td></tr></table></figure>

<p>利用按目标幂等来实现这个总数10把椅子请求的设计流程图如下：</p>
<p><img src="https://img.toutiao.io/c/0f4b81ab2ae6e759c2403c476ff07a17" alt="img"></p>
<p>采用按目标的设计，相同会议ID，不管多少次请求，请求椅子的总数就是10把。多次请求不改变行为，从而实现了幂等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
