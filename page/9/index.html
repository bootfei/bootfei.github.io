<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/9/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">218</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/12/pros&cons/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/12/pros&cons/" class="post-title-link" itemprop="url">服务端性能优化-01-单台4核8G机器支撑5万QPS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-12 00:19:51" itemprop="dateCreated datePublished" datetime="2021-05-12T00:19:51+08:00">2021-05-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-08-26 22:35:28" itemprop="dateModified" datetime="2023-08-26T22:35:28+08:00">2023-08-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Tcpdump"><a href="#Tcpdump" class="headerlink" title="Tcpdump"></a>Tcpdump</h2><h3 id="1-tcpDump介绍"><a href="#1-tcpDump介绍" class="headerlink" title="1. tcpDump介绍"></a>1. tcpDump介绍</h3><h3 id="2-tcpDump工作原理"><a href="#2-tcpDump工作原理" class="headerlink" title="2. tcpDump工作原理"></a>2. tcpDump工作原理</h3><h3 id="3-tcpDump如何使用"><a href="#3-tcpDump如何使用" class="headerlink" title="3. tcpDump如何使用"></a>3. tcpDump如何使用</h3><h4 id="前置操作：开启网卡的混合模式"><a href="#前置操作：开启网卡的混合模式" class="headerlink" title="前置操作：开启网卡的混合模式"></a>前置操作：开启网卡的混合模式</h4><table>
<thead>
<tr>
<th></th>
<th>网卡的默认</th>
<th>网卡的混合模式</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>默认情况下，tcpdump不会抓取本机内部通讯的报文。根据网络协议栈的规定，对于报文，即使是目的地是本机，也需要经过本机的网络协议层，所以本机通讯肯定是通过API进入了内核，并且完成了路由选择。【比如本机的TCP通信，也必须要socket通信的基本要素：src ip port dst ip port】</td>
<td>如果要使用tcpdump抓取其他主机MAC地址的数据包，必须开启网卡混杂模式。<br />所谓混杂模式，用最简单的语言就是让网卡抓取任何经过它的数据包，不管这个数据包是不是发给它或者是它发出的。一般而言，Unix不会让普通用户设置混杂模式，因为这样可以看到别人的信息，比如telnet的用户名和密码，这样会引起一些安全上的问题，所以只有root用户可以开启混杂模式，</td>
</tr>
<tr>
<td>命令</td>
<td></td>
<td>ifconfig en0 promisc<br /> en0是你要打开混杂模式的网卡。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/12/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/12/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">服务端性能优化-01-单台4核8G机器支撑5万QPS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-12 00:19:51" itemprop="dateCreated datePublished" datetime="2021-05-12T00:19:51+08:00">2021-05-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-17 11:53:08" itemprop="dateModified" datetime="2023-03-17T11:53:08+08:00">2023-03-17</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="令牌桶的效果"><a href="#令牌桶的效果" class="headerlink" title="令牌桶的效果"></a>令牌桶的效果</h2><h3 id="场景1：平滑突发限流"><a href="#场景1：平滑突发限流" class="headerlink" title="场景1：平滑突发限流"></a>场景1：平滑突发限流</h3><p>设置每秒放置的令牌数为5个。返回的RateLimiter对象可以保证1秒内不会给超过5个令牌，并且以固定速率（0.2秒一个）进行放置，达到平滑输出的效果。</p>
<h4 id="获取频率高于令牌产生频率，一次获取一个"><a href="#获取频率高于令牌产生频率，一次获取一个" class="headerlink" title="获取频率高于令牌产生频率，一次获取一个"></a>获取频率高于令牌产生频率，一次获取一个</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSmoothBursty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> RateLimiter r = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire() + <span class="string">&quot;s&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * output: 基本上都是0.2s执行一次，符合一秒发放5个令牌的设定。</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.0s </span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.182014s</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.188464s</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.198072s</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.196048s</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.197538s</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.196049s</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="获取频率低于令牌产生频率，一次获取一个"><a href="#获取频率低于令牌产生频率，一次获取一个" class="headerlink" title="获取频率低于令牌产生频率，一次获取一个"></a>获取频率低于令牌产生频率，一次获取一个</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSmoothBursty2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> RateLimiter r = RateLimiter.create(<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line"> System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * output:</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * end</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.499796s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="一次获取5个（滞后效应）"><a href="#一次获取5个（滞后效应）" class="headerlink" title="一次获取5个（滞后效应）"></a>一次获取5个（滞后效应）</h4><p><code>RateLimiter</code>由于会累积令牌，所以可以应对突发流量。在下面代码中，有一个请求会直接请求5个令牌，但是由于此时令牌桶中有累积的令牌，足以快速响应。 <code>RateLimiter</code>在没有足够令牌发放时，采用滞后处理的方式，也就是前一个请求获取令牌所需等待的时间由下一次请求来承受，也就是代替前一个请求进行等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSmoothBursty3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> RateLimiter r = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;get 5 tokens: &quot;</span> + r.acquire(<span class="number">5</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 			<span class="comment">/**</span></span><br><span class="line"><span class="comment">       * output:</span></span><br><span class="line"><span class="comment">       * get 5 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.996766s 滞后效应，需要替前一个请求进行等待</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.194007s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.196267s</span></span><br><span class="line"><span class="comment">       * end</span></span><br><span class="line"><span class="comment">       * get 5 tokens: 0.195756s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.995625s 滞后效应，需要替前一个请求进行等待</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.194603s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.196866s</span></span><br><span class="line"><span class="comment">       */</span></span><br></pre></td></tr></table></figure>

<h3 id="场景2：平滑预热限流"><a href="#场景2：平滑预热限流" class="headerlink" title="场景2：平滑预热限流"></a>场景2：平滑预热限流</h3><p><code>RateLimiter</code>的 <code>SmoothWarmingUp</code>是带有预热期的平滑限流，它启动后会有一段预热期，逐步将分发频率提升到配置的速率。 比如下面代码中的例子，创建一个平均分发令牌速率为2，预热期为3分钟。由于设置了预热时间是3秒，令牌桶一开始并不会0.5秒发一个令牌，而是频率越来越高，在3秒钟之内达到原本设置的频率，以后就以固定的频率输出。这种功能适合系统刚启动需要一点时间来“热身”的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSmoothwarmingUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> RateLimiter r = RateLimiter.create(<span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 			<span class="comment">/**</span></span><br><span class="line"><span class="comment">       * output:</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 1.329289s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.994375s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.662888s  上边三次获取的时间相加正好为3秒</span></span><br><span class="line"><span class="comment">       * end</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.49764s  正常速率0.5秒一个令牌</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.497828s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.49449s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.497522s</span></span><br><span class="line"><span class="comment">       * end</span></span><br><span class="line"><span class="comment">       */</span></span><br></pre></td></tr></table></figure>



<h2 id="令牌桶的实现"><a href="#令牌桶的实现" class="headerlink" title="令牌桶的实现"></a>令牌桶的实现</h2><h3 id="平滑突发限流"><a href="#平滑突发限流" class="headerlink" title="平滑突发限流"></a>平滑突发限流</h3><p><code>RateLimiter</code>的原理就是每次调用 <code>acquire</code>时用当前时间和 <code>nextFreeTicketMicros</code>进行比较，根据二者的间隔和添加单位令牌的时间间隔 <code>stableIntervalMicros</code>来刷新存储令牌数 <code>storedPermits</code>。然后acquire会进行休眠，直到 <code>nextFreeTicketMicros</code>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp/%E5%A4%A7%E9%87%8F%20CLOSE_WAIT%20%E8%BF%9E%E6%8E%A5%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp/%E5%A4%A7%E9%87%8F%20CLOSE_WAIT%20%E8%BF%9E%E6%8E%A5%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">大量 CLOSE_WAIT 连接原因分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-12 00:19:51" itemprop="dateCreated datePublished" datetime="2021-05-12T00:19:51+08:00">2021-05-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-05-11 10:53:40" itemprop="dateModified" datetime="2024-05-11T10:53:40+08:00">2024-05-11</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>CLOSE_WAIT是tcp的四次挥手阶段的服务器状态</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/u4aVxRTn2TgUCmDdceT9LVRwWgb9icsy4AsN4tIJ7iaibx2iaSxNa59JZHQRSjqf41ibqDQia01SZ7bPOWo1Dn3qJjRg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p>服务端收到FIN包后，一直没有发送FIN包</p>
<h1 id="Dubbo服务器出现大量-CLOSE-WAIT"><a href="#Dubbo服务器出现大量-CLOSE-WAIT" class="headerlink" title="Dubbo服务器出现大量 CLOSE_WAIT"></a>Dubbo服务器出现大量 CLOSE_WAIT</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&amp;mid=2247486020&amp;idx=1&amp;sn=f7cf41aec28e2e10a46228a64b1c0a5c&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&amp;mid=2247486020&amp;idx=1&amp;sn=f7cf41aec28e2e10a46228a64b1c0a5c&amp;scene=21#wechat_redirect</a></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/298214130">https://www.zhihu.com/question/298214130</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/11/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E7%93%B6%E9%A2%88%E5%88%A4%E6%96%AD%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/11/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E7%93%B6%E9%A2%88%E5%88%A4%E6%96%AD%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">性能测试常见问题及瓶颈判断分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-11 19:27:28 / Modified: 19:27:52" itemprop="dateCreated datePublished" datetime="2021-05-11T19:27:28+08:00">2021-05-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.录制登录脚本后回放，结果失败<br>登录中为了安全，一般会对密码进行加密，查看录制的脚本中密码是否加密，如果是加密信息，有两种解决：一个是让开发修改应用，使用明码；一个是开发修改应用不做密码验证，脚本输入任何密码都通过。</p>
<p>2.增加并发后，TPS基本没有变化，应用和数据库的CPU也都消耗不高<br>可以先选择一个非登录的交易，最好是查询类交易，做1并发、5并发、10并发，试运行5分钟查看平均响应时间和TPS，如果TPS从5到10并发基本没有变化，应用和数据库的CPU也没大的变化，只是平均响应时间翻倍增加，那么基本可以确定是连接的限制问题，需要让开发查看三个连接数的设置：一个是应用允许的连接数；一个是连接池的限制；一个是数据库允许的连接限制。<br>切记：一定跟开发确认关闭日志或者为error级别，否则也会存在TPS很低。</p>
<p>3.数据库瓶颈判断<br>在少量并发，比如10并发左右，应用服务器cpu基本没消耗，但数据库的cpu却消耗非常高，一般是数据库问题，常见的是索引或者大量的order by以及group yu语句，需要开发修改。<br>一般的机器配置cpu为8C，足够支持50以上的并发。</p>
<p>4.应用问题判断<br>通常的软件设计，最后的资源消耗是在数据库，所以如果是在低并发（10user）应用的消耗非常高，但数据库却很低，说明是应用存在问题，需要开发介入查找。</p>
<p>5.压力机是win7的特殊限制<br>如果压力机是win7，那么默认的win7允许的连接是5个，所以需要通过工具修改半连接数的限制。而windonws server则没有这个问题。</p>
<p>6.磁盘瓶颈的判断<br>在linux中，通过iostat命令可以查看磁盘的一些数据，如果Pages Read/sec很低，同时%Disk Time和Average Disk Queue Length的值很高，即磁盘非常繁忙但实际读取的数据却很少，说明磁盘性能低，大量的数据等待磁盘读取，磁盘存在瓶颈。</p>
<p>7.内存的瓶颈判断<br>在linux中，通过top或free命令查看到内存的一些数据，在swap项，如果used使用的很多，而free很少，说明大量数据需要从磁盘读取而不是内存读取，这样初步可以判断是内存不够。</p>
<p>8.内存泄漏判断<br>在linux中，通过top命令查看到内存的一些数据，如果available mem非常少，比如只有几十兆，说明可能有程序没有释放内存。如果这个数值在逐渐的减少，说明是内存泄漏。</p>
<p>9.数据库锁的判断<br>1个用户tps到5个用户tps到10个用户tps基本没有变化，应该是数据库有锁，导致是串行交易，查看脚本是否对单账户操作，或者应用是不是单账户操作。</p>
<p>10.判断应用服务器的连接数<br>可以在应用服务器端运行脚本的时候执行下列命令，查看系统是否有很多的“TIME_WAIT”,如果有近万的等待说明问题出在应用端，当然只是几百个就可以忽略了。<br>命令：ps –ef | grep “TIME_WAIT” |wc –l ;</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-02-%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-02-%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">一致性-02-分布式事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-11 12:55:26" itemprop="dateCreated datePublished" datetime="2021-05-11T12:55:26+08:00">2021-05-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="分布式事务–数据一致性引擎概览"><a href="#分布式事务–数据一致性引擎概览" class="headerlink" title="分布式事务–数据一致性引擎概览"></a>分布式事务–数据一致性引擎概览</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>一般，广告检索系统都承载着公司很大比重的营收占比。</p>
<p>计费系统是广告系统的偏底层一环，承担着反作弊、计算费用、优惠扣减、费用实际扣除等职责。整个扣费流程涉及到了计费单、营销系统、支付账务系统、预算系统等的上下游数据一致性问题。</p>
<p>并且，由于存在CPT、CPA、CPC等不同类型的计费方式，而广告点击有流量不可回溯等特点（普通支付场景可以让用户重试），计费的数据一致性引擎的合理设计就变得尤为重要了。</p>
<h3 id="一致性保障方案选择"><a href="#一致性保障方案选择" class="headerlink" title="一致性保障方案选择"></a>一致性保障方案选择</h3><p>支付业务一般的可以分为两种</p>
<ul>
<li>一种是有支付牌照的公司，直接和账户和银行打交道<ul>
<li>一般需要非常强硬的保障手段来实现分布式下数据的强一致性。比如TCC的类二阶段提交方式</li>
</ul>
</li>
<li>另一种是调用第三方支付服务，实现支付业务。<ul>
<li>相对来说，一致性要求不是非常苛刻，有不少的解决方案可供选择，比如本地消息表、事务型消息等等</li>
</ul>
</li>
</ul>
<p>当前项目的场景显然属于第二种。那么，应该怎么合理选择实现方式呢：</p>
<h4 id="事务型消息"><a href="#事务型消息" class="headerlink" title="事务型消息"></a>事务型消息</h4><p>优点：实现方案轻量，改造成本小，适合为对实时性不是特别高的场景。</p>
<p>缺点：就是每个系统只能负责自己这一块，流程变得冗长，不利于问题排查。业务耦合程度可能要高一些。</p>
<h4 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h4><p>系统实现真的是非常的重。</p>
<ul>
<li>需要流程中的所有系统，按照既定的规范来实现一套包含了try/commit/cancel三个处理逻辑的调用模板。 </li>
<li>需要流程中的所有系统，按照既定的规范来创建主事务表和分支事务表，来记录事务状态和调用参数及路由。</li>
<li>需要参与者创建事务幂等表，实现拒绝空回滚或拒绝后到达的资源扣减等的防悬挂逻辑。</li>
</ul>
<p>光是让各系统配合实现几个接口，我觉得，如果没有非常大的资金风险压迫，没几个人会配合。</p>
<p>而且，TCC可能更适用于有用户直接参与的资源扣减场景，因为引擎的基本思路是失败时操作回滚，保证上下游一致。</p>
<p>但是，上面也说过了，广告点击流的特点是流量不可回放，用户不可能因为这次计费没成功，就帮我们再点一次。所以，我们的一致性引擎的恢复逻辑，不仅要支持回滚，还要支持重试。不可漏掉每一次点击计费。</p>
<h4 id="saga模式"><a href="#saga模式" class="headerlink" title="saga模式"></a>saga模式</h4><p>最终，我们参考saga模式，选择的是类saga的状态机引擎的补偿模式。</p>
<p>这种方式的优点是，对老系统改造成本友好，即使实现接口也比较方便，通过状态机编排执行节点链，并配置重试回滚方式、实时异步策略。</p>
<p>事务信息存储方式相对灵活，主要看自己公司的各种存储的可靠性和一致性的承诺。</p>
<h3 id="数据一致性引擎-saga模式"><a href="#数据一致性引擎-saga模式" class="headerlink" title="数据一致性引擎: saga模式"></a>数据一致性引擎: saga模式</h3><h4 id="引擎架构图"><a href="#引擎架构图" class="headerlink" title="引擎架构图"></a>引擎架构图</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT531rYZT3GBGOAHYiaBqrVEmcZHSCLhUsnUzqJjRWp0V1Rep93Bpjicqs1bbp5U4KEx1LWibdnYicCBL2bQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h4 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h4><ul>
<li><em>状态机</em> 实现节点执行顺序编排及其他执行特性</li>
<li><em>节点</em> 业务需要实现的逻辑节点，比如计费的cpc扣费逻辑，需要有前置check、price调价、coupon优惠券、pmc扣费等执行节点</li>
<li><em>补偿逻辑</em> 属于节点的一部分实现，每个执行节点需要实现当前节点的补偿逻辑，以供执行异常时进行恢复操作</li>
<li><em>钩子函数</em> 在引擎执行前和执行后，允许业务系统执行自有的特殊操作</li>
<li><em>定时任务</em> 异常数据恢复的触发入口</li>
</ul>
<h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><ul>
<li><em>补偿方式</em> 可配置，有重试/回滚 两种补偿方式可选；重试补偿时，执行顺便和正常顺序一致，回滚补偿时，从最后一个执行节点往前回滚</li>
<li><em>补偿触发时效</em> 可配置，有实时/异步延时 两种触发策略可选，如果有资源悬挂的风险，建议选异步延时触发</li>
<li><em>重试次数及时间衰减</em> 可配置，按业务实际情况定制衰减序列</li>
</ul>
<h4 id="状态机配置实例"><a href="#状态机配置实例" class="headerlink" title="状态机配置实例"></a>状态机配置实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;xxxx_xxxx_xxxx&quot;,</span><br><span class="line">  &quot;comment&quot;: &quot;cpc计费状态机&quot;,</span><br><span class="line">  &quot;firstNodeName&quot;: &quot;check&quot;,</span><br><span class="line">  &quot;nodes&quot;: &#123;</span><br><span class="line">    &quot;check&quot;: &#123;</span><br><span class="line">      &quot;nextNodeName&quot;: &quot;land&quot;,</span><br><span class="line">      &quot;preNodeName&quot;: &quot;&quot;,</span><br><span class="line">      &quot;skipRecover&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;land&quot;: &#123;</span><br><span class="line">      &quot;nextNodeName&quot;: &quot;antiFraud&quot;,</span><br><span class="line">      &quot;preNodeName&quot;: &quot;check&quot;,</span><br><span class="line">      &quot;skipRecover&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;antiFraud&quot;: &#123;</span><br><span class="line">      &quot;nextNodeName&quot;: &quot;realPrice&quot;,</span><br><span class="line">      &quot;preNodeName&quot;: &quot;land&quot;,</span><br><span class="line">      &quot;skipRecover&quot;: false</span><br><span class="line">    &#125;,&quot;...&quot;:&#123;&quot;...&quot;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  #重试次数</span><br><span class="line">  &quot;retryCount&quot;: &quot;4&quot;, </span><br><span class="line">  #重试时间衰减</span><br><span class="line">  &quot;timeDecaySeries&quot;: [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;10&quot;], </span><br><span class="line">  #补偿策略，重试&#x2F;回滚</span><br><span class="line">  &quot;recoverType&quot;: &quot;Retry&quot;,</span><br><span class="line">  #触发时效，实时触发&#x2F;异步触发</span><br><span class="line">  &quot;compensateTimeliness&quot;: &quot;ASYNC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引擎初始化"><a href="#引擎初始化" class="headerlink" title="引擎初始化"></a>引擎初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DTConfig.builder()</span><br><span class="line">    .setAppName(&quot;billing&quot;)&#x2F;&#x2F;配置appName</span><br><span class="line">    .setLogStoreStrategy(StoreStrategyEnum.DEFAULT_STORE)&#x2F;&#x2F;存储策略</span><br><span class="line">    .setRedisConfig(redisConfigPath) &#x2F;&#x2F;设置redis配置</span><br><span class="line">    .setDBTableConfig(mysqlConfigPath) &#x2F;&#x2F;mysql配置</span><br><span class="line">    .setZKConfig(configPath) &#x2F;&#x2F; wConfig 配置 ，切流灰度使用</span><br><span class="line">    .setStateMachinePath(stateMachinePath)&#x2F;&#x2F;状态机配置项地址</span><br><span class="line">    .setNegligibleErrorCode(BillingDTConstants.serious_error_code_str) &#x2F;&#x2F;当前系统关键异常code集合（不可忽略的致命异常，供恢复逻辑使用）</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h4 id="引擎调用"><a href="#引擎调用" class="headerlink" title="引擎调用"></a>引擎调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;本次调用所使用的状态机名称</span><br><span class="line">String stateMachineName&#x3D;&quot;ecpm_state_machine&quot;; &#x2F;&#x2F;当前请求使用到的状态机名称（和状态机配置中的name一致）</span><br><span class="line">&#x2F;&#x2F;获取引擎实例</span><br><span class="line">DTBizEngine dtBizEngine&#x3D;new SagaDTBizEngine();</span><br><span class="line">&#x2F;&#x2F;组装入参执行调用</span><br><span class="line">DTResponse response&#x3D;  dtBizEngine.start(new DTEngineRequest(bizType,bizId,stateMachineName,originContext));</span><br><span class="line">&#x2F;&#x2F;打印结果</span><br><span class="line">System.out.println(response.getData());</span><br></pre></td></tr></table></figure>

<h4 id="异步化（参考dubbo的异步化实现的）"><a href="#异步化（参考dubbo的异步化实现的）" class="headerlink" title="异步化（参考dubbo的异步化实现的）"></a>异步化（参考dubbo的异步化实现的）</h4><p>主线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   &#x2F;&#x2F;创建 DTFurure ,传入 (DTEngineRequest request , int timeout)</span><br><span class="line">   DTFuture mFuture&#x3D;new DTFuture(request, 1000);</span><br><span class="line">   &#x2F;&#x2F;将该future传递下去，也可以用其他方式传递，这里直接放到了request扩展字段做示例</span><br><span class="line">   request.getExtendField().put(&quot;MY_KEY&quot;,mFuture);</span><br><span class="line">   &#x2F;&#x2F;异步线程调用 </span><br><span class="line">   EcpmEventBus.getInstance().post(new EcpmBillingEvent(request));</span><br><span class="line">   &#x2F;&#x2F;有限时间超时等待，get到的结果是业务完成时设置进来的对象，业务系统可以按自己的场景转换</span><br><span class="line">   Object future&#x3D; mFuture.get(1000); &#x2F;&#x2F;单位是毫秒</span><br><span class="line">   &#x2F;&#x2F;do something</span><br><span class="line"></span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>执行线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;do something ...</span><br><span class="line"></span><br><span class="line">DTFurure futrue&#x3D;(DTFurure)request.getExtendField().get(&quot;MY_KEY&quot;);</span><br><span class="line"></span><br><span class="line">DTFuture.received(futrue.getId(),response);</span><br></pre></td></tr></table></figure>





<h2 id="分布式事务2–-数据一致性引擎原理"><a href="#分布式事务2–-数据一致性引擎原理" class="headerlink" title="分布式事务2– 数据一致性引擎原理"></a>分布式事务2– 数据一致性引擎原理</h2><blockquote>
<p>分布式事务解决什么问题</p>
<ul>
<li><em>准备调用下游扣费，或刚调起下游扣费接口，服务宕机了，怎么办？</em></li>
<li><em>调用下游超时，不知道下游是否执行怎么办？</em></li>
<li><em>调用下游时发生网路堵塞，回滚先到扣费操作后到被悬挂怎么办？</em></li>
<li><em>整个事务需要同时满足重试和回滚操作怎么办？</em></li>
<li><em>因为支付系统大面积重试时，优惠券节点也要重试么？</em></li>
<li><em>重试失败怎么办？重试间隔怎么设置？</em></li>
</ul>
</blockquote>
<p>下面就带着这些待解决的场景问题，看看 DT 引擎是个什么东西</p>
<h3 id="DT-引擎是个什么东西"><a href="#DT-引擎是个什么东西" class="headerlink" title="DT 引擎是个什么东西"></a>DT 引擎是个什么东西</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT532jLJNoZH2DKo0XkmGoibsPVkfHP9DkJ8CSICmttBZeQDwYTMnlwH9HACOiaQcvdEeo9hqsBjxn7LYQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">从上图可以看到，DT 的核心组成包括三大部分：</p>
<ul>
<li><em>事务协调器</em>：负责节点编排、结果判断、分支路由等主要功能。</li>
<li><em>业务执行及补偿节点</em> ：负责调用业务系统实现的多个执行节点。</li>
<li><em>异步补偿触发</em>：负责在执行异常时，异步调起恢复任务并触发执行。</li>
</ul>
<p><strong>「总结下，DT 是个以状态机为基础的，补偿式的分布式长事务一致性保障引擎。」</strong></p>
<p>下面将详述每个模块的实现方案和细节。</p>
<h3 id="DT-引擎原理介绍"><a href="#DT-引擎原理介绍" class="headerlink" title="DT 引擎原理介绍"></a>DT 引擎原理介绍</h3><p><strong>「理论基础」</strong>：是从Hector&amp;Kenneth在1987年发表的《Sagas》论文中演化而来：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT532jLJNoZH2DKo0XkmGoibsPV6iafWicVp2q6BkiakhygY9bm6pz9ez7W4ooSehcXORuPehagNfwg3NiaMg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>图中绿色的部分是正向执行逻辑，发起方逐个调用，参与者不分阶段，直接执行并提交本地事务.</p>
<p>当链路中某个参与者执行逻辑发生异常时，则依据实际配置，执行补偿–回滚或重试。</p>
<p><em>适用场景</em>：</p>
<ul>
<li>业务流程长、业务流程多</li>
<li>业务场景除了回滚还有重试等场景。</li>
<li>参与者没法保证提供 TCC 接口。</li>
</ul>
<p>优势：</p>
<ul>
<li>一阶段提交本地事务，无锁，高性能、事件驱动架构；</li>
<li>参与者可异步执行，高吞吐；补偿服务易于实现。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不保证隔离性</li>
</ul>
<h3 id="模块设计详解"><a href="#模块设计详解" class="headerlink" title="模块设计详解"></a>模块设计详解</h3><p>相比Seate里的saga， 原理都是一样的，但是内部实现很多实现方案进行了精炼和一些专属定制化的开发。</p>
<p>比如，saga 中的状态机定义内容非常庞大，几乎所有的内容都出现在了配置文件中，而 DT 精简到了只剩下节点编排，且顺序固定，不支持节点间路由跳转（因为感觉也没必要~）。</p>
<p>诸如此类的定制等等~</p>
<p>其目的，不是为了重复造轮子，是为了有一致性诉求，但是不想对接庞大的解决方案的同学们，提供一种轻量级的处理方案。</p>
<h4 id="事务协调器"><a href="#事务协调器" class="headerlink" title="事务协调器"></a>事务协调器</h4><p>协调器的主要职责，是执行节点的流程编排、事务的开启、节点状态的维护和上报、全局状态的维护和更新、全局事务完结后的后续处理等。<img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT532jLJNoZH2DKo0XkmGoibsPVuhotJZBDuYibcmOwGXNR2H9pHROkpBTjduuKHjicJAVmr0xj8iaSzTq8Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">整个事务协调器类图如图所示：</p>
<ol>
<li><code>DTBizEngine</code>接口定义了引擎的执行入口，具体实现策略都继承自它。</li>
<li><code>SagaDTBizEngine</code> 是saga模式的具体实现类。</li>
<li>通过<code>DTStart</code> 注解实现启动拦截器，执行事务启动初始化操作。</li>
<li>通过<code>DTAction</code> 注解实现业务节点拦截器，执行数据上报和状态维护。</li>
<li>引擎通过<code>config</code>类拿到业务配置的<code>DTactionService</code>实例执行链，执行 <code>action</code>方法以触发业务逻辑。</li>
<li><code>TriggerManager</code>负责调取<em>框架定义+业务自定义</em>的<strong>「钩子函数」</strong>，负责处理各个不同的执行阶段的特殊处理。</li>
<li>整个业务流程，均由事务协调器协调处理。业务系统只需要实现每个节点的 <code>DTactionService.action</code> 接口和 <code>compensate</code> 接口</li>
</ol>
<p><strong>「为了达到进度协调且保证各节点之间的数据一致性，有一些核心的问题需要解决。下面我们详细说明」</strong></p>
<h4 id="状态机的设计和维护"><a href="#状态机的设计和维护" class="headerlink" title="状态机的设计和维护"></a>状态机的设计和维护</h4><p>状态机的配置决定了事务的节点编排和执行流程。既要决定正常的业务执行流程，还要考虑不同场景下的可配置策略。</p>
<h5 id="重试和回滚"><a href="#重试和回滚" class="headerlink" title="重试和回滚"></a>重试和回滚</h5><p>回滚，需要从最后一个节点往前回滚。而重试，则需要从前往后执行，因此，状态机节点需要和二叉树一样，将pre 和next节点维护起来。</p>
<p>目前这种方式，是一种极简方式，适用于业务流程比较固定的场景。如果有节点路由的诉求，那另当别论了。</p>
<h5 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h5><p>业务执行过程中可能会遇到不同类别的异常。</p>
<p>有些异常是可以忽略的，比如某作弊流量查某个关键配置时未查到，可以直接过滤，不进行后续流程。而个别的严重异常是我们不希望忽略的，比如调支付系统失败，超时等等。</p>
<p>而有些节点，包含了上述两种异常，而有些节点，所有异常均不能忽略。</p>
<p>所以，我们在捕获异常方面会支持两种配置方式：<br><strong>「整个节点异常不可忽略」</strong><br><strong>「不可忽略的异常码列表」</strong></p>
<p>如果当前节点配置了所有异常不可忽略，会直接进入补偿流程。如果没有配置该参数，则会在不可忽略的异常码列表中查询匹配。</p>
<h5 id="重试时间衰减"><a href="#重试时间衰减" class="headerlink" title="重试时间衰减"></a>重试时间衰减</h5><p>为了防止下游系统异常恢复不及时和异常请求因特殊情况被防止无限期补偿等场景，我们做了重试时间衰减策略。该时间衰减序列被维护在状态机配置中，比如<br><strong>「1,3,5,10」</strong><br>则，框架在捞取异常数据进行处理时，会计算上次补偿的时间是否满足该时间序列，再进行执行。</p>
<h4 id="主事务和分支事务"><a href="#主事务和分支事务" class="headerlink" title="主事务和分支事务"></a>主事务和分支事务</h4><p><em>我们需要依赖主事务串联整个流程，依赖分支事务在执行异常时感知各参与者的执行结果。</em></p>
<p>一般在TCC模式下，绝大部分情况都以<em>本地数据库事务</em>为依托，会把主事务的创建、参与者的调用包在本地事务内部，这样，使用同一个数据库创建主事务和分支事务表，天然保证和本地业务数据的一致性。这样数据的压力也会有所增加，基本都是在分库分表之后，把压力均摊到分库上完成性能要求。</p>
<p>但是，还有一些情况另外，比如我们目前的业务，为了提高性能，没有启动本地事务，相当于是在裸跑。</p>
<p>那么，一个关键的问题就是数据存储的稳定性和流程阻断方案的完善。</p>
<p><em>一是</em>需要一个高性能的存储来满足数据的强一致性要求，可以允许存储操作失败，但是决不允许接口返回成功，实际上数据丢失的情况发生。<br><em>二是</em>一个完善的流程阻断方案：我们的存储操作一般分为前置操作和后置操作，如主事务插入和分支事务插入都是前置操作，而分支事务状态更新则是后置操作。在前置操作时失败，则流程阻断，返回失败，让调用方重试或框架补偿。</p>
<p><em>最终希望起到的作用是</em>：<br>(1)只要存储中没有，那就是肯定没执行；<br>(2)而如果在存储中查到了记录，框架会认为，曾经有可能执行过，还需要看对应的状态执行对应的补偿。</p>
<h4 id="流程串联"><a href="#流程串联" class="headerlink" title="流程串联"></a>流程串联</h4><p>框架需要确定后置处理器和钩子函数的注册时机和方式，需要把主事务的开启，执行节点状态的更新，全部执行完成后的处理逻辑编织在一起，等等。</p>
<p><em>具体方法</em>：使用拦截器的方式，在事务开启前后、节点执行前后，进行事务信息维护和更新，保证流程和数据相互匹配</p>
<h4 id="服务匹配和调起"><a href="#服务匹配和调起" class="headerlink" title="服务匹配和调起"></a>服务匹配和调起</h4><p>执行到每个节点，都需要获取参与者的对应服务实例。这个地方之前还会面试问过，问我异常恢复的时候怎么做到通过分支事务表里记录的字符串，调起对方的rpc服务。</p>
<p>这块的实现其实也有很多种，之前工作中用到的tcc模式的dtx引擎，是依托spring框架，使用XMap技术将配置在xml中的对应服务解析成对应的 Javabean,并匹配本地注册中心的服务端信息，调起对应服务。</p>
<p>DT中，我们用了一种比较简单的方法，那就是<code>「ServiceLoader」</code>，非常有用的一个获取同一接口下所有实现类服务的方法。</p>
<p>只需三步:</p>
<ul>
<li>创建接口。<br><code>com.cjh.test.Hello</code></li>
<li>创建实现类。<br><code>com.cjh.test.AHelloImpl</code><br><code>com.cjh.test.BHelloImpl</code></li>
<li>指定位置创建接口文件. 在<br><code>resource/META-INF/service</code><br>文件夹下，创建名为<br><strong>「com.cjh.test.Hello」</strong><br>的文件，将<br><code>com.cjh.test.AHelloImpl</code><br><code>com.cjh.test.BHelloImpl</code><br>这两行文本填入</li>
</ul>
<p>ok 完事~ 所以只要框架指定一个包含了 action 和 compesate 的接口，而业务系统的各个节点都实现了该接口，我们就可以方便的调起这些服务~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;示例代码</span><br><span class="line">ServiceLoader&lt;AAA&gt; serviceLoader&#x3D;ServiceLoader.load(AAA.class);</span><br><span class="line"></span><br><span class="line">for (AAA load : serviceLoader) &#123;</span><br><span class="line">  System.out.println(load);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoadInterface loadInterface&#x3D; EnhancedServiceLoader.load(LoadInterface.class,&quot;BLoad&quot;);</span><br><span class="line">loadInterface.execute();</span><br><span class="line"></span><br><span class="line">Method method &#x3D; loadInterface.getClass().getMethod(&quot;execute&quot;);</span><br><span class="line">method.invoke(loadInterface);</span><br><span class="line"></span><br><span class="line">EnhancedServiceLoader.load(LoadInterface.class,&quot;ALoad&quot;).execute();</span><br></pre></td></tr></table></figure>

<h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>框架支持业务系统在流程执行开始前、完成后、成功后、异常后执行对应的自定义处理，以满足业务系统的特殊需求。</p>
<h4 id="异步补偿"><a href="#异步补偿" class="headerlink" title="异步补偿"></a>异步补偿</h4><p>采用分布式调用方法，定时触发未处理数据的捞取操作，并用数据总线的方式，让系统快速执行补偿。为了防止某条数据被多台机器同时捞取，会加分布式锁进行拒绝拦截。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>那么，DT是如何解决开篇提到的那些问题的呢：</p>
<ol>
<li>在调用扣费服务时发生本服务宕机，说明主事务一定是插入成功的，异步补偿会捞取该主事务记录，并捞取对应的分支事务记录，执行异步补偿。</li>
<li>调用下游超时，说明分支事务已经插入成功，我们更新分支事务为状态未知，等待补偿。</li>
<li>用异步补偿的方式，处理一分钟之前的未完成数据，尽可能避免网络阻塞带来的影响<em>拒绝空回滚，扣费请求后置的幂等处理，需要下游保障</em></li>
<li>支付系统大面积超时，我们会根据分支事务记录来判断其他节点是否已经执行成功，如果执行成功，则跳过重试操作，以避免不必要的系统调用，防止因为冗余的重试调用触发某一系统瓶颈导致全链路崩溃。</li>
<li>时间衰减等  略</li>
</ol>
<h2 id="高并发消息队列补充篇：在所依赖存储不授信的场景下实现柔性事务降级"><a href="#高并发消息队列补充篇：在所依赖存储不授信的场景下实现柔性事务降级" class="headerlink" title="高并发消息队列补充篇：在所依赖存储不授信的场景下实现柔性事务降级"></a>高并发消息队列补充篇：在所依赖存储不授信的场景下实现柔性事务降级</h2><h3 id="基础服务支持不到位的坑"><a href="#基础服务支持不到位的坑" class="headerlink" title="基础服务支持不到位的坑"></a>基础服务支持不到位的坑</h3><h4 id="项目背景和整理设计思路"><a href="#项目背景和整理设计思路" class="headerlink" title="项目背景和整理设计思路"></a>项目背景和整理设计思路</h4><p>项目背景其实还是我们的数据一致性保证长事务引擎。</p>
<p>整体架构如下：<img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT530yxTpTWvojyJtiaOx7PibGLmKicicpErWQMicaMx4Qia15njNTb2icCwTibIskpo1zNMfFxLVjJqGDn2GbyA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li>通过状态机来组织和支持多种不同的业务流</li>
<li>通过将外部服务节点化来抽象和规范化参与者的服务</li>
<li>通过节点的异常捕获来感知参与方的执行结果</li>
<li>通过实时或异步的恢复机制，实现柔性事务·</li>
</ul>
<h4 id="不可缺少的强依赖–存储"><a href="#不可缺少的强依赖–存储" class="headerlink" title="不可缺少的强依赖–存储"></a>不可缺少的强依赖–存储</h4><p>想要业务请求保证最终一致，不可能是没有存储参与的一锤子买卖，因为还要考虑本身服务器的抖动，业务上的异步要求等等。所以，存储是一个不可缺少的依赖，如下图所示：<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">存储服务作用在引擎的整个生命周期：</p>
<ul>
<li>在请求进入初期，进行上下文落地(因为广告流量只有一次操作，不像普通支付可以允许用户重试，广告场景下，用户的多次操作需要进行分别计费，并且不太适合利用MQ的ack机制进行重试，因为那需要等流程全部执行完，会影响消息消费速率)</li>
<li>在节点执行结束，进行节点执行状态落地(这样，在遇到需要补偿的情况，可以避免冗余调用，防止不需要重试的系统被其他抖动的系统冲击)</li>
<li>在异步恢复时，获取上下文和节点执行状态集合，以完成事务的最终一致性处理。</li>
</ul>
<h4 id="存储的调研和选择"><a href="#存储的调研和选择" class="headerlink" title="存储的调研和选择"></a>存储的调研和选择</h4><h5 id="业界的选择–数据库"><a href="#业界的选择–数据库" class="headerlink" title="业界的选择–数据库"></a>业界的选择–数据库</h5><p>对于支付类业务，其实，最好的是用数据库。业务层的订单表相当于业务请求上下文，会将请求的所需信息落地(没有上下文落地其实也没关系，返回用户失败即可)。</p>
<p>节点执行状态数据存在和订单表同库的另一个表中，即可支持一个在一个本地事务内保证分布式事务的最终一致性逻辑。</p>
<h5 id="业务特性决定了数据库不合适"><a href="#业务特性决定了数据库不合适" class="headerlink" title="业务特性决定了数据库不合适"></a>业务特性决定了数据库不合适</h5><p>由于种种原因，我们这里不太适合用数据库，一个是广告上下文太大，且绝大多时候没有用，为了少数异常存到订单表的话太浪费；二是目前采用实时库+历史库的方式进行，没有分库，如果增加了中间状态表，目前的并发量，对数据库压力会很大，但目前搞分库又不是那么必要。</p>
<p>所以数据库不太适合。</p>
<h5 id="公司自研存储的选择和使用"><a href="#公司自研存储的选择和使用" class="headerlink" title="公司自研存储的选择和使用"></a>公司自研存储的选择和使用</h5><p>正好，公司自研了一套基于rocksdb的高性能存储，在读写性能和数据结构方面基本可以代替MySQL和Redis。在公司内部被广泛使用。</p>
<p>两个版本，一个是paxos强一致版本，读写性能稍弱，但保证数据强一致；另一个是普通版本，读写性能更高，但不保证强一致，即有可能主从切换会丢数据。</p>
<p>对于带金融属性的业务来说，在理论上的读写性能满足业务要求的情况下，当然是首选强一致的版本了。特别是业务上下文，丢失的结果就是该请求的整个异常恢复流程无法被正常唤起。</p>
<p>然而，理想照进现实，由于该版本之前应对的业务场景较为简单，并发也没有我们这么大，一些底层调优不到位导致服务抖动频繁。</p>
<p>如果是在大厂，就像之前用OB，只要OB有承若数据不丢，那基本不用考虑丢失的问题。如果丢了，我想可能大概率就会把锅抛给存储团队，限时优化之类。</p>
<p>但，我们小厂可都是<em>相亲相爱的一家人</em>，怎么能干这种事。所以选了另一个版本，使用更广泛，更成熟的非强一致版本。而数据丢失的问题由业务自己来想办法。</p>
<h3 id="消息队列的介入"><a href="#消息队列的介入" class="headerlink" title="消息队列的介入"></a>消息队列的介入</h3><h4 id="非强一致存储为啥会丢数据"><a href="#非强一致存储为啥会丢数据" class="headerlink" title="非强一致存储为啥会丢数据"></a>非强一致存储为啥会丢数据</h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">如上图所示，该存储架构采用的是主从模式，数据由主写入，同步到从，当主异常时，进行主从切换，恢复服务。</p>
<p>但是，由于不是强一致协议，写主成功即为成功，当主宕机时，虽然主从切换很快，10秒完成，但还没有来得及同步到从的那部分数据，就会因为因为主从切换而丢失。</p>
<p>怎么办？</p>
<h4 id="消息队列登场"><a href="#消息队列登场" class="headerlink" title="消息队列登场"></a>消息队列登场</h4><p>为了应对存储不授信的情况，我们引入了消息队列来实现存储的丢失补偿。<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">如上图所示，引入延迟消息进入处理流程。</p>
<ul>
<li>当节点执行发生异常时，发送当前业务上下文到消息队列。如果是正常执行的情况则无需发送。</li>
<li>消息的延迟间隔，要大于主从切换的时间，并且需要小于定时任务的触发间隔。比如，主从切换需要10s，那延迟消息的延迟间隔就设置为30s , 接收消息都重新插入上下文到存储。在节点异常一分钟之后，被定时任务捞取，执行处理。</li>
</ul>
<p>用两个时间差来覆盖掉主从切换带来的数据丢失的影响。</p>
<h4 id="更进一步–存储降级"><a href="#更进一步–存储降级" class="headerlink" title="更进一步–存储降级"></a>更进一步–存储降级</h4><p>那么，更极端的情况，如果整个存储服务持续不可用怎么办？</p>
<p><strong>降级：</strong> 自己的命运要把握在自己手中。目的是保证绝大部分服务正常。<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></p>
<ul>
<li>监控系统。用于收集和汇报操作存储时的异常，并统计错误率和超时率</li>
<li>一旦错误率和超时率达到阈值（比如持续30s，所有服务全部超时）执行关联脚本。</li>
<li>脚本负责触发配置中心的配置切换，由正常模式切换为柔性模式。</li>
<li>柔性模式下，所有涉及存储读写的操作将被忽略，以保障绝大部分请求可以正常执行。</li>
<li>遇到执行异常的节点，将上下文发送至消息队列，消费时不再插入存储，而是改为直接消费。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%88%86%E5%B8%83%E5%BC%8F-01-subject%E7%BB%B4%E6%8A%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%88%86%E5%B8%83%E5%BC%8F-01-subject%E7%BB%B4%E6%8A%A4/" class="post-title-link" itemprop="url">shiro分布式-01-subject维护</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-11 11:52:48" itemprop="dateCreated datePublished" datetime="2021-05-11T11:52:48+08:00">2021-05-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在技术群有一位提出</p>
<p>   shiro框架下获取主题subject信息都是从SecurityUtils.getSubject()方法中获取，跟踪到最后都是从ThreadLocal变量中获取的值，只能在当前内存中存储，那分布式部署的话，会产生获取到的subject的主体信息不一致的问题？</p>
<p>那么 先看下上述问题的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SecurityUtils</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Subject <span class="title">getSubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     Subject subject = ThreadContext.getSubject();</span><br><span class="line">     <span class="keyword">if</span> (subject == <span class="literal">null</span>) &#123;</span><br><span class="line">         subject = (<span class="keyword">new</span> Subject.Builder()).buildSubject();</span><br><span class="line">         ThreadContext.bind(subject);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> subject;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看下ThreadContext的方法 getSubject-&gt;get-&gt;getValue-&gt;resources</span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    public <span class="keyword">static</span> Subject getSubject() &#123;</span><br><span class="line">        <span class="keyword">return</span> (Subject) <span class="keyword">get</span>(SUBJECT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">   public <span class="keyword">static</span> <span class="built_in">Object</span> <span class="keyword">get</span>(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">String</span> msg = <span class="string">&quot;get() - in thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            log.trace(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span> value = getValue(key);</span><br><span class="line">        <span class="keyword">if</span> ((value != <span class="keyword">null</span>) &amp;&amp; log.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">String</span> msg = <span class="string">&quot;Retrieved value of type [&quot;</span> + value.getClass().getName() + <span class="string">&quot;] for key [&quot;</span> +</span><br><span class="line">                    key + <span class="string">&quot;] &quot;</span> + <span class="string">&quot;bound to thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            log.trace(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//3 </span></span><br><span class="line">     private <span class="keyword">static</span> <span class="built_in">Object</span> getValue(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, <span class="built_in">Object</span>&gt; perThreadResources = resources.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">return</span> perThreadResources != <span class="keyword">null</span> ? perThreadResources.<span class="keyword">get</span>(key) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">        private <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, <span class="built_in">Object</span>&gt;&gt; resources = <span class="keyword">new</span> InheritableThreadLocalMap&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, <span class="built_in">Object</span>&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>单看这些，可能有的朋友也会认同如此，都是从resources这个线程私有变量拿去。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="谁负责从subject取值"><a href="#谁负责从subject取值" class="headerlink" title="谁负责从subject取值"></a>谁负责从subject取值</h3><p>根据上述代码分析，是每个请求从subject中获取自己的subject信息</p>
<h3 id="谁负责对subject赋值"><a href="#谁负责对subject赋值" class="headerlink" title="谁负责对subject赋值"></a>谁负责对subject赋值</h3><p>但是我是做过基于redis分布搭建shiro项目的，肯定应该不会存在上述现象，还是查源码为先吧。</p>
<h4 id="先看这个ThreadLocal变量究竟是哪个类在给他赋值？"><a href="#先看这个ThreadLocal变量究竟是哪个类在给他赋值？" class="headerlink" title="先看这个ThreadLocal变量究竟是哪个类在给他赋值？"></a>先看这个ThreadLocal变量究竟是哪个类在给他赋值？</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadContext类</span></span><br><span class="line"><span class="comment">//获取的变量key，请注意看，无论怎么取subject，key值永远不变 </span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> String SECURITY_MANAGER_KEY = ThreadContext.<span class="keyword">class</span>.getName() + <span class="string">&quot;_SECURITY_MANAGER_KEY&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> String SUBJECT_KEY = ThreadContext.<span class="keyword">class</span>.getName() + <span class="string">&quot;_SUBJECT_KEY&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到一个引用，置入subject的信息</span></span><br><span class="line">    <span class="keyword">public</span> static void bind(Subject subject) &#123;</span><br><span class="line">        <span class="keyword">if</span> (subject != <span class="literal">null</span>) &#123;</span><br><span class="line">            put(SUBJECT_KEY, subject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>对bind方法进行跟踪</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">--SubjectThreadState</span><span class="selector-class">.bind</span>()</span><br><span class="line"><span class="selector-tag">----SubjectCallable</span><span class="selector-class">.call</span>()</span><br><span class="line"><span class="selector-tag">------DelegatingSubject</span><span class="selector-class">.execute</span>(<span class="selector-tag">Callable</span>&lt;<span class="selector-tag">V</span>&gt; <span class="selector-tag">callable</span>)</span><br><span class="line"><span class="selector-tag">----SubjectRunnable</span><span class="selector-class">.run</span>()</span><br><span class="line"><span class="selector-tag">------DelegatingSubject</span><span class="selector-class">.execute</span>(<span class="selector-tag">Runnable</span> <span class="selector-tag">runnable</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到SubjectThreadState字面意思应该是线程状态的信息，最终都跟踪到DelegatingSubject这个代理类上，其执行线程方法，更新绑定的subject值；</p>
<p>再继续溯源，找到AbstractShiroFilter类的doFilterInternal。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, <span class="keyword">final</span> FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Throwable t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);</span><br><span class="line">            <span class="keyword">final</span> ServletResponse response = prepareServletResponse(request, servletResponse, chain);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Subject subject = createSubject(request, response);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="comment">//在该处调用线程方法更新</span></span><br><span class="line">            subject.execute(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    updateSessionLastAccessTime(request, response);</span><br><span class="line">                    executeChain(request, response, chain);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">            t = ex.getCause();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            t = throwable;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，应该了解到一点，就是每个请求进来的时候，这个主线程会有对应的新线程去更新赋值subject的信息。</p>
<h4 id="每次请求进来时这个subject信息是在这里生成的，那原来已经登录的用户再次来请求的subject已经变了，怎么登录成功呢？还有没登录的时候，这里会怎么处理呢？"><a href="#每次请求进来时这个subject信息是在这里生成的，那原来已经登录的用户再次来请求的subject已经变了，怎么登录成功呢？还有没登录的时候，这里会怎么处理呢？" class="headerlink" title="每次请求进来时这个subject信息是在这里生成的，那原来已经登录的用户再次来请求的subject已经变了，怎么登录成功呢？还有没登录的时候，这里会怎么处理呢？"></a>每次请求进来时这个subject信息是在这里生成的，那原来已经登录的用户再次来请求的subject已经变了，怎么登录成功呢？还有没登录的时候，这里会怎么处理呢？</h4><p>借着这个问题，咱么看一下这个shiro过滤器都干啥了？</p>
<p> 一般web项目都指定 ShiroFilter这个过滤器，在初始化到第一个请求到达之前，首先设置了一些环境参数，获取配置信息，初始化一些变量，包含SecurityManager这个核心（可以看init()，onFilterConfigSet()函数）</p>
<p>第一个请求到达进入doFilterInternal方法内，调用prepareServletRequest，prepareServletResponse，判断为http方式时，封装Shiro格式的输入输出流。</p>
<p>还有就是一旦发生请求，那么会话session就已经存在了</p>
<p>接下来创建新的subject具体过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractShiroFilter</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebSubject <span class="title">createSubject</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebSubject.Builder(getSecurityManager(), request, response).buildWebSubject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跟踪buildWebSubject方法，DefaultSecurityManager类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSecurityManager</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Subject <span class="title">createSubject</span><span class="params">(SubjectContext subjectContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//create a copy so we don&#x27;t modify the argument&#x27;s backing map:</span></span><br><span class="line">        <span class="comment">//英文不好，自行百度吧</span></span><br><span class="line">        SubjectContext context = copy(subjectContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ensure that the context has a SecurityManager instance, and if not, add one:</span></span><br><span class="line">         <span class="comment">//英文不好，自行百度吧</span></span><br><span class="line">        context = ensureSecurityManager(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Resolve an associated Session (usually based on a referenced session ID), and place it in the context before</span></span><br><span class="line">        <span class="comment">//sending to the SubjectFactory.  The SubjectFactory should not need to know how to acquire sessions as the</span></span><br><span class="line">        <span class="comment">//process is often environment specific - better to shield the SF from these details:</span></span><br><span class="line">         <span class="comment">//这里是重点</span></span><br><span class="line">        context = resolveSession(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Similarly, the SubjectFactory should not require any concept of RememberMe - translate that here first</span></span><br><span class="line">        <span class="comment">//if possible before handing off to the SubjectFactory:</span></span><br><span class="line">        context = resolvePrincipals(context);</span><br><span class="line">        <span class="comment">//也是重点</span></span><br><span class="line">        Subject subject = doCreateSubject(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//save this subject for future reference if necessary:</span></span><br><span class="line">        <span class="comment">//(this is needed here in case rememberMe principals were resolved and they need to be stored in the</span></span><br><span class="line">        <span class="comment">//session, so we don&#x27;t constantly rehydrate the rememberMe PrincipalCollection on every operation).</span></span><br><span class="line">        <span class="comment">//Added in 1.2:</span></span><br><span class="line">        </span><br><span class="line">        save(subject);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>重点跟踪resolveSession()方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> SubjectContext resolveSession(SubjectContext context) &#123;</span><br><span class="line">      <span class="comment">//第一次进来肯定没有缓存值，会进入下面的resolveContextSession</span></span><br><span class="line">      <span class="keyword">if</span> (context.resolveSession() != <span class="literal">null</span>) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;Context already contains a session.  Returning.&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> context;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//Context couldn&#x27;t resolve it directly, let&#x27;s see if we can since we have direct access to </span></span><br><span class="line">          <span class="comment">//the session manager:</span></span><br><span class="line">          Session session = resolveContextSession(context);</span><br><span class="line">          <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">              context.setSession(session);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvalidSessionException e) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;Resolved SubjectContext context session is invalid.  Ignoring and creating an anonymous &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;(session-less) Subject instance.&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSecurityManager</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Session <span class="title">resolveContextSession</span><span class="params">(SubjectContext context)</span> <span class="keyword">throws</span> InvalidSessionException </span>&#123;</span><br><span class="line"><span class="comment">//这里判断一下是http请求的话，会获取本身session的id</span></span><br><span class="line">     SessionKey key = getSessionKey(context);</span><br><span class="line">     <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> getSession(key);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//一直跟踪getSession方法到AbstractNativeSessionManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Session <span class="title">getSession</span><span class="params">(SessionKey key)</span> <span class="keyword">throws</span> SessionException </span>&#123;</span><br><span class="line">       Session session = lookupSession(key);</span><br><span class="line">       <span class="keyword">return</span> session != <span class="keyword">null</span> ? createExposedSession(session, key) : <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Session <span class="title">lookupSession</span><span class="params">(SessionKey key)</span> <span class="keyword">throws</span> SessionException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;SessionKey argument cannot be null.&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> doGetSession(key);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面doGetSession调用了了AbstractValidatingSessionManager</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Session <span class="title">doGetSession</span><span class="params">(<span class="keyword">final</span> SessionKey key)</span> <span class="keyword">throws</span> InvalidSessionException </span>&#123;</span><br><span class="line">        enableSessionValidationIfNecessary();</span><br><span class="line"></span><br><span class="line">        log.trace(<span class="string">&quot;Attempting to retrieve session with key &#123;&#125;&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">        Session s = retrieveSession(key);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">            validate(s, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSessionManager.retrieveSession</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Session <span class="title">retrieveSession</span><span class="params">(SessionKey sessionKey)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</span><br><span class="line">        Serializable sessionId = getSessionId(sessionKey);</span><br><span class="line">        <span class="keyword">if</span> (sessionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Unable to resolve session ID from SessionKey [&#123;&#125;].  Returning null to indicate a &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;session could not be found.&quot;</span>, sessionKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Session s = retrieveSessionFromDataSource(sessionId);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//session ID was provided, meaning one is expected to be found, but we couldn&#x27;t find one:</span></span><br><span class="line">            String msg = <span class="string">&quot;Could not find session with ID [&quot;</span> + sessionId + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownSessionException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DefaultSessionManager.retrieveSessionFromDataSource</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Session <span class="title">retrieveSessionFromDataSource</span><span class="params">(Serializable sessionId)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sessionDAO.readSession(sessionId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>一直跟踪到sessionDAO.readSession,这里，从方法字面意思也知道是从缓存或者数据库读取session信息了。就是上面提到的redis缓存，会吧session信息存储。</p>
<p>接下来回头看，在buildWebSubject的方法里面，获取到了缓存的session信息或者是一个全新的session信息，</p>
<p>之后的doCreateSubject方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultWebSubjectFactory</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subject <span class="title">createSubject</span><span class="params">(SubjectContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//SHIRO-646</span></span><br><span class="line">        <span class="comment">//Check if the existing subject is NOT a WebSubject. If it isn&#x27;t, then call super.createSubject instead.</span></span><br><span class="line">        <span class="comment">//Creating a WebSubject from a non-web Subject will cause the ServletRequest and ServletResponse to be null, which wil fail when creating a session.</span></span><br><span class="line">        <span class="keyword">boolean</span> isNotBasedOnWebSubject = context.getSubject() != <span class="keyword">null</span> &amp;&amp; !(context.getSubject() <span class="keyword">instanceof</span> WebSubject);</span><br><span class="line">        <span class="keyword">if</span> (!(context <span class="keyword">instanceof</span> WebSubjectContext) || isNotBasedOnWebSubject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.createSubject(context);</span><br><span class="line">        &#125;</span><br><span class="line">        WebSubjectContext wsc = (WebSubjectContext) context;</span><br><span class="line">        SecurityManager securityManager = wsc.resolveSecurityManager();</span><br><span class="line">        <span class="comment">//取到session信息</span></span><br><span class="line">        Session session = wsc.resolveSession();</span><br><span class="line">        <span class="keyword">boolean</span> sessionEnabled = wsc.isSessionCreationEnabled();</span><br><span class="line">        <span class="comment">//如果缓存没有，获取session中的身份信息</span></span><br><span class="line">        PrincipalCollection principals = wsc.resolvePrincipals();</span><br><span class="line">        <span class="comment">//如果缓存没有，获取session中的认证信息</span></span><br><span class="line">        <span class="keyword">boolean</span> authenticated = wsc.resolveAuthenticated();</span><br><span class="line">        String host = wsc.resolveHost();</span><br><span class="line">        ServletRequest request = wsc.resolveServletRequest();</span><br><span class="line">        ServletResponse response = wsc.resolveServletResponse();</span><br><span class="line">        <span class="comment">//创建新的subject</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebDelegatingSubject(principals, authenticated, host, session, sessionEnabled,</span><br><span class="line">                request, response, securityManager);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建完毕以后，接下来就更新缓存内的subject的状态，直至请求结束</p>
<p>到这里每次请求到达filter基本上流程就完毕了，如果已经登录了，无论是从本身的map缓存还是外部的redis缓存，都应该能拿到session信息，如果没有登录，是拿不到的。也证明了分布式部署时，有了session的分布式缓存，应该就基本搭建成功了吧。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/database/redis/redis-7-%E5%8D%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/database/redis/redis-7-%E5%8D%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">redis-7-单多线程以及线程安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-10 13:27:23" itemprop="dateCreated datePublished" datetime="2021-05-10T13:27:23+08:00">2021-05-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-09 15:13:16" itemprop="dateModified" datetime="2021-08-09T15:13:16+08:00">2021-08-09</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>单线程的设计也给Redis带来一些问题：</p>
<ul>
<li>只能使用CPU一个核；</li>
<li>如果删除的键过大（比如Set类型中有上百万个对象），会导致服务端阻塞好几秒；</li>
<li>QPS难再提高。</li>
</ul>
<p>针对上面问题，Redis在4.0版本以及6.0版本分别引入了<code>Lazy Free</code>以及<code>多线程IO</code>，逐步向多线程过渡</p>
<h2 id="单线程体现在哪里？"><a href="#单线程体现在哪里？" class="headerlink" title="单线程体现在哪里？"></a>单线程体现在哪里？</h2><h3 id="版本不同，单线程不同"><a href="#版本不同，单线程不同" class="headerlink" title="版本不同，单线程不同"></a>版本不同，单线程不同</h3><blockquote>
<p><strong>正确的说法是，redis只使用了单个线程去处理客户端的网络请求。到6.0版本，那这个答案还要修正为多线程处理网络请求，但是真正操作数据部分程序是单线程的。</strong></p>
</blockquote>
<ul>
<li>Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问这种问题，是不是有点耍流氓。</li>
<li>限定版本之后 比如4.x，严格意义来说Redis也不是单线程，而是负责处理客户端的请求的线程是单线程。</li>
<li>最新版本的6.0版本，告别了大家印象中的单线程，用一种全新的多线程来解决问题</li>
</ul>
<p><img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/2226BB23364A3092021556482C0880F0.jpg" alt="img"></p>
<h3 id="事件处理是单线程"><a href="#事件处理是单线程" class="headerlink" title="事件处理是单线程"></a>事件处理是单线程</h3><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p>
<ul>
<li><code>文件事件</code>：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象；服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作，比如连接<code>accept</code>，<code>read</code>，<code>write</code>，<code>close</code>等；</li>
<li><code>时间事件</code>：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象，比如过期键清理，服务状态统计等。</li>
</ul>
<img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBGjKoEV1qzhribnDJZeSp9ZGKyAlBBia6Au7U9ScIxh5QsI1KJaCuFaLsoJIWzpuVyCqALjd9dWX8A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom: 33%;" />

<p>如上图，Redis将文件事件和时间事件进行抽象，时间轮训器会监听I/O事件表，一旦有文件事件就绪，Redis就会优先处理文件事件，接着处理时间事件。<a href="">在上述所有事件处理上，Redis都是以<code>单线程</code>形式处理，所以说Redis是单线程的</a></p>
<p>Redis基于Reactor模式开发了自己的I/O事件处理器，也就是文件事件处理器，Redis在I/O事件处理上，采用了I/O多路复用技术，同时监听多个套接字，并为套接字关联不同的事件处理函数，<a href="">通过单线程实现了多客户端并发处理</a>。</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBGjKoEV1qzhribnDJZeSp9ZBrrXaOVX2HR8uoJLd4PIpJBmIUXiaVfsp2UPtl5n3icmsRzhpcgIISdA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:33%;" />

<p>正因为这样的设计，在数据处理上避免了加锁操作，既使得实现上足够简洁，也保证了其高性能。</p>
<h2 id="单线程瓶颈"><a href="#单线程瓶颈" class="headerlink" title="单线程瓶颈"></a>单线程瓶颈</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>通常来说多线程对于提高CPU利用率有重要作用，但是Redis对于提高CPU利用率并不感冒，在Redis看来如果要提高CPU利用率，那在一台机器部署多个实例就好了。</p>
<blockquote>
<p>其实在Redis 4.0就引入了多个线程来实现数据的异步删除等功能，但是其处理读写请求的仍然只有一个线程，所以仍然算是狭义上的单线程。</p>
</blockquote>
<p>抛开CPU之后，影响Redis性能的地方主要就剩下：<strong>内存和网络IO</strong>。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存更多属于硬件范畴的东西，比如我们用容量更大、吞吐率更高的内存介质来进行优化，因此对于Redis来说可以优化的空间有限。</p>
<h3 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h3><p>在优化网络IO之前，我们有必要回顾下Redis单线程整体架构：</p>
<img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/D62600E64DD64120A1AFC7B02C249F05.jpg" alt="img" style="zoom: 50%;" />

<p>Redis采用Reactor模式的网络模型，对于一个客户端请求，主线程负责一个完整的处理过程：</p>
<img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/17AC77F7B141692BBB88D38395BDAB5A.jpg" alt="img" style="zoom: 50%;" />

<p>从socket中读取数据和往socket写数据都是比较耗时的网络IO操作，解析请求和内存交互耗时可能远小于IO操作。</p>
<p>对于这种问题，我们常见的解决方法是标准的多线程化：</p>
<img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/9AE12897F8FCA20AA8BADAF3D04E3E56.jpg" alt="img" style="zoom:50%;" />

<p>该方案中工作线程的功能是一样的，MemCached就是采用这种方案，具体的流程：</p>
<blockquote>
<p>Memcached采用 master-woker 模式进行工作，主线程采用 Libevent 监听和处理事件，主线程将连接请求封装为任务放到队列中，根据算法选择空闲的工作线程，相应的工作线程处理完成后通过soeket与客户端进行数据交互。</p>
</blockquote>
<p>但是Redis 6.0的多线程并没有这么做。</p>
<h2 id="多线程体现在哪里？"><a href="#多线程体现在哪里？" class="headerlink" title="多线程体现在哪里？"></a>多线程体现在哪里？</h2><h3 id="生成RBD日志文件"><a href="#生成RBD日志文件" class="headerlink" title="生成RBD日志文件"></a>生成RBD日志文件</h3><p><a href="">当然，Redis单线程只是指其在事件处理上，实际上，Redis也并不是单线程的，比如生成RDB文件，就会fork一个子进程来实现</a></p>
<h3 id="4-0-Lazy-Free机制"><a href="#4-0-Lazy-Free机制" class="headerlink" title="4.0 Lazy Free机制"></a>4.0 Lazy Free机制</h3><p>如上所知，Redis在处理客户端命令时是以单线程形式运行，而且处理速度很快，期间不会响应其他客户端请求，但若客户端向Redis发送一条耗时较长的命令，比如删除一个含有上百万对象的Set键，或者执行flushdb，flushall操作，Redis服务器需要回收大量的内存空间，导致服务器卡住好几秒，对负载较高的缓存系统而言将会是个灾难。为了解决这个问题，在Redis 4.0版本引入了<code>Lazy Free</code>，将<code>慢操作</code>异步化，这也是在事件处理上向多线程迈进了一步。</p>
<p>要解决<code>慢操作</code>，可以采用渐进式处理，即增加一个时间事件，比如在删除一个具有上百万个对象的Set键时，每次只删除大键中的一部分数据，最终实现大键的删除。但是，该方案可能会导致回收速度赶不上创建速度，最终导致内存耗尽。因此，Redis最终实现上是将大键的删除操作异步化，采用非阻塞删除（对应命令<code>UNLINK</code>），大键的空间回收交由单独线程实现，主线程只做关系解除，可以快速返回，继续处理其他事件，避免服务器长时间阻塞。</p>
<p>以删除（<code>DEL</code>命令）为例，看看Redis是如何实现的，下面就是删除函数的入口，其中，<code>lazyfree_lazy_user_del</code>是是否修改<code>DEL</code>命令的默认行为，一旦开启，执行<code>DEL</code>时将会以<code>UNLINK</code>形式执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void delCommand(client *c) &#123;</span><br><span class="line">    delGenericCommand(c,server.lazyfree_lazy_user_del);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* This command implements DEL and LAZYDEL. *&#x2F;</span><br><span class="line">void delGenericCommand(client *c, int lazy) &#123;</span><br><span class="line">    int numdel &#x3D; 0, j;</span><br><span class="line"></span><br><span class="line">    for (j &#x3D; 1; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        &#x2F;&#x2F; 根据配置确定DEL在执行时是否以lazy形式执行</span><br><span class="line">        int deleted  &#x3D; lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        if (deleted) &#123;</span><br><span class="line">            signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                &quot;del&quot;,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步删除很简单，只要把key和value删除，如果有内层引用，则进行递归删除，这里不做介绍。下面看下异步删除，Redis在回收对象时，会先计算回收收益，只有回收收益在超过一定值时，采用封装成Job加入到异步处理队列中，否则直接同步回收，这样效率更高。回收收益计算也很简单，比如<code>String</code>类型，回收收益值就是1，而<code>Set</code>类型，回收收益就是集合中元素个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Delete a key, value, and associated expiration entry if any, from the DB.</span><br><span class="line"> * If there are enough allocations to free the value object may be put into</span><br><span class="line"> * a lazy free list instead of being freed synchronously. The lazy free list</span><br><span class="line"> * will be reclaimed in a different bio.c thread. *&#x2F;</span><br><span class="line">#define LAZYFREE_THRESHOLD 64</span><br><span class="line">int dbAsyncDelete(redisDb *db, robj *key) &#123;</span><br><span class="line">    &#x2F;* Deleting an entry from the expires dict will not free the sds of</span><br><span class="line">     * the key, because it is shared with the main dictionary. *&#x2F;</span><br><span class="line">    if (dictSize(db-&gt;expires) &gt; 0) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    &#x2F;* If the value is composed of a few allocations, to free in a lazy way</span><br><span class="line">     * is actually just slower... So under a certain limit we just free</span><br><span class="line">     * the object synchronously. *&#x2F;</span><br><span class="line">    dictEntry *de &#x3D; dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        robj *val &#x3D; dictGetVal(de);</span><br><span class="line">        &#x2F;&#x2F; 计算value的回收收益</span><br><span class="line">        size_t free_effort &#x3D; lazyfreeGetFreeEffort(val);</span><br><span class="line"></span><br><span class="line">        &#x2F;* If releasing the object is too much work, do it in the background</span><br><span class="line">         * by adding the object to the lazy free list.</span><br><span class="line">         * Note that if the object is shared, to reclaim it now it is not</span><br><span class="line">         * possible. This rarely happens, however sometimes the implementation</span><br><span class="line">         * of parts of the Redis core may call incrRefCount() to protect</span><br><span class="line">         * objects, and then call dbDelete(). In this case we&#39;ll fall</span><br><span class="line">         * through and reach the dictFreeUnlinkedEntry() call, that will be</span><br><span class="line">         * equivalent to just calling decrRefCount(). *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 只有回收收益超过一定值，才会执行异步删除，否则还是会退化到同步删除</span><br><span class="line">        if (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            atomicIncr(lazyfree_objects,1);</span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,NULL,NULL);</span><br><span class="line">            dictSetVal(db-&gt;dict,de,NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Release the key-val pair, or just the key if we set the val</span><br><span class="line">     * field to NULL in order to lazy free it later. *&#x2F;</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        if (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过引入<code>a threaded lazy free</code>，Redis实现了对于<code>Slow Operation</code>的<code>Lazy</code>操作，避免了在大键删除，<code>FLUSHALL</code>，<code>FLUSHDB</code>时导致服务器阻塞。当然，在实现该功能时，不仅引入了<code>lazy free</code>线程，也对Redis聚合类型在存储结构上进行改进。因为Redis内部使用了很多共享对象，比如客户端输出缓存。当然，Redis并未使用加锁来避免线程冲突，锁竞争会导致性能下降，而是去掉了共享对象，直接采用数据拷贝，如下，在3.x和6.x中<code>ZSet</code>节点value的不同实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 3.2.5版本ZSet节点实现，value定义robj *obj</span><br><span class="line">&#x2F;* ZSETs use a specialized version of Skiplists *&#x2F;</span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    robj *obj;</span><br><span class="line">    double score;</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        unsigned int span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6.0.10版本ZSet节点实现，value定义为sds ele</span><br><span class="line">&#x2F;* ZSETs use a specialized version of Skiplists *&#x2F;</span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    sds ele;</span><br><span class="line">    double score;</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        unsigned long span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>去掉共享对象，不但实现了<code>lazy free</code>功能，也为Redis向多线程跨进带来了可能，正如作者所述：</p>
<blockquote>
<p>Now that values of aggregated data types are fully unshared, and client output buffers don’t contain shared objects as well, there is a lot to exploit. For example it is finally possible to implement threaded I/O in Redis, so that different clients are served by different threads. This means that we’ll have a global lock only when accessing the database, but the clients read/write syscalls and even the parsing of the command the client is sending, can happen in different threads.</p>
</blockquote>
<h3 id="6-0-多线程I-O"><a href="#6-0-多线程I-O" class="headerlink" title="6.0 多线程I/O"></a>6.0 多线程I/O</h3><p>单线程给Redis带来的好处，或许更大。</p>
<p>另外一点如果做成<a href="">标准化的多线程（见单线程瓶颈 - 网络IO）</a>，对于Redis来说可能更不好处理，因为多线程带来的线程安全问题和底层复杂的数据结构操作都十分棘手。</p>
<p>Redis 6.0将处理过程中最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由单线程来完成和内存的数据交互。</p>
<p>这样一来，网络IO操作就变成多线程化了，其他核心部分仍然是线程安全的，确实是个不错的折中办法。</p>
<img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/45B0A1BFD93CE1E776FBD5BFE6D2756D.jpg" alt="img" style="zoom:50%;" />

<blockquote>
<p>画外音：<strong>Redis 6.0 将网络数据读写、请求协议解析通过多个IO线程的来处理 ，对于真正的命令执行来说，仍然使用主线程操作，真是个很特别的多线程啊！</strong></p>
</blockquote>
<img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/0AC4121F88297E685697B648CE50BD5D.jpg" alt="img" style="zoom:50%;" />

<h2 id="多线程瓶颈"><a href="#多线程瓶颈" class="headerlink" title="多线程瓶颈"></a>多线程瓶颈</h2><h4 id="多线程I-O及其局限性"><a href="#多线程I-O及其局限性" class="headerlink" title="多线程I/O及其局限性"></a>多线程I/O及其局限性</h4><p>Redis在4.0版本引入了<code>Lazy Free</code>，自此Redis有了一个<code>Lazy Free</code>线程专门用于大键的回收，同时，也去掉了聚合类型的共享对象，这为多线程带来可能，Redis也不负众望，在6.0版本实现了<code>多线程I/O</code>。</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>正如官方以前的回复，Redis的性能瓶颈并不在CPU上，而是在内存和网络上。因此6.0发布的多线程并未将事件处理改成多线程，而是在I/O上，此外，如果把事件处理改成多线程，不但会导致锁竞争，而且会有频繁的上下文切换，即使用分段锁来减少竞争，对Redis内核也会有较大改动，性能也不一定有明显提升。</p>
<p>是Redis实现的多线程部分，利用多核来分担I/O读写负荷。在<code>事件处理线程</code>每次获取到可读事件时，会将所有就绪的读事件分配给<code>I/O线程</code>，并进行等待，在所有<code>I/O线程</code>完成读操作后，<code>事件处理线程</code>开始执行任务处理，在处理结束后，同样将写事件分配给<code>I/O线程</code>，等待所有<code>I/O</code>线程完成写操作。</p>
<p>以读事件处理为例，看下<code>事件处理线程</code>任务分配流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int handleClientsWithPendingReadsUsingThreads(void) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;* Distribute the clients across N different lists. *&#x2F;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    int item_id &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 将等待处理的客户端分配给I&#x2F;O线程</span><br><span class="line">    while((ln &#x3D; listNext(&amp;li))) &#123;</span><br><span class="line">        client *c &#x3D; listNodeValue(ln);</span><br><span class="line">        int target_id &#x3D; item_id % server.io_threads_num;</span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;* Wait for all the other threads to end their work. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 轮训等待所有I&#x2F;O线程处理完</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        unsigned long pending &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 1; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending +&#x3D; io_threads_pending[j];</span><br><span class="line">        if (pending &#x3D;&#x3D; 0) break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>I/O线程</code>处理流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void *IOThreadMain(void *myid) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; I&#x2F;O线程执行读写操作</span><br><span class="line">        while((ln &#x3D; listNext(&amp;li))) &#123;</span><br><span class="line">            client *c &#x3D; listNodeValue(ln);</span><br><span class="line">            &#x2F;&#x2F; io_threads_op判断是读还是写事件</span><br><span class="line">            if (io_threads_op &#x3D;&#x3D; IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c,0);</span><br><span class="line">            &#125; else if (io_threads_op &#x3D;&#x3D; IO_THREADS_OP_READ) &#123;</span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                serverPanic(&quot;io_threads_op value is unknown&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listEmpty(io_threads_list[id]);</span><br><span class="line">        io_threads_pending[id] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (tio_debug) printf(&quot;[%ld] Done\n&quot;, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h5><p>从上面实现上看，6.0版本的多线程并非彻底的多线程，<code>I/O线程</code>只能同时执行读或者同时执行写操作，期间<code>事件处理线程</code>一直处于等待状态，并非流水线模型，有很多轮训等待开销。</p>
<h5 id="Tair多线程实现原理"><a href="#Tair多线程实现原理" class="headerlink" title="Tair多线程实现原理"></a>Tair多线程实现原理</h5><p>相较于6.0版本的多线程，Tair的多线程实现更加优雅。如下图，Tair的<code>Main Thread</code>负责客户端连接建立等，<code>IO Thread</code>负责请求读取、响应发送、命令解析等，<code>Worker Thread</code>线程专门用于事件处理。<code>IO Thread</code>读取用户的请求并进行解析，之后将解析结果以命令的形式放在队列中发送给<code>Worker Thread</code>处理。<code>Worker Thread</code>将命令处理完成后生成响应，通过另一条队列发送给<code>IO Thread</code>。为了提高线程的并行度，<code>IO Thread</code>和<code>Worker Thread</code>之间采用<strong>无锁队列</strong>和<strong>管道</strong>进行数据交换，整体性能会更好。<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Redis 4.0引入<code>Lazy Free</code>线程，解决了诸如大键删除导致服务器阻塞问题，在6.0版本引入了<code>I/O Thread</code>线程，正式实现了多线程，但相较于Tair，并不太优雅，而且性能提升上并不多，压测看，多线程版本性能是单线程版本的2倍，Tair多线程版本则是单线程版本的3倍。在作者看来，Redis多线程无非两种思路，<code>I/O threading</code>和<code>Slow commands threading</code>，正如作者在其博客中所说：</p>
<blockquote>
<p>I/O threading is not going to happen in Redis AFAIK, because after much consideration I think it’s a lot of complexity without a good reason. Many Redis setups are network or memory bound actually. Additionally I really believe in a share-nothing setup, so the way I want to scale Redis is by improving the support for multiple Redis instances to be executed in the same host, especially via Redis Cluster.</p>
</blockquote>
<blockquote>
<p>What instead I really want a lot is slow operations threading, and with the Redis modules system we already are in the right direction. However in the future (not sure if in Redis 6 or 7) we’ll get key-level locking in the module system so that threads can completely acquire control of a key to process slow operations. Now modules can implement commands and can create a reply for the client in a completely separated way, but still to access the shared data set a global lock is needed: this will go away.</p>
</blockquote>
<p>Redis作者更倾向于采用集群方式来解决<code>I/O threading</code>，尤其是在6.0版本发布的原生Redis Cluster Proxy背景下，使得集群更加易用。此外，作者更倾向于<code>slow operations threading</code>（比如4.0版本发布的<code>Lazy Free</code>）来解决多线程问题。后续版本，是否会将<code>IO Thread</code>实现的更加完善，采用Module实现对慢操作的优化，着实值得期待。</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="读取过期数据"><a href="#读取过期数据" class="headerlink" title="读取过期数据"></a>读取过期数据</h3><p>典型场景是：</p>
<ul>
<li>Redis 内存储了一个用户的状态：<code>user5277=idle</code>；</li>
<li>客户端连接 A 读取了用户状态，获取到用户的空闲状态 <code>status = get(&quot;user5277&quot;)</code>；</li>
<li>客户端连接 B 也同样读取了用户状态；</li>
<li>客户端连接 A 给用户安排了一个任务，并将 Redis 内用户状态置为忙碌 <code>set(&quot;user5277&quot;, &quot;busy&quot;)</code>；</li>
<li>客户端连接 B 同样设置用户为忙碌状态。</li>
<li>可是此时用户却被同时分配了两个任务。</li>
</ul>
<p>解决方法1：给用户状态加锁就行了，使同一时间内只能有一个客户端操作用户状态。不过加锁我们就需要考虑锁粒度、死锁等问题了，无疑添加了程序的复杂性，不利于维护。</p>
<p>解决方法2：使用lua脚本，保证<a href="">复合命令</a>的原子性。java可以使用字符串的方式拼接lua脚本</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-01-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-01-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/" class="post-title-link" itemprop="url">shiro应用-01-使用流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-10 13:25:09" itemprop="dateCreated datePublished" datetime="2021-05-10T13:25:09+08:00">2021-05-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JfTPiahTHJhpmuJOMKBHpBCC00gwWgjwZW67mVRo4ffmBpibDMLQicgZJuicvNNnPaiaeXFxOPYY4OXATuhDj6Wnq6Q/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h2 id="jdk实现"><a href="#jdk实现" class="headerlink" title="jdk实现"></a>jdk实现</h2><h3 id="设置Realm域"><a href="#设置Realm域" class="headerlink" title="设置Realm域"></a>设置Realm域</h3><p>Shiro要从Realm域中获取安全、正确的数据。该类必须继承org.apache.shiro.realm.AuthorizingRealm；</p>
<p>　　并重写doGetAuthorizationInfo与doGetAuthenticationInfo方法。doGetAuthorizationInfo是对角色权限的认证，这里暂且不详述；doGetAuthenticationInfo对用户的认证，这里正是我们要详细讲述的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">implements</span> <span class="title">Realm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationInfo <span class="title">getAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = (String)token.getPrincipal();  <span class="comment">//得到用户名</span></span><br><span class="line">        String password = <span class="keyword">new</span> String((<span class="keyword">char</span>[])token.getCredentials()); <span class="comment">//得到密码</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;zhang&quot;</span>.equals(username)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException(); <span class="comment">//如果用户名错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;123&quot;</span>.equals(password)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncorrectCredentialsException(); <span class="comment">//如果密码错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果身份认证验证成功，返回一个AuthenticationInfo实现；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(username, password, getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件，使securityManager获取到该Realm域"><a href="#配置文件，使securityManager获取到该Realm域" class="headerlink" title="配置文件，使securityManager获取到该Realm域"></a>配置文件，使securityManager获取到该Realm域</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 [main]</span><br><span class="line">2 <span class="comment">#自定义 realm</span></span><br><span class="line">3 customRealm=org.ssm.service.CustomRealm</span><br><span class="line">4 <span class="comment">#将realm设置到securityManager</span></span><br><span class="line">5 securityManager.realms=<span class="variable">$customRealm</span></span><br></pre></td></tr></table></figure>

<h3 id="测试：main函数"><a href="#测试：main函数" class="headerlink" title="测试：main函数"></a>测试：main函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShiro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过工厂加载配置</span></span><br><span class="line">  Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro-shiro.ini&quot;</span>);</span><br><span class="line">  <span class="comment">//通过工厂获取安全管理器</span></span><br><span class="line">  SecurityManager securityManager = factory.getInstance();</span><br><span class="line">  <span class="comment">//注册Subject工具</span></span><br><span class="line">  SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">  <span class="comment">//获取Subject对象</span></span><br><span class="line">  Subject subject = SecurityUtils.getSubject();</span><br><span class="line">  <span class="comment">//获取验证对象</span></span><br><span class="line">  AuthenticationToken authenticationToken = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="comment">//        验证</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    subject.login(authenticationToken);</span><br><span class="line">    System.out.println(<span class="string">&quot;通过...&quot;</span> + <span class="string">&quot;\t&quot;</span> + authenticationToken.getPrincipal());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未通过:用户不存在&quot;</span> + <span class="string">&quot;\t&quot;</span> + authenticationToken.getPrincipal());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="spring-mvc实现"><a href="#spring-mvc实现" class="headerlink" title="spring mvc实现"></a>spring mvc实现</h2><h3 id="配置Shiro的过滤器"><a href="#配置Shiro的过滤器" class="headerlink" title="配置Shiro的过滤器"></a>配置Shiro的过滤器</h3><p>对所有访问进行过滤；需要在web.xml中加上如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置上shiro过滤器，使其生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置url由servlet容器控制filter的生命周期--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>transformWsdlLocations<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="设置Realm域，且安全数据来源于数据库"><a href="#设置Realm域，且安全数据来源于数据库" class="headerlink" title="设置Realm域，且安全数据来源于数据库"></a>设置Realm域，且安全数据来源于数据库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 引入users操作的整合操作</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="meta">@Qualifier(&quot;usersService&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> UsersService usersService;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *获取授权信息</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> principalCollection</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 获取获取身份验证相关信息</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> authenticationToken</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"> <span class="comment">//        获取用户输入的用户名</span></span><br><span class="line">         String userName = (String) authenticationToken.getPrincipal();</span><br><span class="line"> <span class="comment">//        根据用户名查询该数据</span></span><br><span class="line">         Users user = usersService.selectByName(userName);</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span> (user == <span class="keyword">null</span>)&#123;</span><br><span class="line"> <span class="comment">//            没有找到账号</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();</span><br><span class="line">         &#125;</span><br><span class="line">         SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(user.getUserName(), user.getPassWord(),</span><br><span class="line"> <span class="comment">//                此为realm内的方法，用于获取realm的name</span></span><br><span class="line">                 getName()</span><br><span class="line">         );</span><br><span class="line">         <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件，使securityManager获取到该Realm域，使spring容器获取securityManager"><a href="#配置文件，使securityManager获取到该Realm域，使spring容器获取securityManager" class="headerlink" title="配置文件，使securityManager获取到该Realm域，使spring容器获取securityManager"></a>配置文件，使securityManager获取到该Realm域，使spring容器获取securityManager</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--shiro的配置--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注入自定义的Realm--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;userRealm&quot; class&#x3D;&quot;org.ssm.shiro.realm.UserRealm&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;securityManager&quot; class&#x3D;&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;realm&quot; ref&#x3D;&quot;userRealm&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--配置ShiroFilter的属性--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;shiroFilter&quot; class&#x3D;&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">            &lt;value&gt;</span><br><span class="line">                &#x2F;login &#x3D; anon</span><br><span class="line">            &lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>



<h3 id="测试：拦截器"><a href="#测试：拦截器" class="headerlink" title="测试：拦截器"></a>测试：拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        从该回话中获取subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="comment">//        获取用户信息</span></span><br><span class="line">        String user = (String) subject.getPrincipal();</span><br><span class="line"><span class="comment">//        如果用户信息为空，则进行拦截</span></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.sendRedirect(request.getContextPath() + <span class="string">&quot;/User/login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7-01-%E7%94%9F%E4%BA%A7%E8%80%85%E9%87%8D%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7-01-%E7%94%9F%E4%BA%A7%E8%80%85%E9%87%8D%E8%AF%95/" class="post-title-link" itemprop="url">一致性-01-微服务依赖的一致性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-10 12:52:01" itemprop="dateCreated datePublished" datetime="2021-05-10T12:52:01+08:00">2021-05-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>微服务场景下需要同步信息的场景。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbucvzl7K951Z4AH8AYxOdkVg1FL3c5JL3MOr5cib0OYrlPoJhwyUFOIsTylUFMs70JJ226DJ2LV82gQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li>支付服务：负责完成支付操作，其中有支付流水数据。</li>
<li>账单服务：指定时间生成账单给用户，其中有账单流水数据。</li>
</ul>
<p>此时产品上有个需求，在支付管理端根据是否出账搜索支付流水，而出账是账单服务的功能。所以这里涉及到信息的同步，那么，我们怎么保证同步一定能成功呢（最终一致性）。</p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>保证在队列中的消息，一定会被消费，即不停消费直到成功。</p>
<p>方式：</p>
<ul>
<li>消息队列都使用手动提交，即业务处理结束以后再提交。</li>
<li>尽量遵循<a href="">触发-查询机制</a>，<a href="">提供可重入性</a>，即消息队列只有id这种非实质信息，消费者收到之后再通过rpc查询拉取完整数据来更新。</li>
</ul>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>主要是发送消息到队列这步的可靠性考量</p>
<h4 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h4><p>以递增的时间间隔重试5次。如果失败了，上报到日志和告警，人工介入。同时，具体业务准备好重试的脚本。根据实时的情况进行处理。</p>
<ul>
<li><p>优点：</p>
<ul>
<li>简单，能解决瞬间的网络抖动造成的失败。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>可靠性低：在消息队列故障30分钟这种场景下，无法自动恢复。</li>
<li>同时从日志捞取信息，也不方便。</li>
</ul>
</li>
</ul>
<h4 id="失败重试-重试队列"><a href="#失败重试-重试队列" class="headerlink" title="失败重试 + 重试队列"></a>失败重试 + 重试队列</h4><p>失败之后，内存维护一个重试队列，先由5，10，20， 40， 80， 160， 320s的间隔重试。之后以5分钟一次的间隔请求。同时，也要打入日志系统，告警通知。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbucvzl7K951Z4AH8AYxOdkVgILMjxJQEicWMDTbfibOD5zv7peThKtbVqQZ7OZmOibe7enJh59wsHvsaw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li><p>优点：</p>
<ul>
<li>可靠性，在消息队列故障30分钟这种场景下，也能自动恢复。</li>
<li>可以做成jar的方式，方便接入。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>服务重启或者机器挂了，消息就丢了。</li>
</ul>
</li>
</ul>
<blockquote>
<p>限制：</p>
<ul>
<li>消息处理需要遵循<a href="">触发-查询机制</a></li>
</ul>
</blockquote>
<h4 id="失败重试-重试队列-落盘"><a href="#失败重试-重试队列-落盘" class="headerlink" title="失败重试 + 重试队列(落盘)"></a>失败重试 + 重试队列(落盘)</h4><p>失败之后，内存维护一个重试队列，先由5，10，20， 40， 80，160， 320s的间隔重试。然后append到本地文件，同时以5分钟一次的频率做重试。重试完成之后，从磁盘中删除对应信息。当服务重启，从磁盘把数据导入内存即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbucvzl7K951Z4AH8AYxOdkVg4d43bFqupgKHwzicRaaMqTrDLuiaGWyP1BLsdfYpepFeQtlya33LmpQA/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>优点：</p>
<ul>
<li>可靠性会比一高很多，在<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247493109&idx=2&sn=b916d91c76b47dcbefee1a7ba5f88373&chksm=ebd5dad9dca253cf6b642d65d64ebdaa5bf13d56444ca1ce7d603d8abd390daa37a6b609e54c&scene=21#wechat_redirect">消息队列</a>故障30分钟这种场景下，也能自动恢复，</li>
<li>可以做成jar包的方式。</li>
<li>具有比较强的通用型</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了和磁盘打交道的逻辑，引入了文件io。 <!--我认为，为什么非得用io文件，用高可用的中间件redis会更好，专门的运维团队维护，并且逻辑简单--></li>
</ul>
<blockquote>
<p>限制：</p>
<ul>
<li>消息处理需要遵循触发-查询机制</li>
</ul>
</blockquote>
<h4 id="失败重试-中间服务"><a href="#失败重试-中间服务" class="headerlink" title="失败重试 + 中间服务"></a>失败重试 + 中间服务</h4><p>实现任务重试微服务，该服务通过维护一张任务表，重试任务直到成功。相当于是消息队列这个可靠中间件有问题，就丢给这个重试服务这个自己实现的“中间件”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbucvzl7K951Z4AH8AYxOdkVgOs0bCyPgzibbIia963lib5SjHtvUt3Jicl3a7KpHt5TKW4sYlY47icELeDw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>优点：</p>
<ul>
<li>可靠性会比一高很多，在消息队列故障30分钟这种场景下，也能自动恢复。</li>
<li>具有比较强的通用性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>成本变高，需要额外服务。同时，如果服务也挂了，还是得依赖上报。</li>
</ul>
<p>限制：</p>
<ul>
<li>消息处理需要遵循触发-查询机制</li>
</ul>
<p>以上方案中，三，四基本能解决重试阶段写入消息队列的可靠性问题。但针对另一个场景：正想写本身服务就没了的情况（比如oom导致服务被系统kill了） 还是不行。</p>
<h4 id="失败重试-消息注册"><a href="#失败重试-消息注册" class="headerlink" title="失败重试 + 消息注册"></a>失败重试 + 消息注册</h4><p>要做变更之前，先写入到消息同步<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247503061&idx=3&sn=a26fa47e1537b02a3bde0113b1c2b1cf&chksm=ebd5f3f9dca27aefdaeb07db8a5bacf72d3be382b89944cc17d02c444f59c47bb9b96f112560&scene=21#wechat_redirect">微服务</a>，告诉他要做什么事（把什么消息放入消息队列），和流程最长执行时间，以及发给谁。该服务维护一张任务表，任务初始处于未激活状态。</p>
<p>等业务做完要同步的时候，再rpc请求触发激活。</p>
<p>任务管理微服务如果发现一个任务，超过最长执行时间没有激活。就说明激活rpc失败了，或者是服务崩溃，本身就没做变更。此时，自动激活即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbucvzl7K951Z4AH8AYxOdkVgibQd02LbnuuS9nkmxYPNqVOErqNlMTq3YO7cE3DJ3PZ7tNpCL8vZjbg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>优点：完全可靠（事务可能还是会失败，可靠指数据一定最终一致）。</p>
<p>缺点：</p>
<ul>
<li>开发成本比较大，同时会增加消息调用。</li>
<li>增加一个节点，事务失败得可能性更高。</li>
</ul>
<p>限制：</p>
<ul>
<li>消息处理需要遵循触发-查询机制</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>推荐方案三，成本不高，可靠性较强。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%BA%94%E7%94%A8-01-java%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%BA%94%E7%94%A8-01-java%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">延迟加载应用-01-java语言</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-08 08:57:23" itemprop="dateCreated datePublished" datetime="2021-05-08T08:57:23+08:00">2021-05-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>一般有几种延迟初始化的场景：</p>
<ul>
<li>对于会消耗较多资源的对象：加快对象的创建速度，从而从整体上提升性能；并且如果这些对象可能根本用不到，那么就节省资源了。</li>
<li>某些数据在启动时无法获取：比如一些上下文信息可能在其他拦截器或处理中才能被设置，导致当前bean在加载的时候可能获取不到对应的变量的值 <!--bean被加载的时候？加载是针对类说的，对于bean，只能是实例化。如果说的是bean实例化阶段，那么就是发生在spring容器启动阶段以后。从另一方面来说，如果作者想表达的是bean被spring容器加载，那么bean被容器进行di时，spring推荐的是懒加载（延迟初始化），即只注入对象句柄，不关心这个对象句柄指向的对象是否有值 --> ，使用 延迟初始化可以在真正调用的时候去获取，通过延迟来保证数据的有效性。</li>
</ul>
<p>在Java8中引入的lambda对于我们实现延迟操作提供很大的便捷性，如Stream、Supplier等，下面介绍几个例子。</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><h4 id="Lambda-Supplier"><a href="#Lambda-Supplier" class="headerlink" title="Lambda Supplier"></a>Lambda Supplier</h4><p>通过调用<code>get()</code>方法来实现具体对象的计算和生成并返回，而不是在定义Supplier的时候计算，从而达到了_延迟初始化_的目的。</p>
<blockquote>
<p>但是在使用 中需要考虑并发的问题，即防止多次被实例化，就像Spring的@Lazy注解一样。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认第一次调用heavy.get()时，触发同步方法；不会在此定义的时候触发</span></span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;Heavy&gt; heavy = () -&gt; createAndCacheHeavy(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Holder created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Heavy <span class="title">getHeavy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次调用后heavy已经指向了新的instance，所以后续不再执行synchronized。为什么？？heavy.get()应该是每次调用getHeavy()，都会被执行一次；但是由于</span></span><br><span class="line">        <span class="keyword">return</span> heavy.get(); </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Heavy <span class="title">createAndCacheHeavy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法内定义class，注意和类内的嵌套class在加载时的区别</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">HeavyFactory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Heavy</span>&gt; </span>&#123;</span><br><span class="line">            <span class="comment">// 饥渴初始化</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Heavy heavyInstance = <span class="keyword">new</span> Heavy(); </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Heavy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 每次返回固定的值</span></span><br><span class="line">                <span class="keyword">return</span> heavyInstance; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一次调用方法来会将heavy重定向到新的Supplier实例</span></span><br><span class="line">        <span class="keyword">if</span>(!HeavyFactory.class.isInstance(heavy)) &#123;</span><br><span class="line">            heavy = <span class="keyword">new</span> HeavyFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heavy.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Holder的实例被创建时，其中的Heavy实例还没有被创建。下面我们假设有三个线程会调用getHeavy方法，其中前两个线程会同时调用，而第三个线程会在稍晚的时候调用。</p>
<p>当前两个线程调用该方法的时候，都会调用到createAndCacheHeavy方法，由于这个方法是同步的。因此第一个线程进入方法体，第二个线程开始等待。在createAndCacheHeavy方法体中会首先判断当前的heavy是否是HeavyInstance的一个实例。</p>
<p>如果不是，就会将heavy对象替换成HeavyFactory类型的实例。</p>
<ul>
<li>第一个线程执行判断时，heavy对象还只是一个<code>Supplier的实例</code>，所以heavy会被替换成为<code>HeavyFactory的实例</code>，此时<code>heavy实例</code>会被真正的实例化，然后返回实例heavyInstance</li>
<li>第二个线程执行判断时，heavy已经是HeavyFactory的一个实例了，跳过判断，即不实例化，然后直接返回已存在的实例heavyInstance。</li>
</ul>
<p>当第三个线程执行getHeavy方法时，由于此时的heavy对象已经是内嵌的HeavyFactory的实例了，因此它会直接调用HeavyFactory的get()方法从而返回需要的实例（即heavyInstance），即不再调用Heavy的同步方法createAndCacheHeavy没有任何关系了。<!--因为Heavy的同步方法是createAndCacheHeavy()--></p>
<!--在我看来，这是通过把Heavy类向下转为另一个类HeavyFactory（从新实现get()方法），从而get()方法的执行对象变了，这在JUC书中阐述的使用工厂类来避免初始化阶段的线程安全性，一致-->

<p>以上代码实际上实现了一个轻量级的虚拟代理模式(Virtual Proxy Pattern)。保证了懒加载在各种环境下的正确性。</p>
<h5 id="基于delegate：容易理解"><a href="#基于delegate：容易理解" class="headerlink" title="基于delegate：容易理解"></a>基于delegate：容易理解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoizeSupplier</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> Supplier&lt;T&gt; delegate;</span><br><span class="line"> ConcurrentMap&lt;Class&lt;?&gt;, T&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MemoizeSupplier</span><span class="params">(Supplier&lt;T&gt; delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 利用computeIfAbsent方法的特性，保证只会在key不存在的时候调用一次实例化方法，进而实现单例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.map.computeIfAbsent(MemoizeSupplier.class,k -&gt; <span class="keyword">this</span>.delegate.get());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Supplier&lt;T&gt; <span class="title">of</span><span class="params">(Supplier&lt;T&gt; provider)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MemoizeSupplier&lt;&gt;(provider);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="基于CloseableSupplier-：复杂但功能多"><a href="#基于CloseableSupplier-：复杂但功能多" class="headerlink" title="基于CloseableSupplier ：复杂但功能多"></a>基于CloseableSupplier ：复杂但功能多</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseableSupplier</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;T&gt; delegate;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> resetAfterClose;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> T value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">CloseableSupplier</span><span class="params">(Supplier&lt;T&gt; delegate, <span class="keyword">boolean</span> resetAfterClose)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">            <span class="keyword">this</span>.resetAfterClose = resetAfterClose;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 经典Singleton实现</span></span><br><span class="line">            <span class="keyword">if</span> (!(<span class="keyword">this</span>.initialized)) &#123; <span class="comment">// 注意是volatile修饰的，保证happens-before，t一定实例化完全</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(<span class="keyword">this</span>.initialized)) &#123; <span class="comment">// Double Lock Check</span></span><br><span class="line">                        T t = <span class="keyword">this</span>.delegate.get();</span><br><span class="line">                        <span class="keyword">this</span>.value = t;</span><br><span class="line">                        <span class="keyword">this</span>.initialized = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始化后就直接读取值，不再同步抢锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> initialized;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(ThrowableConsumer&lt;T, X&gt; consumer)</span> <span class="keyword">throws</span> X </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialized &amp;&amp; <span class="keyword">this</span>.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    consumer.accept(<span class="keyword">this</span>.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class="line">            checkNotNull(mapper);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialized &amp;&amp; <span class="keyword">this</span>.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ofNullable(mapper.apply(value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            tryClose(i -&gt; &#123; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">tryClose</span><span class="params">(ThrowableConsumer&lt;T, X&gt; close)</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">                    close.accept(value);</span><br><span class="line">                    <span class="keyword">if</span> (resetAfterClose) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">                        initialized = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;MoreSuppliers.lazy(&quot;</span> + get() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;MoreSuppliers.lazy(&quot;</span> + <span class="keyword">this</span>.delegate + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lambda-Stream"><a href="#Lambda-Stream" class="headerlink" title="Lambda Stream"></a>Lambda Stream</h4><p>Stream中的各种方法分为两类：</p>
<ul>
<li>中间方法(limit()/iterate()/filter()/map())</li>
<li>结束方法(collect()/findFirst()/findAny()/count())</li>
</ul>
<p>前者的调用并不会立即执行，只有结束方法被调用后才会依次从前往后触发整个调用链条。但是需要注意，对于集合来说，是每一个元素依次按照处理链条执行到尾，而不是每一个中间方法都将所有能处理的元素全部处理一遍才触发 下一个中间方法。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Brad&quot;</span>, <span class="string">&quot;Kate&quot;</span>, <span class="string">&quot;Kim&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Joe&quot;</span>, <span class="string">&quot;Mike&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String firstNameWith3Letters = names.stream()</span><br><span class="line">    .filter(name -&gt; length(name) == <span class="number">3</span>)</span><br><span class="line">    .map(name -&gt; toUpper(name))</span><br><span class="line">    .findFirst()</span><br><span class="line">    .get();</span><br><span class="line"></span><br><span class="line">System.out.println(firstNameWith3Letters);</span><br></pre></td></tr></table></figure>

<p>当触发findFirst()这一结束方法的时候才会触发整个Stream链条，每个元素依次经过filter()-&gt;map()-&gt;findFirst()后返回。所以filter()先处理，names中第一个和第二个元素不符合条件，不会触发后续的map方法；继续处理第三个元素符合条件，再触发map()方法，最后将转换的结果返回给findFirst()。所以filter()触发了_3_次，map()触发了_1_次。</p>
<p>Stream类型的一个特点是：它们可以是无限的。Stream之所以可以是无限的也是源于Stream「懒」的这一特点。Stream只会返回你需要的元素，而不会一次性地将整个无限集合返回给你。</p>
<p>Stream接口中有一个静态方法iterate()，这个方法能够为你创建一个无限的Stream对象。它需要接受两个参数：</p>
<blockquote>
<p>public static Stream iterate(final T seed, final UnaryOperator f)</p>
</blockquote>
<p>其中，seed表示的是这个无限序列的起点，而UnaryOperator则表示的是如何根据前一个元素来得到下一个元素，比如序列中的第二个元素可以这样决定：f.apply(seed)。</p>
<p>下面是一个计算从某个数字开始并依次返回后面count个素数的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Primes</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">            <span class="comment">// 依次从2到number的平方根判断number是否可以整除该值，即divisor</span></span><br><span class="line">            IntStream.rangeClosed(<span class="number">2</span>, (<span class="keyword">int</span>) Math.sqrt(number))</span><br><span class="line">                .noneMatch(divisor -&gt; number % divisor == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">primeAfter</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(number + <span class="number">1</span>)) <span class="comment">// 如果当前的数的下一个数是素数，则直接返回该值</span></span><br><span class="line">            <span class="keyword">return</span> number + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 否则继续从下一个数据的后面继续找到第一个素数返回，递归</span></span><br><span class="line">            <span class="keyword">return</span> primeAfter(number + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">primes</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> fromNumber, <span class="keyword">final</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(primeAfter(fromNumber - <span class="number">1</span>), Primes::primeAfter)</span><br><span class="line">            .limit(count)</span><br><span class="line">            .collect(Collectors.&lt;Integer&gt;toList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于iterate和limit，它们只是中间操作，得到的对象仍然是Stream类型。对于collect方法，它是一个结束操作，会触发中间操作来得到需要的结果。</p>
<p>如果用非Stream的方式需要面临两个问题：</p>
<ul>
<li>一是无法提前知晓fromNumber后count个素数的数值边界是什么</li>
<li>二是无法使用有限的集合来表示计算范围，无法计算超大的数值</li>
</ul>
<p>所以，因为不知道第一个素数的位置在哪儿，需要提前计算出来第一个素数，然后用while来处理count次查找后续的素数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
