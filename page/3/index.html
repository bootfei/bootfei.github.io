<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">177</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-drool%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-drool%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">开源项目-drool规则引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 12:56:00" itemprop="dateCreated datePublished" datetime="2021-04-20T12:56:00+08:00">2021-04-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%9C%BA%E6%99%AF%E4%B8%AD%E8%A7%84%E5%88%99%E6%89%A7%E8%A1%8C%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%9C%BA%E6%99%AF%E4%B8%AD%E8%A7%84%E5%88%99%E6%89%A7%E8%A1%8C%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">多条件判断场景中规则执行器的设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-20 12:55:44 / Modified: 13:30:25" itemprop="dateCreated datePublished" datetime="2021-04-20T12:55:44+08:00">2021-04-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a><a href="juejin.cn/post/6951764927958745124">业务场景</a></h2><p>近日在公司领到一个小需求，需要对之前已有的试用用户申请规则进行拓展。我们的场景大概如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (是否海外用户) &#123;</span><br><span class="line"> return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (刷单用户) &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (未付费用户 &amp;&amp; 不再服务时段) &#123;</span><br><span class="line">  return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (转介绍用户 || 付费用户 || 内推用户) &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照上述的条件我们可以得出的结论是：</p>
<ul>
<li>咱们的的主要流程主要是基于 and 或者 or 的关系。</li>
<li>如果有一个不匹配的话，其实咱们后续的流程是不用执行的，就是需要具备一个短路的功能。</li>
<li>对于目前的现状来说，我如果在原有的基础上来改，只要稍微注意一下解决需求不是很大的问题，但是说后面可维护性非常差。</li>
</ul>
<p>后面进过权衡过后，我还是决定将这个部分进行重构一下。</p>
<h2 id="规则执行器"><a href="#规则执行器" class="headerlink" title="规则执行器"></a>规则执行器</h2><p>针对这个需求，我首先梳理了一下咱们规则执行器大概的设计， 然后我设计了一个 V1 版本和大家一起分享一下，如果大家也有这样的 case 可以给我分享留言，下面部分主要是<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487450&idx=1&sn=de3de5a8e5ac476935f2e02706125549&chksm=ebd630f6dca1b9e0ac044234ecb72d54a2d9c46bc3b84dd3b56dbca59b6ba79e56a3434d4c4d&scene=21#wechat_redirect">设计和实现</a>的流程和 code.</p>
<h3 id="设计图"><a href="#设计图" class="headerlink" title="设计图"></a>设计图</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c6560fb2f5f445d8716438974f165db~tplv-k3u1fbpfcp-watermark.image" alt="规则处理逻辑优化.png"></p>
<h3 id="操作交互对象RuleDto"><a href="#操作交互对象RuleDto" class="headerlink" title="操作交互对象RuleDto"></a>操作交互对象RuleDto</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 业务数据</span><br><span class="line">@Data</span><br><span class="line">public class RuleDto &#123;</span><br><span class="line">  private String address;</span><br><span class="line"> private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="规则BaseRule"><a href="#规则BaseRule" class="headerlink" title="规则BaseRule"></a>规则BaseRule</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 规则抽象</span><br><span class="line">public interface BaseRule &#123;</span><br><span class="line">    boolean execute(RuleDto dto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 规则模板</span><br><span class="line">public abstract class AbstractRule implements BaseRule &#123;</span><br><span class="line">    protected &lt;T&gt; T convert(RuleDto dto) &#123;</span><br><span class="line">        return (T) dto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean execute(RuleDto dto) &#123;</span><br><span class="line">        return executeRule(convert(dto));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    protected &lt;T&gt; boolean executeRule(T t) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 具体规则- 例子1</span><br><span class="line">public class AddressRule extends AbstractRule &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean execute(RuleDto dto) &#123;</span><br><span class="line">        System.out.println(&quot;AddressRule invoke!&quot;);</span><br><span class="line">        if (dto.getAddress().startsWith(MATCH_ADDRESS_START)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 具体规则- 例子2</span><br><span class="line">public class NationalityRule extends AbstractRule &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected &lt;T&gt; T convert(RuleDto dto) &#123;</span><br><span class="line">        NationalityRuleDto nationalityRuleDto &#x3D; new NationalityRuleDto();</span><br><span class="line">        if (dto.getAddress().startsWith(MATCH_ADDRESS_START)) &#123;</span><br><span class="line">            nationalityRuleDto.setNationality(MATCH_NATIONALITY_START);</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) nationalityRuleDto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected &lt;T&gt; boolean executeRule(T t) &#123;</span><br><span class="line">        System.out.println(&quot;NationalityRule invoke!&quot;);</span><br><span class="line">        NationalityRuleDto nationalityRuleDto &#x3D; (NationalityRuleDto) t;</span><br><span class="line">        if (nationalityRuleDto.getNationality().startsWith(MATCH_NATIONALITY_START)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 常量定义</span><br><span class="line">public class RuleConstant &#123;</span><br><span class="line">    public static final String MATCH_ADDRESS_START&#x3D; &quot;北京&quot;;</span><br><span class="line">    public static final String MATCH_NATIONALITY_START&#x3D; &quot;中国&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行器RuleService"><a href="#执行器RuleService" class="headerlink" title="执行器RuleService"></a>执行器RuleService</h3><ul>
<li>存储需要的BaseRule</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class RuleService &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;Integer, List&lt;BaseRule&gt;&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    private static final int AND &#x3D; 1;</span><br><span class="line">    private static final int OR &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static RuleService create() &#123;</span><br><span class="line">        return new RuleService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RuleService and(List&lt;BaseRule&gt; ruleList) &#123;</span><br><span class="line">        hashMap.put(AND, ruleList);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RuleService or(List&lt;BaseRule&gt; ruleList) &#123;</span><br><span class="line">        hashMap.put(OR, ruleList);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean execute(RuleDto dto) &#123;</span><br><span class="line">        for (Map.Entry&lt;Integer, List&lt;BaseRule&gt;&gt; item : hashMap.entrySet()) &#123;</span><br><span class="line">            List&lt;BaseRule&gt; ruleList &#x3D; item.getValue();</span><br><span class="line">            switch (item.getKey()) &#123;</span><br><span class="line">                case AND:</span><br><span class="line">                    &#x2F;&#x2F; 如果是 and 关系，同步执行</span><br><span class="line">                    System.out.println(&quot;execute key &#x3D; &quot; + 1);</span><br><span class="line">                    if (!and(dto, ruleList)) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case OR:</span><br><span class="line">                    &#x2F;&#x2F; 如果是 or 关系，并行执行</span><br><span class="line">                    System.out.println(&quot;execute key &#x3D; &quot; + 0);</span><br><span class="line">                    if (!or(dto, ruleList)) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean and(RuleDto dto, List&lt;BaseRule&gt; ruleList) &#123;</span><br><span class="line">        for (BaseRule rule : ruleList) &#123;</span><br><span class="line">            boolean execute &#x3D; rule.execute(dto);</span><br><span class="line">            if (!execute) &#123;</span><br><span class="line">                &#x2F;&#x2F; and 关系匹配失败一次就返回 false</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; and 关系全部匹配成功，返回 true</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean or(RuleDto dto, List&lt;BaseRule&gt; ruleList) &#123;</span><br><span class="line">        for (BaseRule rule : ruleList) &#123;</span><br><span class="line">            boolean execute &#x3D; rule.execute(dto);</span><br><span class="line">            if (execute) &#123;</span><br><span class="line">                &#x2F;&#x2F; or 关系匹配到一个就返回 true</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; or 关系一个都匹配不到就返回 false</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class RuleServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        &#x2F;&#x2F;规则执行器</span><br><span class="line">        &#x2F;&#x2F;优点：比较简单，每个规则可以独立，将规则，数据，执行器拆分出来，调用方比较规整</span><br><span class="line">        &#x2F;&#x2F;缺点：数据依赖公共传输对象 dto</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1. 定义规则  init rule</span><br><span class="line">        AgeRule ageRule &#x3D; new AgeRule();</span><br><span class="line">        NameRule nameRule &#x3D; new NameRule();</span><br><span class="line">        NationalityRule nationalityRule &#x3D; new NationalityRule();</span><br><span class="line">        AddressRule addressRule &#x3D; new AddressRule();</span><br><span class="line">        SubjectRule subjectRule &#x3D; new SubjectRule();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2. 构造需要的数据 create dto</span><br><span class="line">        RuleDto dto &#x3D; new RuleDto();</span><br><span class="line">        dto.setAge(5);</span><br><span class="line">        dto.setName(&quot;张三&quot;);</span><br><span class="line">        dto.setAddress(&quot;北京&quot;);</span><br><span class="line">        dto.setSubject(&quot;数学&quot;);;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3. 通过以链式调用构建和执行 rule execute</span><br><span class="line">        boolean ruleResult &#x3D; RuleService</span><br><span class="line">                .create()</span><br><span class="line">                .and(Arrays.asList(nationalityRule, nameRule, addressRule))</span><br><span class="line">                .or(Arrays.asList(ageRule, subjectRule))</span><br><span class="line">                .execute(dto);</span><br><span class="line">        System.out.println(&quot;this student rule execute result :&quot; + ruleResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>规则执行器的优点和缺点</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>比较简单，每个规则可以独立，将规则，数据，执行器拆分出来，调用方比较规整；</li>
<li>我在 Rule 模板类中定义 convert 方法做参数的转换这样可以能够，为特定 rule 需要的场景数据提供拓展。</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>上下 rule 有数据依赖性，如果直接修改公共传输对象 dto 这样设计不是很合理，建议提前构建数据。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/Nginx/nginx-02-%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/Nginx/nginx-02-%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">nginx-02-搭建图片服务器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-20 09:12:25 / Modified: 09:12:39" itemprop="dateCreated datePublished" datetime="2021-04-20T09:12:25+08:00">2021-04-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在我们搭建一个网站的时候，往往有时候会加载更多的图片，如果都从tomcat服务器来获取静态资源，这样会增加我们服务器的负载，使得服务器运行 速度非常慢，这时我们可以使用nginx服务器来加载这些静态资源，这样就可以实现负载均衡，为我们的Tomcat服务器减压了。一般大型网站都这么干，他们有单独的图片服务器，这里我们在本地利用nignx来搭建一个简单的图片服务器。</p>
<h2 id="一、安装nignx"><a href="#一、安装nignx" class="headerlink" title="一、安装nignx"></a>一、安装nignx</h2><p>nignx是绿色版本的，只要到官网下载解压既可启动，解压目录图如下所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhoty2G93IHlGMySSUwnawYO0q6XiaO29lAOHcYLTOcJIiaoqOQu0Iu2P2pbp4wGMGVaibAerUiau4BcrQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>这里我们可以通过命令行start nignx.exe来启动服务器，也可以通过bat批处理文件来启动，打开批处理文件简单处理一下就 可以启动了：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhoty2G93IHlGMySSUwnawYO5I0AROmR7uyjzT8L1ZwHzmmZ218JPxTtkJa6j2MWVNQA63BdibG5VBg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>上面的两种方式都可以启动服务器，当我们启动一下服务器我们来简单测试一下，在浏览器输入localhost访问，你可以看见一个简单nignx服务器欢迎页面。</p>
<p>下面，我们着重讲解一下nignx的配置文件，在conf目录下，打开nignx.conf文件，nginx.conf由多个块组成，最外面的块是main，main包含events和http,http包含多个upstream和多个server，server又包含多个location：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhoty2G93IHlGMySSUwnawYO7JEQPfRYQ3eML9BEEVA9kWDcYLxAScu5O8yrhjsyPwtQibk7CSMjKwQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>main（全局设置）、server（虚拟主机设置）、upstream（负载均衡服务器设置）和 location（URL匹配特定位置的设置）。</p>
<ol>
<li>main块设置的指令将影响其他所有设置；</li>
<li>server块的指令主要用于指定主机和端口；</li>
<li>upstream指令主要用于负载均衡，设置一系列的后端服务器；</li>
<li>location块用于匹配网页位置。 这四者之间的关系式：server继承main，location继承server，upstream既不会继承其他设置也不会被继承。</li>
</ol>
<p>在这四个部分当中，每个部分都包含若干指令，这些指令主要包含Nginx的主模块指令、事件模块指令、HTTP核心模块指令，同时每个部分还可以使用其他HTTP模块指令，例如Http SSL模块、HttpGzip Static模块和Http Addition模块等。</p>
<p>通过上面的简单的讲解我们了解了一下nignx的配置文件，现在我们来具体看一下它的内容并且开始配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面这是配置文件中的一部分，我们看一下location这个节点，它下面的root表示该站点的根目录，root html表示根目录下有一个html文件夹，当你访问上面配置的域名（laocahost）时，它默认访问跟目录下的html文件中的index.html页面，这样你应该就明白了怎么样配置一个自定义的图片服务器了吧，我们可以自定一个server节点，将其localhost节点指定为我们要访问的图片地址域名，这样我们就可以轻松访问我们的静态资源了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">           root   html;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、搭建图片服务器"><a href="#二、搭建图片服务器" class="headerlink" title="二、搭建图片服务器"></a>二、搭建图片服务器</h2><p>经过上面的介绍我们应该明白了它的大概原理，下面我们来实战配置一下。</p>
<p>首先我们这里是本地搭建，所以没有域名，这里我们可以随便一个二级域名来作为练习（比如images.shinelon.com），我们找到C:\Windows\System32\drivers\etc这个目录下有一个hosts文件来加入映射我们的域名，加入下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   images.shinelon.com</span><br></pre></td></tr></table></figure>

<p>然后我们复制nignx.conf文件的server节点，改为如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  images.shinelon.com;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root  D:\images;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面，我们将域名改为了我们自定义的图片域名，将root目录改为了我们的图片存放目录（D:\images），这样我们启动nignx服务器就可以访问图片资源了，这里加入该目录下有一张图片为1.jpg。当你在浏览器中输入images.shinelon.com/1.jpg就可以访问我们的图片资源了。</p>
<p>至此，我们就搭建了一个简单的图片服务器。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-JUC-ConcurrentHashMap%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-JUC-ConcurrentHashMap%E8%A7%A3%E8%AF%BB/" class="post-title-link" itemprop="url">JDK-JUC-ConcurrentHashMap解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-19 09:07:43" itemprop="dateCreated datePublished" datetime="2021-04-19T09:07:43+08:00">2021-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-27 13:43:15" itemprop="dateModified" datetime="2021-04-27T13:43:15+08:00">2021-04-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UOr9BOWrv67d8l1VQxqUkA">HashMap</a></h1><h2 id="把书读薄"><a href="#把书读薄" class="headerlink" title="把书读薄"></a>把书读薄</h2><p>在<code>Java 7</code>中<code>HashMap</code>实现有1000多行，到了<code>Java 8</code>中增长为2000多行，虽然代码行数不多，但代码中有比较多的位运算，以及其他的一些细枝末节，导致这部分代码看起来很复杂，理解起来比较困难。但是如果我们跳出来看，<code>HashMap</code>这个数据结构是非常基础的，我们大脑中首先要有这样一幅图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdibMJVazadOLIHm8dB5Us2Nq4WlibbqZL4NMBNIMsRP3NibcOYT3uU7wNrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>图片来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/tianzhihensu/p/11972780.html">https://www.cnblogs.com/tianzhihensu/p/11972780.html</a></p>
<p>这张图囊括了HashMap中最基础的几个点：</p>
<ol>
<li><code>Java</code>中<code>HashMap</code>的实现的基础数据结构是数组，每一对<code>key</code>-&gt;<code>value</code>的键值对组成<code>Entity</code>类以双向链表的形式存放到这个数组中</li>
<li>元素在数组中的位置由<code>key.hashCode()</code>的值决定，如果两个<code>key</code>的哈希值相等，即发生了哈希碰撞，则这两个<code>key</code>对应的<code>Entity</code>将以链表的形式存放在数组中</li>
<li>调用<code>HashMap.get()</code>的时候会首先计算<code>key</code>的值，继而在数组中找到<code>key</code>对应的位置，然后遍历该位置上的链表找相应的值。</li>
</ol>
<p>当然这张图中没有体现出来的有两点：</p>
<ol>
<li>为了提升整个<code>HashMap</code>的读取效率，当<code>HashMap</code>中存储的元素大小等于桶数组大小乘以负载因子的时候整个<code>HashMap</code>就要扩容，以减小哈希碰撞，具体细节我们在后文中讲代码会说到</li>
<li>在<code>Java 8</code>中如果桶数组的同一个位置上的链表数量超过一个定值，则整个链表有一定概率会转为一棵红黑树。</li>
</ol>
<p>整体来看，整个<code>HashMap</code>中最重要的点有四个：<strong>初始化</strong>，<strong>数据寻址-<code>hash</code>方法</strong>，<strong>数据存储-<code>put</code>方法</strong>,<strong>扩容-<code>resize</code>方法</strong>，只要理解了这四个点的原理和调用时机，也就理解了整个<code>HashMap</code>的设计。</p>
<h2 id="把书读厚"><a href="#把书读厚" class="headerlink" title="把书读厚"></a>把书读厚</h2><p>在理解了<code>HashMap</code>的整体架构的基础上，我们可以试着回答一下下面的几个问题，如果对其中的某几个问题还有疑惑，那就说明我们还需要深入代码，把书读厚。</p>
<ol>
<li><code>HashMap</code>内部的<code>bucket</code>数组长度为什么一直都是2的整数次幂</li>
<li><code>HashMap</code>默认的<code>bucket</code>数组是多大</li>
<li><code>HashMap</code>什么时候开辟<code>bucket</code>数组占用内存</li>
<li><code>HashMap</code>何时扩容？</li>
<li>桶中的元素链表何时转换为红黑树，什么时候转回链表，为什么要这么设计？</li>
<li><code>Java 8</code>中为什么要引进红黑树，是为了解决什么场景的问题？</li>
<li><code>HashMap</code>如何处理<code>key</code>为<code>null</code>的键值对？</li>
</ol>
<h2 id="new-HashMap"><a href="#new-HashMap" class="headerlink" title="new HashMap()"></a><code>new HashMap()</code></h2><p>在<code>JDK 8</code>中，在调用<code>new HashMap()</code>的时候并没有分配数组堆内存，只是做了一些参数校验，初始化了一些常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n &#x3D; cap - 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tableSizeFor</code>的作用是找到大于<code>cap</code>的最小的2的整数幂，我们假设n(注意是n，不是cap哈)对应的二进制为000001xxxxxx，其中x代表的二进制位是0是1我们不关心 <!--我个人看法，使用位运算时，一定要注意最高位，最高位是符号位，不能移动，所以32bit的int，只能用到倒数第2的高位bit，所以HashMap的最大容量是2^30 --></p>
<p><code>n |= n &gt;&gt;&gt; 1;</code>执行后<code>n</code>的值为：</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdibnWhteLvazicGAkd7go3CeiabRjYN0ib1Wb5h1B8TuPOHBT1cr1K0GCaSA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:33%;" />

<p>可以看到此时<code>n</code>的二进制最高两位已经变成了1（1和0或1异或都是1），再接着执行第二行代码：</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdibibEwy9YFEA0Gy21LJYNColicAxpW11teDQpRZvE0HqcTC1QYJ6Z7fWBQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:33%;" />

<p>可见<code>n</code>的二进制最高四位已经变成了1，等到执行完代码<code>n |= n &gt;&gt;&gt; 16;</code>之后，<code>n</code>的二进制最低位全都变成了1，<!--就是为了创建最低位都是1的整数--> 也就是<code>n = 2^x - 1</code>其中x和n的值有关，如果没有超过<code>MAXIMUM_CAPACITY</code>，最后会返回一个2的正整数次幂，因此<code>tableSizeFor()</code>的作用就是保证返回一个比入参大的最小的2的正整数次幂。<!--说白了，就是把bit是1的最高位以后的低位，全部置为1，这就是“最小的2的正整数次幂”--></p>
<p>在<code>JDK 7</code>中初始化的代码大体一致，在<code>HashMap</code>第一次<code>put</code>的时候会调用<code>inflateTable</code>计算桶数组的长度，但其算法并没有变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一次put时，初始化table</span><br><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">    &#x2F;&#x2F; Find an power of 2 &gt;&#x3D; toSize</span><br><span class="line">    int capacity &#x3D; roundUpToPowerOf2(toSize);</span><br><span class="line">    threshold &#x3D; (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    table &#x3D; new Entry(capacity);</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们也回答了开头提出来的问题：</p>
<p><code>HashMap</code>什么时候开辟<code>bucket</code>数组占用内存？答案是在<code>HashMap</code>第一次<code>put</code>的时候，无论<code>Java 8</code>还是<code>Java 7</code>都是这样实现的 <!--计算机领域，只有对象真正被使用的时候，才被初始化。类似“延迟加载”-->。这里我们可以看到两个版本的实现中，桶数组的大小都是2的正整数幂，至于为什么这么设计，看完后文你就明白了。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a><code>hash</code></h2><p>在<code>HashMap</code>这个特殊的数据结构中，<code>hash</code>函数承担着寻址定址的作用，其性能对整个<code>HashMap</code>的性能影响巨大，那什么才是一个好的<code>hash</code>函数呢？</p>
<ul>
<li>计算出来的哈希值足够散列，能够有效减少哈希碰撞</li>
<li>本身能够快速计算得出，因为<code>HashMap</code>每次调用<code>get</code>和<code>put</code>的时候都会调用<code>hash</code>方法</li>
</ul>
<p>下面是<code>Java 8</code>中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里比较重要的是<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，这个位运算其实是将<code>key.hashCode()</code>计算出来的<code>hash</code>值的高16位与低16位继续异或，为什么要这么做呢？</p>
<p>我们知道<code>hash</code>函数的作用是用来确定<code>key</code>在桶数组中的位置的，在<code>JDK</code>中为了更好的性能，通常会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D;(table.length - 1) &amp; key.hash();</span><br></pre></td></tr></table></figure>

<p>回忆前文中的内容，<code>table.length</code>是一个2的正整数次幂，类似于<code>000100000</code>，这样的值减一就成了<code>000011111</code>，通过位运算可以高效寻址，这也回答了前文中提到的一个问题，<code>HashMap</code>内部的<code>bucket</code>数组长度为什么一直都是2的整数次幂？好处之一就是可以通过构造位运算快速寻址定址。</p>
<p>回到本小节的议题，既然计算出来的哈希值都要与<code>table.length - 1</code>做与运算，那就意味着计算出来的<code>hash</code>值只有低位有效，这样会加大碰撞几率，因此让高16位与低16位做异或，让低位保留部分高位信息，减少哈希碰撞。</p>
<p>我们再看<code>Java 7</code>中对hash的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final int hash(Object k) &#123;</span><br><span class="line">    int h &#x3D; hashSeed;</span><br><span class="line">    if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">        return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^&#x3D; k.hashCode();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This function ensures that hashCodes that differ only by </span><br><span class="line">    &#x2F;&#x2F; constant multiples at each bit position have a bounded </span><br><span class="line">    &#x2F;&#x2F; number of collisions (approximately 8 at default load factor). </span><br><span class="line">    h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Java 7</code>中为了避免<code>hash</code>值的高位信息丢失，做了更加复杂的异或运算，但是基本出发点都是一样的，都是让哈希值的低位保留部分高位信息，减少哈希碰撞。</p>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a><code>put</code></h2><p>在<code>Java 8</code>中<code>put</code>这个方法的思路分为以下几步：</p>
<ol>
<li>调用<code>key</code>的<code>hashCode</code>方法计算哈希值，并据此计算出数组下标index</li>
<li>如果发现当前的桶数组为<code>null</code>，则调用<code>resize()</code>方法进行初始化</li>
<li>如果没有发生哈希碰撞，则直接放到对应的桶中</li>
<li>如果发生哈希碰撞，且节点已经存在，就替换掉相应的<code>value</code></li>
<li>如果发生哈希碰撞，且桶中存放的是树状结构，则挂载到树上</li>
<li>如果碰撞后为链表，添加到链表尾，如果链表长度超过<code>TREEIFY_THRESHOLD</code>默认是8，则将链表转换为树结构</li>
<li>数据<code>put</code>完成后，如果<code>HashMap</code>的总数超过<code>threshold</code>就要<code>resize</code></li>
</ol>
<p>具体代码以及注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用上文我们已经分析过的hash方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 第一次put时，会调用resize进行桶数组初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据数组长度和哈希值相与来寻址，原理上文也分析过</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果没有哈希碰撞，直接放到桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 哈希碰撞，且节点已存在，直接替换</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 哈希碰撞，树结构</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 哈希碰撞，链表结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表过长，转换为树结构</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 如果节点已存在，则跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 否则，指针后移，继续后循环</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 对应着上文中节点已存在，跳出循环的分支</span></span><br><span class="line">            <span class="comment">// 直接替换</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 如果超过阈值，还需要扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之下<code>Java 7</code>中的<code>put</code>方法就简单不少</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果 key 为 null，调用 putForNullKey 方法进行处理  </span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash &#x3D; hash(key.hashCode());</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">    for (Entry&lt;K, V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;  </span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key</span><br><span class="line">                || key.equals(k))) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K, V&gt; e &#x3D; table[bucketIndex];     &#x2F;&#x2F; ①  </span><br><span class="line">    table[bucketIndex] &#x3D; new Entry&lt;K, V&gt;(hash, key, value, e);</span><br><span class="line">    if (size++ &gt;&#x3D; threshold)</span><br><span class="line">        resize(2 * table.length);    &#x2F;&#x2F; ②  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个小细节，<code>HashMap</code>允许<code>put</code>key为<code>null</code>的键值对，但是这样的键值对都放到了桶数组的第0个桶中。</p>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a><code>resize()</code></h2><p><code>resize</code>是整个<code>HashMap</code>中最复杂的一个模块，如果在<code>put</code>数据之后超过了<code>threshold</code>的值，则需要扩容，扩容意味着桶数组大小变化，我们在前文中分析过，<code>HashMap</code>寻址是通过<code>index =(table.length - 1) &amp; key.hash();</code>来计算的，现在<code>table.length</code>发生了变化，势必会导致部分<code>key</code>的位置也发生了变化，<code>HashMap</code>是如何设计的呢？</p>
<p>这里就涉及到桶数组长度为2的正整数幂的第二个优势了：当桶数组长度为2的正整数幂时，如果桶发生扩容（长度翻倍），则桶中的元素大概只有一半需要切换到新的桶中，另一半留在原先的桶中就可以，并且这个概率可以看做是均等的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdiblzYia6ic0unz6yDBBUz9zaYTfnYCdtazFW4ibtEf8bs5F6K2zdNPK7n9w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>通过这个分析可以看到如果在即将扩容的那个位上<code>key.hash()</code>的二进制值为0，则扩容后在桶中的地址不变，否则，扩容后的最高位变为了1，新的地址也可以快速计算出来<code>newIndex = oldCap + oldIndex;</code> <!--对以前的地址完美兼容，这就是size是2的次幂的优势--></p>
<p>下面是<code>Java 8</code>中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果oldCap &gt; 0则对应的是扩容而不是初始化</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 没有超过最大值，就扩大为原先的2倍</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">        &#x2F;&#x2F; 如果oldCap为0， 但是oldThr不为0，则代表的是table还未进行过初始化</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果到这里newThr还未计算，比如初始化时，则根据容量计算出新的阈值</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历之前的桶数组，对其值重新散列</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    &#x2F;&#x2F; 如果原先的桶中只有一个元素，则直接放置到新的桶中</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    &#x2F;&#x2F; 如果原先的桶中是链表</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F; hiHead和hiTail代表元素在新的桶中和旧的桶中的位置不一致</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        &#x2F;&#x2F; loHead和loTail代表元素在新的桶中和旧的桶中的位置一致</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        &#x2F;&#x2F; 新的桶中的位置 &#x3D; 旧的桶中的位置 + oldCap， 详细分析见前文</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Java 7</code>中的<code>resize</code>方法相对简单许多：</p>
<ol>
<li>基本的校验之后<code>new</code>一个新的桶数组，大小为指定入参</li>
<li>桶内的元素根据新的桶数组长度确定新的位置，放置到新的桶数组中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable &#x3D; table;</span><br><span class="line">    int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable &#x3D; new Entry[newCapacity];</span><br><span class="line">    boolean oldAltHashing &#x3D; useAltHashing;</span><br><span class="line">    useAltHashing |&#x3D; sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (newCapacity &gt;&#x3D; Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    boolean rehash &#x3D; oldAltHashing ^ useAltHashing;</span><br><span class="line">    transfer(newTable, rehash);</span><br><span class="line">    table &#x3D; newTable;</span><br><span class="line">    threshold &#x3D; (int) Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity &#x3D; newTable.length;</span><br><span class="line">    for (Entry&lt;K, V&gt; e : table) &#123;</span><br><span class="line">        &#x2F;&#x2F;链表跟table[i]断裂遍历，头部往后遍历插入到newTable中</span><br><span class="line">        while (null !&#x3D; e) &#123;</span><br><span class="line">            Entry&lt;K, V&gt; next &#x3D; e.next;</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next &#x3D; newTable[i];</span><br><span class="line">            newTable[i] &#x3D; e;</span><br><span class="line">            e &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在看完了<code>HashMap</code>在<code>Java 8</code>和<code>Java 7</code>的实现之后我们回答一下前文中提出来的那几个问题：</p>
<ol>
<li><p><code>HashMap</code>内部的<code>bucket</code>数组长度为什么一直都是2的整数次幂</p>
<p>答：这样做有两个好处，第一，可以通过<code>(table.length - 1) &amp; key.hash()</code>这样的位运算快速寻址，第二，在<code>HashMap</code>扩容的时候可以保证同一个桶中的元素均匀的散列到新的桶中，具体一点就是同一个桶中的元素在扩容后一般留在原先的桶中，一般放到了新的桶中。</p>
</li>
<li><p><code>HashMap</code>默认的<code>bucket</code>数组是多大</p>
<p>答：默认是16，即时指定的大小不是2的整数次幂，<code>HashMap</code>也会找到一个最近的2的整数次幂来初始化桶数组。<!--长度不超过2^30--></p>
</li>
<li><p><code>HashMap</code>什么时候开辟<code>bucket</code>数组占用内存</p>
<p>答：在第一次<code>put</code>的时候调用<code>resize</code>方法</p>
</li>
<li><p><code>HashMap</code>何时扩容？</p>
<p>答：当<code>HashMap</code>中的元素熟练超过阈值时，阈值计算方式是<code>capacity * loadFactor</code>，在<code>HashMap</code>中<code>loadFactor</code>是0.75</p>
</li>
<li><p>桶中的元素链表何时转换为红黑树，什么时候转回链表，为什么要这么设计？</p>
<p>答：当同一个桶中的元素数量大于等于8的时候元素中的链表转换为红黑树，反之，当桶中的元素数量小于等于6的时候又会转为链表，这样做的原因是避免红黑树和链表之间频繁转换，引起性能损耗</p>
</li>
<li><p><code>Java 8</code>中为什么要引进红黑树，是为了解决什么场景的问题？</p>
<p>答：引入红黑树是为了避免<code>hash</code>性能急剧下降，引起<code>HashMap</code>的读写性能急剧下降的场景，正常情况下，一般是不会用到红黑树的，在一些极端场景下，假如客户端实现了一个性能拙劣的<code>hashCode</code>方法，可以保证<code>HashMap</code>的读写复杂度不会低于O(lgN)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>HashMap</code>如何处理<code>key</code>为<code>null</code>的键值对？</p>
<p>答：放置在桶数组中下标为0的桶中</p>
</li>
</ol>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BwSfp1yfQP-OJc9BqecPvQ">ConcurrentHashMap</a></h1><h2 id="一些题外话"><a href="#一些题外话" class="headerlink" title="一些题外话"></a>一些题外话</h2><p>如何在高并发下提高系统吞吐是所有后端开发者追求的目标，Java并发的开创者Doug Lea在Java 7 ConcurrentHashMap的设计中给出了一些参考答案，本文详细的总结了ConcurrentHashMap源码中影响并发性能的十个细节，有常见的自旋锁，CAS的使用，也有延迟写内存，volatile语义退化等不常见的技巧，希望对大家的开发设计有所帮助。</p>
<h2 id="把书读薄-1"><a href="#把书读薄-1" class="headerlink" title="把书读薄"></a>把书读薄</h2><p>《阿里巴巴Java开发手册》的作者孤尽对<code>ConcurrentHashMap</code>的设计十分推崇，他说：“<code>ConcurrentHashMap</code>源码是学习<code>Java</code>代码开发规范的一个非常好的学习材料，我建议同学们可以时常去看一看，总会有新的收货的”，相信大家平常也能听到很多对于<code>ConcurrentHashMap</code>设计的溢美之词，在展开隐藏在<code>ConcurrentHashMap</code>所有小秘密之前，大家在大脑中首先要有这样的一幅图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/R7PtjL3tdAicMdbQfrvwSkfich8cYHngc1rpQ50iaXsQib1VWGqQLr22AgdZcyW71A5P2FpBd9nia1ahOJAXAXSVOOA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">img</p>
<p>对于<code>Java 7</code>来说，这张图已经能完全把<code>ConcurrentHashMap</code>的架构说清楚了：</p>
<ol>
<li><code>ConcurrentHashMap</code>是一个线程安全的<code>Map</code>实现，其读取不需要加锁，通过引入<code>Segment</code>，可以做到写入的时候加锁力度足够小</li>
<li>由于引入了<code>Segment</code>，<code>ConcurrentHashMap</code>在读取和写入的时候需要需要做两次哈希，但这两次哈希换来的是更细力粒度的锁，也就意味着可以支持更高的并发</li>
<li>每个桶数组中的<code>key-value</code>对仍然以链表的形式存放在桶中，这一点和<code>HashMap</code>是一致的。</li>
</ol>
<h2 id="把书读厚-1"><a href="#把书读厚-1" class="headerlink" title="把书读厚"></a>把书读厚</h2><p>关于<code>Java 7</code>的<code>ConcurrentHashMap</code>的整体架构，用上面三两句话就可以概括，这张图应该很快就可以在大家的大脑中留下印象，接下来我们通过几个问题来尝试吸引大家继续看下去，把书读厚：</p>
<ol>
<li><code>ConcurrentHashMap</code>的哪些操作需要加锁？</li>
<li><code>ConcurrentHashMap</code>的无锁读是如何实现的？</li>
<li>在多线程的场景下调用<code>size（）</code>方法获取<code>ConcurrentHashMap</code>的大小有什么挑战？<code>ConcurrentHashMap</code>是怎么解决的？</li>
<li>在有<code>Segment</code>存在的前提下，应该如何扩容的？</li>
</ol>
<p>在上一篇文章中我们总结了<code>HashMap</code>中最重要的点有四个：<strong>初始化</strong>，<strong>数据寻址-<code>hash</code>方法</strong>，<strong>数据存储-<code>put</code>方法</strong>,<strong>扩容-<code>resize</code>方法</strong>，对于<code>ConcurrentHashMap</code>来说，这四个操作依然是最重要的，但由于其引入了更复杂的数据结构，因此在调用<code>size()</code>查看整个<code>ConcurrentHashMap</code>的数量大小的时候也有不小的挑战，我们也会重点看下Doug Lea在<code>size()</code>方法中的设计</p>
<h2 id="new-ConcurrentHashMap"><a href="#new-ConcurrentHashMap" class="headerlink" title="new ConcurrentHashMap()"></a><code>new ConcurrentHashMap()</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 保证ssize是大于concurrencyLevel的最小的2的整数次幂</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻址需要两次哈希，哈希的高位用于确定segment，低位用户确定桶数组中的元素</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化方法中做了三件重要的事：</p>
<ol>
<li>确定了<code>segments</code>的数组的大小<code>ssize</code>，<code>ssize</code>根据入参<code>concurrencyLevel</code>确定，取大于<code>concurrencyLevel</code>的最小的2的整数次幂</li>
<li>确定哈希寻址时的偏移量，这个偏移量在确定元素在<code>segment</code>数组中的位置时会用到</li>
<li>初始化<code>segment</code>数组中的第一个元素，元素类型为<code>HashEntry</code>的数组，这个数组的长度为<code>initialCapacity / ssize</code>，即初始化大小除以<code>segment</code>数组的大小，<code>segment</code>数组中的其他元素在后续<code>put</code>操作时参考第一个已初始化的实例初始化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash; </span><br><span class="line">    final K key;</span><br><span class="line">    volatile V value;</span><br><span class="line">    volatile HashEntry&lt;K,V&gt; next; </span><br><span class="line"> </span><br><span class="line">    HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash &#x3D; hash;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">    final void setNext(HashEntry&lt;K,V&gt; n) &#123;</span><br><span class="line">        UNSAFE.putOrderedObject(this, nextOffset, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>HashEntry</code>和<code>HashMap</code>中的<code>HashEntry</code>作用是一样的，它是<code>ConcurrentHashMap</code>的数据项，这里要注意两个细节：</p>
<p><strong>细节一：</strong></p>
<p><code>HashEntry</code>的成员变量<code>value</code>和<code>next</code>是被关键字<code>volatile</code>修饰的，也就是说所有线程都可以及时检查到其他线程对这两个变量的改变，因而可以在不加锁的情况下读取到这两个引用的最新值</p>
<p><strong>细节二：</strong></p>
<p><code>HashEntry</code>的<code>setNext</code>方法中调用了<code>UNSAFE.putOrderedObject</code>，这个接口是属于<code>sun</code>安全库中的<code>api</code>，并不是<code>J2SE</code>的一部分，它的作用和<code>volatile</code>恰恰相反，调用这个<code>api</code>设值是使得<code>volatile</code>修饰的变量延迟写入主存，那到底是什么时候写入主存呢？</p>
<blockquote>
<p>JMM中有一条规定：</p>
<p>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p>
</blockquote>
<p>后文在讲<code>put</code>方法的时候我们再详细看<code>setNext</code>的用法</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>由于引入了<code>segment</code>，因此不管是调用<code>get</code>方法读还是调用<code>put</code>方法写，都需要做两次哈希，还记得在上文我们讲初始化的时候系统做了一件重要的事：</p>
<ul>
<li>确定哈希寻址时的偏移量，这个偏移量在确定元素在<code>segment</code>数组中的位置时会用到</li>
</ul>
<p>没错就是这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.segmentShift &#x3D; 32 - sshift;</span><br></pre></td></tr></table></figure>

<p>这里用32去减是因为<code>int</code>型的长度是32，有了<code>segmentShift</code>，<code>ConcurrentHashMap</code>是如何做第一次哈希的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    if (value &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    &#x2F;&#x2F; 变量j代表着数据项处于segment数组中的第j项</span><br><span class="line">    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        &#x2F;&#x2F; 如果segment[j]为null,则下面的这个方法负责初始化之</span><br><span class="line">        s &#x3D; ensureSegment(j); </span><br><span class="line">    return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以<code>put</code>方法为例，变量<code>j</code>代表着数据项处于<code>segment</code>数组中的第<code>j</code>项。如下图所示假如<code>segment</code>数组的大小为2的n次方，则<code>hash &gt;&gt;&gt; segmentShift</code>正好取了key的哈希值的高n位，再与掩码<code>segmentMask</code>相与相当与仍然用key的哈希的高位来确定数据项在<code>segment</code>数组中的位置。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">image-20210409232020703</p>
<p><code>hash</code>方法与非线程安全的<code>HashMap</code>相似，这里不再细说。</p>
<p><strong>细节三：</strong></p>
<p>在延迟初始化<code>Segment</code>数组时，作者采用了<code>CAS</code>避免了加锁，而且<code>CAS</code>可以保证最终的初始化只能被一个线程完成。在最终决定调用<code>CAS</code>进行初始化前又做了两次检查，第一次检查可以避免重复初始化<code>tab</code>数组，而第二次检查则可以避免重复初始化<code>Segment</code>对象，每一行代码作者都有详细的考虑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">    final Segment&lt;K,V&gt;[] ss &#x3D; this.segments;</span><br><span class="line">    long u &#x3D; (k &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; raw offset 实际的字节偏移量</span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto &#x3D; ss[0]; &#x2F;&#x2F; use segment 0 as prototype</span><br><span class="line">        int cap &#x3D; proto.table.length;</span><br><span class="line">        float lf &#x3D; proto.loadFactor;</span><br><span class="line">        int threshold &#x3D; (int)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class="line">        if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; recheck 再检查一次是否已经被初始化</span><br><span class="line">            Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s)) &#x2F;&#x2F; 使用 CAS 确保只被初始化一次</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a><code>put</code>方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null : scanAndLockForPut(key, hash, value); </span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">        int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                K k; &#x2F;&#x2F; 如果找到key相同的数据项，则直接替换</span><br><span class="line">                if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue &#x3D; e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value &#x3D; value;</span><br><span class="line">                        ++modCount; </span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (node !&#x3D; null)</span><br><span class="line">                    &#x2F;&#x2F; node不为空说明已经在自旋等待时初始化了，注意调用的是setNext，不是直接操作next</span><br><span class="line">                    node.setNext(first); </span><br><span class="line">                else</span><br><span class="line">                    &#x2F;&#x2F; 否则，在这里新建一个HashEntry</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c &#x3D; count + 1; &#x2F;&#x2F; 先加1</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    &#x2F;&#x2F; 将新节点写入，注意这里调用的方法有门道</span><br><span class="line">                    setEntryAt(tab, index, node); </span><br><span class="line">                ++modCount;</span><br><span class="line">                count &#x3D; c;</span><br><span class="line">                oldValue &#x3D; null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在整个<code>ConcurrentHashMap</code>的设计中非常出彩，在这短短的40行代码中，Doug Lea就像一位神奇的魔术师，转眼间已经变换了好几种魔法，让人目瞪口呆，感叹其对并发的理解之深，让我们慢慢的解析Doug Lea在这段代码中使用的魔法：</p>
<p><strong>细节四：</strong></p>
<p>CPU的调度是公平的，好不容易轮到的时间片如果因为获取不到锁就将本线程挂起无疑会降低本线程的效率，更何况挂起之后还要重新调度，切换上下文，又是一笔不小的开销。如果可以遇见其他线程占有锁的时间不会很长，采用自旋将会是一个比较好的选择，在这里面也有一个权衡，如果别的线程占有锁的时间过长，反而是挂起阻塞等待性能好一点，我们来看下<code>ConcurrentHashMap</code>的做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first &#x3D; entryForHash(this, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e &#x3D; first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; null;</span><br><span class="line">    int retries &#x3D; -1; &#x2F;&#x2F; negative while locating node</span><br><span class="line">    while (!tryLock()) &#123; &#x2F;&#x2F; 自旋等待</span><br><span class="line">        HashEntry&lt;K,V&gt; f; &#x2F;&#x2F; to recheck first below</span><br><span class="line">        if (retries &lt; 0) &#123;</span><br><span class="line">            if (e &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 这个桶中还没有写入k-v项</span><br><span class="line">                if (node &#x3D;&#x3D; null) &#x2F;&#x2F; speculatively create node 直接创建一个新的节点</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">                retries &#x3D; 0;  </span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; key值相等，直接跳出去尝试获取锁</span><br><span class="line">            else if (key.equals(e.key))</span><br><span class="line">                retries &#x3D; 0;</span><br><span class="line">            else &#x2F;&#x2F; 遍历链表</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            &#x2F;&#x2F; 自旋等待超过一定次数之后只能挂起线程，阻塞等待了</span><br><span class="line">            lock();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((retries &amp; 1) &#x3D;&#x3D; 0 &amp;&amp; (f &#x3D; entryForHash(this, hash)) !&#x3D; first) &#123; </span><br><span class="line">            &#x2F;&#x2F; 如果头节点改变了，则重置次数，继续自旋等待</span><br><span class="line">            e &#x3D; first &#x3D; f; </span><br><span class="line">            retries &#x3D; -1; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConcurrentHashMap</code>的策略是自旋<code>MAX_SCAN_RETRIES</code>次，如果还没有获取到锁则调用<code>lock</code>挂起阻塞等待，当然如果其他线程采用头插法改变了链表的头结点，则重置自旋等待次数。</p>
<p><strong>细节五：</strong></p>
<p>要知道，如果要从编码的角度提升系统的并发度，一个黄金法则就是减少并发临界区的大小。在<code>scanAndLockForPut</code>这个方法的设计上，有个小细节让我眼前一亮，就是在自旋的过程中初始化了一个<code>HashEntry</code>，这样做的好处就是线程在拿到锁之后不用初始化<code>HashEntry</code>了，占有锁的时间相应减小，进而提升性能。</p>
<p><strong>细节六：</strong></p>
<p>在<code>put</code>方法的开头，有这么一行不起眼的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br></pre></td></tr></table></figure>

<p>看起来好像就是简单的临时变量赋值，其实大有来头，我们看一下<code>table</code>的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient volatile HashEntry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p><code>table</code>变量被关键字<code>volatile</code>修饰，<code>CPU</code>在处理<code>volatile</code>修饰的变量的时候会有下面的行为：</p>
<blockquote>
<p><strong>嗅探</strong></p>
<p>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里</p>
</blockquote>
<p>因此直接读取这类变量的读取和写入比普通变量的性能消耗更大，因此在<code>put</code>方法的开头将<code>table</code>变量赋值给一个普通的本地变量目的是为了消除<code>volatile</code>带来的性能损耗。这里就有另外一个问题：那这样做会不会导致<code>table</code>的语义改变，让别的线程读取不到最新的值呢？别着急，我们接着看。</p>
<p><strong>细节七：</strong></p>
<p>注意<code>put</code>方法中的这个方法：<code>entryAt()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; HashEntry&lt;K,V&gt; entryAt(HashEntry&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">    return (tab &#x3D;&#x3D; null) ? null : (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile(tab, ((long)i &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的底层会调用<code>UNSAFE.getObjectVolatile</code>，这个方法的目的就是对于普通变量读取也能像<code>volatile</code>修饰的变量那样读取到最新的值，在前文中我们分析过，由于变量<code>tab</code>现在是一个普通的临时变量，如果直接调用<code>tab[i]</code>不一定能拿到最新的首节点的。细心的读者读到这里可能会想：Doug Lea是不是糊涂了，兜兜转换不是回到了原点么，为啥不刚开始就操作<code>volatile</code>变量呢，费了这老大劲。我们继续往下看。</p>
<p><strong>细节八：</strong></p>
<p>在<code>put</code>方法的实现中，如果链表中没有<code>key</code>值相等的数据项，则会把新的数据项插入到链表头写入到数组中，其中调用的方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; void setEntryAt(HashEntry&lt;K,V&gt;[] tab, int i, HashEntry&lt;K,V&gt; e) &#123;</span><br><span class="line">    UNSAFE.putOrderedObject(tab, ((long)i &lt;&lt; TSHIFT) + TBASE, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>putOrderedObject</code>这个接口写入的数据不会马上被其他线程获取到，而是在<code>put</code>方法最后调用<code>unclock</code>后才会对其他线程可见，参见前文中对JMM的描述：</p>
<blockquote>
<p>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p>
</blockquote>
<p>这样的好处有两个，第一是性能，因为在持有锁的临界区不需要有同步主存的操作，因此持有锁的时间更短。第二是保证了数据的一致性，在<code>put</code>操作的<code>finally</code>语句执行完之前，<code>put</code>新增的数据是不对其他线程展示的，这是<code>ConcurrentHashMap</code>实现无锁读的关键原因。</p>
<p>我们在这里稍微总结一下<code>put</code>方法里面最重要的三个细节，首先将<code>volatile</code>变量转为普通变量提升性能，因为在<code>put</code>中需要读取到最新的数据，因此接下来调用<code>UNSAFE.getObjectVolatile</code>获取到最新的头结点，但是通过调用<code>UNSAFE.putOrderedObject</code>让变量写入主存的时间延迟到<code>put</code>方法的结尾，一来缩小临界区提升性能，而来也能保证其他线程读取到的是完整数据。</p>
<p><strong>细节九：</strong></p>
<p>如果<code>put</code>真的需要往链表头插入数据项，那也得注意了，<code>ConcurrentHashMap</code>相应的语句是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.setNext(first);</span><br></pre></td></tr></table></figure>

<p>我们看下<code>setNext</code>的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void setNext(HashEntry&lt;K,V&gt; n) &#123;</span><br><span class="line">    UNSAFE.putOrderedObject(this, nextOffset, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>next</code>变量是用<code>volatile</code>关键字修饰的，这里调用<code>UNSAFE.putOrderedObject</code>相当于是改变了<code>volatile</code>的语义，这里面的考量有两个，第一个仍然是性能，这样的实现性能明显更高，这一点前文已经详细的分析过，第二点是考虑了语义的一致性，对于<code>put</code>方法来说因为其调用的是<code>UNSAFE.getObjectVolatile</code>，仍然能获取到最新的数据，对于<code>get</code>方法，在<code>put</code>方法未结束之前，是不希望不完整的数据被其他线程通过<code>get</code>方法读取的，这也是合理的。</p>
<h2 id="resize扩容"><a href="#resize扩容" class="headerlink" title="resize扩容"></a><code>resize</code>扩容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;</span><br><span class="line">    int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity &lt;&lt; 1;</span><br><span class="line">    threshold &#x3D; (int)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable &#x3D; (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class="line">    int sizeMask &#x3D; newCapacity - 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            int idx &#x3D; e.hash &amp; sizeMask;</span><br><span class="line">            if (next &#x3D;&#x3D; null) &#x2F;&#x2F;  Single node on list 只有一个节点，简单处理</span><br><span class="line">                newTable[idx] &#x3D; e;</span><br><span class="line">            else &#123; </span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun &#x3D; e;</span><br><span class="line">                int lastIdx &#x3D; idx;</span><br><span class="line">                &#x2F;&#x2F; 保证下文中newTable[k]不会为null</span><br><span class="line">                for (HashEntry&lt;K,V&gt; last &#x3D; next;</span><br><span class="line">                        last !&#x3D; null;</span><br><span class="line">                        last &#x3D; last.next) &#123;</span><br><span class="line">                    int k &#x3D; last.hash &amp; sizeMask;</span><br><span class="line">                    if (k !&#x3D; lastIdx) &#123;</span><br><span class="line">                        lastIdx &#x3D; k;</span><br><span class="line">                        lastRun &#x3D; last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] &#x3D; lastRun;</span><br><span class="line">                &#x2F;&#x2F; Clone remaining nodes 对标记之前的不能重用的节点进行复制，再重新添加到新数组对应的hash桶中去</span><br><span class="line">                for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;</span><br><span class="line">                    V v &#x3D; p.value;</span><br><span class="line">                    int h &#x3D; p.hash;</span><br><span class="line">                    int k &#x3D; h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n &#x3D; newTable[k];</span><br><span class="line">                    newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int nodeIndex &#x3D; node.hash &amp; sizeMask; &#x2F;&#x2F; add the new node 部分的put功能，把新节点添加到链表的最前面</span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] &#x3D; node;</span><br><span class="line">    table &#x3D; newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果大家看过我们上一篇分析<code>HashMap</code>的<code>rehash</code>的过程看这段代码就会比较轻松，在上一篇我们分析过，在整个桶数组长度为2的正整数幂的情况下，扩容前同一个桶中的元素在扩容后只会分布在两个桶中，其中一个桶的下标保持不变，我们称之为旧桶，另一个桶的下标为旧桶下标加上旧的容量，我们称之为新桶，其实第一个for循环的目的就是在一个链表中找到最后一个应该移到新桶的数据项，直接移到新桶中，这样做是为了保证后面调用<code>HashEntry&lt;K,V&gt; n = newTable[k];</code>的时候不会读取到<code>null</code>。第二个<code>for</code>就比较简单了，将所有的数据项移到新的桶数组中，当所有的操作完成之后才将<code>newTable</code>赋值给<code>table</code>。</p>
<p><code>rehash</code>方法中是没有加锁的，并不是说调用这个方法不需要加锁，作者是在外层加了锁，这一点需要注意。</p>
<h2 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h2><p>之前在分析<code>HashMap</code>方法的时候我们并没有去讲<code>size</code>方法，因为在单线程环境下这个方法可以使用一个全局的变量解决，同样的方案当然也可以在多线程场景下使用，不过要在多线程环境下读取全局变量又会陷入到无尽的“锁”中，这是我们不愿意看到的，那<code>ConcurrentHashMap</code>是如何解决这个问题的呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    final Segment&lt;K,V&gt;[] segments &#x3D; this.segments;</span><br><span class="line">    int size;</span><br><span class="line">    boolean overflow; &#x2F;&#x2F; true if size overflows 32 bits</span><br><span class="line">    long sum;         &#x2F;&#x2F; sum of modCounts</span><br><span class="line">    long last &#x3D; 0L;   &#x2F;&#x2F; previous sum</span><br><span class="line">    int retries &#x3D; -1; &#x2F;&#x2F; first iteration isn&#39;t retry</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (retries++ &#x3D;&#x3D; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); &#x2F;&#x2F; force creation</span><br><span class="line">            &#125;</span><br><span class="line">            sum &#x3D; 0L;</span><br><span class="line">            size &#x3D; 0;</span><br><span class="line">            overflow &#x3D; false;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg &#x3D; segmentAt(segments, j);</span><br><span class="line">                if (seg !&#x3D; null) &#123;</span><br><span class="line">                    sum +&#x3D; seg.modCount;</span><br><span class="line">                    int c &#x3D; seg.count;</span><br><span class="line">                    if (c &lt; 0 || (size +&#x3D; c) &lt; 0)</span><br><span class="line">                        overflow &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sum &#x3D;&#x3D; last)</span><br><span class="line">                break;</span><br><span class="line">            last &#x3D; sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面介绍<code>put</code>方法时我们选择忽略了一个小小的成员变量<code>modCount</code>，这个变量在这里大显身手，它的主要作用就是记录整个<code>Segment</code>中写入操作的次数，因为写入操作是会影响整个<code>ConcurrentHashMap</code>的大小的。</p>
<p>因为在读取<code>ConcurrentHashMap</code>大小的时候需要保证读到的是最新的值，因此其调用了<code>UNSAFE.getObjectVolatile</code>这个方法，虽然这个方法的性能比普通变量要差，但是比起全局加锁，可好多了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; Segment&lt;K,V&gt; segmentAt(Segment&lt;K,V&gt;[] ss, int j) &#123;</span><br><span class="line">    long u &#x3D; (j &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; 计算实际的字节偏移量</span><br><span class="line">    return ss &#x3D;&#x3D; null ? null : (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(ss, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>细节十：</strong></p>
<p>在<code>size</code>方法的设计上，<code>ConcurrentHashMap</code>先尝试无锁的方法，如果两次遍历所有<code>segment</code>数组的时候整个<code>ConcurrentHashMap</code>没有发生写入操作，则直接返回每个<code>segment</code>数组的<code>size()</code>之和，否则重新遍历，如果写入操作频繁，则不得已加锁处理，这里的加锁相当于是一个全局的锁，因为对<code>segment</code>数组的每一个元素都加了锁。那如何判断整个<code>ConcurrentHashMap</code>的写入是否频繁呢？就看无锁重试的次数，当无锁重试的次数超过阈值的话就全局加锁处理。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在看完<code>ConcurrentHashMap</code>中的这些细节之后我们尝试回答一下文章开头提出来的问题：</p>
<ol>
<li><p><code>ConcurrentHashMap</code>的哪些操作需要加锁？</p>
<p>答：只有写入操作才需要加锁，读取操作不需要加锁</p>
</li>
<li><p><code>ConcurrentHashMap</code>的无锁读是如何实现的？</p>
<p>答：首先<code>HashEntry</code>中的<code>value</code>和<code>next</code>都是有<code>volatile</code>修饰的，其次在写入操作的时候通过调用<code>UNSAFE</code>库延迟同步了主存，保证了数据的一致性</p>
</li>
<li><p>在多线程的场景下调用<code>size（）</code>方法获取<code>ConcurrentHashMap</code>的大小有什么挑战？<code>ConcurrentHashMap</code>是怎么解决的？</p>
<p>答：<code>size()</code>具有全局的语义，如何能保证在不加全局锁的情况下读取到全局状态的值是一个很大的挑战，<code>ConcurrentHashMap</code>通过查看两次无锁读中间是否发生了写入操作来决定读取到的<code>size()</code>是否可信，如果写入操作频繁，则再退化为全局加锁读取。</p>
</li>
<li><p>在有<code>Segment</code>存在的前提下，是如何扩容的？</p>
<p>答：<code>segment</code>数组的大小在一开始初始化的时候就已经决定了，扩容主要扩的是<code>HashEntry</code>数组，基本的思路与<code>HashTable</code>一致，但这是一个线程不安全方法，调用之前需要加锁。</p>
</li>
</ol>
<h1 id="Java-8-ConcurrentHashMap源码中隐藏2个BUG"><a href="#Java-8-ConcurrentHashMap源码中隐藏2个BUG" class="headerlink" title="Java 8 ConcurrentHashMap源码中隐藏2个BUG"></a>Java 8 ConcurrentHashMap源码中隐藏2个BUG</h1><p><code>Java 7</code>的<code>ConcurrenHashMap</code>的<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzk0NjExMjU3Mg==&mid=2247484661&idx=1&sn=0005cd08cf76c6bab5727ec532983415&chksm=c30a55a6f47ddcb04891349eef82f61830c6df7495944184fd98f1253913edd9e3187e73ddae&scene=21#wechat_redirect">源码</a>我建议大家都看看，那个版本的源码就是<code>Java</code>多线程编程的教科书。在<code>Java 7</code>的源码中，作者对悲观锁的使用非常谨慎，大多都转换为自旋锁加<code>volatile</code>获得相同的语义，即使最后迫不得已要用，作者也会通过各种技巧减少锁的临界区。在上一篇文章中我们也有讲到，自旋锁在临界区比较小的时候是一个较优的选择是因为它避免了线程由于阻塞而切换上下文，但本质上它也是个锁，在自旋等待期间只有一个线程能进入临界区，其他线程只会自旋消耗<code>CPU</code>的时间片。<code>Java 8</code>中<code>ConcurrentHashMap</code>的实现通过一些巧妙的设计和技巧，避开了自旋锁的局限，提供了更高的并发性能。如果说<code>Java 7</code>版本的源码是在教我们如何将悲观锁转换为自旋锁，那么在<code>Java 8</code>中我们甚至可以看到如何将自旋锁转换为无锁的方法和技巧。</p>
<h2 id="把书读薄-2"><a href="#把书读薄-2" class="headerlink" title="把书读薄"></a>把书读薄</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdA8G9gcTVIgP3JZWCv0UibUvicIeiaDmgzDGzAh50zu8uibcTzY7acGCJI84Y9J86iaJ0aPK0mD9ASTdR6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">image</p>
<p>图片来源：<a target="_blank" rel="noopener" href="https://www.zhenchao.org/2019/01/31/java/cas-based-concurrent-hashmap/">https://www.zhenchao.org/2019/01/31/java/cas-based-concurrent-hashmap/</a></p>
<p>在开始本文之前，大家首先在心里还是要有这样的一张图，如果有同学对<code>HashMap</code>比较熟悉，那这张图也应该不会陌生。事实上在整体的数据结构的设计上<code>Java 8</code>的<code>ConcurrentHashMap</code>和<code>HashMap</code>基本上是一致的。</p>
<p><code>Java 7</code>中<code>ConcurrentHashMap</code>为了提升性能使用了很多的编程技巧，但是引入<code>Segment</code>的设计还是有很大的改进空间的，<code>Java 7</code>中<code>ConcurrrentHashMap</code>的设计有下面这几个可以改进的点：</p>
<ol>
<li><code>Segment</code>在扩容的时候非扩容线程对本<code>Segment</code>的写操作时都要挂起等待的</li>
<li>对<code>ConcurrentHashMap</code>的读操作需要做两次哈希寻址，在读多写少的情况下其实是有额外的性能损失的</li>
<li>尽管<code>size()</code>方法的实现中先尝试无锁读，但是如果在这个过程中有别的线程做写入操作，那调用<code>size()</code>的这个线程就会给整个<code>ConcurrentHashMap</code>加锁，这是整个<code>ConcurrrentHashMap</code>唯一一个全局锁，这点对底层的组件来说还是有性能隐患的</li>
<li>极端情况下（比如客户端实现了一个性能很差的哈希函数）<code>get()</code>方法的复杂度会退化到<code>O(n)</code>。</li>
</ol>
<p>针对1和2，在<code>Java 8</code>的设计是废弃了<code>Segment</code>的使用，将悲观锁的粒度降低至桶维度，因此调用<code>get</code>的时候也不需要再做两次哈希了。<code>size()</code>的设计是<code>Java 8</code>版本中最大的亮点，我们在后面的文章中会详细说明。至于红黑树，这篇文章仍然不做过多阐述。接下来的篇幅会深挖细节，把书读厚，涉及到的模块有：初始化，<code>put</code>方法, 扩容方法<code>transfer</code>以及<code>size()</code>方法，而其他模块，比如<code>hash</code>函数等改变较小，故不再深究。</p>
<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a><code>ForwardingNode</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    final Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        &#x2F;&#x2F; MOVED &#x3D; -1，ForwardingNode的哈希值为-1</span><br><span class="line">        super(MOVED, null, null, null);</span><br><span class="line">        this.nextTable &#x3D; tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了普通的<code>Node</code>和<code>TreeNode</code>之外，<code>ConcurrentHashMap</code>还引入了一个新的数据类型<code>ForwardingNode</code>，我们这里只展示他的构造方法，<code>ForwardingNode</code>的作用有两个：</p>
<ul>
<li>在动态扩容的过程中标志某个桶已经被复制到了新的桶数组中</li>
<li>如果在动态扩容的时候有<code>get</code>方法的调用，则<code>ForwardingNode</code>将会把请求转发到新的桶数组中，以避免阻塞<code>get</code>方法的调用，<code>ForwardingNode</code>在构造的时候会将扩容后的桶数组<code>nextTable</code>保存下来。</li>
</ul>
<h3 id="UNSAFE-compareAndSwap"><a href="#UNSAFE-compareAndSwap" class="headerlink" title="UNSAFE.compareAndSwap***"></a><code>UNSAFE.compareAndSwap***</code></h3><p>这是在<code>Java 8</code>版本的<code>ConcurrentHashMap</code>实现<code>CAS</code>的工具，以<code>int</code>类型为例其方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Atomically update Java variable to &lt;tt&gt;x&lt;&#x2F;tt&gt; if it is currently</span><br><span class="line">* holding &lt;tt&gt;expected&lt;&#x2F;tt&gt;.</span><br><span class="line">* @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if successful</span><br><span class="line">*&#x2F;</span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                              int expected,</span><br><span class="line">                                              int x);</span><br></pre></td></tr></table></figure>

<p>相应的语义为：</p>
<blockquote>
<p>如果对象<code>o</code>起始地址偏移量为<code>offset</code>的值等于<code>expected</code>，则将该值设为<code>x</code>，并返回<code>true</code>表明更新成功，否则返回<code>false</code>，表明<code>CAS</code>失败</p>
</blockquote>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0) &#x2F;&#x2F; 检查参数</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (initialCapacity &lt; concurrencyLevel)</span><br><span class="line">        initialCapacity &#x3D; concurrencyLevel;</span><br><span class="line">    long size &#x3D; (long)(1.0 + (long)initialCapacity &#x2F; loadFactor);</span><br><span class="line">    int cap &#x3D; (size &gt;&#x3D; (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((int)size); &#x2F;&#x2F; tableSizeFor，求不小于size的 2^n的算法，jdk1.8的HashMap中说过</span><br><span class="line">    this.sizeCtl &#x3D; cap; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使是最复杂的一个初始化方法代码也是比较简单的，这里我们只需要注意两个点：</p>
<ul>
<li><code>concurrencyLevel</code>在<code>Java 7</code>中是<code>Segment</code>数组的长度，由于在<code>Java 8</code>中已经废弃了<code>Segment</code>，因此<code>concurrencyLevel</code>只是一个保留字段，无实际意义</li>
<li><code>sizeCtl</code>这个值第一次出现，这个值如果等于-1则表明系统正在初始化，如果是其他负数则表明系统正在扩容，在扩容时<code>sizeCtl</code>二进制的低十六位等于扩容的线程数加一，高十六位（除符号位之外）包含桶数组的大小信息</li>
</ul>
<h2 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a><code>put</code>方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>put</code>方法将调用转发到<code>putVal</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; spread(key.hashCode());</span><br><span class="line">    int binCount &#x3D; 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        &#x2F;&#x2F; 【A】延迟初始化</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            tab &#x3D; initTable();</span><br><span class="line">        &#x2F;&#x2F; 【B】当前桶是空的，直接更新</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                            new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 【C】如果当前的桶的第一个元素是一个ForwardingNode节点，则该线程尝试加入扩容</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">            tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">        &#x2F;&#x2F; 【D】否则遍历桶内的链表或树，并插入</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 暂时折叠起来，后面详细看</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 【F】流程走到此处，说明已经put成功，map的记录总数加一</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从整个代码结构上来看流程还是比较清楚的，我用括号加字母的方式标注了几个非常重要的步骤，<code>put</code>方法依然牵扯出很多的知识点</p>
<h3 id="桶数组的初始化"><a href="#桶数组的初始化" class="headerlink" title="桶数组的初始化"></a>桶数组的初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if ((sc &#x3D; sizeCtl) &lt; 0)</span><br><span class="line">            &#x2F;&#x2F; 说明已经有线程在初始化了，本线程开始自旋</span><br><span class="line">            Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            &#x2F;&#x2F; CAS保证只有一个线程能走到这个分支</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    table &#x3D; tab &#x3D; nt;</span><br><span class="line">                    &#x2F;&#x2F; sc &#x3D; n - n&#x2F;4 &#x3D; 0.75n</span><br><span class="line">                    sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; 恢复sizeCtl &gt; 0相当于释放锁</span><br><span class="line">                sizeCtl &#x3D; sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化桶数组的过程中，系统如何保证不会出现并发问题呢，关键点在于自旋锁的使用，当有多个线程都执行<code>initTable</code>方法的时候，<code>CAS</code>可以保证只有一个线程能够进入到真正的初始化分支，其他线程都是自旋等待。这段代码中我们关注三点即可：</p>
<ul>
<li>依照前文所述，当有线程开始初始化桶数组时，会通过<code>CAS</code>将<code>sizeCtl</code>置为-1，其他线程以此为标志开始自旋等待</li>
<li>当桶数组初始化结束后将<code>sizeCtl</code>的值恢复为正数，其值等于0.75倍的桶数组长度，这个值的含义和之前<code>HashMap</code>中的<code>THRESHOLD</code>一致，是系统触发扩容的临界点</li>
<li>在<code>finally</code>语句中对<code>sizeCtl</code>的操作并没有使用<code>CAS</code>是因为<code>CAS</code>保证只有一个线程能够执行到这个地方</li>
</ul>
<h3 id="添加桶数组第一个元素"><a href="#添加桶数组第一个元素" class="headerlink" title="添加桶数组第一个元素"></a>添加桶数组第一个元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span><br><span class="line">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>put</code>方法的第二个分支会用<code>tabAt</code>判断当前桶是否是空的，如果是则会通过<code>CAS</code>写入，<code>tabAt</code>通过<code>UNSAFE</code>接口会拿到桶中的最新元素，<code>casTabAt</code>通过<code>CAS</code>保证不会有并发问题，如果<code>CAS</code>失败，则通过循环再进入其他分支</p>
<h3 id="判断是否需要新增线程扩容"><a href="#判断是否需要新增线程扩容" class="headerlink" title="判断是否需要新增线程扩容"></a>判断是否需要新增线程扩容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">    if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123;</span><br><span class="line">        int rs &#x3D; resizeStamp(tab.length);</span><br><span class="line">        while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;</span><br><span class="line">                (sc &#x3D; sizeCtl) &lt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; RESIZE_STAMP_SHIFT &#x3D; 16</span><br><span class="line">            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0)</span><br><span class="line">                break;</span><br><span class="line">            &#x2F;&#x2F; 这里将sizeCtl的值自增1，表明参与扩容的线程数量+1</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个地方我们就要详细说下<code>sizeCtl</code>这个标志位了，临时变量<code>rs</code>由<code>resizeStamp</code>这个方法返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int resizeStamp(int n) &#123;</span><br><span class="line">    &#x2F;&#x2F; RESIZE_STAMP_BITS &#x3D; 16</span><br><span class="line">    return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为入参<code>n</code>是一个<code>int</code>类型的值，所有<code>Integer.numberOfLeadingZeros(n)</code>的返回值介于0到32之间，如果转换成二进制</p>
<ul>
<li><code>Integer.numberOfLeadingZeros(n)</code>的最大值是：00000000 00000000 00000000 00100000</li>
<li><code>Integer.numberOfLeadingZeros(n)</code>的最小值是：00000000 00000000 00000000 00000000</li>
</ul>
<p>因此<code>resizeStampd</code>的返回值也就介于<code>00000000 00000000 10000000 00000000</code>到<code>00000000 00000000 10000000 00100000</code>之间，从这个返回值的范围可以看出来<code>resizeStamp</code>的返回值高16位全都是0，是不包含任何信息的。因此在<code>ConcurrrentHashMap</code>中，会把<code>resizeStamp</code>的返回值左移16位拼到<code>sizeCtl</code>中，这就是为什么<code>sizeCtl</code>的高16位包含整个<code>Map</code>大小的原理。有了这个分析，这段代码中比较长的<code>if</code>判断也就能看懂了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">    sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0)</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</code>保证所有线程要基于同一个旧的桶数组扩容</li>
<li><code>transferIndex &lt;= 0</code>已经有线程完成扩容任务了</li>
</ul>
<p>至于<code>sc == rs + 1 || sc == rs + MAX_RESIZERS</code>这两个判断条件如果是细心的同学一定会觉得难以理解，这个地方确实是JDK的一个<code>BUG</code>，这个<code>BUG</code>已经在<code>JDK 12</code>中修复，详细情况可以参考一下Oracle的官网：<a target="_blank" rel="noopener" href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427%EF%BC%8C%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E5%BA%94%E8%AF%A5%E5%86%99%E6%88%90%E8%BF%99%E6%A0%B7%EF%BC%9A%60sc">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427，这两个判断条件应该写成这样：`sc</a> == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1 || sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS<code>,因为直接比较</code>rs<code>和</code>sc`是没有意义的，必须要有移位操作。它表达的含义是</p>
<ul>
<li><code>sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1</code>当前扩容的线程数为0，即已经扩容完成了，就不需要再新增线程扩容</li>
<li><code>sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS</code>参与扩容的线程数已经到了最大，就不需要再新增线程扩容</li>
</ul>
<p>真正扩容的逻辑在<code>transfer</code>方法中，我们后面会详细看，不过有个小细节可以提前注意，如果<code>nextTable</code>已经初始化了，<code>transfer</code>会返回<code>nextTable</code>的的引用，后续可以直接操作新的桶数组。</p>
<h3 id="插入新值"><a href="#插入新值" class="headerlink" title="插入新值"></a>插入新值</h3><p>如果桶数组已经初始化好了，该扩容的也扩容了，并且根据哈希定位到的桶中已经有元素了，那流程就跟普通的<code>HashMap</code>一样了，唯一一点不同的就是，这时候要给当前的桶加锁，且看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; spread(key.hashCode());</span><br><span class="line">    int binCount &#x3D; 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)&#x2F;&#x2F; 折叠</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 折叠&#125;</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)&#x2F;&#x2F; 折叠</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal &#x3D; null;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                &#x2F;&#x2F; 要注意这里这个不起眼的判断条件</span><br><span class="line">                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                    if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; fh&gt;&#x3D;0的节点是链表，否则是树节点或者ForwardingNode</span><br><span class="line">                        binCount &#x3D; 1;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                    (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal &#x3D; e.val; &#x2F;&#x2F; 如果链表中有值了，直接更新</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val &#x3D; value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                &#x2F;&#x2F; 如果流程走到这里，则说明链表中还没值，直接连接到链表尾部</span><br><span class="line">                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 红黑树的操作先略过</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; put成功，map的元素个数+1</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中要特备注意一个不起眼的判断条件（上下文在源码上已经标注出来了）：<code>tabAt(tab, i) == f</code>，这个判断的目的是为了处理调用<code>put</code>方法的线程和扩容线程的竞争。因为<code>synchronized</code>是阻塞锁，如果调用<code>put</code>方法的线程恰好和扩容线程同时操作同一个桶，且调用<code>put</code>方法的线程竞争锁失败，等到该线程重新获取到锁的时候，当前桶中的元素就会变成一个<code>ForwardingNode</code>，那就会出现<code>tabAt(tab, i) != f</code>的情况。</p>
<h2 id="多线程动态扩容"><a href="#多线程动态扩容" class="headerlink" title="多线程动态扩容"></a>多线程动态扩容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n &#x3D; tab.length, stride;</span><br><span class="line">    if ((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride &#x3D; MIN_TRANSFER_STRIDE; &#x2F;&#x2F; subdivide range</span><br><span class="line">    if (nextTab &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F; 初始化新的桶数组</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab &#x3D; nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      &#x2F;&#x2F; try to cope with OOME</span><br><span class="line">            sizeCtl &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable &#x3D; nextTab;</span><br><span class="line">        transferIndex &#x3D; n;</span><br><span class="line">    &#125;</span><br><span class="line">    int nextn &#x3D; nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd &#x3D; new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    boolean advance &#x3D; true;</span><br><span class="line">    boolean finishing &#x3D; false; &#x2F;&#x2F; to ensure sweep before committing nextTab</span><br><span class="line">    for (int i &#x3D; 0, bound &#x3D; 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;&#x3D; bound || finishing)</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line">            else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;</span><br><span class="line">                i &#x3D; -1;</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                        (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                        nextBound &#x3D; (nextIndex &gt; stride ?</span><br><span class="line">                                    nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound &#x3D; nextBound;</span><br><span class="line">                i &#x3D; nextIndex - 1;</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable &#x3D; null;</span><br><span class="line">                table &#x3D; nextTab;</span><br><span class="line">                sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断是会否是最后一个扩容线程</span><br><span class="line">                if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                finishing &#x3D; advance &#x3D; true;</span><br><span class="line">                i &#x3D; n; &#x2F;&#x2F; recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i)) &#x3D;&#x3D; null)</span><br><span class="line">            advance &#x3D; casTabAt(tab, i, null, fwd);</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 只有最后一个扩容线程才有机会执行这个分支</span><br><span class="line">            advance &#x3D; true; &#x2F;&#x2F; already processed</span><br><span class="line">        else &#123; &#x2F;&#x2F; 复制过程与HashMap类似，这里不再赘述</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">               &#x2F;&#x2F; 折叠</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在深入到源码细节之前我们先根据下图看一下在<code>Java 8</code>中<code>ConcurrentHashMap</code>扩容的几个特点：</p>
<ul>
<li>新的桶数组<code>nextTable</code>是原先桶数组长度的2倍，这与之前<code>HashMap</code>一致</li>
<li>参与扩容的线程也是分段将<code>table</code>中的元素复制到新的桶数组<code>nextTable</code>中</li>
<li>桶一个桶数组中的元素在新的桶数组中均匀的分布在两个桶中，桶下标相差n(旧的桶数组的长度)，这一点依然与<code>HashMap</code>保持一致</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">image-20210424202636495</p>
<h3 id="各个线程之间如何通力协作"><a href="#各个线程之间如何通力协作" class="headerlink" title="各个线程之间如何通力协作"></a>各个线程之间如何通力协作</h3><p>先看一个关键的变量<code>transferIndex</code>，这是一个被<code>volatile</code>修饰的变量，这一点可以保证所有线程读到的一定是最新的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile int transferIndex;</span><br></pre></td></tr></table></figure>

<p>这个值会被第一个参与扩容的线程初始化，因为只有第一个参与扩容的线程才满足条件<code>nextTab == null</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (nextTab &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F; initiating</span><br><span class="line">    try &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">        nextTab &#x3D; nt;</span><br><span class="line">    &#125; catch (Throwable ex) &#123;      &#x2F;&#x2F; try to cope with OOME</span><br><span class="line">        sizeCtl &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    nextTable &#x3D; nextTab;</span><br><span class="line">    transferIndex &#x3D; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在了解了<code>transferIndex</code>属性的基础上，上面的这个循环就好理解了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">while (advance) &#123;</span><br><span class="line">    int nextIndex, nextBound;</span><br><span class="line">      &#x2F;&#x2F; 当bound &lt;&#x3D; i &lt;&#x3D; transferIndex的时候i自减跳出这个循环继续干活</span><br><span class="line">    if (--i &gt;&#x3D; bound || finishing)</span><br><span class="line">        advance &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 扩容的所有任务已经被认领完毕，本线程结束干活</span><br><span class="line">    else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;</span><br><span class="line">        i &#x3D; -1;</span><br><span class="line">        advance &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 否则认领新的一段复制任务，并通过&#96;CAS&#96;更新transferIndex的值</span><br><span class="line">    else if (U.compareAndSwapInt</span><br><span class="line">                (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                nextBound &#x3D; (nextIndex &gt; stride ?</span><br><span class="line">                            nextIndex - stride : 0))) &#123;</span><br><span class="line">        bound &#x3D; nextBound;</span><br><span class="line">        i &#x3D; nextIndex - 1;</span><br><span class="line">        advance &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>transferIndex</code>就像是一个游标，每个线程认领一段复制任务的时候都会通过CAS将其更新为<code>transferIndex - stride</code>， <code>CAS</code>可以保证<code>transferIndex</code>可以按照<code>stride</code>这个步长降到0。</p>
<h3 id="最后一个扩容线程需要二次确认？"><a href="#最后一个扩容线程需要二次确认？" class="headerlink" title="最后一个扩容线程需要二次确认？"></a>最后一个扩容线程需要二次确认？</h3><p>对于每一个扩容线程，<code>for</code>循环的变量<code>i</code>代表要复制的桶的在桶数组中的下标，这个值的上限和下限通过游标<code>transferIndex</code>和步长<code>stride</code>计算得来，当<code>i</code>减小为负数，则说明当前扩容线程完成了扩容任务，这时候流程会走到这个分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; i &gt;&#x3D; n || i + n &gt;&#x3D; nextn现在看来取不到</span><br><span class="line">if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;</span><br><span class="line">    int sc;</span><br><span class="line">    if (finishing) &#123; &#x2F;&#x2F; 【A】完成整个扩容过程</span><br><span class="line">        nextTable &#x3D; null;</span><br><span class="line">        table &#x3D; nextTab;</span><br><span class="line">        sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 【B】判断是否是最后一个扩容线程，如果是，则需要重新扫描一遍桶数组，做二次确认</span><br><span class="line">    if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;</span><br><span class="line">        &#x2F;&#x2F; (sc - 2) &#x3D;&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT 说明是最后一个扩容线程</span><br><span class="line">        if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F; 重新扫描一遍桶数组，做二次确认</span><br><span class="line">        finishing &#x3D; advance &#x3D; true;</span><br><span class="line">        i &#x3D; n; &#x2F;&#x2F; recheck before commit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为变量<code>finishing</code>被初始化为<code>false</code>，所以当线程第一次进入这个<code>if</code>分支的话，会先执行注释为【B】的这个分支，同时因为<code>sizeCtl</code>的低16位被初始化为参与扩容的线程数加一，因此，当条件<code>(sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT</code>满足时，就能证明当前线程就是最后一个扩容线程了，这这时候将<code>i</code>置为<code>n</code>重新扫描一遍桶数组，并且将<code>finishing</code>置为<code>true</code>保证当桶数组被扫描结束后能够进入注释为【A】的分支结束扩容。</p>
<p>这里就有一个问题，按照我们前面的分析，扩容线程能够通力协作，保证各自负责的桶数组的分段不重不漏，这里为什么还需要做二次确认么？有一个开发者在<code>concurrency-interest</code>这个邮件列表中也关于这件事咨询了<code>Doug Lea</code>(地址：<a target="_blank" rel="noopener" href="http://cs.oswego.edu/pipermail/concurrency-interest/2020-July/017171.html)%EF%BC%8C%E4%BB%96%E7%BB%99%E5%87%BA%E7%9A%84%E5%9B%9E%E5%A4%8D%E6%98%AF%EF%BC%9A">http://cs.oswego.edu/pipermail/concurrency-interest/2020-July/017171.html)，他给出的回复是：</a></p>
<blockquote>
<p>Yes, this is a valid point; thanks. The post-scan was needed in a previous version, and could be removed. It does not trigger often enough to matter though, so is for now another minor tweak that might be included next time CHM is updated.</p>
</blockquote>
<p>虽然<code>Doug</code>在邮件中的措辞用了could be, not often enough等，但也确认了最后一个扩容线程的二次检查是没有必要的。具体的复制过程与<code>HashMap</code>类似，感兴趣的读者可以翻一下<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzk0NjExMjU3Mg==&mid=2247484593&idx=1&sn=1329f371cc600813034535411c3a987f&chksm=c30a55e2f47ddcf47a6fc2fbd67be93ec4a87dd00dccbd60d9b602f591f9218cb526ac739a16&scene=21#wechat_redirect">高端的面试从来不会在HashMap的红黑树上纠缠太多</a>这篇文章。</p>
<h2 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a><code>size()</code>方法</h2><h3 id="addCount-方法"><a href="#addCount-方法" class="headerlink" title="addCount()方法"></a><code>addCount()方法</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 记录map元素总数的成员变量</span><br><span class="line">private transient volatile long baseCount;</span><br></pre></td></tr></table></figure>

<p>在<code>put</code>方法的最后，有一个<code>addCount</code>方法，因为<code>putVal</code>执行到此处说明已经成功新增了一个元素，所以<code>addCount</code>方法的作用就是维护当前<code>ConcurrentHashMap</code>的元素总数，在<code>ConcurrentHashMap</code>中有一个变量<code>baseCount</code>用来记录<code>map</code>中元素的个数，如下图所示，如果同一时刻有n个线程通过CAS同时操作<code>baseCount</code>变量，有且仅有一个线程会成功，其他线程都会陷入无休止的自旋当中，那一定会带来性能瓶颈。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">image-20210420221407349</p>
<p>为了避免大量线程都在自旋等待写入<code>baseCount</code>，<code>ConcurrentHashMap</code>引入了一个辅助队列，如下图所示，现在操作<code>baseCount</code>的线程可以分散到这个辅助队列中去了，调用<code>size()</code>的时候只需要将<code>baseCount</code>和辅助队列中的数值相加即可，这样就实现了调用<code>size()</code>无需加锁。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">image-20210420222306734</p>
<p>辅助队列是一个类型为<code>CounterCell</code>的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended static final class CounterCell &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">    CounterCell(long x) &#123; value &#x3D; x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以简单理解为只是包装了一个<code>long</code>型的变量<code>value</code>，还需要解决一个问题是，对于某个具体的线程它是如何知道操作辅助队列中的哪个值呢？答案是下面的这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int getProbe() &#123;</span><br><span class="line">    return UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProbe</code>方法会返回当前线程的一个唯一身份码，这个值是不会变的，因此可以将<code>getProbe</code>的返回值与辅助队列的长度作求余运算得到具体的下标，它的返回值可能是0，如果返回0则需要调用<code>ThreadLocalRandom.localInit()</code>初始化。<code>addCount</code>方法中有两个细节需要注意</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">    CounterCell[] as; long b, s;</span><br><span class="line">    &#x2F;&#x2F; 注意这里的判断条件，是有技巧的</span><br><span class="line">    if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">        !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123;</span><br><span class="line">        CounterCell a; long v; int m;</span><br><span class="line">        boolean uncontended &#x3D; true;</span><br><span class="line">        if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">            (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">            &#x2F;&#x2F; 变量uncontended记录着这个CAS操作是否成功</span><br><span class="line">            !(uncontended &#x3D;</span><br><span class="line">                U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &lt;&#x3D; 1)</span><br><span class="line">            return;</span><br><span class="line">        s &#x3D; sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    if (check &gt;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 检查是否需要扩容，后面再详细看</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节一：</p>
<p>首先我们要注意方法中刚进来的<code>if</code>判断条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">    !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者在这里巧妙的运用了逻辑短路，如果<code>(as = counterCells) != null</code>则后面的<code>CAS</code>是不会执行的，为什么要这么设置呢？作者有两点考虑：</p>
<ol>
<li>原因在于如果<code>(as = counterCells) != null</code>，则说明辅助队列已经初始化好了，相比于所有的线程都自旋等待<code>baseCount</code>这一个变量，让线程通过<code>CAS</code>去操作队列中的值有更大的可能性成功，因为辅助队列的最大长度为大于当前处理器个数的2的正整数幂，可以支持更大的并发</li>
<li>如果辅助队列还没有初始化好，直到有必要的时候再去创建队列，如何判断“必要性”呢？就看对<code>baseCount</code>的<code>CAS</code>操作能否成功，如果失败，就说明当前系统的并发已经比较高了，需要队列的辅助，否则直接操作<code>baseCount</code></li>
</ol>
<p>细节二：</p>
<p>只有当辅助队列已存在，且由<code>ThreadLocalRandom.getProbe()</code>在辅助队列中确定的位置不为<code>null</code>时，才对其做<code>CAS</code>操作，这本来是一个正常的防御性判断，但是<code>uncontended</code>记录了<code>CAS</code>是否成功，如果失败，则会在<code>fullAddCount</code>中调用<code>ThreadLocalRandom.advanceProbe</code>换一个身份码调整下当前线程在辅助队列的位置，避免所有线程都在辅助队列的同一个坑位自旋等待。</p>
<h3 id="fullAddCount-方法"><a href="#fullAddCount-方法" class="headerlink" title="fullAddCount()方法"></a><code>fullAddCount()</code>方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; See LongAdder version for explanation</span><br><span class="line">&#x2F;&#x2F; wasUncontended 记录着调用方CAS是否成功，如果失败则换一个辅助队列的元素继续CAS</span><br><span class="line">private final void fullAddCount(long x, boolean wasUncontended) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    if ((h &#x3D; ThreadLocalRandom.getProbe()) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      &#x2F;&#x2F; force initialization</span><br><span class="line">        h &#x3D; ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean collide &#x3D; false;                &#x2F;&#x2F; True if last slot nonempty</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; int n; long v;</span><br><span class="line">        &#x2F;&#x2F; 【A】如果辅助队列已经创建，则直接操作辅助队列</span><br><span class="line">        if ((as &#x3D; counterCells) !&#x3D; null &amp;&amp; (n &#x3D; as.length) &gt; 0) &#123;</span><br><span class="line">            if ((a &#x3D; as[(n - 1) &amp; h]) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (cellsBusy &#x3D;&#x3D; 0) &#123;            &#x2F;&#x2F; Try to attach new Cell</span><br><span class="line">                    CounterCell r &#x3D; new CounterCell(x); &#x2F;&#x2F; Optimistic create</span><br><span class="line">                    if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">                        boolean created &#x3D; false;</span><br><span class="line">                        try &#123;               &#x2F;&#x2F; Recheck under lock</span><br><span class="line">                            CounterCell[] rs; int m, j;</span><br><span class="line">                            if ((rs &#x3D; counterCells) !&#x3D; null &amp;&amp;</span><br><span class="line">                                (m &#x3D; rs.length) &gt; 0 &amp;&amp;</span><br><span class="line">                                rs[j &#x3D; (m - 1) &amp; h] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                rs[j] &#x3D; r;</span><br><span class="line">                                created &#x3D; true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            cellsBusy &#x3D; 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (created)</span><br><span class="line">                            break;</span><br><span class="line">                        continue;           &#x2F;&#x2F; Slot is now non-empty</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (!wasUncontended)       &#x2F;&#x2F; 如果调用方CAS失败了，本轮空跑，下一个循环换下标继续操作</span><br><span class="line">                wasUncontended &#x3D; true;      &#x2F;&#x2F; Continue after rehash</span><br><span class="line">            else if (U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))</span><br><span class="line">                break;</span><br><span class="line">            else if (counterCells !&#x3D; as || n &gt;&#x3D; NCPU) </span><br><span class="line">                &#x2F;&#x2F; 如果辅助队列长度已经超过了CPU个数，本轮空跑，下一个循环换下标继续操作</span><br><span class="line">                collide &#x3D; false;            &#x2F;&#x2F; At max size or stale</span><br><span class="line">            else if (!collide) &#x2F;&#x2F; 如果上一次操作失败了(CAS失败或者新建CounterCell失败)，本轮空跑，下一个循环换下标继续操作</span><br><span class="line">                collide &#x3D; true;</span><br><span class="line">            else if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; &#x2F;&#x2F; 如果连续两次操作辅助队列失败，则考虑扩容</span><br><span class="line">                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (counterCells &#x3D;&#x3D; as) &#123;&#x2F;&#x2F; Expand table unless stale</span><br><span class="line">                        CounterCell[] rs &#x3D; new CounterCell[n &lt;&lt; 1];</span><br><span class="line">                        for (int i &#x3D; 0; i &lt; n; ++i)</span><br><span class="line">                            rs[i] &#x3D; as[i];</span><br><span class="line">                        counterCells &#x3D; rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    cellsBusy &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                collide &#x3D; false;</span><br><span class="line">                continue;                   &#x2F;&#x2F; Retry with expanded table</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果上一次操作失败或者调用方CAS失败，都会走到这里，变换要操作的辅助队列下标</span><br><span class="line">            h &#x3D; ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 【B】如果辅助队列还未创建，则加锁创建</span><br><span class="line">        else if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; counterCells &#x3D;&#x3D; as &amp;&amp;</span><br><span class="line">                    U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">            boolean init &#x3D; false;</span><br><span class="line">            try &#123;                           &#x2F;&#x2F; Initialize table</span><br><span class="line">                if (counterCells &#x3D;&#x3D; as) &#123;</span><br><span class="line">                    CounterCell[] rs &#x3D; new CounterCell[2];</span><br><span class="line">                    rs[h &amp; 1] &#x3D; new CounterCell(x);</span><br><span class="line">                    counterCells &#x3D; rs;</span><br><span class="line">                    init &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                cellsBusy &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (init)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 【C】如果辅助队列创建失败(拿锁失败)，则尝试直接操作&#96;baseCount&#96;</span><br><span class="line">        else if (U.compareAndSwapLong(this, BASECOUNT, v &#x3D; baseCount, v + x))</span><br><span class="line">            break;                          &#x2F;&#x2F; Fall back on using base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>counterCells</code>是一个普通的数组，因此对其的写操作，包括初始化，扩容以及元素的写都需要加锁，加锁的方式是对全局变量<code>cellsBusy</code>的自旋锁。先看最外层的三个分支：</p>
<ul>
<li>【B】如果辅助队列还没有创建，则加锁创建</li>
<li>【C】如果因为拿锁失败导致辅助队列创建失败，则尝试自旋写入变量<code>baseCount</code>，万一真的成功了呢</li>
<li>【A】如果辅助队列已经创建了，则直接去操作辅助队列相应的元素</li>
</ul>
<p>注释中标注【A】的这个分支代码较多，其主要思路是如果通过<code>CAS</code>或者加锁操作辅助队列中的某个元素失败，则首先通过调用<code>ThreadLocalRandom.advanceProbe(h)</code>换一个队列中的元素继续操作，这次操作是否成功会记录在临时变量<code>collide</code>中。如果下一次操作还是失败，则说明此时的并发量比较大需要扩容了。如果辅助队列的长度已经超过了<code>CPU</code>的个数，那就不再扩容，继续换一个元素操作，因为同一时间能运行的线程数最大不会超过计算机的<code>CPU</code>个数。</p>
<p>在这个过程中有四个细节仍然需要注意：</p>
<p>细节一：</p>
<p><code>counterCells</code>只是一个普通的数组，因此并不是线程安全的，所以对其写操作需要加锁保证并发安全</p>
<p>细节二：</p>
<p>加锁的时候，作者做了一个<code>double-check</code>的动作，我看有的文章将其解读为“类似于单例模式的<code>double-check</code>”，这个是不对的，作者这样做的原因我们在上一篇文章中有讲过，首先第一个检查<code>cellsBusy == 0</code>是流程往下走的基础，如果<code>cellsBusy == 1</code>则直接拿锁失败退出，调用<code>h = ThreadLocalRandom.advanceProbe(h);</code>更新<code>h</code>后重试，如果<code>cellsBusy == 0</code>校验通过，则调用<code>CounterCell r = new CounterCell(x);</code>初始化一个<code>CounterCell</code>，这样做是为了减少自旋锁的临界区的大小，以此来提升并发性能</p>
<p>细节三：</p>
<p>在加锁的时候先判断下<code>cellsBusy</code>是否为0，如果为1那直接宣告拿锁失败，为什么这么做呢？因为相比于调用<code>UNSAFE</code>的<code>CAS</code>操作，直接读取<code>volatile</code>的消耗更少，如果直接读取<code>cellsBusy</code>已经能判断出拿锁失败，那就没必要再调用耗时更多的<code>CAS</code>了</p>
<p>细节四：</p>
<p>对<code>cellsBusy</code>从0到1的更改调用了<code>CAS</code>但是从1置为0却只用了赋值操作，这是因为<code>CAS</code>可以保证能走到这条语句的只有一个线程，因此可以用赋值操作来更改<code>cellsBusy</code>的值。</p>
<h3 id="sumCount"><a href="#sumCount" class="headerlink" title="sumCount"></a><code>sumCount</code></h3><p>前面两个方法主要是把<code>ConcurrentHashMap</code>中的元素个数分散的记录到<code>baseCount</code>和辅助队列中，调用<code>size()</code>方法的时候只需要把这些值相加即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    long n &#x3D; sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as &#x3D; counterCells; CounterCell a;</span><br><span class="line">    long sum &#x3D; baseCount;</span><br><span class="line">    if (as !&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a &#x3D; as[i]) !&#x3D; null)</span><br><span class="line">                sum +&#x3D; a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter01-%E7%AE%80%E5%8D%95web%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter01-%E7%AE%80%E5%8D%95web%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">chapter01-简单web服务器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-17 22:17:44" itemprop="dateCreated datePublished" datetime="2021-04-17T22:17:44+08:00">2021-04-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-20 18:06:45" itemprop="dateModified" datetime="2021-04-20T18:06:45+08:00">2021-04-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>三部分 + 回车</p>
<ul>
<li>请求方法    统一资源标识符(URI)    协议/版本</li>
<li>请求头</li>
<li>回车/换行: CRLF（carriage returen/LineFeed）</li>
<li>实体</li>
</ul>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>三部分</p>
<ul>
<li>协议    状态码    描述</li>
<li>响应头</li>
<li>响应实体段</li>
</ul>
<h2 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h2><p>套接字是网络连接的端点。套接字使应用程序可以从网络中读取数据，可以向网络中写入数据。<a href="">不同计算机上的两个应用程序可以通过连接发送或接收字节流，以此达到相互通信的目的</a>。为了从一个应用程序向另一个应用程序发送消息，需要知道另一个应用程序中套接字的IP地址和端口号。在Java中，套接字由java.net.Socket表示。<br>要创建一个套接字，可以使用Socket类中众多构造函数中的一个。其中一个构造函数接收两个参数：主机名和端口号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Socket (java.lang.String host, int port)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Socket (&quot;yahoo.com&quot;, 80);</span><br></pre></td></tr></table></figure>

<p>一旦成功地创建了Socket类的实例，就可以使用该实例发送或接收字节流。要发送字节流，需要调用Socket类的getOutputStream()方法获取一个java.io.OutputStream对象。要发送文本到远程应用程序，通常需要使用返回的OutputStream对象创建一个java.io.PrintWriter对象。若想要从连接的另一端接收字节流，需要调用Socket类的getInputStream()方法，该法会返回一个java.io.InputStream对象。</p>
<p><img src="https://yqfile.alicdn.com/642c4a62ac7a1790bca190ed30d4ab8006d1fbb6.png" alt="image"></p>
<p><img src="https://yqfile.alicdn.com/9303042d37ef3886d4aa73ce2a798cb7bae62eda.png" alt="image"></p>
<h2 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a><strong>ServerSocket类</strong></h2><p>Socket类表示一个客户端套接字。正因如此，需要使用java.net.ServerSocket类，这是服务器套接字的实现。<br>ServerSocket类与Socket类并不相同。服务器套接字要等待来自客户端的连接请求。当服务器套接字收到了连接请求后，它会创建一个Socket实例来处理与客户端的通信。<br>要创建一个服务器套接字，可以使用ServerSocket类提供的4个构造函数中的任意一个。需要指明IP地址和服务器套接字侦听的端口号。典型情况下，IP地址可以是127.0.0.1，即服务器套接字会侦听本地机器接收到的连接请求。服务器套接字侦听的IP地址称为绑定地址。服务器套接字的另一个重要属性是backlog，后者表示在服务器拒绝接收传入的请求之前，传入的连接请求的最大队列长度。<br>ServerSocket类的其中一个构造函数的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ServerSocket(int port, int backLog, InetAddress bindingAddress);</span><br></pre></td></tr></table></figure>

<p>ServerSocket对象侦听本地主机的8080端口，其backlog值为1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ServerSocket(8080, 1, InetAddress.getByName(&quot;127.0.0.1&quot;));</span><br></pre></td></tr></table></figure>

<p>在应用程序的入口点，也就是静态main函数中，创建一个HttpServer实例，然后调用其await()方法。顾名思义，await方法会在制定的端口上等待http请求，并对其进行处理，然后发送相应的消息回客户端。在接收到命令之前，它会一直保持等待的状态。</p>
<h2 id="HttpServer类"><a href="#HttpServer类" class="headerlink" title="HttpServer类"></a>HttpServer类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package simpleHttpServer;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class HttpServer &#123;</span><br><span class="line">    </span><br><span class="line">    public static final String WEB_ROOT &#x3D; System.getProperty(&quot;user.dir&quot;) + File.separator</span><br><span class="line">            + &quot;webroot&quot;;</span><br><span class="line">    </span><br><span class="line">    private static final String SHUTDOWN_COMMAND &#x3D; &quot;&#x2F;SHUTDOWN&quot;;</span><br><span class="line">    </span><br><span class="line">    private boolean shudown &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        HttpServer server &#x3D; new HttpServer();</span><br><span class="line">        server.await();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void await()&#123;</span><br><span class="line">        ServerSocket serverSocket &#x3D; null;</span><br><span class="line">        int port &#x3D; 8080;</span><br><span class="line">        </span><br><span class="line">        try&#123;</span><br><span class="line">            serverSocket &#x3D; new ServerSocket(port,1,InetAddress.getByName(&quot;127.0.0.1&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!this.shudown)&#123;</span><br><span class="line">            Socket socket &#x3D; null;</span><br><span class="line">            InputStream input &#x3D; null;</span><br><span class="line">            OutputStream output &#x3D; null;</span><br><span class="line">            </span><br><span class="line">            try&#123;</span><br><span class="line">                </span><br><span class="line">                socket &#x3D; serverSocket.accept();</span><br><span class="line">                input &#x3D; socket.getInputStream();</span><br><span class="line">                output &#x3D; socket.getOutputStream();</span><br><span class="line">                </span><br><span class="line">                Request request &#x3D; new Request(input);</span><br><span class="line">                request.parse();</span><br><span class="line">                </span><br><span class="line">                Response response &#x3D; new Response(output);</span><br><span class="line">                response.setRequest(request);</span><br><span class="line">                response.sendStaticResource();</span><br><span class="line">                </span><br><span class="line">                socket.close();</span><br><span class="line">                </span><br><span class="line">                this.shudown &#x3D; request.getUri().equals(SHUTDOWN_COMMAND);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个简单的web服务器，可以处理指定目录中的静态资源请求；用WEB_ROOT表示制定的目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String WEB_ROOT &#x3D; System.getProperty(&quot;user.dir&quot;) + File.separator + &quot;webroot&quot;;</span><br></pre></td></tr></table></figure>

<p>这里是指当前目录下的webroot文件夹下面的资源。<br>我们通过在游览器中输入这样的内容，进行资源的请求:<br><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/index.html">http://127.0.0.1:8080/index.html</a></p>
<h2 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h2><p>Request类表示一个Http请求，可以传递InputStream对象来创建Request对象，调用InputStream对象的read进行Http请求数据的读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package simpleHttpServer;</span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">public class Request &#123;</span><br><span class="line">    private InputStream input;</span><br><span class="line">    private String uri;</span><br><span class="line">    </span><br><span class="line">    public Request(InputStream input)&#123;</span><br><span class="line">        this.input &#x3D; input;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void parse()&#123;</span><br><span class="line">        StringBuffer request &#x3D; new StringBuffer(2048);</span><br><span class="line">        </span><br><span class="line">        int i;</span><br><span class="line">        byte[] buffer &#x3D; new byte[2048];</span><br><span class="line">        try&#123;</span><br><span class="line">            i &#x3D; input.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            i &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int j&#x3D;0;j&lt;i;j++)&#123;</span><br><span class="line">            request.append((char)buffer[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.print(request.toString());</span><br><span class="line">        this.uri &#x3D; this.parseUri(request.toString());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private String parseUri(String requestString)&#123;</span><br><span class="line">        int index1,index2;</span><br><span class="line">        index1 &#x3D; requestString.indexOf(&#39; &#39;);</span><br><span class="line">        if(index1 !&#x3D; -1)&#123;</span><br><span class="line">            index2 &#x3D; requestString.indexOf(&#39; &#39;, index1 + 1);</span><br><span class="line">            if(index2 &gt; index1)&#123;</span><br><span class="line">                return requestString.substring(index1 + 1,index2 );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getUri()&#123;</span><br><span class="line">        return this.uri;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Request类最重要的两个函数是parse和ParseUri；parse()方法会调用私有方法parseUri来解析HTTP请求的uri，初次之外，并没有做太多的工作。parseuri会将解析的URI存储在变量uri中。</p>
<p>我们以 <a target="_blank" rel="noopener" href="http://127.0.0.1:8080/index.html">http://127.0.0.1:8080/index.html</a> 请求为例，HTTP请求的请求行为<br>GET /index.html HTTP/1.1<br>parse()方法从传入的Request对象的InputStream对象中读取整个字节流，并且将字节数组存入缓冲区。然后用缓存区的数组初始化StringBuffer对象request。 这样再解析StringBuffer就可以解析到Uri。</p>
<h2 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h2><p>Response类表示Http相应。其定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package simpleHttpServer;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line"></span><br><span class="line">public class Response &#123;</span><br><span class="line">    </span><br><span class="line">    private static final int BUFFER_SIZE &#x3D; 1024;</span><br><span class="line">    private Request request;</span><br><span class="line">    private OutputStream output;</span><br><span class="line">    </span><br><span class="line">    public Response(OutputStream output)&#123;</span><br><span class="line">        this.output &#x3D; output;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setRequest(Request request)&#123;</span><br><span class="line">        this.request &#x3D; request;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void sendStaticResource()throws IOException&#123;</span><br><span class="line">        </span><br><span class="line">        byte[] bytes &#x3D; new byte[BUFFER_SIZE];</span><br><span class="line">        FileInputStream fis &#x3D; null;</span><br><span class="line">        </span><br><span class="line">        try&#123;</span><br><span class="line">            </span><br><span class="line">            File file &#x3D; new File(HttpServer.WEB_ROOT,request.getUri());</span><br><span class="line">            if(file.exists())&#123;</span><br><span class="line">                fis &#x3D; new FileInputStream(file);</span><br><span class="line">                int ch &#x3D; fis.read(bytes, 0, BUFFER_SIZE);</span><br><span class="line">                while(ch !&#x3D; -1)&#123;</span><br><span class="line">                    output.write(bytes, 0, ch);</span><br><span class="line">                    ch &#x3D; fis.read(bytes, 0, BUFFER_SIZE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                String errorMessage &#x3D; &quot;HTTP&#x2F;1.1 404 File Not Found\r\n&quot; + </span><br><span class="line">                            &quot;Content-Type: text&#x2F;html\r\n&quot; +</span><br><span class="line">                            &quot;Content-Length:23\r\n&quot; +</span><br><span class="line">                            &quot;\r\n&quot; + </span><br><span class="line">                            &quot;&lt;h1&gt;File Not Found&lt;&#x2F;h1&gt;&quot;;</span><br><span class="line">                output.write(errorMessage.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally&#123;</span><br><span class="line">            if(fis !&#x3D; null)&#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用OutputStream和Request来初始化Reponse，Response比较简单，得到Request的Uri，然后读取对应的file，如果file存在，则将file中的数据读取到缓存中，并且发送给游览器；如果file不存在，那么就发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;HTTP&#x2F;1.1 404 File Not Found\r\n&quot; + </span><br><span class="line">                            &quot;Content-Type: text&#x2F;html\r\n&quot; +</span><br><span class="line">                            &quot;Content-Length:23\r\n&quot; +</span><br><span class="line">                            &quot;\r\n&quot; + </span><br><span class="line">                            &quot;&lt;h1&gt;File Not Found&lt;&#x2F;h1&gt;&quot;;</span><br></pre></td></tr></table></figure>



<p>错误信息给游览器。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter02-%E7%AE%80%E5%8D%95servlet%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter02-%E7%AE%80%E5%8D%95servlet%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">chapter01-简单web服务器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-17 22:17:44" itemprop="dateCreated datePublished" datetime="2021-04-17T22:17:44+08:00">2021-04-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-08 07:49:15" itemprop="dateModified" datetime="2021-05-08T07:49:15+08:00">2021-05-08</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="javax-servlet-Servlet接口"><a href="#javax-servlet-Servlet接口" class="headerlink" title="javax.servlet.Servlet接口"></a><a target="_blank" rel="noopener" href="http://sishuok.com/forum/blogPost/list/4067.html;jsessionid=F387500832428F51B04251FC9481DB31">javax.servlet.Servlet接口</a></h2><p>Servlet接口需要实现下面的5个方法：</p>
<blockquote>
<p>l     public void init(ServletConfig config) throws ServletException</p>
<p>l     public void service(ServletRequest request, ServletResponse response) throws ServletException, java.io.IOException</p>
<p>l     public void destroy()</p>
<p>l     public ServletConfig getServletConfig()</p>
<p>l     public java.lang.String getServletInfo()</p>
</blockquote>
<p>在某个servlet类被实例化之后，init方法由servlet容器调用。servlet容器只调用该方法一次，调用后则可以执行服务方法了。在servlet接收任何请求之前，必须是经过正确初始化的。</p>
<p>当一个客户端请求到达后，servlet容器就调用相应的servlet的service方法，并将Request和Response对象作为参数传入。在servlet实例的生命周期内，service方法会被多次调用。<!--这个客户请求就是为了请求这个servlet资源--></p>
<p>在将servlet实例从服务中移除前，会调用servlet实例的destroy方法。一般情况下，在服务器关闭前，会发生上述情况，servlet容器会释放内存。只有当servlet实例的service方法中所有的线程都退出或执行超时后，才会调用destroy方法。当容器调用了destroy方法，就不会再调用service方法了。</p>
<h2 id="Application-1"><a href="#Application-1" class="headerlink" title="Application 1"></a>Application 1</h2><p>下面从servlet容器的角度观察servlet的开发。在一个全功能servlet容器中，对servlet的每个HTTP请求来说，容器要做下面几件事：</p>
<ul>
<li>当第一次调用servlet时，要载入servlet类，调用init方法（仅此一次）；</li>
<li>针对每个request请求，创建一个Request对象和一个Resposne对象；</li>
<li>调用相应的servlet的service方法，将Request对象和Response对象作为参数传入；</li>
<li>当关闭servlet时，调用destroy方法，并卸载该servlet类。</li>
</ul>
<p>这里建立的servlet容器是一个很小的容器，没有实现所有的功能。因此，它仅能运行非常简单的servlet类，无法调用servlet的init和destroy方法。它能执行功能如下所示：</p>
<ul>
<li>等待HTTP请求；</li>
<li>创建Request和Response对象；</li>
<li><a href="">若请求的是一个静态资源，则调用StaticResourceProcessor对象的process方法，传入request和response对象;</a> </li>
<li><a href="">若请求的是servlet，则载入相应的servlet类，调用service方法，传入request对象和response对象。</a><!--其实servlet就是用户请求的一种资源--></li>
</ul>
<p><font color="red">注意，在这个servlet中，每次请求servlet都会载入servlet类。</font></p>
<p>该程序包括6个类：HttpServer1、Request、Response、StaticResourceProcessor、ServletProcessor1、Constants。</p>
<p><img src="https://yqfile.alicdn.com/2d4ea4f13960600f97c3391b641a0afa78a01d15.png" alt="image"></p>
<p>​     该程序的入口点（静态main方法）在类HttpServer1中。main方法中创建HttpServer1的实例，饭后调用其await方法。await方法等待HTTP请求，为接收到的每个请求创建request和response对象，将它们分发到一个StaticResourceProcessor类或ServletProcessor类的实例。</p>
<h3 id="HttpServer1类"><a href="#HttpServer1类" class="headerlink" title="HttpServer1类"></a>HttpServer1类</h3><p>应用程序1中的HttpServer1类与第1章中简单Web服务器应用程序中的HttpServer类似。但是，<a href="">该应用程序中的HttpServer1类既可以对静态资源请求，也可以对于servlet资源请求</a>。</p>
<p>若要请求一个静态资源，可以在浏览器的地址栏或URL框中输入如下格式的URL：这与第1章的Web服务器应用程序中对静态资源的请求相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;machineName:port&#x2F;staticResource</span><br></pre></td></tr></table></figure>


<p>若要请求servlet资源，可以使用如下格式的URL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;machineName:port&#x2F;servlet&#x2F;servletClass</span><br></pre></td></tr></table></figure>

<p>但是，若要调用其他的servlet（如ModernServlet），则servlet容器抛出异常。在后面的章节中，你将学会如何构建可以兼具两种功能的servlet容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * WEB_ROOT is the directory where our HTML and other files reside.</span></span><br><span class="line"><span class="comment">     * For this package, WEB_ROOT is the &quot;webroot&quot; directory under the working</span></span><br><span class="line"><span class="comment">     * directory.</span></span><br><span class="line"><span class="comment">     * The working directory is the location in the file system</span></span><br><span class="line"><span class="comment">     * from where the java command was invoked.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// shutdown command</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SHUTDOWN_COMMAND = <span class="string">&quot;/SHUTDOWN&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the shutdown command received</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> shutdown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HttpServer1 server = <span class="keyword">new</span> HttpServer1();</span><br><span class="line">        server.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port, <span class="number">1</span>, InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop waiting for a request</span></span><br><span class="line">        <span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            InputStream input = <span class="keyword">null</span>;</span><br><span class="line">            OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                input = socket.getInputStream();</span><br><span class="line">                output = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// create Request object and parse</span></span><br><span class="line">                Request request = <span class="keyword">new</span> Request(input);</span><br><span class="line">                request.parse();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// create Response object</span></span><br><span class="line">                Response response = <span class="keyword">new</span> Response(output);</span><br><span class="line">                response.setRequest(request);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// check if this is a request for a servlet or a static resource              </span></span><br><span class="line">                <span class="keyword">if</span> (request.getUri().startsWith(<span class="string">&quot;/servlet/&quot;</span>)) &#123; <span class="comment">// a request for a servlet begins with &quot;/servlet/&quot;</span></span><br><span class="line">                    ServletProcessor1 processor = <span class="keyword">new</span> ServletProcessor1();</span><br><span class="line">                    processor.process(request, response);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    StaticResourceProcessor processor = <span class="keyword">new</span> StaticResourceProcessor();</span><br><span class="line">                    processor.process(request, response);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Close the socket</span></span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="comment">//check if the previous URI is a shutdown command</span></span><br><span class="line">                shutdown = request.getUri().equals(SHUTDOWN_COMMAND);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类的await()方法会一直等待HTTP请求，直到接收到一条关闭命令，这点与第1章中的await()方法类似。区别在于，本章中的await()方法可以将HTTP请求分发给StaticResourceProcessor对象或ServletProcessor对象来处理。<a href="">当URI包含字符串“/servlet/”时，会把请求转发给servletProcessor对象处理</a>。 <!--这就是UML类图中HttpServer持有1个ServletProcessor的原因--> 否则的话，把HTTP请求传递给StaticResourceProcessor对象处理。</p>
<h3 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h3><p>该类实现了javax.servlet.ServletRequest接口，但并不返回实际内容。</p>
<h3 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h3><p>实现了javax.servlet.ServletResponse接口，大部分方法都返回一个空值，除了getWriter方法以外。</p>
<p>​     在getWriter方法中，PrintWriter类的构造函数的第二个参数表示是否启用autoFlush。因此，若是设置为false，则如果是servlet的service方法的最后一行调用打印方法，则该打印内容不会被发送到客户端。这个bug会在后续的版本中修改。</p>
<h3 id="StaticResourceProcessor类"><a href="#StaticResourceProcessor类" class="headerlink" title="StaticResourceProcessor类"></a>StaticResourceProcessor类</h3><p>该类用于处理对静态资源的请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class StaticResourceProcessor &#123;</span><br><span class="line">    public void process(Request request, Response response) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            response.sendStaticResource();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServletProcessor1类"><a href="#ServletProcessor1类" class="headerlink" title="ServletProcessor1类"></a>ServletProcessor1类</h3><p>​     该类用于处理对servlet资源的请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletProcessor1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line">        String uri = request.getUri();</span><br><span class="line">        String servletName = uri.substring(uri.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        URLClassLoader loader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL[] urls = <span class="keyword">new</span> URL[<span class="number">1</span>];</span><br><span class="line">            URLStreamHandler streamHandler = <span class="keyword">null</span>;</span><br><span class="line">            File classPath = <span class="keyword">new</span> File(Constants.WEB_ROOT); <span class="comment">//类加载器需要加载的目标地址</span></span><br><span class="line"></span><br><span class="line">            String repository = (<span class="keyword">new</span> URL(<span class="string">&quot;file&quot;</span>, <span class="keyword">null</span>, classPath.getCanonicalPath() + File.separator)).toString();</span><br><span class="line">            urls[<span class="number">0</span>] = <span class="keyword">new</span> URL(<span class="keyword">null</span>, repository, streamHandler);</span><br><span class="line">            loader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class myClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myClass = loader.loadClass(servletName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            servlet = (Servlet) myClass.newInstance();  <span class="comment">//很有意思，使用的是newInstance()而不是new，因为把类加载与类实例化分开了</span></span><br><span class="line">            servlet.service((ServletRequest) request, (ServletResponse) response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该类很简单，只有一个process方法。</p>
<ul>
<li><p>为了载入servlet类，需要从URI中获取servlet的类名称，由request负责；</p>
</li>
<li><p>为了载入servlet类，载入servlet时使用的是UrlClassLoader类，它是ClassLoader类的直接子类，有三种构造方法。</p>
<ul>
<li>public URLClassLoader(URL[] urls);</li>
<li>public URL(URL context, java.lang.String spec, URLStreamHandler hander) throws MalformedURLException</li>
<li>public URL(java.lang.String protocol, java.lang.String host, java.lang.String file) throws MalformedURLException</li>
</ul>
<p>第一个构造函数，参数为一个Url对象的数组，每个url指明了从哪里查找servlet类。若某个Url是以“/”结尾的，则认为它是一个目录；否则，认为它是一个jar文件，必要时会将它下载并解压。 <!--这里使用的是Constans.WEB_ROOT，其实就是项目编译后的WEB_INFO/Class目录--></p>
</li>
<li><p>加载并创建完servlet类以后<!--所以必须使用加载和newInstance()方式分布进行-->，将其向下转型为javax.servlet.servlet，并调用其service()方法</p>
</li>
</ul>
<p>注：在servlet容器中，查找servlet类的位置称为repository。</p>
<p>在我们的应用程序中，servlet容器只需要查找一个repository，在工作目录的webroot路径下。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>Linux下启动项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .&#x2F;lib&#x2F;servlet.jar:.&#x2F;  ex02.pyrmont.HttpServer1</span><br></pre></td></tr></table></figure>

<p>测试访问servlet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;servlet&#x2F;Primitiveservlet</span><br></pre></td></tr></table></figure>



<h2 id="Application-2"><a href="#Application-2" class="headerlink" title="Application 2"></a>Application 2</h2><p>在之前的程序中，有一个严重的问题，必须将ex02.pyrmont.Request和ex02.pyrmont.Response分别转型为javax.servlet.ServletRequest和javax.servlet.ServletResponse，再作为参数传递给具体的servlet的service方法。这样并不安全，熟知servlet容器的人可以将ServletRequest和ServletResponse类向下转型为Request和Response类，并执行parse和sendStaticResource方法。</p>
<ul>
<li><p>一种解决方案是将这两个方法的访问修饰符改为默认的（即，default），这样就可以避免包外访问。<!--很多第三方jar包都这样使用，比如shiro--></p>
</li>
<li><p>另一种更好的方案是使用外观设计模式。uml图如下：</p>
</li>
</ul>
<p><img src="http://sishuok.com/forum/upload/2012/4/10/8cdb2ac0da1fdb61ed7cdfdb2694b664__%E6%9C%AA%E5%91%BD%E5%90%8D.jpg" alt="img"></p>
<p>在第二个应用程序中，添加了两个façade类，RequestFacade和ResponseFacade。RequestFacade类实现了ServletRequest接口，通过在其构造方法中传入一个ServletRequest类型引用的Request对象来实例化。ServletRequest接口中每个方法的实现都会调用Request对象的相应方法。但是，ServletRequest对象本身是private类型，这样就不能从类的外部进行访问。这里也不再将Request对象向上转型为ServletRequest对象，而是创建一个RequestFacade对象，并把它传给service方法。这样，就算是将在servlet中获取了ServletRequest对象，并向下转型为RequestFacade对象，也不能再访问ServletRequest接口中的方法了，就可以避免前面所说的安全问题。</p>
<blockquote>
<p>注意: 它的构造函数，接收一个Request对象，然后向上转型为ServletRequest对象，赋给其private成员变量request。该类的其他方法中，都是调用request的相应方法实现的，这样就将ServletRequest完整的封装得RequestFacade中了。</p>
</blockquote>
<p> serveltProcess方法修改以下部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    servlet = (Servlet) myClass.newInstance();  <span class="comment">//很有意思，使用的是newInstance()而不是new，因为把类加载与类实例化分开了, tomcat需要破坏双亲委派，使用线程级别的类加载器</span></span><br><span class="line">    servlet.service((ServletRequest) requestFacade, (ServletResponse) responseFacade);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/16/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E2%80%9C12306%E2%80%9D-%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%AF%E6%92%91%E8%B5%B7%E7%99%BE%E4%B8%87-QPS-%E7%9A%84%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/16/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E2%80%9C12306%E2%80%9D-%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%AF%E6%92%91%E8%B5%B7%E7%99%BE%E4%B8%87-QPS-%E7%9A%84%EF%BC%9F/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-16 09:38:22" itemprop="dateCreated datePublished" datetime="2021-04-16T09:38:22+08:00">2021-04-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-21 20:19:45" itemprop="dateModified" datetime="2021-04-21T20:19:45+08:00">2021-04-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="大型高并发系统架构"><a href="#大型高并发系统架构" class="headerlink" title="大型高并发系统架构"></a>大型高并发系统架构</h2><p>高并发的系统架构都会采用分布式集群部署，服务上层有着层层负载均衡，并提供各种容灾手段(双火机房、节点容错、服务器灾备等)保证系统的高可用,流量也会根据不同的负载能力和配置策略均衡到不同的服务器上。下边是一个简单的示意图:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhrFzwRdyIg4jfZXa5IJQbRVxJvshqibibWXZbI2WQrZeoYJ4EiaibRLHFjBwcZ8dryibSM5CZPapa5g1TA/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h3 id="1-1-负载均衡简介"><a href="#1-1-负载均衡简介" class="headerlink" title="1.1 负载均衡简介"></a>1.1 负载均衡简介</h3><p>上图中描述了用户请求到服务器经历了三层的负载均衡，下边分别简单介绍一下这三种负载均衡：</p>
<ul>
<li>OSPF(开放式最短链路优先)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，OSPF会自动计算路由接口上的Cost值，但也可以通过手工指定该接口的Cost值，手工指定的优先于自动计算的值。OSPF计算的Cost，同样是和接口带宽成反比，带宽越高，Cost值越小。到达目标相同Cost值的路径，可以执行负载均衡，最多6条链路同时执行负载均衡。</li>
<li>LVS (Linux VirtualServer)，它是一种集群(Cluster)技术，采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。</li>
<li>Nginx想必大家都很熟悉了,是一款非常高性能的http代理/反向代理服务器,服务开发中也经常使用它来做负载均衡。Nginx实现负载均衡的方式主要有三种:轮询、加权轮询、ip hash轮询，下面我们就针对Nginx的加权轮询做专门的配置和测试</li>
</ul>
<h3 id="1-2-Nginx加权轮询的演示"><a href="#1-2-Nginx加权轮询的演示" class="headerlink" title="1.2 Nginx加权轮询的演示"></a>1.2 Nginx加权轮询的演示</h3><p>Nginx实现负载均衡通过upstream模块实现，其中加权轮询的配置是可以给相关的服务加上一个权重值，配置的时候可能根据服务器的性能、负载能力设置相应的负载。</p>
<p>下面是一个加权轮询负载的配置，我将在本地的监听3001-3004端口,分别配置1，2，3，4的权重:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#配置负载均衡</span><br><span class="line">    upstream load_rule &#123;</span><br><span class="line">       server 127.0.0.1:3001 weight&#x3D;1;</span><br><span class="line">       server 127.0.0.1:3002 weight&#x3D;2;</span><br><span class="line">       server 127.0.0.1:3003 weight&#x3D;3;</span><br><span class="line">       server 127.0.0.1:3004 weight&#x3D;4;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  load_balance.com www.load_balance.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">       proxy_pass http:&#x2F;&#x2F;load_rule;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在本地/etc/hosts目录下配置了 <a href="http://www.load_balance.com的虚拟域名地址，接下来使用Go语言开启四个http端口监听服务，下面是监听在3001端口的Go程序,其他几个只需要修改端口即可：">www.load_balance.com的虚拟域名地址，接下来使用Go语言开启四个http端口监听服务，下面是监听在3001端口的Go程序,其他几个只需要修改端口即可：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;net&#x2F;http&quot;</span><br><span class="line"> &quot;os&quot;</span><br><span class="line"> &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> http.HandleFunc(&quot;&#x2F;buy&#x2F;ticket&quot;, handleReq)</span><br><span class="line"> http.ListenAndServe(&quot;:3001&quot;, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理请求函数,根据请求将响应结果信息写入日志</span><br><span class="line">func handleReq(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line"> failedMsg :&#x3D;  &quot;handle in port:&quot;</span><br><span class="line"> writeLog(failedMsg, &quot;.&#x2F;stat.log&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写入日志</span><br><span class="line">func writeLog(msg string, logPath string) &#123;</span><br><span class="line"> fd, _ :&#x3D; os.OpenFile(logPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)</span><br><span class="line"> defer fd.Close()</span><br><span class="line"> content :&#x3D; strings.Join([]string&#123;msg, &quot;\r\n&quot;&#125;, &quot;3001&quot;)</span><br><span class="line"> buf :&#x3D; []byte(content)</span><br><span class="line"> fd.Write(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我将请求的端口日志信息写到了./stat.log文件当中，然后使用ab压测工具做压测:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 1000 -c 100 http:&#x2F;&#x2F;www.load_balance.com&#x2F;buy&#x2F;ticket</span><br></pre></td></tr></table></figure>

<p>统计日志中的结果，3001-3004端口分别得到了100、200、300、400的请求量，这和我在nginx中配置的权重占比很好的吻合在了一起，并且负载后的流量非常的均匀、随机。具体的实现大家可以参考nginx的upsteam模块实现源码,这里推荐一篇文章：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/digest/understandingnginx/202607">https://www.kancloud.cn/digest/understandingnginx/202607</a></p>
</blockquote>
<h2 id="秒杀抢购系统选型"><a href="#秒杀抢购系统选型" class="headerlink" title="秒杀抢购系统选型"></a>秒杀抢购系统选型</h2><p>回到我们最初提到的问题中来：火车票秒杀系统如何在高并发情况下提供正常、稳定的服务呢？从上面的介绍我们知道用户秒杀流量通过层层的负载均衡，均匀到了不同的服务器上，即使如此，集群中的单机所承受的QPS也是非常高的。如何将单机性能优化到极致呢？要解决这个问题，我们就要想明白一件事：</p>
<blockquote>
<p>通常订票系统要处理生成订单、减扣库存、用户支付这三个基本的阶段，我们系统要做的事情是要保证火车票订单不超卖、不少卖，每张售卖的车票都必须支付才有效，还要保证系统承受极高的并发。这三个阶段的先后顺序改怎么分配才更加合理呢?我们来分析一下：</p>
</blockquote>
<h3 id="下单减库存"><a href="#下单减库存" class="headerlink" title="下单减库存"></a>下单减库存</h3><p>当用户并发请求到达服务端时，首先创建订单，然后扣除库存 <!--这是一个原子操作-->，等待用户支付。</p>
<ul>
<li>Pros: <ul>
<li>这种顺序是我们一般人首先会想到的解决方案，保证订单不会超卖。</li>
</ul>
</li>
<li>Cons:<ul>
<li>不能避免并发操作数据库磁盘IO</li>
<li>如果用户存在恶意下单的情况，只下单不支付这样库存就会变少，会少卖订单。然服务端可以限制IP和用户的购买订单数量，这也不算是一个好方法。</li>
</ul>
</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhrFzwRdyIg4jfZXa5IJQbRVqVibq32eZqibicwz5UOibKbKfN4xzsc8Xa6TwgyYP7pFmqpfSvr4tpq5Kw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h3 id="支付减库存"><a href="#支付减库存" class="headerlink" title="支付减库存"></a>支付减库存</h3><p>等待用户支付了订单在减库存 <!--这是一个原子操作--></p>
<ul>
<li>Pros: <ul>
<li>不会少卖。</li>
</ul>
</li>
<li>Cons: <ul>
<li>在极限并发情况下，用户可能会创建很多订单，当库存减为零的时候很多用户发现抢到的订单支付不了了，这也就是“超卖”。</li>
<li>不能避免并发操作数据库磁盘IO</li>
</ul>
</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhrFzwRdyIg4jfZXa5IJQbRVOSaRNvHmlEr8MibfmK5HNKlgHHOjmiaiaaTiczAdIxN8icu4HjicSmncG4Kg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h3 id="预扣库存"><a href="#预扣库存" class="headerlink" title="预扣库存"></a>预扣库存</h3><p>从上边两种方案的考虑，我们可以得出结论：只要创建订单，就要频繁操作数据库IO。那么有没有一种不需要直接操作数据库IO的方案呢，这就是预扣库存。</p>
<ul>
<li>Pros<ul>
<li>先扣除了库存，保证不超卖，<!--这里说的不好，扣除库存也是数据库IO。只是现在企业用了redis保存库存--> 然后异步生成用户订单，这样响应给用户的速度就会快很多 。<!--这里生成订单的操作，从响应时间上，因为异步，确实快了；但是对于整个订单流程来说，还是要数据库IO--></li>
<li>订单都有有效期，比如说用户五分钟内不支付，订单就失效了，订单一旦失效，就会加入新的库存。保障不少卖</li>
</ul>
</li>
</ul>
<p>订单的生成是异步的,一般都会放到MQ、kafka这样的即时消费队列中处理,订单量比较少的情况下，生成订单非常快，用户几乎不用排队。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhrFzwRdyIg4jfZXa5IJQbRVMTWVA7bAqAFyibk8TsnNQwoVuibxRoUwicIasheBQ6z0AbxzwOh4ibKt6w/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h2 id="预扣库存的艺术"><a href="#预扣库存的艺术" class="headerlink" title="预扣库存的艺术"></a>预扣库存的艺术</h2><h3 id="单机部署-Mysql"><a href="#单机部署-Mysql" class="headerlink" title="单机部署 + Mysql"></a>单机部署 + Mysql</h3><p>在单机低并发情况下，我们实现扣库存通常是这样的:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhrFzwRdyIg4jfZXa5IJQbRVJ5xiaDBib7IowIaIEakPPjM5KbO3Ulo3Jw6yjcg3vKbdPDbKgHHickfKA/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><a href="">为了保证扣库存和生成订单的原子性</a>，<!--非常重要！--> 需要采用事务处理，然后取库存判断、减库存，最后提交事务，整个流程有很多IO，对数据库的操作又是阻塞的。这种方式根本不适合高并发的秒杀系统。</p>
<h3 id="单机部署-单机内存-Mysql"><a href="#单机部署-单机内存-Mysql" class="headerlink" title="单机部署 + 单机内存 + Mysql"></a>单机部署 + 单机内存 + Mysql</h3><p>接下来我们对单机扣库存的方案做优化：本地扣库存。我们把一定的库存量分配到本地机器，直接在内存中减库存   <!--最好用Redis--> ，然后按照之前的逻辑异步创建订单。改进过之后的单机系统是这样的:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhrFzwRdyIg4jfZXa5IJQbRVjKMQlznZFA2cqCEvYXteH5n2CCBteORwtiaEa9acplcE30lVZ3cXZtg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>这样就避免了对数据库频繁的IO操作，只在内存中做运算，极大的提高了单机抗并发的能力。但是百万的用户请求量单机是无论如何也抗不住的，虽然nginx处理网络请求使用epoll模型，c10k的问题在业界早已得到了解决。但是linux系统下，一切资源皆文件，网络请求也是这样，大量的文件描述符会使操作系统瞬间失去响应。</p>
<h3 id="多机部署-多机内存-Mysql"><a href="#多机部署-多机内存-Mysql" class="headerlink" title="多机部署 + 多机内存 + Mysql"></a>多机部署 + 多机内存 + Mysql</h3><p>上面我们提到了nginx的加权均衡策略，我们不妨假设将100W的用户请求量平均均衡到100台服务器上，这样单机所承受的并发量就小了很多。</p>
<p>然后我们每台机器本地库存100张火车票，<!--这和平安的面试官问我的问题一样--> 100台服务器上的总库存还是1万，这样保证了库存订单不超卖,下面是我们描述的集群架构:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhrFzwRdyIg4jfZXa5IJQbRVicDCCRAuFALDDnqFkiahVyp4n4QGPLb9vpEqyXHP0xyyzz9k3zoyy0hw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>问题接踵而至，在高并发情况下，现在我们还无法保证系统的高可用，假如这100台服务器上有两三台机器因为扛不住并发的流量或者其他的原因宕机了。那么这些服务器上的订单就卖不出去了，这就造成了订单的少卖。</p>
<h3 id="多机部署-多机内存-Redis统一内存-Mysql"><a href="#多机部署-多机内存-Redis统一内存-Mysql" class="headerlink" title="多机部署 + 多机内存 + Redis统一内存 + Mysql"></a>多机部署 + 多机内存 + Redis统一内存 + Mysql</h3><p>要解决这个问题，我们需要对总订单量做统一的管理，这就是接下来的容错方案。服务器不仅要在本地减库存，另外要远程统一减库存。</p>
<p>有了远程统一减库存的操作，我们就可以根据机器负载情况，为每台机器分配一些多余的“buffer库存”用来防止机器中有机器宕机的情况。我们结合下面架构图具体分析一下:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhrFzwRdyIg4jfZXa5IJQbRV2RDibC3EQwsPibOgF0rG1KQpKGKibLIvbQ5mAo6ibW5vYB33xRAtQRb17A/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>我们采用Redis存储统一库存</p>
<ul>
<li><p>避免”超卖”：在本地减库存以后，如果本地有订单，我们再去请求redis远程减库存，本地减库存和远程减库存都成功了，才返回给用户抢票成功的提示</p>
</li>
<li><p>避免”少卖”：当机器中有机器宕机时，因为每个机器上有预留的buffer余票，所以宕机机器上的余票依然能够在其他机器上得到弥补，保证了不少卖。</p>
</li>
</ul>
<p>buffer余票设置多少合适呢，理论上buffer设置的越多，系统容忍宕机的机器数量就越多，但是buffer设置的太大也会对redis造成一定的影响。</p>
<p>虽然redis内存数据库抗并发能力非常高，请求依然会走一次网络IO,其实抢票过程中对redis的请求次数是本地库存和buffer库存的总量，因为当本地库存不足时，系统直接返回用户“已售罄”的信息提示，就不会再走统一扣库存的逻辑，这在一定程度上也避免了巨大的网络请求量把redis压跨，所以buffer值设置多少，需要架构师对系统的负载能力做认真的考量。</p>
<h2 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4. 代码演示"></a>4. 代码演示</h2><p>Go语言原生为并发设计，我采用go语言给大家演示一下单机抢票的具体流程。</p>
<h3 id="4-1-初始化工作"><a href="#4-1-初始化工作" class="headerlink" title="4.1 初始化工作"></a>4.1 初始化工作</h3><p>go包中的init函数先于main函数执行，在这个阶段主要做一些准备性工作。我们系统需要做的准备工作有：初始化本地库存、初始化远程redis存储统一库存的hash键值、初始化redis连接池；</p>
<p>另外还需要初始化一个大小为1的int类型chan，目的是实现分布式锁的功能，也可以直接使用读写锁或者使用redis等其他的方式避免资源竞争,但使用channel更加高效，这就是go语言的哲学：不要通过共享内存来通信，而要通过通信来共享内存。redis库使用的是redigo，下面是代码实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//localSpike包结构体定义</span></span><br><span class="line"><span class="keyword">package</span> localSpike</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LocalSpike <span class="keyword">struct</span> &#123;</span><br><span class="line"> LocalInStock     <span class="keyword">int64</span></span><br><span class="line"> LocalSalesVolume <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//remoteSpike对hash结构的定义和redis连接池</span></span><br><span class="line"><span class="keyword">package</span> remoteSpike</span><br><span class="line"><span class="comment">//远程订单存储健值</span></span><br><span class="line"><span class="keyword">type</span> RemoteSpikeKeys <span class="keyword">struct</span> &#123;</span><br><span class="line"> SpikeOrderHashKey <span class="keyword">string</span> <span class="comment">//redis中秒杀订单hash结构key</span></span><br><span class="line"> TotalInventoryKey <span class="keyword">string</span> <span class="comment">//hash结构中总订单库存key</span></span><br><span class="line"> QuantityOfOrderKey <span class="keyword">string</span> <span class="comment">//hash结构中已有订单数量key</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化redis连接池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPool</span><span class="params">()</span> *<span class="title">redis</span>.<span class="title">Pool</span></span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;redis.Pool&#123;</span><br><span class="line">  MaxIdle:   <span class="number">10000</span>,</span><br><span class="line">  MaxActive: <span class="number">12000</span>, <span class="comment">// max number of connections</span></span><br><span class="line">  Dial: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(redis.Conn, error)</span></span> &#123;</span><br><span class="line">   c, err := redis.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:6379&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> c, err</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"> localSpike = localSpike2.LocalSpike&#123;</span><br><span class="line">  LocalInStock:     <span class="number">150</span>,</span><br><span class="line">  LocalSalesVolume: <span class="number">0</span>,</span><br><span class="line"> &#125;</span><br><span class="line"> remoteSpike = remoteSpike2.RemoteSpikeKeys&#123;</span><br><span class="line">  SpikeOrderHashKey:  <span class="string">&quot;ticket_hash_key&quot;</span>,</span><br><span class="line">  TotalInventoryKey:  <span class="string">&quot;ticket_total_nums&quot;</span>,</span><br><span class="line">  QuantityOfOrderKey: <span class="string">&quot;ticket_sold_nums&quot;</span>,</span><br><span class="line"> &#125;</span><br><span class="line"> redisPool = remoteSpike2.NewPool()</span><br><span class="line"> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"> done &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-本地扣库存和统一扣库存"><a href="#4-2-本地扣库存和统一扣库存" class="headerlink" title="4.2 本地扣库存和统一扣库存"></a>4.2 本地扣库存和统一扣库存</h3><p>本地扣库存逻辑非常简单，用户请求过来，添加销量，然后对比销量是否大于本地库存，返回bool值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package localSpike</span><br><span class="line">&#x2F;&#x2F;本地扣库存,返回bool值</span><br><span class="line">func (spike *LocalSpike) LocalDeductionStock() bool&#123;</span><br><span class="line"> spike.LocalSalesVolume &#x3D; spike.LocalSalesVolume + 1</span><br><span class="line"> return spike.LocalSalesVolume &lt; spike.LocalInStock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里对共享数据LocalSalesVolume的操作是要使用锁来实现的，但是因为本地扣库存和统一扣库存是一个原子性操作，所以在最上层使用channel来实现，这块后边会讲。</p>
<p>统一扣库存操作redis，因为redis是单线程的，而我们要实现从中取数据，写数据并计算一些列步骤，我们要配合lua脚本打包命令，保证操作的原子性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package remoteSpike</span><br><span class="line">......</span><br><span class="line">const LuaScript &#x3D; &#96;</span><br><span class="line">        local ticket_key &#x3D; KEYS[1]</span><br><span class="line">        local ticket_total_key &#x3D; ARGV[1]</span><br><span class="line">        local ticket_sold_key &#x3D; ARGV[2]</span><br><span class="line">        local ticket_total_nums &#x3D; tonumber(redis.call(&#39;HGET&#39;, ticket_key, ticket_total_key))</span><br><span class="line">        local ticket_sold_nums &#x3D; tonumber(redis.call(&#39;HGET&#39;, ticket_key, ticket_sold_key))</span><br><span class="line">  -- 查看是否还有余票,增加订单数量,返回结果值</span><br><span class="line">       if(ticket_total_nums &gt;&#x3D; ticket_sold_nums) then</span><br><span class="line">            return redis.call(&#39;HINCRBY&#39;, ticket_key, ticket_sold_key, 1)</span><br><span class="line">        end</span><br><span class="line">        return 0</span><br><span class="line">&#96;</span><br><span class="line">&#x2F;&#x2F;远端统一扣库存</span><br><span class="line">func (RemoteSpikeKeys *RemoteSpikeKeys) RemoteDeductionStock(conn redis.Conn) bool &#123;</span><br><span class="line"> lua :&#x3D; redis.NewScript(1, LuaScript)</span><br><span class="line"> result, err :&#x3D; redis.Int(lua.Do(conn, RemoteSpikeKeys.SpikeOrderHashKey, RemoteSpikeKeys.TotalInventoryKey, RemoteSpikeKeys.QuantityOfOrderKey))</span><br><span class="line"> if err !&#x3D; nil &#123;</span><br><span class="line">  return false</span><br><span class="line"> &#125;</span><br><span class="line"> return result !&#x3D; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用hash结构存储总库存和总销量的信息,用户请求过来时，判断总销量是否大于库存，然后返回相关的bool值。在启动服务之前，我们需要初始化redis的初始库存信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset ticket_hash_key &quot;ticket_total_nums&quot; 10000 &quot;ticket_sold_nums&quot; 0</span><br></pre></td></tr></table></figure>

<h3 id="4-3-响应用户信息"><a href="#4-3-响应用户信息" class="headerlink" title="4.3 响应用户信息"></a>4.3 响应用户信息</h3><p>我们开启一个http服务，监听在一个端口上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">...</span><br><span class="line">func main() &#123;</span><br><span class="line"> http.HandleFunc(&quot;&#x2F;buy&#x2F;ticket&quot;, handleReq)</span><br><span class="line"> http.ListenAndServe(&quot;:3005&quot;, nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我们做完了所有的初始化工作，接下来handleReq的逻辑非常清晰，判断是否抢票成功，返回给用户信息就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">&#x2F;&#x2F;处理请求函数,根据请求将响应结果信息写入日志</span><br><span class="line">func handleReq(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line"> redisConn :&#x3D; redisPool.Get()</span><br><span class="line"> LogMsg :&#x3D; &quot;&quot;</span><br><span class="line"> &lt;-done</span><br><span class="line"> &#x2F;&#x2F;全局读写锁</span><br><span class="line"> if localSpike.LocalDeductionStock() &amp;&amp; remoteSpike.RemoteDeductionStock(redisConn) &#123;</span><br><span class="line">  util.RespJson(w, 1,  &quot;抢票成功&quot;, nil)</span><br><span class="line">  LogMsg &#x3D; LogMsg + &quot;result:1,localSales:&quot; + strconv.FormatInt(localSpike.LocalSalesVolume, 10)</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  util.RespJson(w, -1, &quot;已售罄&quot;, nil)</span><br><span class="line">  LogMsg &#x3D; LogMsg + &quot;result:0,localSales:&quot; + strconv.FormatInt(localSpike.LocalSalesVolume, 10)</span><br><span class="line"> &#125;</span><br><span class="line"> done &lt;- 1</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;将抢票状态写入到log中</span><br><span class="line"> writeLog(LogMsg, &quot;.&#x2F;stat.log&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func writeLog(msg string, logPath string) &#123;</span><br><span class="line"> fd, _ :&#x3D; os.OpenFile(logPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)</span><br><span class="line"> defer fd.Close()</span><br><span class="line"> content :&#x3D; strings.Join([]string&#123;msg, &quot;\r\n&quot;&#125;, &quot;&quot;)</span><br><span class="line"> buf :&#x3D; []byte(content)</span><br><span class="line"> fd.Write(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前边提到我们扣库存时要考虑竞态条件，我们这里是使用channel避免并发的读写，保证了请求的高效顺序执行。我们将接口的返回信息写入到了./stat.log文件方便做压测统计。</p>
<h3 id="4-4-单机服务压测"><a href="#4-4-单机服务压测" class="headerlink" title="4.4 单机服务压测"></a>4.4 单机服务压测</h3><p>开启服务，我们使用ab压测工具进行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 10000 -c 100 http:&#x2F;&#x2F;127.0.0.1:3005&#x2F;buy&#x2F;ticket</span><br></pre></td></tr></table></figure>

<p>下面是我本地低配mac的压测信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1826891 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http:&#x2F;&#x2F;www.zeustech.net&#x2F;</span><br><span class="line">Licensed to The Apache Software Foundation, http:&#x2F;&#x2F;www.apache.org&#x2F;</span><br><span class="line"></span><br><span class="line">Benchmarking 127.0.0.1 (be patient)</span><br><span class="line">Completed 1000 requests</span><br><span class="line">Completed 2000 requests</span><br><span class="line">Completed 3000 requests</span><br><span class="line">Completed 4000 requests</span><br><span class="line">Completed 5000 requests</span><br><span class="line">Completed 6000 requests</span><br><span class="line">Completed 7000 requests</span><br><span class="line">Completed 8000 requests</span><br><span class="line">Completed 9000 requests</span><br><span class="line">Completed 10000 requests</span><br><span class="line">Finished 10000 requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:</span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            3005</span><br><span class="line"></span><br><span class="line">Document Path:          &#x2F;buy&#x2F;ticket</span><br><span class="line">Document Length:        29 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   2.339 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      1370000 bytes</span><br><span class="line">HTML transferred:       290000 bytes</span><br><span class="line">Requests per second:    4275.96 [#&#x2F;sec] (mean)</span><br><span class="line">Time per request:       23.387 [ms] (mean)</span><br><span class="line">Time per request:       0.234 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          572.08 [Kbytes&#x2F;sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+&#x2F;-sd] median   max</span><br><span class="line">Connect:        0    8  14.7      6     223</span><br><span class="line">Processing:     2   15  17.6     11     232</span><br><span class="line">Waiting:        1   11  13.5      8     225</span><br><span class="line">Total:          7   23  22.8     18     239</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%     18</span><br><span class="line">  66%     24</span><br><span class="line">  75%     26</span><br><span class="line">  80%     28</span><br><span class="line">  90%     33</span><br><span class="line">  95%     39</span><br><span class="line">  98%     45</span><br><span class="line">  99%     54</span><br><span class="line"> 100%    239 (longest request)</span><br></pre></td></tr></table></figure>

<p>根据指标显示，我单机每秒就能处理4000+的请求，正常服务器都是多核配置，处理1W+的请求根本没有问题。而且查看日志发现整个服务过程中，请求都很正常，流量均匀，redis也很正常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;stat.log</span><br><span class="line">...</span><br><span class="line">result:1,localSales:145</span><br><span class="line">result:1,localSales:146</span><br><span class="line">result:1,localSales:147</span><br><span class="line">result:1,localSales:148</span><br><span class="line">result:1,localSales:149</span><br><span class="line">result:1,localSales:150</span><br><span class="line">result:0,localSales:151</span><br><span class="line">result:0,localSales:152</span><br><span class="line">result:0,localSales:153</span><br><span class="line">result:0,localSales:154</span><br><span class="line">result:0,localSales:156</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="5-总结回顾"><a href="#5-总结回顾" class="headerlink" title="5.总结回顾"></a>5.总结回顾</h2><p>总体来说，秒杀系统是非常复杂的。我们这里只是简单介绍模拟了一下单机如何优化到高性能，集群如何避免单点故障，保证订单不超卖、不少卖的一些策略，完整的订单系统还有订单进度的查看，每台服务器上都有一个任务，定时的从总库存同步余票和库存信息展示给用户,还有用户在订单有效期内不支付，释放订单，补充到库存等等。</p>
<p>我们实现了高并发抢票的核心逻辑，可以说系统设计的非常的巧妙，巧妙的避开了对DB数据库IO的操作，对Redis网络IO的高并发请求，几乎所有的计算都是在内存中完成的，而且有效的保证了不超卖、不少卖，还能够容忍部分机器的宕机。我觉得其中有两点特别值得学习总结：</p>
<ul>
<li><strong>负载均衡，分而治之。</strong> 通过负载均衡，将不同的流量划分到不同的机器上，每台机器处理好自己的请求，将自己的性能发挥到极致，这样系统的整体也就能承受极高的并发了，就像工作的的一个团队，每个人都将自己的价值发挥到了极致，团队成长自然是很大的。</li>
<li><strong>合理的使用并发和异步。</strong> 自epoll网络架构模型解决了c10k问题以来，异步越来被服务端开发人员所接受，能够用异步来做的工作，就用异步来做，在功能拆解上能达到意想不到的效果，这点在nginx、node.js、redis上都能体现，他们处理网络请求使用的epoll模型，用实践告诉了我们单线程依然可以发挥强大的威力。服务器已经进入了多核时代，go语言这种天生为并发而生的语言，完美的发挥了服务器多核优势，很多可以并发处理的任务都可以使用并发来解决，比如go处理http请求时每个请求都会在一个goroutine中执行，总之:怎样合理的压榨CPU,让其发挥出应有的价值，是我们一直需要探索学习的方向。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-04-%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-04-%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">springboot-04-父子容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-16 09:30:13 / Modified: 09:31:22" itemprop="dateCreated datePublished" datetime="2021-04-16T09:30:13+08:00">2021-04-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Spring</code>就是父容器，<code>SpringMvc</code>就是子容器，子容器可以访问父容器的内容，父容器不能访问子容器的东西。有点类似java里面的继承的味道，子类可以继承父类共有方法和变量，可以访问它们，父类不可以访问子类的方法和变量。在这里就会衍生出几个比较经典的问题：</p>
<ul>
<li>为什么需要父子容器？</li>
<li>是否可以把所有类都通过<code>Spring</code>容器来管理？（<code>Spring</code>的<code>applicationContext.xml</code>中配置全局扫描)</li>
<li>是否可以把我们所需的类都放入<code>Spring-mvc</code>子容器里面来管理（<code>springmvc</code>的<code>spring-servlet.xml</code>中配置全局扫描）?</li>
<li>同时通过两个容器同时来管理所有的类？如果能够把上面这四个问题可以说个所以然来，个人觉得<code>Spring</code>的父子容器应该问题不大了。我们可以看下官网提供的父子容器的图片<img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZicd8HYAuu5icgYtIBibc3T8GDib34mBYBNS1e38p5kYfZvDicDtKcaPlKxFw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></li>
<li>上图中显示了2个<code>WebApplicationContext</code>实例，为了进行区分，分别称之为：<code>Servlet WebApplicationContext</code>(子容器)、<code>Root WebApplicationContext</code>(父容器)。</li>
<li><strong>Servlet WebApplicationContext</strong>：这是对J2EE三层架构中的<code>web</code>层进行配置，如控制器(<code>controller</code>)、视图解析器(<code>view resolvers</code>)等相关的bean。通过<code>spring mvc</code>中提供的DispatchServlet来加载配置，通常情况下，配置文件的名称为spring-servlet.xml。</li>
<li><strong>Root WebApplicationContext</strong>：这是对J2EE三层架构中的<code>service</code>层、<code>dao</code>层进行配置，如业务<code>bean</code>，数据源(<code>DataSource</code>)等。通常情况下，配置文件的名称为<code>applicationContext.xml</code>。在<code>web</code>应用中，其一般通过<code>ContextLoaderListener</code>来加载。</li>
</ul>
<h1 id="Spring的启动"><a href="#Spring的启动" class="headerlink" title="Spring的启动"></a>Spring的启动</h1><p>要想很好的理解它们之间的关系，我们就有必要先弄清楚Spring的启动流程。要弄清楚这个启动流程我们就需要搭建一个<code>SpringMvc</code>项目，说句实话，用惯了<code>SpringBooot</code>开箱即用,突然在回过头来搭建一个<code>SpringMvc</code>项目还真有点不习惯，一大堆的配置文件。（虽然也可以用注解来实现）具体怎么搭建<code>SpringMvc</code>项目这个就不介绍了，搭建好项目我们运行起来可以看到控制台会输出如下日志：<img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZicuuCX4lfhl92VWJQ5giccp4pIM7CeTUODe214USqP5gjibBNzNncwrWuA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">日志里面分别打印出了父容器和子容器分别的一个耗时。</p>
<h1 id="如何验证是有两个容器？"><a href="#如何验证是有两个容器？" class="headerlink" title="如何验证是有两个容器？"></a>如何验证是有两个容器？</h1><p>我们只需要<code>Controller</code>与我们的<code>Service</code>中实现<code>ApplicationContextAware</code>接口，就可以得知对应的管理容器：在<code>Service</code>所属的父容器里面我们可以看到父容器对应的对象是<code>XmlWebApplicationContext@3972</code><img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZica1FZbchfGhcNibEgZuL5QC0LZqicjwRZMiakEdicec0qy6LVKNWXVMMn9Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">在<code>Controller</code>中对应的容器对象是<code>XmlWebApplicationContext@4114</code><img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZiccPsA5gDib890BOuQmFb6OZ0Vxe4Vqhm4pjWYRsRKEDb4AcJN43Agibsg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">由此可见它们是两个不同的容器。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>我们知道<code>SpringServletContainerInitializer</code>从 <code>servlet 3.0</code>开始，<code>Tomcat</code> 启动时会自动加载实现了 <code>ServletContainerInitializer</code><br>接口的类（需要在 <code>META-INF/services</code> 目录下新建配置文件）也称为 <code>SPI（Service Provider Interface）</code> 机制，<code>SPI</code>的应用还是挺广的比如我们的<code>JDBC</code>、还有<code>Dubbo</code>框架里面都有用到，如果还有不是很了解<code>SPI</code>机制的 可以去学习下。所以我们的入口就是<code>SpringServletContainerInitializer</code>的<code>onStartup</code>方法，这也应该是web容器启动调用<code>Spring</code>相关的第一个方法。</p>
<h3 id="初始化SpringIoc"><a href="#初始化SpringIoc" class="headerlink" title="初始化SpringIoc"></a>初始化SpringIoc</h3><p>如果实在找不到入口的话，我们可以 根据控制台打印的日志，然后拿着日志进行反向查找这应该总能找到开始加载父容器的地方。启动的时候控制台应该会打印出“<code>Root WebApplicationContext: initialization started</code>” 我们拿着这个日志就能定位到代码了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;</span><br><span class="line">  if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) !&#x3D; null) &#123;</span><br><span class="line">   throw new IllegalStateException(</span><br><span class="line">     &quot;Cannot initialize context because there is already a root application context present - &quot; +</span><br><span class="line">     &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);</span><br><span class="line">  Log logger &#x3D; LogFactory.getLog(ContextLoader.class);</span><br><span class="line">  if (logger.isInfoEnabled()) &#123;</span><br><span class="line">   logger.info(&quot;Root WebApplicationContext: initialization started&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">   &#x2F;&#x2F; Store context in local instance variable, to guarantee that</span><br><span class="line">   &#x2F;&#x2F; it is available on ServletContext shutdown.</span><br><span class="line">   if (this.context &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过反射去创建context </span><br><span class="line">    this.context &#x3D; createWebApplicationContext(servletContext);</span><br><span class="line">   &#125;</span><br><span class="line">   if (this.context instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">    ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext) this.context;</span><br><span class="line">    if (!cwac.isActive()) &#123;</span><br><span class="line">     &#x2F;&#x2F; The context has not yet been refreshed -&gt; provide services such as</span><br><span class="line">     &#x2F;&#x2F; setting the parent context, setting the application context id, etc</span><br><span class="line">     if (cwac.getParent() &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; The context instance was injected without an explicit parent -&gt;</span><br><span class="line">      &#x2F;&#x2F; determine parent for root web application context, if any.</span><br><span class="line">      ApplicationContext parent &#x3D; loadParentContext(servletContext);</span><br><span class="line">      cwac.setParent(parent);</span><br><span class="line">     &#125;</span><br><span class="line">      &#x2F;&#x2F; IOC容器初始化</span><br><span class="line">     configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);</span><br><span class="line"></span><br><span class="line">   ClassLoader ccl &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">   if (ccl &#x3D;&#x3D; ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">    currentContext &#x3D; this.context;</span><br><span class="line">   &#125;</span><br><span class="line">   else if (ccl !&#x3D; null) &#123;</span><br><span class="line">    currentContextPerThread.put(ccl, this.context);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (logger.isInfoEnabled()) &#123;</span><br><span class="line">    long elapsedTime &#x3D; System.currentTimeMillis() - startTime;</span><br><span class="line">    logger.info(&quot;Root WebApplicationContext initialized in &quot; + elapsedTime + &quot; ms&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return this.context;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (RuntimeException | Error ex) &#123;</span><br><span class="line">   logger.error(&quot;Context initialization failed&quot;, ex);</span><br><span class="line">   servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">   throw ex;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是创建父容器的地方。</p>
<h3 id="初始化-Spring-MVC"><a href="#初始化-Spring-MVC" class="headerlink" title="初始化 Spring MVC"></a>初始化 Spring MVC</h3><p>接着我们再来看看创建子容器的地方：在<code>FrameworkServlet</code>类<img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZicBwHej2kQUFJGicQegEAuTo4q8V9j0GADxmpGDeajhTribicSWIgZEVu4Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">上述代码是不是会有个疑问我们怎么就会执行<code>FrameworkServlet</code>的<code>initServletBean</code>方法。这是由于我们在<code>web.xml</code> 里面配置了<code>DispatcherServlet</code>，然后web容器就会去调用<code>DispatcherServlet</code>的<code>init</code>方法，并且这个方法只会被执行一次。通过init方法就会去执行到<code>initWebApplicationContext</code>这个方法了，这就是web子容器的一个启动执行顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &#x2F;&#x2F; 如果不配置这个load-on-startup 1 不会再项目启动的时候执行inti方法。而是首次访问再启动</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">  &lt;&#x2F;servlet&gt;</span><br></pre></td></tr></table></figure>

<p>大概流程如下：<img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZic5eW09yvicicjcb8xtjbicVbZJ8zl2ZxdHwF3xGp5bTLMITqM9cMGeofCw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">从上述代码我们可以发现子容器是自己重新通过反射<code>new</code>了一个新的容器作为子容器， 并且设置自己的父容器为<code>Spring</code> 初始化创建的<code>WebApplicationContext</code>。然后就是去加载我们在<code>web.xml</code> 里面配置的<code>Springmvc</code>的配置文件，然后通过创建的子容器去执行<code>refresh</code>方法，这个方法我相信很多人应该都比较清楚了。</p>
<h1 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h1><p>我们知道了<code>Sping</code>父容器以及<code>SpingMvc</code>子容器的一个启动过程，以及每个容器都分别干了什么事情现在再回过头来看看上述四个问题。</p>
<ul>
<li><strong>为什么需要父子容器？</strong>父子容器的主要作用应该是划分框架边界。有点单一职责的味道。在<code>J2EE</code>三层架构中，在<code>service</code>层我们一般使用<code>spring</code>框架来管理， 而在<code>web</code>层则有多种选择，如<code>spring mvc、struts</code>等。因此，通常对于<code>web</code>层我们会使用单独的配置文件。例如在上面的案例中，一开始我们使用<code>spring-servlet.xml</code>来配置web层，使用applicationContext.xml来配置<code>service</code>、<code>dao</code>层。如果现在我们想把<code>web</code>层从<code>spring mvc</code>替换成<code>struts</code>，那么只需要将<code>spring-servlet.xml</code>替换成<code>Struts</code>的配置文件<code>struts.xml</code>即可，而<code>applicationContext.xml</code>不需要改变。</li>
<li>**是否可以把所有类都通过Spring父容器来管理？（Spring的applicationContext.xml中配置全局扫描)**所有的类都通过父容器来管理的配置就是如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan  use-default-filters&#x3D;&quot;false&quot;  base-package&#x3D;&quot;cn.javajr&quot;&gt;</span><br><span class="line">        &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Service&quot; &#x2F;&gt;</span><br><span class="line">        &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Component&quot; &#x2F;&gt;</span><br><span class="line">        &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Repository&quot; &#x2F;&gt;</span><br><span class="line">        &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<p>然后在<code>SpringMvc</code>的配置里面不配置扫描包路径。很显然这种方式是行不通的，这样会导致我们请求接口的时候产生<code>404</code>。因为在解析@ReqestMapping注解的过程中<code>initHandlerMethods</code>()函数只是对<code>Spring MVC</code> 容器中的<code>bean</code>进行处理的，并没有去查找父容器的<code>bean</code>， 因此不会对父容器中含有<code>@RequestMapping</code>注解的函数进行处理，更不会生成相应的<code>handler</code>。所以当请求过来时找不到处理的<code>handler</code>，导致404。<img src="https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAptNmswNYxGwRhk0TU4spZicHpNuL6FGSbdMvS3NLfvDic3kECN4GvOl3Dlx9nEP78PQcAFVQG6w9cg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li><strong>是否可以把我们所需的类都放入Spring-mvc子容器里面来管理（springmvc的spring-servlet.xml中配置全局扫描）?**这个是把包的扫描配置<code>spring-servlet.xml</code>中这个是可行的。为什么可行因为无非就是把所有的东西全部交给子容器来管理了，子容器执行了<code>refresh</code>方法，把在它的配置文件里面的东西全部加载管理起来来了。虽然可以这么做不过一般应该是不推荐这么去做的，一般人也不会这么干的。</strong>如果你的项目里有用到事物、或者aop记得也需要把这部分配置需要放到Spring-mvc子容器的配置文件来，不然一部分内容在子容器和一部分内容在父容器,可能就会导致你的事物或者AOP不生效<strong>。（这里不就有个经典的八股文吗？</strong>你有遇到事物不起作用的时候**，其实这也是一种情况）</li>
<li><strong>同时通过两个容器同时来管理所有的类？</strong>这个问题应该是比较好回答了，肯定不会通过这种方式来的，先不说会不会引发其他问题，首先两个容器里面都放一份一样的对象，造成了内存浪费。再者的话子容器会覆盖父容器加载，本来可能父容器配置了事物生成的是代理对象，但是被子容器一覆盖，又成了原生对象。这就导致了你的事物不起作用了。在补充一个问题：<strong>SpringBoot 里面是否还有父子容器</strong>？我们下篇再见！</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>其实父子容器对于程序员来说是无感的，是一个并没有什么用的知识点，都是<code>Spring</code>帮我们处理了，但是我们还是需要知道有这么个东西，不然我们有可能遇到问题的时候可能不知道如何下手。比如为啥我这个事物不起作用了，我这个<code>aop</code>怎么也不行了，网上都是这么配置的。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">JDK-正则表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-15 13:30:09" itemprop="dateCreated datePublished" datetime="2021-04-15T13:30:09+08:00">2021-04-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-27 17:16:11" itemprop="dateModified" datetime="2021-04-27T17:16:11+08:00">2021-04-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h2><ol>
<li>数字：<code>^[0-9]*$</code></li>
<li>n位的数字：<code>^\d&#123;n&#125;$</code></li>
<li>至少n位的数字：<code>^\d&#123;n,&#125;$</code></li>
<li>m-n位的数字：<code>^\d&#123;m,n&#125;$</code></li>
<li>零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code></li>
<li>非零开头的最多带两位小数的数字：<code>^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</code></li>
<li>带1-2位小数的正数或负数：<code>^(\-)?\d+(\.\d&#123;1,2&#125;)?$</code></li>
<li>正数、负数、和小数：<code>^(\-|\+)?\d+(\.\d+)?$</code></li>
<li>有两位小数的正实数：<code>^[0-9]+(.[0-9]&#123;2&#125;)?$</code></li>
<li>有1~3位小数的正实数：<code>^[0-9]+(.[0-9]&#123;1,3&#125;)?$</code></li>
<li>非零的正整数：<code>^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$</code></li>
<li>非零的负整数：<code>^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$</code></li>
<li>非负整数：<code>^\d+$ 或 ^[1-9]\d*|0$</code></li>
<li>非正整数：<code>^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</code></li>
<li>非负浮点数：<code>^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</code></li>
<li>非正浮点数：<code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</code></li>
<li>正浮点数：<code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</code></li>
<li>负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</code></li>
<li>浮点数：<code>^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></li>
</ol>
<h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><ol>
<li>汉字：<code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code></li>
<li>英文和数字：<code>^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</code></li>
<li>长度为3-20的所有字符：<code>^.&#123;3,20&#125;$</code></li>
<li>由26个英文字母组成的字符串：<code>^[A-Za-z]+$</code></li>
<li>由26个大写英文字母组成的字符串：<code>^[A-Z]+$</code></li>
<li>由26个小写英文字母组成的字符串：<code>^[a-z]+$</code></li>
<li>由数字和26个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code></li>
<li>由数字、26个英文字母或者下划线组成的字符串：<code>^\w+$ 或 ^\w&#123;3,20&#125;</code></li>
<li>中文、英文、数字包括下划线：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></li>
<li>中文、英文、数字但不包括下划线等符号：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</code></li>
<li>可以输入含有<code>^%&amp;&#39;,;=?$\&quot;</code>等字符：<code>[^%&amp;&#39;,;=?$\x22]+</code></li>
<li>禁止输入含有<del>的字符`[^</del>\x22]+`</li>
</ol>
<p>其它：</p>
<p><code>.*</code>匹配除 <code>\n</code> 以外的任何字符。</p>
<p><code>/[\u4E00-\u9FA5]/</code> 汉字</p>
<p><code>/[\uFF00-\uFFFF]/</code> 全角符号</p>
<p><code>/[\u0000-\u00FF]/</code> 半角符号</p>
<h2 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h2><ol>
<li>Email地址：<code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></li>
<li>域名：<code>[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</code></li>
<li>InternetURL：<code>[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></li>
<li>手机号码：<code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</code></li>
<li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<code>^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</code></li>
<li>国内电话号码(0511-4405222、021-87888822)：<code>\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</code></li>
<li>身份证号(15位、18位数字)：<code>^\d&#123;15&#125;|\d&#123;18&#125;$</code></li>
<li>短身份证号码(数字、字母x结尾)：<code>^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$</code></li>
<li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<code>^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</code></li>
<li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<code>^[a-zA-Z]\w&#123;5,17&#125;$</code></li>
<li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</code></li>
<li>日期格式：<code>^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</code></li>
<li>一年的12个月(01～09和1～12)：<code>^(0?[1-9]|1[0-2])$</code></li>
<li>一个月的31天(01～09和1～31)：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></li>
</ol>
<h3 id="钱的输入格式："><a href="#钱的输入格式：" class="headerlink" title="钱的输入格式："></a>钱的输入格式：</h3><p>1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：<code>^[1-9][0-9]*$</code></p>
<p>2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：<code>^(0|[1-9][0-9]*)$</code></p>
<p>3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：<code>^(0|-?[1-9][0-9]*)$</code></p>
<p>4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：<code>^[0-9]+(.[0-9]+)?$</code></p>
<p>5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：<code>^[0-9]+(.[0-9]&#123;2&#125;)?$</code></p>
<p>6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：<code>^[0-9]+(.[0-9]&#123;1,2&#125;)?$</code></p>
<p>7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：<code>^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$</code></p>
<p>8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：<code>^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$</code></p>
<blockquote>
<p>备注：这就是最终结果了,别忘了<code>+</code>可以用<code>*</code>替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</p>
</blockquote>
<ol>
<li>xml文件：<code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></li>
<li>中文字符的正则表达式：<code>[\u4e00-\u9fa5]</code></li>
<li>双字节字符：<code>[^\x00-\xff]</code> (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</li>
<li>空白行的正则表达式：<code>\n\s*\r</code> (可以用来删除空白行)</li>
<li>HTML标记的正则表达式：<code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</code> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</li>
<li>首尾空白字符的正则表达式：<code>^\s*|\s*$或(^\s*)|(\s*$)</code> (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li>
<li>腾讯QQ号：<code>[1-9][0-9]&#123;4,&#125;</code> (腾讯QQ号从10000开始)</li>
<li>中国邮政编码：<code>[1-9]\d&#123;5&#125;(?!\d)</code> (中国邮政编码为6位数字)</li>
<li>IP地址：<code>\d+\.\d+\.\d+\.\d+</code> (提取IP地址时有用)</li>
<li>IP地址：<code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></li>
<li>IP-v4地址：<code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</code> (提取IP地址时有用)</li>
<li>校验IP-v6地址:<code>(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))</code></li>
<li>子网掩码：<code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></li>
<li>校验日期:<code>^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</code>(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。)</li>
<li>抽取注释：<code>&lt;!--(.*?)--&gt;</code></li>
<li>查找CSS属性:<code>^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;</code></li>
<li>提取页面超链接:<code>(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot; rel=&quot;external nofollow&quot; ]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</code></li>
<li>提取网页图片:<code>\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&#39;]&#123;0,1&#125;([^\\&quot;\\&#39;\\ &gt;]*)</code></li>
<li>提取网页颜色代码:<code>^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$</code></li>
<li>文件扩展名效验:<code>^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$</code></li>
<li>判断IE版本：<code>^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$</code></li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="附表"><a href="#附表" class="headerlink" title="附表:"></a>附表:</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufndG3m3Odth7t4Uku459PC67neGZ425peCPYXC9OKrLr9kRBdCjLbElZbQNtOibye9qsP08tvBR9A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufndG3m3Odth7t4Uku459PC10t4Hujwia7AIiage1jJ4icDXbg07wSibAJgvqs00sg1yQocFpVX3t667A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufndG3m3Odth7t4Uku459PC49ulu1a6RmqgKRcLRpEtrpeTBllJvt4Pd0icP2njxxUSEicreY125KGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufndG3m3Odth7t4Uku459PCyjQhlcsO3SVOmBmxNN7lIfNfnHys7hxlicedf8aLAOUBlfcSGP3uibiaA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufndG3m3Odth7t4Uku459PC7KFmevIEwPz25nvlptWCqWmjdnsDQTMGVc6VIib3A3icw9kN5BSupmOQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufndG3m3Odth7t4Uku459PC2sx0J0UZEfrAk7bA6mOFIDViaddEffopAuw6sXXvbqnHYibkbBdf8ic4w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufndG3m3Odth7t4Uku459PCURqGIY61icvGlhmib8dvG3gwT7Rdiay5VIf6mRICQFfGpff0ia4DILJWMg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufndG3m3Odth7t4Uku459PCPicytQUVee0j8NS6eYWJicaT8bzAAAKPNfRHhRDArlDaEumOqeX6vnEA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufndG3m3Odth7t4Uku459PCYJf59Yic4ACLXgGnWLeg5BP46AjaRiat9ZQHabaXovdMrsVAEv87Y3Sg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufndG3m3Odth7t4Uku459PCaIVfq9ntr8kxNRxVh9Orv5mSHBK5BlbiaGKjZqtNkicQrRXiclPENlvEw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenMatchesTenDigitsNumberWhitespacesDotHyphen_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pattern pattern = Pattern.compile(<span class="string">&quot;^(\\d&#123;3&#125;[- .]?)&#123;2&#125;\\d&#123;4&#125;$&quot;</span>);</span><br><span class="line">    Matcher matcher = pattern.matcher(<span class="string">&quot;202 555 0125&quot;</span>);</span><br><span class="line">    assertTrue(matcher.matches());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/15/database/redis/redis%E6%BA%90%E7%A0%81-LRU%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/15/database/redis/redis%E6%BA%90%E7%A0%81-LRU%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">redis源码-LRU实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-15 13:24:31 / Modified: 13:26:18" itemprop="dateCreated datePublished" datetime="2021-04-15T13:24:31+08:00">2021-04-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LRU是什么"><a href="#LRU是什么" class="headerlink" title="LRU是什么"></a>LRU是什么</h1><p>LRU(least recently used)是一种缓存置换算法。即在缓存有限的情况下，如果有新的数据需要加载进缓存，则需要将最不可能被继续访问的缓存剔除掉。因为缓存是否可能被访问到没法做预测，所以基于如下假设实现该算法:</p>
<p><strong>如果一个key经常被访问，那么该key的idle time应该是最小的。</strong></p>
<p>(但这个假设也是基于概率，并不是充要条件,很明显,idle time最小的,甚至都不一定会被再次访问到)</p>
<p>这也就是LRU的实现思路。首先实现一个双向链表,每次有一个key被访问之后，就把被访问的key放到链表的头部。当缓存不够时,直接从尾部逐个摘除。</p>
<p>在这种假设下的实现方法很明显会有一个问题，例如mysql中执行如下一条语句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_a;</span><br></pre></td></tr></table></figure>

<p>如果table_a中有大量数据并且读取之后不会继续使用,则LRU头部会被大量的table_a中的数据占据。这样会造成热点数据被逐出缓存从而导致大量的磁盘io</p>
<p>mysql innodb的buffer pool使用了一种改进的LRU算法，大意是将LRU链表分成两部分，一部分为newlist,一部分为oldlist,newlist是头部热点数据，oldlist是非热点数据,oldlist默认占整个list长度的3/8.当初次加载一个page的时候，会首先放入oldlist的头部，再次访问时才会移动到newlist.具体参考如下文章:</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html">https://dev.mysql.com/doc/ref…</a></p>
<p>而Redis整体上是一个大的dict，如果实现一个双向链表需要在每个key上首先增加两个指针，需要16个字节，并且额外需要一个list结构体去存储该双向链表的头尾节点信息。Redis作者认为这样实现不仅内存占用太大，而且可能导致性能降低。他认为既然LRU本来就是基于假设做出的算法，为什么不能模拟实现一个LRU呢。</p>
<h1 id="Redis中的实现"><a href="#Redis中的实现" class="headerlink" title="Redis中的实现"></a><a target="_blank" rel="noopener" href="https://redis.io/topics/lru-cache">Redis中的实现</a></h1><p>首先Redis并没有使用双向链表实现一个LRU算法。具体实现方法接下来逐步介绍</p>
<p>首先看一下robj结构体(Redis整体上是一个大的dict,key是一个string,而value都会保存为一个robj)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    ...</span><br><span class="line">    unsigned lru:LRU_BITS; &#x2F;&#x2F;LRU_BITS为24bit</span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>我们看到每个robj中都有一个24bit长度的lru字段，lru字段里边保存的是一个时间戳。看下边的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">robj *lookupKey(redisDb *db, robj *key, int flags) &#123;</span><br><span class="line">    ...</span><br><span class="line">            if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123; &#x2F;&#x2F;如果配置的是lfu方式，则更新lfu</span><br><span class="line">                updateLFU(val);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                val-&gt;lru &#x3D; LRU_CLOCK();&#x2F;&#x2F;否则按lru方式更新</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Redis的dict中每次按key获取一个值的时候，都会调用lookupKey函数,如果配置使用了LRU模式,该函数会更新value中的lru字段为当前秒级别的时间戳(lfu方式后文再描述)。</p>
<p>那么，虽然记录了每个value的时间戳，但是淘汰时总不能挨个遍历dict中的所有槽，逐个比较lru大小吧。</p>
<p>Redis初始的实现算法很简单，随机从dict中取出五个key,淘汰一个lru字段值最小的。(随机选取的key是个可配置的参数maxmemory-samples,默认值为5).</p>
<p>在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按lru大小顺序排列的。接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。</p>
<p>淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰。</p>
<p>我们知道Redis执行命令时首先会调用processCommand函数，在processCommand中会进行key的淘汰，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int processCommmand()&#123;</span><br><span class="line">    ...</span><br><span class="line">    if (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        int out_of_memory &#x3D; freeMemoryIfNeeded() &#x3D;&#x3D; C_ERR;&#x2F;&#x2F;如果开启了maxmemory的限制,则会调用freeMemoryIfNeeded()函数，该函数中进行缓存的淘汰</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，lru本身是基于概率的猜测，这个算法也是基于概率的猜测，也就是作者说的模拟lru.那么效果如何呢？作者做了个实验，如下图所示</p>
<p><img src="https://segmentfault.com/img/bVblPdJ?w=854&h=449" alt="clipboard.png"></p>
<p>首先加入n个key并顺序访问这n个key,之后加入n/2个key（假设redis中只能保存n个key,于是会有n/2个key被逐出）.上图中浅灰色为被逐出的key,淡蓝色是新增加的key,灰色的为最近被访问的key(即不会被lru逐出的key)</p>
<p>左上图为理想中的LRU算法,新增加的key和最近被访问的key都不应该被逐出。</p>
<p>可以看到,Redis2.8当每次随机采样5个key时，新增加的key和最近访问的key都有一定概率被逐出</p>
<p>Redis3.0增加了pool后效果好一些(右下角的图)。当Redis3.0增加了pool并且将采样key增加到10个后，基本等同于理想中的LRU(虽然还是有一点差距)</p>
<p>如果继续增加采样的key或者pool的大小，作者发现很能进一步优化LRU算法,于是作者开始转换思路。</p>
<p>上文介绍了实现LRU的一种思路,<strong>即如果一个key经常被访问，那么该key的idle time应该是最小的。</strong></p>
<p>那么能不能换一种思路呢。<strong>如果能够记录一个key被访问的次数,那么经常被访问的key最有可能再次被访问到。</strong>这也就是lfu(least frequently used),访问次数最少的最应该被逐出。</p>
<p>lfu的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void updateLFU(robj *val) &#123;</span><br><span class="line">    unsigned long counter &#x3D; LFUDecrAndReturn(val);&#x2F;&#x2F;首先计算是否需要将counter衰减</span><br><span class="line">    counter &#x3D; LFULogIncr(counter);&#x2F;&#x2F;根据上述返回的counter计算新的counter</span><br><span class="line">    val-&gt;lru &#x3D; (LFUGetTimeInMinutes()&lt;&lt;8) | counter; &#x2F;&#x2F;robj中的lru字段只有24bits,lfu复用该字段。高16位存储一个分钟数级别的时间戳，低8位存储访问计数</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">unsigned long LFUDecrAndReturn(robj *o) &#123;</span><br><span class="line">    unsigned long ldt &#x3D; o-&gt;lru &gt;&gt; 8;&#x2F;&#x2F;原来保存的时间戳</span><br><span class="line">    unsigned long counter &#x3D; o-&gt;lru &amp; 255; &#x2F;&#x2F;原来保存的counter</span><br><span class="line">    unsigned long num_periods &#x3D; server.lfu_decay_time ? LFUTimeElapsed(ldt) &#x2F; server.lfu_decay_time : 0;</span><br><span class="line">    &#x2F;&#x2F;server.lfu_decay_time默认为1,每经过一分钟counter衰减1</span><br><span class="line">    if (num_periods)</span><br><span class="line">        counter &#x3D; (num_periods &gt; counter) ? 0 : counter - num_periods;&#x2F;&#x2F;如果需要衰减,则计算衰减后的值</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">uint8_t LFULogIncr(uint8_t counter) &#123;</span><br><span class="line">    if (counter &#x3D;&#x3D; 255) return 255;&#x2F;&#x2F;counter最大只能存储到255,到达后不再增加</span><br><span class="line">    double r &#x3D; (double)rand()&#x2F;RAND_MAX;&#x2F;&#x2F;算一个随机的小数值</span><br><span class="line">    double baseval &#x3D; counter - LFU_INIT_VAL;&#x2F;&#x2F;新加入的key初始counter设置为LFU_INIT_VAL,为5.不设置为0的原因是防止直接被逐出</span><br><span class="line">    if (baseval &lt; 0) baseval &#x3D; 0;</span><br><span class="line">    double p &#x3D; 1.0&#x2F;(baseval*server.lfu_log_factor+1);&#x2F;&#x2F;server.lfu_log_facotr默认为10</span><br><span class="line">    if (r &lt; p) counter++;&#x2F;&#x2F;可以看到,counter越大,则p越小，随机值r小于p的概率就越小。换言之,counter增加起来会越来越缓慢</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">unsigned long LFUGetTimeInMinutes(void) &#123;</span><br><span class="line">    return (server.unixtime&#x2F;60) &amp; 65535;&#x2F;&#x2F;获取分钟级别的时间戳</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LRU本质上是一个概率计数器，称为morris counter.随着访问次数的增加,counter的增加会越来越缓慢。如下是访问次数与counter值之间的关系</p>
<p><img src="https://segmentfault.com/img/bVblPdW?w=2538&h=914" alt="clipboard.png"></p>
<p>factor即server.lfu_log_facotr配置值，默认为10.可以看到,一个key访问一千万次以后counter值才会到达255.factor值越小, counter越灵敏</p>
<p>lfu随着分钟数对counter做衰减是基于一个原理:过去被大量访问的key不一定现在仍然会被访问。相当于除了计数，给时间也增加了一定的权重。</p>
<p>淘汰时就很简单了，仍然是一个pool,随机选取10个key,counter最小的被淘汰</p>
<h1 id="算法验证"><a href="#算法验证" class="headerlink" title="算法验证"></a>算法验证</h1><p>redis-cli提供了一个参数,可以验证LRU算法的效率。主要是通过验证hits/miss的比率，来判断淘汰算法是否有效。命中比率高说明确实淘汰了不会被经常访问的key.具体做法如下:</p>
<p>配置redis LRU算法为 allkeys-lru</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test ~&#x2F;redis-5.0.0$.&#x2F;src&#x2F;redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; config set maxmemory 50m &#x2F;&#x2F;设置redis最大使用50M内存</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; config get  maxmemory-policy</span><br><span class="line">1) &quot;maxmemory-policy&quot;</span><br><span class="line">2) &quot;noeviction&quot;</span><br><span class="line">127.0.0.1:6380&gt; config set maxmemory-policy allkeys-lru&#x2F;&#x2F;设置lru算法为allkeys-lru</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>执行redis-cli –lru-test验证命中率</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;src&#x2F;redis-cli -p 6380 --lru-test 1000000&#x2F;&#x2F;模拟100万个key</span><br></pre></td></tr></table></figure>

<p>通过info查看使用的内存和被逐出的keys</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"># Memory</span><br><span class="line">used_memory:50001216</span><br><span class="line">...</span><br><span class="line">evicted_keys:115092</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>查看lru-test的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">131250 Gets&#x2F;sec | Hits: 124113 (94.56%) | Misses: 7137 (5.44%)</span><br><span class="line">132250 Gets&#x2F;sec | Hits: 125091 (94.59%) | Misses: 7159 (5.41%)</span><br><span class="line">131250 Gets&#x2F;sec | Hits: 124027 (94.50%) | Misses: 7223 (5.50%)</span><br><span class="line">133000 Gets&#x2F;sec | Hits: 125855 (94.63%) | Misses: 7145 (5.37%)</span><br><span class="line">136250 Gets&#x2F;sec | Hits: 128882 (94.59%) | Misses: 7368 (5.41%)</span><br><span class="line">139750 Gets&#x2F;sec | Hits: 132231 (94.62%) | Misses: 7519 (5.38%)</span><br><span class="line">136000 Gets&#x2F;sec | Hits: 128702 (94.63%) | Misses: 7298 (5.37%)</span><br><span class="line">134500 Gets&#x2F;sec | Hits: 127374 (94.70%) | Misses: 7126 (5.30%)</span><br><span class="line">134750 Gets&#x2F;sec | Hits: 127427 (94.57%) | Misses: 7323 (5.43%)</span><br><span class="line">134250 Gets&#x2F;sec | Hits: 127004 (94.60%) | Misses: 7246 (5.40%)</span><br><span class="line">138500 Gets&#x2F;sec | Hits: 131019 (94.60%) | Misses: 7481 (5.40%)</span><br><span class="line">130000 Gets&#x2F;sec | Hits: 122918 (94.55%) | Misses: 7082 (5.45%)</span><br><span class="line">126500 Gets&#x2F;sec | Hits: 119646 (94.58%) | Misses: 6854 (5.42%)</span><br><span class="line">132750 Gets&#x2F;sec | Hits: 125672 (94.67%) | Misses: 7078 (5.33%)</span><br><span class="line">136000 Gets&#x2F;sec | Hits: 128563 (94.53%) | Misses: 7437 (5.47%)</span><br><span class="line">132500 Gets&#x2F;sec | Hits: 125450 (94.68%) | Misses: 7050 (5.32%)</span><br><span class="line">132250 Gets&#x2F;sec | Hits: 125234 (94.69%) | Misses: 7016 (5.31%)</span><br><span class="line">133000 Gets&#x2F;sec | Hits: 125761 (94.56%) | Misses: 7239 (5.44%)</span><br><span class="line">134750 Gets&#x2F;sec | Hits: 127431 (94.57%) | Misses: 7319 (5.43%)</span><br><span class="line">130750 Gets&#x2F;sec | Hits: 123707 (94.61%) | Misses: 7043 (5.39%)</span><br><span class="line">133500 Gets&#x2F;sec | Hits: 126195 (94.53%) | Misses: 7305 (5.47%)</span><br></pre></td></tr></table></figure>

<p>大概有5%-5.5%之间的miss概率。我们将LRU策略切换为allkeys-lfu，再次实验</p>
<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">131250 Gets&#x2F;sec | Hits: 124480 (94.84%) | Misses: 6770 (5.16%)</span><br><span class="line">134750 Gets&#x2F;sec | Hits: 127926 (94.94%) | Misses: 6824 (5.06%)</span><br><span class="line">130000 Gets&#x2F;sec | Hits: 123458 (94.97%) | Misses: 6542 (5.03%)</span><br><span class="line">127750 Gets&#x2F;sec | Hits: 121231 (94.90%) | Misses: 6519 (5.10%)</span><br><span class="line">130500 Gets&#x2F;sec | Hits: 123958 (94.99%) | Misses: 6542 (5.01%)</span><br><span class="line">130500 Gets&#x2F;sec | Hits: 123935 (94.97%) | Misses: 6565 (5.03%)</span><br><span class="line">131250 Gets&#x2F;sec | Hits: 124622 (94.95%) | Misses: 6628 (5.05%)</span><br><span class="line">131250 Gets&#x2F;sec | Hits: 124618 (94.95%) | Misses: 6632 (5.05%)</span><br><span class="line">128000 Gets&#x2F;sec | Hits: 121315 (94.78%) | Misses: 6685 (5.22%)</span><br><span class="line">129000 Gets&#x2F;sec | Hits: 122585 (95.03%) | Misses: 6415 (4.97%)</span><br><span class="line">132000 Gets&#x2F;sec | Hits: 125277 (94.91%) | Misses: 6723 (5.09%)</span><br><span class="line">134000 Gets&#x2F;sec | Hits: 127329 (95.02%) | Misses: 6671 (4.98%)</span><br><span class="line">131750 Gets&#x2F;sec | Hits: 125258 (95.07%) | Misses: 6492 (4.93%)</span><br><span class="line">136000 Gets&#x2F;sec | Hits: 129207 (95.01%) | Misses: 6793 (4.99%)</span><br><span class="line">135500 Gets&#x2F;sec | Hits: 128659 (94.95%) | Misses: 6841 (5.05%)</span><br><span class="line">133750 Gets&#x2F;sec | Hits: 126995 (94.95%) | Misses: 6755 (5.05%)</span><br><span class="line">131250 Gets&#x2F;sec | Hits: 124680 (94.99%) | Misses: 6570 (5.01%)</span><br><span class="line">129750 Gets&#x2F;sec | Hits: 123408 (95.11%) | Misses: 6342 (4.89%)</span><br><span class="line">130500 Gets&#x2F;sec | Hits: 124043 (95.05%) | Misses: 6457 (4.95%)</span><br></pre></td></tr></table></figure>

<p>%5左右的miss率，在这个测试下,LFU比LRU的预测准确率略微高一些。</p>
<p>在实际生产环境中,不同的redis访问模式需要配置不同的LRU策略， 然后可以通过lru test工具验证效果。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
