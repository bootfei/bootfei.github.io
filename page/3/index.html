<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>BootFei&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="BootFei&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BootFei&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-编程语言/Java/springMVC/springMVC-02-Controller" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springMVC/springMVC-02-Controller/" class="article-date">
  <time datetime="2021-07-21T00:34:42.000Z" itemprop="datePublished">2021-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springMVC/springMVC-02-Controller/">springMVC-01-执行流程分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>controller使用无注解的参数</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestparam">https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestparam</a></p>
<p>@RequestParam不是必须使用的，默认spring mvc使用的handler会对参数做映射</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springMVC/springMVC-02-Controller/" data-id="cm6lsyz5x008xk2dl3uuz5jbx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/开源项目/软件设计/加密设计/公钥私钥-加密解密" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E5%8A%A0%E5%AF%86%E8%AE%BE%E8%AE%A1/%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5-%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/" class="article-date">
  <time datetime="2021-07-08T13:00:10.000Z" itemprop="datePublished">2021-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E5%8A%A0%E5%AF%86%E8%AE%BE%E8%AE%A1/%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5-%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/">公钥私钥-加密解密</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E5%8A%A0%E5%AF%86%E8%AE%BE%E8%AE%A1/%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5-%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/" data-id="cm6lsyz5z009pk2dla3ll11gv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-集群管理/zk调优与分析-01-集群无法选举出leader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/05/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/zk%E8%B0%83%E4%BC%98%E4%B8%8E%E5%88%86%E6%9E%90-01-%E9%9B%86%E7%BE%A4%E6%97%A0%E6%B3%95%E9%80%89%E4%B8%BE%E5%87%BAleader/" class="article-date">
  <time datetime="2021-07-05T11:01:00.000Z" itemprop="datePublished">2021-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/05/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/zk%E8%B0%83%E4%BC%98%E4%B8%8E%E5%88%86%E6%9E%90-01-%E9%9B%86%E7%BE%A4%E6%97%A0%E6%B3%95%E9%80%89%E4%B8%BE%E5%87%BAleader/">zk调优与分析-01-集群无法选举出leader</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ZooKeeper作为dubbo的注册中心，可谓是重中之重，线上ZK的任何风吹草动都会牵动心弦。最近笔者就碰到线上ZK Leader宕机后，选主无法成功导致ZK集群拒绝服务的现象，于是把这个case写出来分享给大家(基于ZooKeeper 3.4.5)。</p>
<h2 id="Bug现场"><a href="#Bug现场" class="headerlink" title="Bug现场"></a>Bug现场</h2><p>一天早上，突然接到电话，说是ZooKeeper物理机宕机了，而剩余几台机器状态都是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh zkServer.sh status</span><br><span class="line">it is probably not running</span><br></pre></td></tr></table></figure>

<p>笔者看了下监控，物理机宕机的正好是ZK的leader。3节点的ZK，leader宕了后，其余两台一直未能成为leader，把宕机的那台紧急拉起来之后，依旧无法选主，<br>导致ZK集群整体拒绝服务！<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0m4ibVmN3CGPSxKJJdcVq2u6cHK6chnCicGLRXE5pLPt5czKt0mcPsx4w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h2 id="业务影响"><a href="#业务影响" class="headerlink" title="业务影响"></a>业务影响</h2><p>Dubbo如果连接不上ZK，其调用元信息会一直缓存着，所以并不会对请求调用造成实际影响。麻烦的是，如果在ZK拒绝服务期间，应用无法重启或者发布，一旦遇到紧急事件而重启(发布)不能，就会造成比较重大的影响。<br>好在我们为了高可用，做了对等机房建设，所以非常淡定的将流量切到B机房，<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er04xonZeWUwegNic2KQHH3jJJGgoz1ltQRxY86ajADNBCYdaAqUd5WU5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>双机房建设就是好啊,一键切换！<br>切换过后就可以有充裕的时间来恢复A机房的集群了。在紧张恢复的同时，笔者也开始了分析工作。</p>
<h2 id="日志表现"><a href="#日志表现" class="headerlink" title="日志表现"></a>日志表现</h2><p>首先，查看日志，期间有大量的client连接报错，自然是直接过滤掉，以免干扰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat zookeeper.out | grep -v &#39;client xxx&#39; | &gt; &#x2F;tmp&#x2F;1.txt</span><br></pre></td></tr></table></figure>

<p>首先看到的是下面这样的日志:</p>
<h3 id="ZK-A机器日志"><a href="#ZK-A机器日志" class="headerlink" title="ZK-A机器日志"></a>ZK-A机器日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Zk-A机器:</span><br><span class="line">2021-06-16 03:32:35 ... New election. My id&#x3D;3</span><br><span class="line">2021-06-16 03:32:46 ... QuoeumPeer] LEADING  &#x2F;&#x2F; 注意，这里选主成功</span><br><span class="line">2021-06-16 03:32:46 ... QuoeumPeer] LEADING - LEADER ELECTION TOOK - 7878&#39;</span><br><span class="line">2021-06-16 03:32:48 ... QuoeumPeer] Reading snapshot &#x2F;xxx&#x2F;snapshot.xxx</span><br><span class="line">2021-06-16 03:32:54 ... QuoeumPeer] Snahotting xxx to &#x2F;xxx&#x2F;snapshot.xxx</span><br><span class="line">2021-06-16 03:33:08 ... Follower sid ZK-B.IP</span><br><span class="line">2021-06-16 03:33:08 ... Unexpected exception causing shutdown while sock still open</span><br><span class="line">java.io.EOFException </span><br><span class="line">    at java.io.DataInputStream.readInt</span><br><span class="line">    ......</span><br><span class="line">    at quorum.LearnerHandler.run</span><br><span class="line">2021-06-16 03:33:08 ******* GOODBYE ZK-B.IP *******</span><br><span class="line">2021-06-16 03:33:27 Shutting down</span><br></pre></td></tr></table></figure>

<p>这段日志看上去像选主成功了，但是和其它机器的通信出问题了，导致Shutdown然后重新选举。</p>
<h2 id="ZK-B机器日志"><a href="#ZK-B机器日志" class="headerlink" title="ZK-B机器日志"></a>ZK-B机器日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2021-06-16 03:32:48 New election. My id&#x3D;2</span><br><span class="line">2021-06-16 03:32:48 QuoeumPeer] FOLLOWING</span><br><span class="line">2021-06-16 03:32:48 QuoeumPeer] FOLLOWING - LEADER ELECTION TOOK - 222</span><br><span class="line">2021-06-16 03:33:08.833 QuoeumPeer] Exception when following the leader</span><br><span class="line">java.net.SocketTimeoutException: Read time out</span><br><span class="line">    at java.net.SocketInputStream.socketRead0</span><br><span class="line">    ......</span><br><span class="line">    at org.apache.zookeeper.server.quorum.Follower.followLeader</span><br><span class="line">2021-06-16 03:33:08.380 Shutting down</span><br></pre></td></tr></table></figure>

<p>这段日志也表明选主成功了，而且自己是Following状态，只不过Leader迟迟不返回，导致超时进而Shutdown</p>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>笔者将上面的日志画成时序图，以便分析:<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0YyjZOzPPZ1H1iatv0dJIWewJmt33kt7bSrMMhiciasLBtdsniaq8HpACSg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>从ZK-B的日志可以看出，其在成为follower之后，一直等待leader，直到Read time out。<br>从ZK-A的日志可以看出,其在成为LEADING后，在33:08,803才收到Follower也就是ZK-B发出的包。而这时，ZK-B已经在33:08,301的时候Read timed out了。</p>
<h3 id="首先分析follower-ZK-B-的情况"><a href="#首先分析follower-ZK-B-的情况" class="headerlink" title="首先分析follower(ZK-B)的情况"></a>首先分析follower(ZK-B)的情况</h3><p>我们知道其在03:32:48成为follower,然后在03:33:08出错Read time out，其间正好是20s。于是笔者先从Zookeeper源码中找下其设置Read time out是多长时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Learner</span><br><span class="line">protected void connectToLeader(InetSocketAddress addr) &#123;</span><br><span class="line">    ......</span><br><span class="line">    sock &#x3D; new Socket()</span><br><span class="line">    &#x2F;&#x2F; self.tockTime 2000 self.initLimit 10</span><br><span class="line">    sock.setSoTimeout(self.tickTime * self.initLimit);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其Read time out是按照zoo.cfg中的配置项而设置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tickTime&#x3D;2000 self.tickTime</span><br><span class="line">initLimit&#x3D;10 self.initLimit</span><br><span class="line">syncLimit&#x3D;5</span><br></pre></td></tr></table></figure>

<p>很明显的，ZK-B在成为follower后，由于某种原因leader在20s后才响应。那么接下来对leader进行分析。</p>
<h3 id="对leader-ZK-A-进行分析"><a href="#对leader-ZK-A-进行分析" class="headerlink" title="对leader(ZK-A)进行分析"></a>对leader(ZK-A)进行分析</h3><p>首先我们先看下Leader的初始化逻辑:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">quorumPeer</span><br><span class="line">    |-&gt;打印 LEADING</span><br><span class="line">    |-&gt;makeLeader</span><br><span class="line">        |-&gt; new ServerSocket listen and bind </span><br><span class="line">    |-&gt;leader.lead()</span><br><span class="line">        |-&gt;打印 LEADER ELECTION TOOK</span><br><span class="line">        |-&gt;loadData</span><br><span class="line">            |-&gt;loadDataBase </span><br><span class="line">                |-&gt;resore 打印Reading snapshot</span><br><span class="line">            |-&gt;takeSnapshot</span><br><span class="line">                |-&gt;save 打印Snapshotting</span><br><span class="line">            |-&gt;cnxAcceptor 处理请求Accept</span><br></pre></td></tr></table></figure>

<p>可以看到，在我们的ZK启动监听端口到正式处理请求之间，还有Reading Snapshot和Snapshotting(写)动作。从日志可以看出一个花了6s多,一个花了14s多。然后就有20s的处理空档期。如下图所示:<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0H8iawNnVj63Ic0JWnlB7EMohfSktibyMNic1ZSfa6trDQbLLoxz3rLyPg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>由于在socket listen 20s之后才开始处理数据，所以ZK-B建立成功的连接实际还放在tcp的内核全连接队列(backlog)里面，由于在内核看来三次握手是成功的，所以能够正常接收ZK-B发送的follower ZK-B数据。在20s，ZK-A真正处理后，从buffer里面拿出来20s前ZK-B发送的数据，处理完回包的时候，发现ZK-B连接已经断开。<br>同样的，另一台follower(这时候我们已经把宕机的拉起来了，所以是3台)也是由于此原因gg,而leader迟迟收不到其它机器的响应，认为自己的leader没有达到1/2的票数，而Shutdown重新选举。</p>
<h2 id="Snapshot耗时"><a href="#Snapshot耗时" class="headerlink" title="Snapshot耗时"></a>Snapshot耗时</h2><p>那么是什么导致Snapshotting读写这么耗时呢？笔者查看了下Snapshot文件大小,有将近一个G左右。</p>
<h2 id="调大initLimit"><a href="#调大initLimit" class="headerlink" title="调大initLimit"></a>调大initLimit</h2><p>针对这种情况，其实我们只要调大initLimit，应该就可以越过这道坎。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zoo.cfg</span><br><span class="line">tickTime&#x3D;2000 &#x2F;&#x2F; 这个不要动，因为和ZK心跳机制有关</span><br><span class="line">initLimit&#x3D;100 &#x2F;&#x2F; 直接调成100,200s!</span><br></pre></td></tr></table></figure>

<h2 id="这么巧就20s么？"><a href="#这么巧就20s么？" class="headerlink" title="这么巧就20s么？"></a>这么巧就20s么？</h2><p>难道就这么巧，每次选举流程都刚好卡在20s不过？反复选举了好多次，应该有一次要&lt;20s成功吧，不然运气也太差了。如果是每次需要处理Snapshot 30s也就算了，但这个20s太接近极限值了，是否还有其它因素导致选主不成功？</p>
<h2 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h2><p>于是笔者翻了下日志，还真有！这次leader这边处理Snapshot快了，但是follower又拉跨了!日志如下:</p>
<h3 id="leader-ZK-A-第二种情况"><a href="#leader-ZK-A-第二种情况" class="headerlink" title="leader(ZK-A)第二种情况"></a>leader(ZK-A)第二种情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2021-06-16 03:38:03 New election. My id&#x3D; 3</span><br><span class="line">2021-06-16 03:38:22 QuorumPeer] LEADING</span><br><span class="line">2021-06-16 03:38:22 QuorumPeer] LEADING - LEADER ELECTION TOOK 25703</span><br><span class="line">2021-06-16 03:38:22 QuorumPeer] Reading snapshot</span><br><span class="line">2021-06-16 03:38:29 QuorumPeer] Snapshotting</span><br><span class="line">2021-06-16 03:38:42 LearnerHandler] Follower sid 1</span><br><span class="line">2021-06-16 03:38:42 LearnerHandler] Follower sid 3</span><br><span class="line">2021-06-16 03:38:42 LearnerHandler] Sending DIFF</span><br><span class="line">2021-06-16 03:38:42 LearnerHandler] Sending DIFF</span><br><span class="line">2021-06-16 03:38:54 LearnerHandler] Have quorum of supporters</span><br><span class="line">2021-06-16 03:38:55 client attempting to establsh new session 到这开始接收client请求了</span><br><span class="line">......</span><br><span class="line">2021-06-16 03:38:58 Shutdown callsed</span><br><span class="line">java.lang.Exception: shutdown Leader! reason: Only 1 followers,need 1</span><br><span class="line">    at org.apache.zookeeper.server.quorum.Leader.shutdown</span><br></pre></td></tr></table></figure>

<p>从日志中我们可以看到选举是成功了的，毕竟处理Snapshot只处理了13s(可能是pagecache的原因处理变快)。其它两个follower顺利连接，同时给他们发送DIFF包，但是情况没好多久，又爆了一个follower不够的报错，这里的报错信息比较迷惑。<br>我们看下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Leader.lead</span><br><span class="line">void lead() &#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">                 Thread.sleep(self.tickTime&#x2F;2);</span><br><span class="line">                 ......</span><br><span class="line">                 syncedSet.add(self.getId())</span><br><span class="line">                 for(LearnerHandler f:getLearners())&#123;</span><br><span class="line">                     if(f.synced() &amp;&amp; f.getLearnerType()&#x3D;&#x3D;LearnerType.PARTICIPANT)&#123;</span><br><span class="line">                         syncedSet.add(f.getSid());</span><br><span class="line">                     &#125;</span><br><span class="line">                     f.ping();</span><br><span class="line">                 &#125;</span><br><span class="line">                  &#x2F;&#x2F; syncedSet只有1个也就是自身，不符合&gt;1&#x2F;2的条件，报错并跳出</span><br><span class="line">                if (!tickSkip &amp;&amp; !self.getQuorumVerifier().containsQuorum(syncedSet)) &#123;</span><br><span class="line">                    shutdown(&quot;Only&quot; + syncedSet.size() + &quot; followers, need&quot; + (self.getVotingView().size()&#x2F;2));</span><br><span class="line">                    return;</span><br><span class="line">              &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错的实质就是和leader同步的syncedSet小于固定的1/2集群，所以shutdown了。同时在代码里面我们又可以看到syncedSet的判定是通过learnerHander.synced()来决定。我们继续看下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LearnerHandler</span><br><span class="line">    public boolean synced()&#123;</span><br><span class="line">        &#x2F;&#x2F; 这边isAlive是线程的isAlive</span><br><span class="line">        return isAlive() &amp;&amp; tickOfLastAck &gt;&#x3D; leader.self.tick - leader.self.syncLimit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>很明显的，follower和leader的同步时间超过了leader.self.syncLimit也就是5 * 2 = 10s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zoo.cfg</span><br><span class="line">tickTime &#x3D; 2000</span><br><span class="line">syncLimit &#x3D; 5</span><br></pre></td></tr></table></figure>

<p>那么我们的tick是怎么更新的呢,答案是在follower响应UPTODATE包,也就是已经和leader同步后，follower每个包过来就更新一次，在此之前并不更新。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0tttT7icMDVASzFJWML5XkY093c94IgvFkt8b1QaibWQMDGRlEbVIzbOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>进一步推理，也就是我们的follower处理leader的包超过了10s，导致tick未及时更新，进而syncedSet小于数量，导致leader shutdown。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0yhedbofHiaNsJib1Lg7ePTiboiaO03k5AC5SpfOpMo2AgnL6E9kvtR5mWA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h3 id="follower-ZK-B-第二种情况"><a href="#follower-ZK-B-第二种情况" class="headerlink" title="follower(ZK-B)第二种情况"></a>follower(ZK-B)第二种情况</h3><p>带着这个结论，笔者去翻了follower(ZK-B)的日志(注:ZK-C也是如此)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2021-06-16 03:38:24 New election. My id &#x3D; 3</span><br><span class="line">2021-06-16 03:38:24 FOLLOWING</span><br><span class="line">2021-06-16 03:38:24 FOLLOWING - LEADER ELECTION TOOK - 8004</span><br><span class="line">2021-06-16 03:38:42 Getting a diff from the leader</span><br><span class="line">2021-06-16 03:38:42 Snapshotting</span><br><span class="line">2021-06-16 03:38:57 Snapshotting</span><br><span class="line">2021-06-16 03:39:12 Got zxid xxx</span><br><span class="line">2021-06-16 03:39:12 Exception when following the leader</span><br><span class="line">java.net.SocketException: Broken pipe</span><br></pre></td></tr></table></figure>

<p>又是Snapshot,这次我们可以看到每次Snapshot会花15s左右，远超了syncLimit。<br>从源码中我们可以得知，每次Snapshot之后都会立马writePacket(即响应)，但是第一次回包有由于不是处理的UPTODATE包,所以并不会更新Leader端对应的tick:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">learner:</span><br><span class="line">proteced void syncWithLeader(...)&#123;</span><br><span class="line">outerloop:</span><br><span class="line">    while(self.isRunning())&#123;</span><br><span class="line">        readPacket(qp);</span><br><span class="line">        switch(qp.getType())&#123;</span><br><span class="line">            case Leader.UPTODATE</span><br><span class="line">            if(!snapshotTaken)&#123;</span><br><span class="line">                zk.takeSnapshot();</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            break outerloop;</span><br><span class="line">        &#125;</span><br><span class="line">        case Leader.NEWLEADER:</span><br><span class="line">            zk.takeSnapshot();</span><br><span class="line">            ......</span><br><span class="line">            writePacket(......) &#x2F;&#x2F; leader收到后会更新tick</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    writePacket(ack,True); &#x2F;&#x2F; leader收到后会更新tick</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，ZK-B的日志里面表明会两次Snapshotting。至于为什么两次，应该是一个微妙的Bug,(在3.4.5的官方注释里面做了fix,但看日志依旧打了两次)，笔者并没有深究。好了，整个时序图就如下所示:<br><img src="https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0JdoibkzrcpBvl1GH9RCIqtbDdlZepmmFBZ4N3Vdr2KSU8oWebetd7Qg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"><br>好了，第二种情况也gg了。这一次时间就不是刚刚好出在边缘了，得将近30s才能Okay, 而synedSet只有10s(2*5)。ZK集群就在这两种情况中反复选举，直到人工介入。</p>
<h2 id="调大syncLimit"><a href="#调大syncLimit" class="headerlink" title="调大syncLimit"></a>调大syncLimit</h2><p>针对这种情况，其实我们只要调大syncLimit，应该就可以越过这道坎。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zoo.cfg</span><br><span class="line">tickTime&#x3D;2000 &#x2F;&#x2F; 这个不要动，因为和ZK心跳机制有关</span><br><span class="line">syncLimit&#x3D;50  &#x2F;&#x2F; 直接调成50,100s!</span><br></pre></td></tr></table></figure>

<h2 id="线下复现"><a href="#线下复现" class="headerlink" title="线下复现"></a>线下复现</h2><p>当然了，有了分析还是不够的。我们还需要通过测试去复现并验证我们的结论。我们在线下构造了一个1024G Snapshot的ZookKeeper进行测试，在initLimit=10以及syncLimit=5的情况下确实和线上出现一模一样的那两种现象。在笔者将参数调整后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zoo.cfg</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;100 &#x2F;&#x2F; 200s</span><br><span class="line">syncLimit&#x3D;50  &#x2F;&#x2F; 100s</span><br></pre></td></tr></table></figure>

<p>Zookeeper集群终于正常了。</p>
<h2 id="线下用新版本3-4-13尝试复现"><a href="#线下用新版本3-4-13尝试复现" class="headerlink" title="线下用新版本3.4.13尝试复现"></a>线下用新版本3.4.13尝试复现</h2><p>我们在线下还用比较新的版本3.4.13尝试复现，发现Zookeeper在不调整参数的情况下，很快的就选主成功并正常提供服务了。笔者翻了翻源码，发现其直接在Leader.lead()阶段和SyncWithLeader阶段(如果是用Diff的话)将takeSnapshot去掉了。这也就避免了处理snapshot时间过长导致无法提供服务的现象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zookeeper 3.4.13</span><br><span class="line"></span><br><span class="line">ZookeeperServer.java</span><br><span class="line">public void loadData()&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; takeSnapshot() 删掉了最后一行的takeSnapshot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">learner.java</span><br><span class="line">protected void syncWithLeader(...)&#123;</span><br><span class="line">    boolean snapshotNeeded&#x3D;true</span><br><span class="line">    if(qp.getType() &#x3D;&#x3D; Leader.DIFF)&#123;</span><br><span class="line">        ......</span><br><span class="line">        snapshotNeeded &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    if(snapshotNeeded)&#123;</span><br><span class="line">        zk.takeSnapshot();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是升级到高版本靠谱呀，这个版本的代码顺带把那个迷惑性的日志也改了！</p>
<h2 id="为何Dubbo-ZK有那么多的数据"><a href="#为何Dubbo-ZK有那么多的数据" class="headerlink" title="为何Dubbo-ZK有那么多的数据"></a>为何Dubbo-ZK有那么多的数据</h2><p>最后的问题就是一个dubbo相关的ZK为什么有那么多数据了!笔者利用ZK使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.zookeeper.server.SnapshotFormatter</span><br></pre></td></tr></table></figure>

<p>工具dump出来并用shell(awk|unique)聚合了一把，发现dubbo的数据只占了其中的1/4。<br>有1/2是Solar的Zookeeper(已经迁移掉，遗留在上面的)。还有1/4是由于某个系统的分布式锁Bug不停的写入进去并且不删除的(已让他们修改)。所以将dubbo-zk和其它ZK数据分离是多么的重要！随便滥用就有可能导致重大事件！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/05/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/zk%E8%B0%83%E4%BC%98%E4%B8%8E%E5%88%86%E6%9E%90-01-%E9%9B%86%E7%BE%A4%E6%97%A0%E6%B3%95%E9%80%89%E4%B8%BE%E5%87%BAleader/" data-id="cm6lsyz5b002mk2dlac9hgb0e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络编程/http协议/http-url-自动转译特殊符号为空格" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/http%E5%8D%8F%E8%AE%AE/http-url-%E8%87%AA%E5%8A%A8%E8%BD%AC%E8%AF%91%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E4%B8%BA%E7%A9%BA%E6%A0%BC/" class="article-date">
  <time datetime="2021-06-23T12:17:10.000Z" itemprop="datePublished">2021-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/http%E5%8D%8F%E8%AE%AE/http-url-%E8%87%AA%E5%8A%A8%E8%BD%AC%E8%AF%91%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E4%B8%BA%E7%A9%BA%E6%A0%BC/">http-url自动转译特殊符号为空格</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>调试客户端向服务器传递参数时，url出现+，空格，/，?，%，#，&amp;，=等特殊符号的时候就自动变成空格，可能在服务器端无法获得正确的参数值</p>
<p>解决方法如下：</p>
<p>URL字符转义</p>
<ol>
<li>URL 中+号表示空格 %2B </li>
<li>空格 URL中的空格可以用+号或者编码 %20 </li>
<li>分隔目录和子目录 %2F </li>
<li>分隔实际的URL和参数 %3F </li>
<li>指定特殊字符 %25</li>
</ol>
<p><img src="https://yqfile.alicdn.com/img_d5780acb990734be5e2ccbd163376ef5.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/http%E5%8D%8F%E8%AE%AE/http-url-%E8%87%AA%E5%8A%A8%E8%BD%AC%E8%AF%91%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E4%B8%BA%E7%A9%BA%E6%A0%BC/" data-id="cm6lsyz5e003rk2dlcgymcipw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法/搜索算法/AC算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/23/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/AC%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2021-06-23T05:29:54.000Z" itemprop="datePublished">2021-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/23/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/AC%E7%AE%97%E6%B3%95/">AC算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="AC算法在美团上单系统的应用"><a href="#AC算法在美团上单系统的应用" class="headerlink" title="AC算法在美团上单系统的应用"></a><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/06/09/ac-algorithm-in-meituan-order-system-practice.html">AC算法在美团上单系统的应用</a></h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>在美团，为了保证单子质量，需要对上单系统创建的每一个产品进行审核。为了提高效率，审核人员积累提炼出了一套关键词库，先基于该词库进行自动审核过滤，对于不包括这些关键词的产品信息不再需要进行人工审核。因此，如何在页面中快速的检测是否包含了这些关键词就变得非常重要。</p>
<p>对于上述问题我们描述为如下的形式：</p>
<ul>
<li>给定关键词集合P={p1,p2,……,pk}，在目标串T[1…m]中找到出现了哪些关键词。</li>
</ul>
<p>很容易想到的方法就是针对每个单词去匹配一遍，最后总结出都哪些单词匹配成功。</p>
<p>考虑KMP算法，单个关键词匹配的时间复杂度是O(|pk|+m)，所以，所有关键词都匹配一遍的时间复杂度为O(|p1|+m+|p2|+m+…+|pk|+m)。令n=|p1|+…+|pk|，上式化简为O(n+km)，因此，当关键词的数量变得非常多时，这种算法就变得无法忍受了。</p>
<p>Alfred V.Aho和Margaret J.Corasick在1974年提出了一个经典的多模式匹配算法-AC算法，这个算法可以保证对于给定的长度为n的文本，和模式集合P{p1,p2,…pm}，在O(n)的时间复杂度内找到文本中的所有目标模式，而与模式集合的规模m无关。</p>
<h2 id="2-AC算法详解"><a href="#2-AC算法详解" class="headerlink" title="2.AC算法详解"></a>2.AC算法详解</h2><p>AC算法的具体实现方法就是创建一棵前缀树，根据被查找的目标字符串，从树的根节点开始往叶子节点逐字符匹配。在这个过程中，如果发生失配，要根据失配跳转点进行跳转，如果找到匹配的模式串则进行打印输出。AC算法在扫描文本时完全不需要回溯，如果只考虑匹配的过程，该算法的时间复杂度为O(n)，也就是只跟待匹配文本的长度相关。</p>
<p>AC算法的实现可以由如下三个步骤构成：</p>
<ol>
<li>构造前缀树</li>
<li>设置每个节点的失配跳转并收集每个节点的所有匹配模式串</li>
<li>对目标字符串进行搜索匹配</li>
</ol>
<p>其间共用到三个函数：goto，fail，output。</p>
<h3 id="步骤一：构造前缀树"><a href="#步骤一：构造前缀树" class="headerlink" title="步骤一：构造前缀树"></a>步骤一：构造前缀树</h3><p>这里我们考虑模式集合P={“he”,”she”,”his”,”hers”}。</p>
<p>首先是goto函数的建立，该函数决定了对于当前状态S和条件C，如何得到下一状态S’。为了构建goto函数，我们需要建立一个状态转移图，开始，这个图只包含一个状态0，然后通过添加一条从起始状态出发的路径的方式，依次向图中输入每个关键字keyword，新的顶点和边被加入到图表中，这样就产生了一条能拼写出关键字keyword的路径。</p>
<p>添加第一个关键词“he”得到下图，其中从状态0到状态2的路径就拼写出了关键字“he”；</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/7fe93be9.gif" alt="img"></p>
<p>接着添加第二个关键字“she”得到下图，输出“she”和状态5相关联；</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/3d902714.gif" alt="img"></p>
<p>增加第三个关键字“his”得到下图，当我们增加“his”时，因为已经存在一条从状态0在输入h的条件下到达状态1的边，因此我们这里不需要另外添加一条同样的边。这个输出的“his”是和状态7相关联的；</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/ec9d47b8.gif" alt="img"></p>
<p>最后我们添加“hers”得到下图，输出“hers”和状态9相关联，最后对除了h和s外的每个字符都增加一个从状态0到0的循环；</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/b649e48a.gif" alt="img"></p>
<p>经由上面一系列添加过程，就构造了整个模式集合的状态转移图，这个图也就代表了转向函数goto。 我们利用伪代码将goto函数表示如下，同时我们在这一步骤中构造了output函数，但这个函数并不是完整的，需要在步骤二中继续完善：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">     newstate ← 0</span><br><span class="line">     for i ← 1 util k do enter(yi)</span><br><span class="line">     for all a such that goto(0,a) &#x3D;&#x3D; fail do goto(0,a) ← 0</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">procedure enter(a1a2…am):</span><br><span class="line">begin</span><br><span class="line">     state ← 0</span><br><span class="line">     j ← 1</span><br><span class="line">     while goto(state, aj) ≠ fail do</span><br><span class="line">          begin</span><br><span class="line">               state ← goto(state, aj)</span><br><span class="line">               j ← j+1</span><br><span class="line">          end</span><br><span class="line">     for p ← j util m do</span><br><span class="line">          begin</span><br><span class="line">               newstate ← newstate + 1</span><br><span class="line">               goto(state, ap) ← newstate</span><br><span class="line">               state ← newstate</span><br><span class="line">          end</span><br><span class="line">     output(state) ← &#123;a1a2…am&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="步骤二：设置每个节点的失配跳转"><a href="#步骤二：设置每个节点的失配跳转" class="headerlink" title="步骤二：设置每个节点的失配跳转"></a>步骤二：设置每个节点的失配跳转</h3><p>失效函数fail决定了当goto函数得到的下一个状态无效时，应该回退到哪一个状态。在构造fail函数时，我们首先定义状态转移图中状态S的深度为从状态0到状态S的最短路径。以我们上面构造的状态转移图为例，起始状态的深度为0，状态1和3的深度是1，状态2、6、4的深度是2，依次类推。计算失效函数的思路是这样的：首先计算深度为1 的状态的失效函数值，然后是深度为2的，以此类推，直到所有状态的失效函数值都被计算出。同时，我们规定所有深度为1的状态的fail值为0，假设所有深度小于d的状态的fail值都已经计算出，考虑每个深度为d-1的状态r，基于这些已经被计算出的深度为d-1的fail值，我们是可以得到深度为d的fail值的。</p>
<p>令L(Si)为从根节点到Si节点的路径上的所有边的值的序列，我们从树的根节点开始遍历计算fail值，如果L(Sj)是L(Si)的一个后缀，并且是最长后缀，那么，fail(Si) = Sj。假设当前状态为S1，现在要求fail(S1)，S1的前一状态我们记为S2，而S2跳到S1的条件为C，也就是S1 = goto(S2,C)，而S2的fail值是已知的，记为S3，也即S3 = fail(S2)，则L(S3)是L(S2)的一个最长后缀，假设S4 = goto(S3,C)存在，那么fail(S1) = S4，如果不存在则测试S5 = goto(fail(S3),C)，直到得到一个有效的状态为止。这个计算的过程是这样的：</p>
<ol>
<li>对于所有的字符a，如果goto(r,a) = fail，那么什么也不做（当r为我们上面构造的trie树的叶子节点时，就符合这种情况）</li>
<li>如果goto(r,a) == s，我们记state = fail®，执行state = f(state)零次或者若干次，直到使得goto(state,a) != fail，因为goto(0,a) != fail，所以这个状态是一定存在的。</li>
<li>记fail(s) = goto(state,a)。</li>
</ol>
<p>我们还是以上面构造出的状态转移图为例，计算每个节点的fail值，根据规定，fail(1) = fail(3) = 0，因为1和3是深度为1的状态。</p>
<blockquote>
<p>考虑深度为2的状态2、6、4： * 计算fail(2)，令state = fail(1) = 0，由于goto(0，e) = 0，所以fail(2) = 0 * 计算fail(4)，令state = fail(3) = 0，由于goto(0，h) = 1，所以fail(4) = 1 * 计算fail(6)，令state = fail(1) = 0，由于goto(0，i) = 0，所以fail(6) = 0</p>
<p>考虑深度为3的节点8、7、5： * 计算fail(8)，令state = fail(2) = 0，因为goto(0，r) = 0，所以fail(8) = 0 * 计算fail(7)，令state = fail(6) = 0，因为goto(0，s) = 3，所以fail(7) = 3 * 计算fail(5)，令state = fail(4) = 1，因为goto(1，e) = 2，所以fail(5) = 2</p>
<p>最后考虑深度为4的节点9： * 计算fail(9)，令state = fail(8) = 0，因为goto(0，s) = 3，所以fail(9) = 3</p>
</blockquote>
<p>这样一来我们构造的fail表如下：</p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">4</th>
<th align="left">5</th>
<th align="left">6</th>
<th align="left">7</th>
<th align="left">8</th>
<th align="left">9</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fail值</td>
<td align="left">None</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">0</td>
<td align="left">3</td>
</tr>
</tbody></table>
<p>失效函数创建的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">     queue ← empty</span><br><span class="line">     for each a such that goto(0,a) &#x3D; s ≠ fail do</span><br><span class="line">          begin</span><br><span class="line">               queue ← queue U &#123;s&#125;</span><br><span class="line">               fail(s) ← 0</span><br><span class="line">          end</span><br><span class="line">     while queue ≠ empty do</span><br><span class="line">     begin</span><br><span class="line">          let r be the next state in queue</span><br><span class="line">          queue ← queue - &#123;r&#125;</span><br><span class="line">          for each a such that goto(r,a) &#x3D; s ≠ fail do</span><br><span class="line">               begin</span><br><span class="line">                    queue ← queue U &#123;s&#125;</span><br><span class="line">                    state ← fail(r)</span><br><span class="line">                    while goto(state,a) &#x3D; fail do state ← fail(state)</span><br><span class="line">                    fail(s) ← goto(state,a)</span><br><span class="line">                    output(s) ← output(s) U output(fail(s))</span><br><span class="line">               end</span><br><span class="line">     end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="步骤三：对目标字符串进行搜索匹配"><a href="#步骤三：对目标字符串进行搜索匹配" class="headerlink" title="步骤三：对目标字符串进行搜索匹配"></a>步骤三：对目标字符串进行搜索匹配</h3><p>上面两个步骤都完成了之后就可以开始对目标串进行搜索了，只需对目标串从头到尾线性扫描，且没有回溯。搜索之前先记录树的当前节点node，初始时，树的当前节点node为根节点Root。从目标串的第一个字符开始，和Root的孩子节点进行匹配，如果不匹配，则目标字符串往后挪一个字符，继续在Root的孩子节点中查找匹配。如果找到匹配的孩子，则目标字符串往后挪一个字符，node变为匹配上的孩子节点。在接下来的匹配过程中，如果失配将跳转到node节点的fail值处继续进行匹配。在树上每次往孩子节点方向走一步都要检查该孩子节点的匹配模式串信息，如果有匹配的模式串信息，则应记录找到了哪些能够匹配的模式串。</p>
<p>整体的匹配过程如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">     state ← 0</span><br><span class="line">     for i ← 1 until n do</span><br><span class="line">          begin</span><br><span class="line">               while goto(state,ai) &#x3D; fail do state &#x3D; fail(state)</span><br><span class="line">               state ← goto(state,ai)</span><br><span class="line">               if output(state) ≠ empty then</span><br><span class="line">                    begin</span><br><span class="line">                         print output(state)</span><br><span class="line">                    end</span><br><span class="line">          end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="3-上单系统中的实现"><a href="#3-上单系统中的实现" class="headerlink" title="3.上单系统中的实现"></a>3.上单系统中的实现</h2><p>在美团上单系统中，待匹配的关键词根据产品类别进行分组，不同品类之间的关键词具有重叠。如果针对每个品类生成一棵状态转移树固然可行，但是随着品类的增多，对内存的使用也会随之增高。考虑到AC算法的时间复杂度与关键词的数量无关，因此可以考虑将所有品类的关键词构造在同一棵状态转移树中，每次进行匹配时，在output函数中对该关键词是否属于该品类做判断。在上单系统中，关键词用Keyword类表示，该类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keyword</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; categoryTypeMap;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; categories; <span class="comment">//当前的关键词属于哪几个分类</span></span><br><span class="line"> </span><br><span class="line">    getter and setter ...</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        Keyword keyword = (Keyword) o;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (id != <span class="keyword">null</span> ? !id.equals(keyword.id) : keyword.id != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id != <span class="keyword">null</span> ? id.hashCode() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，categoryTypeMap属性用来标识该关键词在不同品类中所代表的类型，当匹配命中时，根据类型信息指出其可能违反了哪些条款。</p>
<p>我们用一个Node类来代表状态转移树的一个节点，同时，将goto信息、fail信息和output信息封装到里面，这样，这个类的定义就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state;                    <span class="comment">//自动机的状态，也就是节点数字</span></span><br><span class="line">    <span class="keyword">char</span> character = <span class="number">0</span>;           <span class="comment">//指向当前节点的字符，也即条件</span></span><br><span class="line">    Node failureNode;             <span class="comment">//匹配失败时，下一个节点</span></span><br><span class="line">    List&lt;Keyword&gt; keywords;       <span class="comment">//匹配成功时，当前节点对应的关键词</span></span><br><span class="line">    List&lt;Node&gt; children;          <span class="comment">//当前节点的子节点</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用Patterns类来表示整个待匹配的模式串，它是对Node的进一步封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Patterns</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Node root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Node&gt; tree;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Patterns</span><span class="params">(List&lt;Keyword&gt; keywords)</span> </span>&#123;</span><br><span class="line">        tree = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        tree.add(root);</span><br><span class="line">        <span class="keyword">for</span>(Keyword keyword : keywords)&#123;</span><br><span class="line">            addKeyword(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">        setFailNode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addKeyword</span><span class="params">(Keyword keyword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] wordCharArr = keyword.getWord().toCharArray();</span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> currentChar : wordCharArr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.containsChild(currentChar))&#123;</span><br><span class="line">                current = current.getChild(currentChar);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node node = <span class="keyword">new</span> Node(table.size(), currentChar, root);</span><br><span class="line">                current.addChild(node);</span><br><span class="line">                current = node;</span><br><span class="line">                tree.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        current.addKeyword(keyword);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFailNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        Node node = root;</span><br><span class="line">        <span class="keyword">for</span> (Node d1 : node.children)</span><br><span class="line">            queue.offer(d1);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node curNode : node.children) &#123;</span><br><span class="line">                    queue.offer(curNode);</span><br><span class="line">                    Node failNode = node.failureNode;</span><br><span class="line">                    <span class="keyword">while</span> (!failNode.containsChild(curNode.character)) &#123;</span><br><span class="line">                        failNode = failNode.failureNode;</span><br><span class="line">                        <span class="keyword">if</span> (failNode.state == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (failNode.containsChild(curNode.character)) &#123;</span><br><span class="line">                        curNode.failureNode = failNode.getChild(curNode.character);</span><br><span class="line">                        curNode.addKeywords(curNode.failureNode.keywords);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上单系统中对关键词的匹配需要传递一个categoryId，当匹配成功时，我们需要根据传递的类别信息判断是否应该保存当前关键词：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Keyword&gt; <span class="title">searchKeyword</span><span class="params">(String data, Integer category)</span> </span>&#123;</span><br><span class="line">    Set&lt;Keyword&gt; matchResult = <span class="keyword">new</span> HashSet&lt;Keyword&gt;();</span><br><span class="line">    Node node = patterns.getRoot();</span><br><span class="line">    <span class="keyword">char</span>[] chs = data.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; chs.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!node.containsChild(chs[i])) &#123;</span><br><span class="line">            node = node.failureNode;</span><br><span class="line">            <span class="keyword">if</span> (node.state == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.containsChild(chs[i]))&#123;</span><br><span class="line">            node = node.getChild(chs[i]);</span><br><span class="line">            <span class="keyword">if</span>(node.keywords != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Keyword pattern : node.keywords)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (category == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        matchResult.add(pattern);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (pattern.getCategories().contains(category)) &#123;</span><br><span class="line">                            matchResult.add(pattern);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法的测试结果如下：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/272631ae.png" alt="img"></p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/fbebb381.png" alt="img"></p>
<p>在第二张图中，有一个因素没有考虑进去，就是同样关键词数量，当关键词在文本中出现的次数较多时，因为需要遍历找出对应该品类的词，所以花费的时间会增加，但整体上还是符合预期的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/23/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/AC%E7%AE%97%E6%B3%95/" data-id="cm6lsyz5c002xk2dl3p2u6tq8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-database/hbase/hbase-01-单机安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/23/database/hbase/hbase-01-%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85/" class="article-date">
  <time datetime="2021-06-23T03:25:41.000Z" itemprop="datePublished">2021-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/23/database/hbase/hbase-01-%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85/">hbase-01-单机安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/23/database/hbase/hbase-01-%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85/" data-id="cm6lsyz510006k2dlegs24iz7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-链路追踪/pinpoint-01-安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/pinpoint-01-%E5%AE%89%E8%A3%85/" class="article-date">
  <time datetime="2021-06-22T11:45:45.000Z" itemprop="datePublished">2021-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/pinpoint-01-%E5%AE%89%E8%A3%85/">pinpoint-01-安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>Download, Configure, and Start HBase</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;hbase&#x2F;2.3.5&#x2F;hbase-2.3.5-bin.tar.gz</span><br><span class="line">$ tar xzvf hbase-x.x.x-bin.tar.gz</span><br><span class="line">$ cd hbase-x.x.x&#x2F;</span><br><span class="line">$ .&#x2F;bin&#x2F;start-hbase.sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果启动之后，使用<code>jps</code>命令可以看到hbase进程，并且可以打开<a href="http://localhost:16010查看Hbase的Web">http://localhost:16010查看Hbase的Web</a> UI</p>
</blockquote>
<p><em>通过$HBASE_HOME/conf/hbase-env.sh文件设置一些环境变量：</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home</span><br><span class="line"><span class="built_in">export</span> HBASE_OPTS=<span class="string">&quot;-XX:+UseConcMarkSweepGC&quot;</span></span><br><span class="line"><span class="built_in">export</span> SERVER_GC_OPTS=<span class="string">&quot;-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/Users/zhuzhi/hbase124/logs/jdk8.log&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何找到jdk安装路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">which java</span><br><span class="line">ls -lrt &#x2F;usr&#x2F;bin&#x2F;java</span><br><span class="line">ls -lrt &#x2F;etc&#x2F;alternatives&#x2F;java</span><br></pre></td></tr></table></figure>
</blockquote>
<p>See <a target="_blank" rel="noopener" href="https://github.com/pinpoint-apm/pinpoint/tree/master/hbase/scripts">scripts</a> and Run.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;bin&#x2F;hbase shell hbase-create.hbase</span><br></pre></td></tr></table></figure>



<h3 id="Pinpoint-Collector"><a href="#Pinpoint-Collector" class="headerlink" title="Pinpoint Collector"></a>Pinpoint Collector</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/pinpoint-apm/pinpoint/releases/download/v2.2.2/pinpoint-collector-boot-2.2.2.jar</span><br><span class="line"></span><br><span class="line">java -jar -Dpinpoint.zookeeper.address=localhost pinpoint-collector-boot-2.2.2.jar</span><br></pre></td></tr></table></figure>





<h3 id="Pinpoint-Web"><a href="#Pinpoint-Web" class="headerlink" title="Pinpoint Web"></a>Pinpoint Web</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;pinpoint-apm&#x2F;pinpoint&#x2F;releases&#x2F;download&#x2F;v2.2.2&#x2F;pinpoint-web-boot-2.2.2.jar</span><br><span class="line"></span><br><span class="line">java -jar -Dpinpoint.zookeeper.address&#x3D;localhost pinpoint-web-boot-2.2.2.jar</span><br></pre></td></tr></table></figure>



<h3 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h3><h4 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h4><p>In order to build Pinpoint, the following requirements must be met:</p>
<ul>
<li>JDK 8 installed</li>
</ul>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/pinpoint-apm/pinpoint/releases/download/v2.2.2/pinpoint-agent-2.2.2.tar.gz</span><br><span class="line"></span><br><span class="line">tar xvzf pinpoint-agent-2.2.2.tar.gz</span><br></pre></td></tr></table></figure>



<h4 id="使用官方的quick-start项目测试"><a href="#使用官方的quick-start项目测试" class="headerlink" title="使用官方的quick-start项目测试"></a>使用官方的quick-start项目测试</h4><p>Download Pinpoint with <code>git clone https://github.com/pinpoint-apm/pinpoint.git</code> or <a target="_blank" rel="noopener" href="https://github.com/pinpoint-apm/pinpoint/archive/master.zip">download</a> the project as a zip file and unzip.</p>
<p>Change to the pinpoint directory, and build.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd pinpoint</span><br><span class="line">$ .&#x2F;mvnw install -DskipTests&#x3D;true </span><br></pre></td></tr></table></figure>

<p>Change to the quickstart testapp directory, and build. Let’s build and run.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd quickstart&#x2F;testapp</span><br><span class="line">$ .&#x2F;mvnw clean package</span><br></pre></td></tr></table></figure>

<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>Change to the pinpoint directory, and run.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ../../</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -jar -javaagent:agent/target/pinpoint-agent-2.2.2/pinpoint-bootstrap.jar -Dpinpoint.agentId=test-agent -Dpinpoint.applicationName=TESTAPP quickstart/testapp/target/pinpoint-quickstart-testapp-2.2.2.jar</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot’s embedded Apache Tomcat server is acting as a webserver and is listening for requests on localhost port 8082. Open your browser and in the address bar at the top enter <a target="_blank" rel="noopener" href="http://localhost:8082/">http://localhost:8082</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/pinpoint-01-%E5%AE%89%E8%A3%85/" data-id="cm6lsyz560017k2dl71r6bxpp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-database/Mybatis/mybatis-01-整体架构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/18/database/Mybatis/mybatis-01-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/" class="article-date">
  <time datetime="2021-06-18T05:39:49.000Z" itemprop="datePublished">2021-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/18/database/Mybatis/mybatis-01-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/">mybatis-01-整体架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文主要讲解JDBC怎么演变到Mybatis的渐变过程，<strong>重点讲解了为什么要将JDBC封装成Mybaits这样一个持久层框架</strong> 。再而论述Mybatis作为一个数据持久层框架本身有待改进之处。</p>
<h2 id="JDBC实现查询分析"><a href="#JDBC实现查询分析" class="headerlink" title="JDBC实现查询分析"></a>JDBC实现查询分析</h2><p>我们先看看我们最熟悉也是最基础的通过JDBC查询数据库数据，一般需要以下七个步骤：</p>
<blockquote>
<ol>
<li>加载JDBC驱动；</li>
<li>建立并获取数据库连接；</li>
<li>创建 JDBC Statements 对象；</li>
<li>设置SQL语句的传入参数；</li>
<li>执行SQL语句并获得查询结果；</li>
<li>对查询结果进行转换处理并将处理结果返回；</li>
<li>释放相关资源（关闭Connection，关闭Statement，关闭ResultSet）；</li>
</ol>
</blockquote>
<p>以下是具体的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Map&lt;String,Object&gt;&gt; queryForList()&#123;</span><br><span class="line">    Connection connection &#x3D; null;</span><br><span class="line">    ResultSet rs &#x3D; null;</span><br><span class="line">    PreparedStatement stmt &#x3D; null;</span><br><span class="line">    List&lt;Map&lt;String,Object&gt;&gt; resultList &#x3D; new ArrayList&lt;Map&lt;String,Object&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 加载JDBC驱动</span><br><span class="line">        Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;).newInstance();</span><br><span class="line">        String url &#x3D; &quot;jdbc:oracle:thin:@localhost:1521:ORACLEDB&quot;;</span><br><span class="line"></span><br><span class="line">        String user &#x3D; &quot;trainer&quot;;</span><br><span class="line">        String password &#x3D; &quot;trainer&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取数据库连接</span><br><span class="line">        connection &#x3D; DriverManager.getConnection(url,user,password);</span><br><span class="line"></span><br><span class="line">        String sql &#x3D; &quot;select * from userinfo where user_id &#x3D; ? &quot;;</span><br><span class="line">        &#x2F;&#x2F; 创建Statement对象（每一个Statement为一次数据库执行请求）</span><br><span class="line">        stmt &#x3D; connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置传入参数</span><br><span class="line">        stmt.setString(1, &quot;zhangsan&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行SQL语句</span><br><span class="line">        rs &#x3D; stmt.executeQuery();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 处理查询结果（将查询结果转换成List&lt;Map&gt;格式）</span><br><span class="line">        ResultSetMetaData rsmd &#x3D; rs.getMetaData();</span><br><span class="line">        int num &#x3D; rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line">        while(rs.next())&#123;</span><br><span class="line">            Map map &#x3D; new HashMap();</span><br><span class="line">            for(int i &#x3D; 0;i &lt; num;i++)&#123;</span><br><span class="line">                String columnName &#x3D; rsmd.getColumnName(i+1);</span><br><span class="line">                map.put(columnName,rs.getString(columnName));</span><br><span class="line">            &#125;</span><br><span class="line">            resultList.add(map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 关闭结果集</span><br><span class="line">            if (rs !&#x3D; null) &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">                rs &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 关闭执行</span><br><span class="line">            if (stmt !&#x3D; null) &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">                stmt &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection !&#x3D; null) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">                connection &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDBC需要优化之处"><a href="#JDBC需要优化之处" class="headerlink" title="JDBC需要优化之处"></a>JDBC需要优化之处</h2><h3 id="连接获取和释放"><a href="#连接获取和释放" class="headerlink" title="连接获取和释放"></a>连接获取和释放</h3><p>1、 <strong>问题描述：</strong></p>
<p>数据库连接频繁的开启和关闭本身就造成了<strong>资源的浪费，影响系统的性能</strong> 。</p>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>数据库连接的获取和关闭我们<strong>可以使用数据库连接池来解决资源浪费的问题</strong> 。通过连接池就可以反复利用已经建立的连接去访问数据库了。减少连接的开启和关闭的时间。</p>
</blockquote>
<p>2、<strong>问题描述：</strong></p>
<p>但是现在<strong>连接池多种多样，可能存在变化</strong> ，有可能采用DBCP的连接池，也有可能采用容器本身的JNDI数据库连接池。</p>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>我们可以<strong>通过DataSource进行隔离解耦</strong> ，我们统一从DataSource里面获取数据库连接，<strong>DataSource具体由DBCP实现还是由容器的JNDI实现都可以</strong> ，所以我们将DataSource的具体实现通过让用户配置来应对变化。</p>
</blockquote>
<h3 id="SQL统一存取"><a href="#SQL统一存取" class="headerlink" title="SQL统一存取"></a>SQL统一存取</h3><p>1、<strong>问题描述：</strong></p>
<p>我们使用JDBC进行操作数据库时，<strong>SQL语句基本都散落在各个JAVA类中</strong> ，这样有三个不足之处：</p>
<blockquote>
<p>第一，可读性很差，不利于维护以及做性能调优。</p>
</blockquote>
<blockquote>
<p>第二，改动Java代码需要重新编译、打包部署。</p>
</blockquote>
<blockquote>
<p>第三，不利于取出SQL在数据库客户端执行（取出后还得删掉中间的Java代码，编写好的SQL语句写好后还得通过＋号在Java进行拼凑）。</p>
</blockquote>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>我们可以考虑不把SQL语句写到Java代码中，那么把SQL语句放到哪里呢？首先需要有一个统一存放的地方，我们可以将这些<strong>SQL语句统一集中放到配置文件或者数据库里面（以key-value的格式存放）</strong> 。然后通过SQL语句的key值去获取对应的SQL语句。</p>
</blockquote>
<blockquote>
<p>既然我们将SQL语句都统一放在配置文件或者数据库中，<strong>那么这里就涉及一个SQL语句的加载问题</strong> 。</p>
</blockquote>
<h3 id="第三步优化：传入参数映射和动态SQL"><a href="#第三步优化：传入参数映射和动态SQL" class="headerlink" title="第三步优化：传入参数映射和动态SQL"></a>第三步优化：传入参数映射和动态SQL</h3><p>1、<strong>问题描述：</strong></p>
<p>很多情况下，我们都可以通过在SQL语句中设置占位符来达到使用传入参数的目的，这种方式本身就有一定局限性，它是按照一定顺序传入参数的，要与占位符一一匹配。但是，如果我们<strong>传入的参数是不确定的</strong> （比如列表查询，根据用户填写的查询条件不同，传入查询的参数也是不同的，有时是一个参数、有时可能是三个参数），那么我们就得<strong>在后台代码中自己根据请求的传入参数去拼凑相应的SQL语句</strong> ，这样的话还是<strong>避免不了在Java代码里面写SQL语句的命运</strong> 。既然我们已经把SQL语句统一存放在配置文件或者数据库中了，<strong>怎么做到能够根据前台传入参数的不同，动态生成对应的SQL语句呢？</strong></p>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>第一，我们先解决这个动态问题，<strong>按照我们正常的程序员思维是，通过if和else这类的判断来进行是最直观的</strong> ，能不能将这类的标签引入到SQL语句中呢？假设可以，那么我们这里就需要一个专门的SQL解析器来解析这样的SQL语句，但是，if判断的变量来自于哪里呢？传入的值本身是可变的，那么我们得为这个值定义一个不变的变量名称，而且这个变量名称必须和对应的值要有对应关系，可以通过这个变量名称找到对应的值，这个时候我们想到了key-value的Map。解析的时候根据变量名的具体值来判断。</p>
</blockquote>
<blockquote>
<p>假如前面可以判断没有问题，那么假如判断的结果是true，那么就需要输出的标签里面的SQL片段，但是怎么解决在标签里面使用变量名称的问题呢？这里我们需要<strong>使用一种有别于SQL的语法来嵌入变量（比如使用＃变量名＃）</strong> 。这样，SQL语句经过解析后就可以动态的生成符合上下文的SQL语句。</p>
</blockquote>
<blockquote>
<p>还有，<strong>怎么区分开占位符变量和非占位变量？</strong> 有时候我们单单使用占位符是满足不了的，占位符只能为查询条件占位，SQL语句其他地方使用不了。<strong>这里我们可以使用#变量名#表示占位符变量，使用变量名表示非占位符变量</strong> 。</p>
</blockquote>
<h3 id="第四步优化：结果映射和结果缓存"><a href="#第四步优化：结果映射和结果缓存" class="headerlink" title="第四步优化：结果映射和结果缓存"></a>第四步优化：结果映射和结果缓存</h3><p>1、<strong>问题描述：</strong></p>
<p>执行SQL语句、获取执行结果、对执行结果进行转换处理、释放相关资源是一整套下来的。假如是执行查询语句，那么执行SQL语句后，返回的是一个ResultSet结果集，<strong>这个时候我们就需要将ResultSet对象的数据取出来，不然等到释放资源时就取不到这些结果信息了</strong> 。我们从前面的优化来看，以及将获取连接、设置传入参数、执行SQL语句、释放资源这些都封装起来了，只剩下结果处理这块还没有进行封装，如果能封装起来，每个数据库操作都不用自己写那么一大堆Java代码，直接调用一个封装的方法就可以搞定了。</p>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>我们分析一下，一般对执行结果的有哪些处理，<strong>有可能将结果不做任何处理就直接返回，也有可能将结果转换成一个JavaBean对象返回、一个Map返回、一个List返回等</strong> `，结果处理可能是多种多样的。从这里看，我们必须告诉SQL处理器两点：<strong>第一，需要返回什么类型的对象；第二，需要返回的对象的数据结构怎么跟执行的结果映射</strong> ，这样才能将具体的值copy到对应的数据结构上。</p>
</blockquote>
<blockquote>
<p>接下来，<strong>我们可以进而考虑对SQL执行结果的缓存来提升性能</strong> 。缓存数据都是key-value的格式，那么这个key怎么来呢？怎么保证唯一呢？即使同一条SQL语句几次访问的过程中由于传入参数的不同，得到的执行SQL语句也是不同的。那么缓存起来的时候是多对。<strong>但是SQL语句和传入参数两部分合起来可以作为数据缓存的key值</strong> 。</p>
</blockquote>
<h3 id="第五步优化：解决重复SQL语句问题"><a href="#第五步优化：解决重复SQL语句问题" class="headerlink" title="第五步优化：解决重复SQL语句问题"></a>第五步优化：解决重复SQL语句问题</h3><p>1、<strong>问题描述：</strong></p>
<p>由于我们将所有SQL语句都放到配置文件中，<strong>这个时候会遇到一个SQL重复的问题</strong> ，几个功能的SQL语句其实都差不多，有些可能是SELECT后面那段不同、有些可能是WHERE语句不同。有时候表结构改了，那么我们就需要改多个地方，不利于维护。</p>
<p><strong>解决问题：</strong></p>
<blockquote>
<p>当我们的代码程序出现重复代码时怎么办？<strong>将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用</strong> 。对于SQL重复的问题，我们也可以采用这种方式，通过将SQL片段模块化，<strong>将重复的SQL片段独立成一个SQL块，然后在各个SQL语句引用重复的SQL块</strong> ，这样需要修改时只需要修改一处即可。</p>
</blockquote>
<h2 id="Mybaits有待改进之处"><a href="#Mybaits有待改进之处" class="headerlink" title="Mybaits有待改进之处"></a>Mybaits有待改进之处</h2><p>1、<strong>问题描述：</strong></p>
<p>Mybaits所有的数据库操作都是基于SQL语句，<strong>导致什么样的数据库操作都要写SQL语句</strong> 。一个应用系统要写的SQL语句实在太多了。</p>
<p><strong>改进方法：</strong></p>
<p>我们对数据库进行的操作大部分都是对表数据的增删改查，很多都是对单表的数据进行操作，由这点我们可以想到一个问题：<strong>单表操作可不可以不写SQL语句，通过JavaBean的默认映射器生成对应的SQL语句</strong> ，比如：一个类UserInfo对应于USER_INFO表， userId属性对应于USER_ID字段。<strong>这样我们就可以通过反射可以获取到对应的表结构了，拼凑成对应的SQL语句显然不是问题</strong> 。</p>
<h2 id="MyBatis框架整体设计"><a href="#MyBatis框架整体设计" class="headerlink" title="MyBatis框架整体设计"></a>MyBatis框架整体设计</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpqQ3RfkR2a6WSvKG9JiawNZ3Ezl6UUP4cUrJicWD8Lxkwr36sc3q9ATJw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>MyBatis框架整体设计</p>
<h3 id="接口层-和数据库交互的方式"><a href="#接口层-和数据库交互的方式" class="headerlink" title="接口层-和数据库交互的方式"></a>接口层-和数据库交互的方式</h3><h4 id="方式1：MyBatis的传统API（废弃）"><a href="#方式1：MyBatis的传统API（废弃）" class="headerlink" title="方式1：MyBatis的传统API（废弃）"></a>方式1：MyBatis的传统API（废弃）</h4><p><strong>这是传统的传递Statement Id 和查询参数给 SqlSession 对象，使用 SqlSession对象完成和数据库的交互</strong> ；MyBatis提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作，以及对数据库连接信息和MyBatis 自身配置信息的维护操作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpynovGbEGB8UlwFxIcic6QjaibJ5pStaPtP8u7IaFehgyicLhajr1OAMJA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<blockquote>
<p>上述使用MyBatis 的方法，是<strong>创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库</strong> ，这种方式固然很简单和实用，但是<strong>它不符合面向对象语言的概念和面向接口编程的编程习惯</strong> 。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用MyBatis 支持接口（Interface）调用方式。</p>
</blockquote>
<h4 id="方式2：使用Mapper接口"><a href="#方式2：使用Mapper接口" class="headerlink" title="方式2：使用Mapper接口"></a>方式2：使用Mapper接口</h4><p><strong>MyBatis 将配置文件中的每一个节点抽象为一个 Mapper 接口：</strong></p>
<blockquote>
<p><strong>这个接口中声明的方法和节点中的&lt;select|update|delete|insert&gt; 节点项对应</strong> ，即&lt;select|update|delete|insert&gt; 节点的id值为Mapper 接口中的方法名称，<strong>parameterType 值表示Mapper 对应方法的入参类型</strong> ，而<strong>resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型</strong> 。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JprLuWsU1bUMrLQjkSZIUB6SNjk6KHUCPg5tCVoemHBth6aISwkg0tHw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<blockquote>
<p><strong>根据MyBatis 的配置规范配置好后，通过SqlSession.getMapper(XXXMapper.class)方法，MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个Mapper 实例</strong> ，我们使用Mapper接口的某一个方法时，MyBatis会根据这个方法的方法名和参数类型，确定Statement Id，底层还是通过SqlSession.select(“statementId”,parameterObject);或者SqlSession.update(“statementId”,parameterObject); 等等来实现对数据库的操作，<strong>MyBatis引用Mapper 接口这种调用方式，纯粹是为了满足面向接口编程的需要</strong> 。（其实还有一个原因是在于，面向接口的编程，使得用户在接口上可以使用注解来配置SQL语句，这样就可以脱离XML配置文件，实现“0配置”）。</p>
</blockquote>
<h3 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h3><p><strong>数据处理层可以说是MyBatis的核心</strong> ，从大的方面上讲，它要完成两个功能：</p>
<blockquote>
<ol>
<li>通过传入参数构建动态SQL语句；</li>
<li>SQL语句的执行以及封装查询结果集成List；</li>
</ol>
</blockquote>
<h4 id="参数映射和动态SQL语句生成"><a href="#参数映射和动态SQL语句生成" class="headerlink" title="参数映射和动态SQL语句生成"></a>参数映射和动态SQL语句生成</h4><p>动态语句生成可以说是MyBatis框架非常优雅的一个设计，<strong>MyBatis 通过传入的参数值，使用 Ognl 来动态地构造SQL语句</strong> ，使得MyBatis 有很强的灵活性和扩展性。</p>
<p><strong>参数映射指的是对于java 数据类型和jdbc数据类型之间的转换：</strong> 这里有包括两个过程：<strong>查询阶段</strong> ，我们要将java类型的数据，转换成jdbc类型的数据，通过 preparedStatement.setXXX() 来设值；另一个就是<strong>对resultset查询结果集的jdbcType 数据转换成java 数据类型</strong> 。</p>
<h4 id="SQL语句的执行以及封装查询结果集成List"><a href="#SQL语句的执行以及封装查询结果集成List" class="headerlink" title="SQL语句的执行以及封装查询结果集成List"></a>SQL语句的执行以及封装查询结果集成List</h4><p>动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List列表。<strong>MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换</strong> ，并且有两种支持方式，<strong>一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询</strong> 。</p>
<h3 id="框架支撑层"><a href="#框架支撑层" class="headerlink" title="框架支撑层"></a>框架支撑层</h3><p>1、事务管理机制</p>
<p><strong>事务管理机制对于ORM框架而言是不可缺少的一部分</strong> ，事务管理机制的质量也是考量一个ORM框架是否优秀的一个标准。</p>
<p>2、连接池管理机制</p>
<p>由于创建一个数据库连接所占用的资源比较大，<strong>对于数据吞吐量大和访问量非常大的应用而言，连接池的设计就显得非常重要</strong> 。</p>
<p>3、缓存机制</p>
<p>为了提高数据利用率和减小服务器和数据库的压力，<strong>MyBatis 会对于一些查询提供会话级别的数据缓存</strong> ，会将对某一次查询，放置到SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis会直接将缓存结果返回给用户，而不用再到数据库中查找。</p>
<p>4、SQL语句的配置方式</p>
<p>传统的MyBatis 配置SQL语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，<strong>为了支持面向接口的编程，MyBatis 引入了Mapper接口的概念，面向接口的引入，对使用注解来配置SQL语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了</strong> ，但是，目前的MyBatis 只是对注解配置SQL语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。</p>
<h3 id="5-4-引导层"><a href="#5-4-引导层" class="headerlink" title="5.4 引导层"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">5.4 引导层</a></h3><p><strong>引导层是配置和启动MyBatis配置信息的方式</strong> 。MyBatis 提供两种方式来引导MyBatis ：<strong>基于XML配置文件的方式和基于Java API 的方式</strong>。</p>
<h3 id="5-5-主要构件及其相互关系"><a href="#5-5-主要构件及其相互关系" class="headerlink" title="5.5 主要构件及其相互关系"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">5.5 主要构件及其相互关系</a></h3><p>从MyBatis代码实现的角度来看，MyBatis的主要的核心部件有以下几个：</p>
<blockquote>
<p><strong>SqlSession：</strong> 作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能；</p>
<p><strong>Executor：</strong> MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护；</p>
<p><strong>StatementHandler：</strong> 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。</p>
<p><strong>ParameterHandler：</strong> 负责对用户传递的参数转换成JDBC Statement 所需要的参数；</p>
<p><strong>ResultSetHandler：</strong> 负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</p>
<p><strong>TypeHandler：</strong> 负责java数据类型和jdbc数据类型之间的映射和转换；</p>
<p><strong>MappedStatement：</strong> MappedStatement维护了一条&lt;select|update|delete|insert&gt;节点的封装；</p>
<p><strong>SqlSource：</strong> 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回；</p>
<p><strong>BoundSql：</strong> 表示动态生成的SQL语句以及相应的参数信息；</p>
<p><strong>Configuration：</strong> MyBatis所有的配置信息都维持在Configuration对象之中；</p>
</blockquote>
<p><strong>它们的关系如下图所示：</strong></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpF41DhLROCCDSw4J8fgRYk56wOvDsf7FxUkaQ7OzThb9QFAjqjLnNWA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>MyBatis主要构件关系如图</p>
<h2 id="6-SqlSession工作过程分析"><a href="#6-SqlSession工作过程分析" class="headerlink" title="6 SqlSession工作过程分析"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">6 SqlSession工作过程分析</a></h2><p>1、<strong>开启一个数据库访问会话—创建SqlSession对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession &#x3D; factory.openSession();</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></a></p>
<p>MyBatis封装了对数据库的访问，把对数据库的会话和事务控制放到了SqlSession对象中</p>
<p>2、<strong>为SqlSession传递一个配置的Sql语句的Statement Id和参数，然后返回结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; result &#x3D; sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;,params);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述的”com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary”，是配置在EmployeesMapper.xml 的Statement ID，params是传递的查询参数。</p>
</blockquote>
<p>让我们来看一下sqlSession.selectList()方法的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123;</span><br><span class="line">    return this.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;1.根据Statement Id，在mybatis 配置对象Configuration中查找和配置文件相对应的MappedStatement</span><br><span class="line">        MappedStatement ms &#x3D; configuration.getMappedStatement(statement);</span><br><span class="line">        &#x2F;&#x2F;2. 将查询任务委托给MyBatis 的执行器 Executor</span><br><span class="line">        List&lt;E&gt; result &#x3D; executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MyBatis在初始化的时候，会将MyBatis的配置信息全部加载到内存中，<strong>使用org.apache.ibatis.session.Configuration实例来维护</strong> 。使用者可以使用sqlSession.getConfiguration()方法来获取。<strong>MyBatis的配置文件中配置信息的组织格式和内存中对象的组织格式几乎完全对应的</strong> 。</p>
</blockquote>
<p>上述例子中的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectByMinSalary&quot; resultMap&#x3D;&quot;BaseResultMap&quot; parameterType&#x3D;&quot;java.util.Map&quot; &gt;</span><br><span class="line">   select</span><br><span class="line">       EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY</span><br><span class="line">   from LOUIS.EMPLOYEES</span><br><span class="line">   &lt;if test&#x3D;&quot;min_salary !&#x3D; null&quot;&gt;</span><br><span class="line">       where SALARY &lt; #&#123;min_salary,jdbcType&#x3D;DECIMAL&#125;</span><br><span class="line">   &lt;&#x2F;if&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>加载到内存中会生成一个对应的MappedStatement对象，然后会以key=”com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary” ，value为MappedStatement对象的形式维护到Configuration的一个Map中</strong> 。当以后需要使用的时候，只需要通过Id值来获取就可以了。</p>
</blockquote>
<p>从上述的代码中我们可以看到SqlSession的职能是：<strong>SqlSession根据Statement ID, 在mybatis配置对象Configuration中获取到对应的MappedStatement对象，然后调用mybatis执行器来执行具体的操作</strong> 。</p>
<p>3、<strong>MyBatis执行器Executor根据SqlSession传递的参数执行query()方法（由于代码过长，读者只需阅读我注释的地方即可）：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * BaseExecutor 类部分代码</span><br><span class="line">   *</span><br><span class="line">   *&#x2F;</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">      &#x2F;&#x2F; 1. 根据具体传入的参数，动态地生成需要执行的SQL语句，用BoundSql对象表示</span><br><span class="line">      BoundSql boundSql &#x3D; ms.getBoundSql(parameter);</span><br><span class="line">      &#x2F;&#x2F; 2. 为当前的查询创建一个缓存Key</span><br><span class="line">      CacheKey key &#x3D; createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">      return query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">       ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());</span><br><span class="line">       if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">       if (queryStack &#x3D;&#x3D; 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">           clearLocalCache();</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;E&gt; list;</span><br><span class="line">       try &#123;</span><br><span class="line">           queryStack++;</span><br><span class="line">           list &#x3D; resultHandler &#x3D;&#x3D; null ? (List&lt;E&gt;) localCache.getObject(key) : null;</span><br><span class="line">           if (list !&#x3D; null) &#123;</span><br><span class="line">               handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; 3.缓存中没有值，直接从数据库中读取数据</span><br><span class="line">               list &#x3D; queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           queryStack--;</span><br><span class="line">       &#125;</span><br><span class="line">       if (queryStack &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           for (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">               deferredLoad.load();</span><br><span class="line">           &#125;</span><br><span class="line">           deferredLoads.clear(); &#x2F;&#x2F; issue #601</span><br><span class="line">           if (configuration.getLocalCacheScope() &#x3D;&#x3D; LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">               clearLocalCache(); &#x2F;&#x2F; issue #482</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">      List&lt;E&gt; list;</span><br><span class="line">      localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;4. 执行查询，返回List 结果，然后    将查询的结果放入缓存之中</span><br><span class="line">          list &#x3D; doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          localCache.removeObject(key);</span><br><span class="line">      &#125;</span><br><span class="line">      localCache.putObject(key, list);</span><br><span class="line">      if (ms.getStatementType() &#x3D;&#x3D; StatementType.CALLABLE) &#123;</span><br><span class="line">          localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">      &#125;</span><br><span class="line">      return list;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">   *</span><br><span class="line">   * SimpleExecutor类的doQuery()方法实现</span><br><span class="line">   *</span><br><span class="line">   *&#x2F;</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">      Statement stmt &#x3D; null;</span><br><span class="line">      try &#123;</span><br><span class="line">          Configuration configuration &#x3D; ms.getConfiguration();</span><br><span class="line">          &#x2F;&#x2F;5. 根据既有的参数，创建StatementHandler对象来执行查询操作</span><br><span class="line">          StatementHandler handler &#x3D; configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">          &#x2F;&#x2F;6. 创建java.Sql.Statement对象，传递给StatementHandler对象</span><br><span class="line">          stmt &#x3D; prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">          &#x2F;&#x2F;7. 调用StatementHandler.query()方法，返回List结果集</span><br><span class="line">          return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           closeStatement(stmt);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的Executor.query()方法几经转折，<strong>最后会创建一个StatementHandler对象，然后将必要的参数传递给StatementHandler</strong> ，使用StatementHandler来完成对数据库的查询，最终返回List结果集。</p>
<p><strong>从上面的代码中我们可以看出，Executor的功能和作用是：</strong></p>
<blockquote>
<ol>
<li>根据传递的参数，完成SQL语句的动态解析，生成BoundSql对象，供StatementHandler使用；</li>
<li>为查询创建缓存，以提高性能；</li>
<li>创建JDBC的Statement连接对象，传递给StatementHandler对象，返回List查询结果；</li>
</ol>
</blockquote>
<p>4、<strong>StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回：</strong></p>
<p>接着上面的Executor第六步，看一下：prepareStatement() 方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   *</span><br><span class="line">   * SimpleExecutor类的doQuery()方法实现</span><br><span class="line">   *</span><br><span class="line">   *&#x2F;</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">      Statement stmt &#x3D; null;</span><br><span class="line">      try &#123;</span><br><span class="line">          Configuration configuration &#x3D; ms.getConfiguration();</span><br><span class="line">          StatementHandler handler &#x3D; configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">          &#x2F;&#x2F; 1.准备Statement对象，并设置Statement对象的参数</span><br><span class="line">          stmt &#x3D; prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">          &#x2F;&#x2F; 2. StatementHandler执行query()方法，返回List结果</span><br><span class="line">          return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          closeStatement(stmt);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">      Statement stmt;</span><br><span class="line">      Connection connection &#x3D; getConnection(statementLog);</span><br><span class="line">      stmt &#x3D; handler.prepare(connection);</span><br><span class="line">      &#x2F;&#x2F;对创建的Statement对象设置参数，即设置SQL 语句中 ? 设置为指定的参数</span><br><span class="line">      handler.parameterize(stmt);</span><br><span class="line">      return stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上我们可以总结StatementHandler对象主要完成两个工作：</p>
<blockquote>
<ol>
<li>对于JDBC的PreparedStatement类型的对象，创建的过程中，我们使用的是SQL语句字符串会包含 若干个? 占位符，我们其后再对占位符进行设值。<strong>StatementHandler通过parameterize(statement)方法对Statement进行设值；</strong></li>
<li>StatementHandler通过Listquery(Statement statement, ResultHandler resultHandler)方法来完成执行Statement，和将Statement对象返回的resultSet封装成List；</li>
</ol>
</blockquote>
<p>5、<strong>StatementHandler 的parameterize(statement) 方法的实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * StatementHandler 类的parameterize(statement) 方法实现</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void parameterize(Statement statement) throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用ParameterHandler对象来完成对Statement的设值</span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">   *</span><br><span class="line">   * ParameterHandler类的setParameters(PreparedStatement ps) 实现</span><br><span class="line">   * 对某一个Statement进行设置参数</span><br><span class="line">   *&#x2F;</span><br><span class="line">public void setParameters(PreparedStatement ps) throws SQLException &#123;</span><br><span class="line">      ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">      List&lt;ParameterMapping&gt; parameterMappings &#x3D; boundSql.getParameterMappings();</span><br><span class="line">      if (parameterMappings !&#x3D; null) &#123;</span><br><span class="line">          for (int i &#x3D; 0; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">              ParameterMapping parameterMapping &#x3D; parameterMappings.get(i);</span><br><span class="line">              if (parameterMapping.getMode() !&#x3D; ParameterMode.OUT) &#123;</span><br><span class="line">                  Object value;</span><br><span class="line">                  String propertyName &#x3D; parameterMapping.getProperty();</span><br><span class="line">                  if (boundSql.hasAdditionalParameter(propertyName)) &#123; &#x2F;&#x2F; issue #448 ask first for additional params</span><br><span class="line">                      value &#x3D; boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                  &#125; else if (parameterObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">                      value &#x3D; null;</span><br><span class="line">                  &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                      value &#x3D; parameterObject;</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      MetaObject metaObject &#x3D; configuration.newMetaObject(parameterObject);</span><br><span class="line">                      value &#x3D; metaObject.getValue(propertyName);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  &#x2F;&#x2F; 每一个Mapping都有一个TypeHandler，根据TypeHandler来对preparedStatement进行设置参数</span><br><span class="line">                  TypeHandler typeHandler &#x3D; parameterMapping.getTypeHandler();</span><br><span class="line">                  JdbcType jdbcType &#x3D; parameterMapping.getJdbcType();</span><br><span class="line">                  if (value &#x3D;&#x3D; null &amp;&amp; jdbcType &#x3D;&#x3D; null) jdbcType &#x3D; configuration.getJdbcTypeForNull();</span><br><span class="line">                  &#x2F;&#x2F; 设置参数</span><br><span class="line">                  typeHandler.setParameter(ps, i + 1, value, jdbcType);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上述的代码可以看到,StatementHandler的parameterize(Statement) 方法调用了 ParameterHandler的setParameters(statement) 方法，<strong>ParameterHandler的setParameters(Statement)方法负责 根据我们输入的参数，对statement对象的 ? 占位符处进行赋值。</strong></p>
</blockquote>
<p>6、<strong>StatementHandler 的Listquery(Statement statement, ResultHandler resultHandler)方法的实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">    * PreParedStatement类的query方法实现</span><br><span class="line">    *&#x2F;</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">      &#x2F;&#x2F;1.调用preparedStatemnt。execute()方法，然后将resultSet交给ResultSetHandler处理</span><br><span class="line">      PreparedStatement ps &#x3D; (PreparedStatement) statement;</span><br><span class="line">      ps.execute();</span><br><span class="line">      &#x2F;&#x2F;2. 使用ResultHandler来处理ResultSet</span><br><span class="line">      return resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上述代码我们可以看出，StatementHandler 的Listquery(Statement statement, ResultHandler resultHandler)方法的实现，是调用了ResultSetHandler的handleResultSets(Statement) 方法。<strong>ResultSetHandler的handleResultSets(Statement) 方法会将Statement语句执行后生成的resultSet 结果集转换成List结果集</strong> ：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * ResultSetHandler类的handleResultSets()方法实现</span><br><span class="line">   *</span><br><span class="line">   *&#x2F;</span><br><span class="line">public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123;</span><br><span class="line">      final List&lt;Object&gt; multipleResults &#x3D; new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">      int resultSetCount &#x3D; 0;</span><br><span class="line">      ResultSetWrapper rsw &#x3D; getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">      List&lt;ResultMap&gt; resultMaps &#x3D; mappedStatement.getResultMaps();</span><br><span class="line">      int resultMapCount &#x3D; resultMaps.size();</span><br><span class="line">      validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line"></span><br><span class="line">      while (rsw !&#x3D; null &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">          ResultMap resultMap &#x3D; resultMaps.get(resultSetCount);</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;将resultSet</span><br><span class="line">          handleResultSet(rsw, resultMap, multipleResults, null);</span><br><span class="line">          rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">          cleanUpAfterHandlingResultSet();</span><br><span class="line">          resultSetCount++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String[] resultSets &#x3D; mappedStatement.getResulSets();</span><br><span class="line">      if (resultSets !&#x3D; null) &#123;</span><br><span class="line">          while (rsw !&#x3D; null &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">              ResultMapping parentMapping &#x3D; nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">              if (parentMapping !&#x3D; null) &#123;</span><br><span class="line">                  String nestedResultMapId &#x3D; parentMapping.getNestedResultMapId();</span><br><span class="line">                  ResultMap resultMap &#x3D; configuration.getResultMap(nestedResultMapId);</span><br><span class="line">                  handleResultSet(rsw, resultMap, null, parentMapping);</span><br><span class="line">              &#125;</span><br><span class="line">              rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">              cleanUpAfterHandlingResultSet();</span><br><span class="line">              resultSetCount++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MyBatis初始化机制"><a href="#MyBatis初始化机制" class="headerlink" title="MyBatis初始化机制"></a>MyBatis初始化机制</h2><h3 id="MyBatis的初始化做了什么"><a href="#MyBatis的初始化做了什么" class="headerlink" title="MyBatis的初始化做了什么"></a>MyBatis的初始化做了什么</h3><p><strong>任何框架的初始化，无非是加载自己运行时所需要的配置信息。</strong> MyBatis的配置信息，大概包含以下信息，其高层级结构如下：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6Jpd0YczNFt9C59JO4a4N7wErMlEoeXhwXFfdicyUCQmED8waP5pCpw1Lw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>MyBatis配置信息结构图</p>
<p><strong>MyBatis的上述配置信息会配置在XML配置文件中，那么，这些信息被加载进入MyBatis内部，MyBatis是怎样维护的呢？</strong></p>
<p>MyBatis采用了一个非常直白和简单的方式—<strong>使用 org.apache.ibatis.session.Configuration对象作为一个所有配置信息的容器，Configuration对象的组织结构和XML配置文件的组织结构几乎完全一样</strong> （当然，Configuration对象的功能并不限于此，它还负责创建一些MyBatis内部使用的对象，如Executor等，这将在后续的文章中讨论）。如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpBne4eIxEggmH7EgW8L4AOOA8TKk94zQjlxurPjGkhaDnN6T2cJSQnA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>Configuration对象的组织结构和XML配置文件的组织结构几乎完全一样</p>
<p>MyBatis根据初始化好Configuration信息，这时候用户就可以使用MyBatis进行数据库操作了。<strong>可以这么说，MyBatis初始化的过程，就是创建 Configuration对象的过程</strong> 。</p>
<p><strong>MyBatis的初始化可以有两种方式：</strong></p>
<blockquote>
<p><strong>基于XML配置文件：</strong> 基于XML配置文件的方式是将MyBatis的所有配置信息放在XML文件中，MyBatis通过加载并XML配置文件，将配置文信息组装成内部的Configuration对象。</p>
<p><strong>基于Java API：</strong> 这种方式不使用XML配置文件，需要MyBatis使用者在Java代码中，手动创建Configuration对象，然后将配置参数set 进入Configuration对象中。</p>
</blockquote>
<p>接下来我们将通过 基于XML配置文件方式的MyBatis初始化，深入探讨MyBatis是如何通过配置文件构建Configuration对象，并使用它。</p>
<h3 id="7-2-基于XML配置文件创建Configuration对象"><a href="#7-2-基于XML配置文件创建Configuration对象" class="headerlink" title="7.2 基于XML配置文件创建Configuration对象"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">7.2 基于XML配置文件创建Configuration对象</a></h3><p>现在就从使用MyBatis的简单例子入手，深入分析一下MyBatis是怎样完成初始化的，都初始化了什么。看以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">List list &#x3D; sqlSession.selectList(&quot;com.foo.bean.BlogMapper.queryAllBlogInfo&quot;);</span><br></pre></td></tr></table></figure>

<p>有过MyBatis使用经验的读者会知道，上述语句的作用是执行com.foo.bean.BlogMapper.queryAllBlogInfo 定义的SQL语句，返回一个List结果集。总的来说，上述代码经历了<strong>mybatis初始化 –&gt;创建SqlSession –&gt;执行SQL语句</strong> 返回结果三个过程。</p>
<p>上述代码的功能是根据配置文件mybatis-config.xml  配置文件，创建SqlSessionFactory对象，然后产生SqlSession，执行SQL语句。<strong>而mybatis的初始化就发生在第三句：SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</strong> 现在就让我们看看第三句到底发生了什么。</p>
<p>1、<strong>MyBatis初始化基本过程：</strong></p>
<p>SqlSessionFactoryBuilder根据传入的数据流生成Configuration对象，然后根据Configuration对象创建默认的SqlSessionFactory实例。</p>
<p><strong>初始化的基本过程如下序列图所示：</strong></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpFl85Ij5u2Enx13oHBe8Mco8Lojteth36c9JGsxMmncYZnWamaT3R1g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>MyBatis初始化序列图</p>
<p><strong>由上图所示，mybatis初始化要经过简单的以下几步：</strong></p>
<blockquote>
<ol>
<li>调用SqlSessionFactoryBuilder对象的build(inputStream)方法；</li>
<li>SqlSessionFactoryBuilder会根据输入流inputStream等信息创建XMLConfigBuilder对象;</li>
<li>SqlSessionFactoryBuilder调用XMLConfigBuilder对象的parse()方法；</li>
<li>XMLConfigBuilder对象返回Configuration对象；</li>
<li>SqlSessionFactoryBuilder根据Configuration对象创建一个DefaultSessionFactory对象；</li>
<li>SqlSessionFactoryBuilder返回 DefaultSessionFactory对象给Client，供Client使用。</li>
</ol>
</blockquote>
<p><strong>SqlSessionFactoryBuilder相关的代码如下所示：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream)  &#123;</span><br><span class="line">      return build(inputStream, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties)  &#123;</span><br><span class="line">      try  &#123;</span><br><span class="line">          &#x2F;&#x2F;2. 创建XMLConfigBuilder对象用来解析XML配置文件，生成Configuration对象</span><br><span class="line">          XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">          &#x2F;&#x2F;3. 将XML配置文件内的信息解析成Java对象Configuration对象</span><br><span class="line">          Configuration config &#x3D; parser.parse();</span><br><span class="line">          &#x2F;&#x2F;4. 根据Configuration对象创建出SqlSessionFactory对象</span><br><span class="line">          return build(config);</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">          try &#123;</span><br><span class="line">              inputStream.close();</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              &#x2F;&#x2F; Intentionally ignore. Prefer previous error.</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从此处可以看出，MyBatis内部通过Configuration对象来创建SqlSessionFactory,用户也可以自己通过API构造好Configuration对象，调用此方法创SqlSessionFactory</span><br><span class="line">public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">      return new DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的初始化过程中，涉及到了以下几个对象：</p>
<blockquote>
<p><strong>SqlSessionFactoryBuilder ：</strong> SqlSessionFactory的构造器，用于创建SqlSessionFactory，采用了Builder设计模式</p>
<p><strong>Configuration ：</strong> 该对象是mybatis-config.xml文件中所有mybatis配置信息</p>
<p><strong>SqlSessionFactory：</strong> SqlSession工厂类，以工厂形式创建SqlSession对象，采用了Factory工厂设计模式</p>
<p><strong>XMLConfigBuilder ：</strong> 负责将mybatis-config.xml配置文件解析成Configuration对象，共SqlSessonFactoryBuilder使用，创建SqlSessionFactory</p>
</blockquote>
<p>2、<strong>创建Configuration对象的过程：</strong>接着上述的 MyBatis初始化基本过程讨论，<strong>当SqlSessionFactoryBuilder执行build()方法，调用了XMLConfigBuilder的parse()方法，然后返回了Configuration对象</strong> 。那么parse()方法是如何处理XML文件，生成Configuration对象的呢？</p>
<ul>
<li><p>（1）XMLConfigBuilder会<strong>将XML配置文件的信息转换为Document对象</strong> ，而XML配置定义文件<strong>DTD转换成XMLMapperEntityResolver对象</strong> ，然后<strong>将二者封装到XpathParser对象中，XpathParser的作用是提供根据Xpath表达式获取基本的DOM节点Node信息的操作</strong> 。如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcmJrnAR0p2MdhNlO89s6JpsnGfGA3ozcXt7xDJE76icYA9Y9QOvGb3H5JRjvHwiaN04jW1MNvgeicrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></a></p>
<p>XpathParser组成结构图和生成图</p>
</li>
<li><p>（2）之后XMLConfigBuilder调用parse()方法：<strong>会从XPathParser中取出节点对应的Node对象，然后解析此Node节点的子Node</strong> ：properties, settings, typeAliases,typeHandlers, objectFactory, objectWrapperFactory, plugins, environments,databaseIdProvider, mappers：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() &#123;</span><br><span class="line">     if (parsed) &#123;</span><br><span class="line">         throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     parsed &#x3D; true;</span><br><span class="line">     &#x2F;&#x2F;源码中没有这一句，只有parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br><span class="line">     &#x2F;&#x2F;为了让读者看得更明晰，源码拆分为以下两句</span><br><span class="line">     XNode configurationNode &#x3D; parser.evalNode(&quot;&#x2F;configuration&quot;);</span><br><span class="line">     parseConfiguration(configurationNode);</span><br><span class="line">     return configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * 解析 &quot;&#x2F;configuration&quot;节点下的子节点信息，然后将解析的结果设置到Configuration对象中</span><br><span class="line">  *&#x2F;</span><br><span class="line">private void parseConfiguration(XNode root) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         &#x2F;&#x2F;1.首先处理properties 节点</span><br><span class="line">         propertiesElement(root.evalNode(&quot;properties&quot;)); &#x2F;&#x2F;issue #117 read properties first</span><br><span class="line">         &#x2F;&#x2F;2.处理typeAliases</span><br><span class="line">         typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">         &#x2F;&#x2F;3.处理插件</span><br><span class="line">         pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">         &#x2F;&#x2F;4.处理objectFactory</span><br><span class="line">         objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">         &#x2F;&#x2F;5.objectWrapperFactory</span><br><span class="line">         objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">         &#x2F;&#x2F;6.settings</span><br><span class="line">         settingsElement(root.evalNode(&quot;settings&quot;));</span><br><span class="line">         &#x2F;&#x2F;7.处理environments</span><br><span class="line">         environmentsElement(root.evalNode(&quot;environments&quot;)); &#x2F;&#x2F; read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">         &#x2F;&#x2F;8.database</span><br><span class="line">         databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">         &#x2F;&#x2F;9.typeHandlers</span><br><span class="line">         typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">         &#x2F;&#x2F;10.mappers</span><br><span class="line">         mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意：在上述代码中，还有一个非常重要的地方，<strong>就是解析XML配置文件子节点的方法mapperElements(root.evalNode(“mappers”)), 它将解析我们配置的Mapper.xml配置文件，Mapper配置文件可以说是MyBatis的核心</strong> ，MyBatis的特性和理念都体现在此Mapper的配置和设计上。</p>
<ul>
<li><p>（3）<strong>然后将这些值解析出来设置到Configuration对象中：</strong></p>
<p>解析子节点的过程这里就不一一介绍了，用户可以参照MyBatis源码仔细揣摩，<strong>我们就看上述的environmentsElement(root.evalNode(“environments”)); 方法是如何将environments的信息解析出来，设置到Configuration对象中的：</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * 解析environments节点，并将结果设置到Configuration对象中</span><br><span class="line">  * 注意：创建envronment时，如果SqlSessionFactoryBuilder指定了特定的环境（即数据源）；</span><br><span class="line">  *      则返回指定环境（数据源）的Environment对象，否则返回默认的Environment对象；</span><br><span class="line">  *      这种方式实现了MyBatis可以连接多数据源</span><br><span class="line">  *&#x2F;</span><br><span class="line">private void environmentsElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">         if (environment &#x3D;&#x3D; null)</span><br><span class="line">         &#123;</span><br><span class="line">             environment &#x3D; context.getStringAttribute(&quot;default&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         for (XNode child : context.getChildren())</span><br><span class="line">         &#123;</span><br><span class="line">              String id &#x3D; child.getStringAttribute(&quot;id&quot;);</span><br><span class="line">              if (isSpecifiedEnvironment(id))</span><br><span class="line">              &#123;</span><br><span class="line">                  &#x2F;&#x2F;1.创建事务工厂 TransactionFactory</span><br><span class="line">                  TransactionFactory txFactory &#x3D; transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));</span><br><span class="line">                  DataSourceFactory dsFactory &#x3D; dataSourceElement(child.evalNode(&quot;dataSource&quot;));</span><br><span class="line">                  &#x2F;&#x2F;2.创建数据源DataSource</span><br><span class="line">                  DataSource dataSource &#x3D; dsFactory.getDataSource();</span><br><span class="line">                  &#x2F;&#x2F;3. 构造Environment对象</span><br><span class="line">                  Environment.Builder environmentBuilder &#x3D; new Environment.Builder(id)</span><br><span class="line">             .transactionFactory(txFactory)</span><br><span class="line">             .dataSource(dataSource);</span><br><span class="line">                  &#x2F;&#x2F;4. 将创建的Envronment对象设置到configuration 对象中</span><br><span class="line">                  configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private boolean isSpecifiedEnvironment(String id)</span><br><span class="line">&#123;</span><br><span class="line">      if (environment &#x3D;&#x3D; null)</span><br><span class="line">      &#123;</span><br><span class="line">           throw new BuilderException(&quot;No environment specified.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (id &#x3D;&#x3D; null)</span><br><span class="line">      &#123;</span><br><span class="line">           throw new BuilderException(&quot;Environment requires an id attribute.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (environment.equals(id))</span><br><span class="line">      &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>（4）<strong>返回Configuration对象：</strong></p>
<p>将上述的MyBatis初始化基本过程的序列图细化：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></a></p>
<p>基于XML配置创建Configuration对象的过程</p>
</li>
</ul>
<h3 id="7-3-基于Java-API手动加载XML配置文件创建Configuration对象，并使用SqlSessionFactory对象"><a href="#7-3-基于Java-API手动加载XML配置文件创建Configuration对象，并使用SqlSessionFactory对象" class="headerlink" title="7.3 基于Java API手动加载XML配置文件创建Configuration对象，并使用SqlSessionFactory对象##"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">7.3 基于Java API手动加载XML配置文件创建Configuration对象，并使用SqlSessionFactory对象##</a></h3><p>我们可以使用XMLConfigBuilder手动解析XML配置文件来创建Configuration对象，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">&#x2F;&#x2F; 手动创建XMLConfigBuilder，并解析创建Configuration对象</span><br><span class="line">XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, null,null);</span><br><span class="line">Configuration configuration&#x3D;parse();</span><br><span class="line">&#x2F;&#x2F; 使用Configuration对象创建SqlSessionFactory</span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(configuration);</span><br><span class="line">&#x2F;&#x2F; 使用MyBatis</span><br><span class="line">SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">List list &#x3D; sqlSession.selectList(&quot;com.foo.bean.BlogMapper.queryAllBlogInfo&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="7-4-涉及到的设计模式"><a href="#7-4-涉及到的设计模式" class="headerlink" title="7.4 涉及到的设计模式"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">7.4 涉及到的设计模式</a></h3><p>初始化的过程涉及到创建各种对象，所以会使用一些创建型的设计模式。<strong>在初始化的过程中，Builder模式运用的比较多</strong> 。</p>
<h4 id="7-4-1-Builder模式应用1：SqlSessionFactory的创建"><a href="#7-4-1-Builder模式应用1：SqlSessionFactory的创建" class="headerlink" title="7.4.1 Builder模式应用1：SqlSessionFactory的创建"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">7.4.1 Builder模式应用1：SqlSessionFactory的创建</a></h4><p>对于创建SqlSessionFactory时，会<strong>根据情况提供不同的参数，其参数组合可以有以下几种</strong> ：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></a></p>
<p>根据情况提供不同的参数，创建SqlSessionFactory</p>
<p>由于构造时参数不定，可以为其创建一个构造器Builder，<strong>将SqlSessionFactory的构建过程和表示分开</strong> ：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></a></p>
<p>MyBatis将SqlSessionFactoryBuilder和SqlSessionFactory相互独立</p>
<h4 id="7-4-2-Builder模式应用2：数据库连接环境Environment对象的创建"><a href="#7-4-2-Builder模式应用2：数据库连接环境Environment对象的创建" class="headerlink" title="7.4.2 Builder模式应用2：数据库连接环境Environment对象的创建"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">7.4.2 Builder模式应用2：数据库连接环境Environment对象的创建</a></h4><p>在构建Configuration对象的过程中，XMLConfigBuilder解析 mybatis XML配置文件节点节点时，会有以下相应的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void environmentsElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context !&#x3D; null) &#123;</span><br><span class="line">        if (environment &#x3D;&#x3D; null) &#123;</span><br><span class="line">            environment &#x3D; context.getStringAttribute(&quot;default&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (XNode child : context.getChildren()) &#123;</span><br><span class="line">            String id &#x3D; child.getStringAttribute(&quot;id&quot;);</span><br><span class="line">            &#x2F;&#x2F;是和默认的环境相同时，解析之</span><br><span class="line">            if (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">                TransactionFactory txFactory &#x3D; transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));</span><br><span class="line">                DataSourceFactory dsFactory &#x3D; dataSourceElement(child.evalNode(&quot;dataSource&quot;));</span><br><span class="line">                DataSource dataSource &#x3D; dsFactory.getDataSource();</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;使用了Environment内置的构造器Builder，传递id 事务工厂和数据源</span><br><span class="line">                Environment.Builder environmentBuilder &#x3D; new Environment.Builder(id)</span><br><span class="line">                .transactionFactory(txFactory)</span><br><span class="line">                .dataSource(dataSource);</span><br><span class="line">                configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Environment内部，定义了静态内部Builder类：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public final class Environment &#123;</span><br><span class="line">    private final String id;</span><br><span class="line">    private final TransactionFactory transactionFactory;</span><br><span class="line">    private final DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    public Environment(String id, TransactionFactory transactionFactory, DataSource dataSource) &#123;</span><br><span class="line">        if (id &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Parameter &#39;id&#39; must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (transactionFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Parameter &#39;transactionFactory&#39; must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        if (dataSource &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Parameter &#39;dataSource&#39; must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.transactionFactory &#x3D; transactionFactory;</span><br><span class="line">        this.dataSource &#x3D; dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        private String id;</span><br><span class="line">        private TransactionFactory transactionFactory;</span><br><span class="line">        private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">        public Builder(String id) &#123;</span><br><span class="line">            this.id &#x3D; id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder transactionFactory(TransactionFactory transactionFactory) &#123;</span><br><span class="line">            this.transactionFactory &#x3D; transactionFactory;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder dataSource(DataSource dataSource) &#123;</span><br><span class="line">            this.dataSource &#x3D; dataSource;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String id() &#123;</span><br><span class="line">            return this.id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Environment build() &#123;</span><br><span class="line">            return new Environment(this.id, this.transactionFactory, this.dataSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TransactionFactory getTransactionFactory() &#123;</span><br><span class="line">        return this.transactionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DataSource getDataSource() &#123;</span><br><span class="line">        return this.dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/18/database/Mybatis/mybatis-01-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/" data-id="cm6lsyz560011k2dlbkts3mhi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-中间件/Kafka/kafka-分析与调优-02-服务宕机引发高可用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-02-%E6%9C%8D%E5%8A%A1%E5%AE%95%E6%9C%BA%E5%BC%95%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8/" class="article-date">
  <time datetime="2021-06-17T05:53:27.000Z" itemprop="datePublished">2021-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-02-%E6%9C%8D%E5%8A%A1%E5%AE%95%E6%9C%BA%E5%BC%95%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8/">kafka-分析与调优-02-服务宕机引发高可用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Kafka宕机引发的高可用问题"><a href="#Kafka宕机引发的高可用问题" class="headerlink" title="Kafka宕机引发的高可用问题"></a>Kafka宕机引发的高可用问题</h1><p>最近系统测试人员常反馈偶有Kafka消费者收不到消息的情况，登陆管理界面发现三个节点中有一个节点宕机挂掉了。但是按照高可用的理念，三个节点还有两个节点可用怎么就引起了整个集群的消费者都接收不到消息呢？</p>
<p>要解决这个问题，就要从Kafka的高可用实现开始讲起。</p>
<h1 id="Kafka的多副本冗余设计"><a href="#Kafka的多副本冗余设计" class="headerlink" title="Kafka的多副本冗余设计"></a>Kafka的多副本冗余设计</h1><ul>
<li><strong>物理模型</strong></li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5d9831010e641d9a296a0277255f9f3~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li><strong>逻辑模型</strong></li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd93eab29efa465c898d91c809226f0b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li><strong>Broker</strong>（节点）：Kafka服务节点，简单来说一个<code>Broker</code>就是一台Kafka服务器，一个物理节点。</li>
<li><strong>Topic</strong>（主题）：在Kafka中消息以主题为单位进行归类，每个主题都有一个<code>Topic Name</code>，生产者根据Topic Name将消息发送到特定的Topic，消费者则同样根据Topic Name从对应的Topic进行消费。</li>
<li><strong>Partition</strong>（分区）：<code>Topic</code>（主题）是消息归类的一个单位，但每一个主题还能再细分为一个或多个<code>Partition</code>（分区），一个分区只能属于一个主题。主题和分区都是逻辑上的概念，举个例子，消息1和消息2都发送到主题1，它们可能进入同一个分区也可能进入不同的分区（所以同一个主题下的不同分区包含的消息是不同的），之后便会发送到分区对应的Broker节点上。</li>
<li><strong>Offset</strong>（偏移量）：分区可以看作是一个只进不出的队列（Kafka只保证一个分区内的消息是有序的），消息会往这个队列的尾部追加，每个消息进入分区后都会有一个偏移量，标识该消息在该分区中的位置，消费者要消费该消息就是通过偏移量来识别。</li>
</ul>
<p>其实，根据上述的几个概念，是不是也多少猜到了Kafka的多副本冗余设计实现了？别急，咱继续往下看。</p>
<p>在Kafka 0.8版本以前，是没有多副本冗余机制的，一旦一个节点挂掉，那么这个节点上的所有<code>Partition</code>的数据就无法再被消费。这就等于发送到Topic的有一部分数据丢失了。</p>
<p>在0.8版本后引入副本则很好地解决宕机后数据丢失的问题。副本是以<code>Topic</code>中每个<code>Partition</code>的数据为单位，每个Partition的数据会同步到其他物理节点上，形成多个副本。</p>
<p>每个<code>Partition</code>的副本都包括一个<code>Leader</code>副本和多个<code>Follower</code>副本，Leader由所有的副本共同选举得出，其他副本则都为Follower副本。在生产者写或者消费者读的时候，都只会与Leader打交道，在写入数据后Follower就会来拉取数据进行数据同步。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69aa10bb5786447ea5d716ef5bc015ab~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>就这么简单？是的，基于上面这张多副本架构图就实现了Kafka的高可用。当某个<code>Broker</code>挂掉了，甭担心，这个<code>Broker</code>上的<code>Partition</code>在其他<code>Broker</code>节点上还有副本。你说如果挂掉的是<code>Leader</code>怎么办？那就在<code>Follower</code>中在选举出一个<code>Leader</code>即可，生产者和消费者又可以和新的<code>Leader</code>愉快地玩耍了，这就是高可用。</p>
<p>你可能还有疑问，那要多少个副本才算够用？Follower和Leader之间没有完全同步怎么办？一个节点宕机后Leader的选举规则是什么？</p>
<p>直接抛结论:</p>
<p><strong>多少个副本才算够用？</strong> 副本肯定越多越能保证Kafka的高可用，但越多的副本意味着网络、磁盘资源的消耗更多，性能会有所下降，通常来说副本数为3即可保证高可用，极端情况下将<code>replication-factor</code>参数调大即可。</p>
<p><strong>Follower和Lead之间没有完全同步怎么办？</strong> Follower和Leader之间并不是完全同步，但也不是完全异步，而是采用一种<code>ISR</code>机制（<code>In-Sync Replica</code>）。每个Leader会动态维护一个ISR列表，该列表里存储的是和Leader基本同步的Follower。如果有Follower由于网络、GC等原因而没有向Leader发起拉取数据请求，此时Follower相对于Leader是不同步的，则会被踢出ISR列表。所以说，ISR列表中的Follower都是跟得上Leader的副本。</p>
<p><strong>一个节点宕机后Leader的选举规则是什么？</strong> 分布式相关的选举规则有很多，像Zookeeper的<code>Zab</code>、<code>Raft</code>、<code>Viewstamped Replication</code>、微软的<code>PacificA</code>等。而Kafka的Leader选举思路很简单，基于我们上述提到的<code>ISR</code>列表，当宕机后会从所有副本中顺序查找，如果查找到的副本在ISR列表中，则当选为Leader。另外还要保证前任Leader已经是退位状态了，否则会出现脑裂情况（有两个Leader）。怎么保证？Kafka通过设置了一个controller来保证只有一个Leader。</p>
<h1 id="Ack参数决定了可靠程度"><a href="#Ack参数决定了可靠程度" class="headerlink" title="Ack参数决定了可靠程度"></a>Ack参数决定了可靠程度</h1><p>另外，这里补充一个面试考Kafka高可用必备知识点：<code>request.required.acks</code>参数。</p>
<p>Acks这个参数是生产者客户端的重要配置，发送消息的时候就可设置这个参数。该参数有三个值可配置：<strong>0、1、All</strong>。</p>
<p><strong>第一种是设为0</strong>，意思是生产者把消息发送出去之后，之后这消息是死是活咱就不管了，有那么点发后即忘的意思，说出去的话就不负责了。不负责自然这消息就有可能丢失，那就把可用性也丢失了。</p>
<p><strong>第二种是设为1</strong>，意思是生产者把消息发送出去之后，这消息只要顺利传达给了Leader，其他Follower有没有同步就无所谓了。存在一种情况，Leader刚收到了消息，Follower还没来得及同步Broker就宕机了，但生产者已经认为消息发送成功了，那么此时消息就丢失了。注意，<strong>设为1是Kafka的默认配置</strong>！！！可见Kafka的默认配置也不是那么高可用，而是对高可用和高吞吐量做了权衡折中。</p>
<p><strong>第三种是设为All（或者-1）</strong>，意思是生产者把消息发送出去之后，不仅Leader要接收到，ISR列表中的Follower也要同步到，生产者才会任务消息发送成功。</p>
<p>进一步思考，<code>Acks=All</code>就不会出现丢失消息的情况吗？答案是否。当ISR列表只剩Leader的情况下，<code>Acks=All</code>相当于<code>Acks=1</code>，这种情况下如果节点宕机了，还能保证数据不丢失吗？因此只有在<code>Acks=All</code>并且有ISR中有两个副本的情况下才能保证数据不丢失。</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>绕了一大圈，了解了Kafka的高可用机制，终于回到我们一开始的问题本身，<code>Kafka</code>的一个节点宕机后为什么不可用？</p>
<p>我在开发测试环境配置的<code>Broker</code>节点数是3，<code>Topic</code>是副本数为3，<code>Partition</code>数为6，<code>Asks</code>参数为1。</p>
<p>当三个节点中某个节点宕机后，集群首先会怎么做？没错，正如我们上面所说的，集群发现有Partition的Leader失效了，这个时候就要从ISR列表中重新选举Leader。如果ISR列表为空是不是就不可用了？并不会，而是从Partition存活的副本中选择一个作为Leader，不过这就有潜在的数据丢失的隐患了。</p>
<p>所以，只要将Topic副本个数设置为和Broker个数一样，Kafka的多副本冗余设计是可以保证高可用的，不会出现一宕机就不可用的情况（不过需要注意的是Kafka有一个保护策略，当一半以上的节点不可用时Kafka就会停止）。那仔细一想，Kafka上是不是有副本个数为1的Topic？</p>
<p>问题出在了<code>__consumer_offset</code>上，<code>__consumer_offset</code>是一个Kafka自动创建的<code>Topic</code>，用来存储消费者消费的<code>offset</code>（偏移量）信息，默认<code>Partition</code>数为50。而就是这个Topic，它的默认副本数为1。如果所有的<code>Partition</code>都存在于同一台机器上，那就是很明显的单点故障了！当将存储<code>__consumer_offset</code>的Partition的Broker给Kill后，会发现所有的消费者都停止消费了。</p>
<p>这个问题怎么解决？</p>
<p><strong>第一点</strong>，需要将<code>__consumer_offset</code>删除，注意这个Topic时Kafka内置的Topic，无法用命令删除，我是通过将<code>logs</code>删了来实现删除。</p>
<p><strong>第二点</strong>，需要通过设置<code>offsets.topic.replication.factor</code>为3来将<code>__consumer_offset</code>的副本数改为3。</p>
<p>通过将<code>__consumer_offset</code>也做副本冗余后来解决某个节点宕机后消费者的消费问题。</p>
<p>最后，关于为什么<code>__consumer_offset</code>的Partition会出现只存储在一个Broker上而不是分布在各个Broker上感到困惑，如果有朋友了解的烦请指教~</p>
<blockquote>
<p>在 Kafka 0.11 之前，当 Kafka 自动创建__consumer_offset topic时，它会综合考虑当前运行的 Broker 台数和 Broker 端参数 offsets.topic.replication.factor 值，然后取两者的较小值作为该主题的副本数。 在 0.11 版本之后，社区修正了这个问题。Kafka 会严格遵守 offsets.topic.replication.factor 值。如果当前运行的 Broker 数量小于 offsets.topic.replication.factor 值，Kafka 会创建主题失败并显式抛出异常。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/kafka-%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98-02-%E6%9C%8D%E5%8A%A1%E5%AE%95%E6%9C%BA%E5%BC%95%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8/" data-id="cm6lsyz5h004qk2dl27xn2w9r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-事务/分布式事务-利用消息队列实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%88%A9%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2021-06-16T05:54:39.000Z" itemprop="datePublished">2021-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%88%A9%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/">分布式事务-利用消息队列实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="消息队列中：消息可靠性、重复消息、消息积压、利用消息实现分布式事务"><a href="#消息队列中：消息可靠性、重复消息、消息积压、利用消息实现分布式事务" class="headerlink" title="消息队列中：消息可靠性、重复消息、消息积压、利用消息实现分布式事务"></a>消息队列中：消息可靠性、重复消息、消息积压、利用消息实现分布式事务</h2><h2 id="一、如何确保消息不丢失？"><a href="#一、如何确保消息不丢失？" class="headerlink" title="一、如何确保消息不丢失？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">一、如何确保消息不丢失？</a></h2><h3 id="1、检测消息丢失的方法"><a href="#1、检测消息丢失的方法" class="headerlink" title="1、检测消息丢失的方法"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">1、检测消息丢失的方法</a></h3><p>可以利用消息队列的有序性来验证是否有消息丢失。在Producer端给每个发出的消息附加一个连续递增的序号，然后在Consumer端来检查这个序号的连续性。如果没有消息丢失，Consumer收到消息的序号必然是连续递增的，如果检测到序号不连续，那就是丢消息了。还可以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因</p>
<p>大多数消息队列的 客户端都支持拦截器机制，可以利用这个拦截器机制，在Producer发送消息之前的拦截器中将序号注入到消息中，在Consumer收到消息的拦截器中检测序号的连续性</p>
<p>如果是在一个分布式系统中实现这个检测方法，有几个问题需要注意：</p>
<p>首先，像Kafka和RocketMQ这样的消息队列，是不保证Topic上的严格顺序的，只能保证分区上的消息是有序的，所以在发消息的时候必须指定分区，并且，在每个分区单独检测消息序号的连续性</p>
<p>如果系统中Producer是多实例的，由于并不好协调多个Producer之间的发送顺序，所以也需要每个Producer分别生成各自的消息序号，并且需要附加上Producer的标识，在Consumer端按照每个Producer分别来检测序号的连续性</p>
<p>Consumer实例的数量最好和分区数量一致，做到Consumer和分区一一对应，这样会比较方便地在Consumer内检测消息序号的连续性</p>
<h3 id="2、确保消息可靠传递"><a href="#2、确保消息可靠传递" class="headerlink" title="2、确保消息可靠传递"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">2、确保消息可靠传递</a></h3><p>一条消息从生产到消费完成这个过程，可以划分为三个阶段：<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhldRGTKuL7mOTr9F8POSo0rNfIsSlviaZSPWV6LibCwI6SzoA4OYIR8V7w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li>生产阶段：在这个阶段，从消息在Producer创建出来，经过网络传输发送到Broker端</li>
<li>存储阶段：在这个阶段，消息在Broker端存储，如果是集群，消息会在这个阶段被复制到其他的副本上</li>
<li>消费阶段：在这个阶段，Consumer从Broker上拉取消息，经过网络传输发送到Consumer上</li>
</ul>
<p>1）、生产阶段</p>
<p>在生产阶段，消息队列通过最常用的请求确认机制，来保证消息的可靠传递：当在代码中调用发送消息方法时，消息队列的客户端会把消息发送到Broker，Broker收到消息后，会给客户端返回一个确认响应，表明消息已经收到了。客户端收到响应后，完成了一次正常消息的发送</p>
<p>只要Producer收到了Broker的确认响应就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会以返回值或者异常的方式告知用户</p>
<p>在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失</p>
<p>以Kafka为例：</p>
<p>同步发送时，只要注意捕获异常即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    producer.send(record).get();</span><br><span class="line">    System.out.println(&quot;消息发送成功&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    System.out.println(&quot;消息发送失败&quot;);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步发送时，则需要在回调方法里进行检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">producer.send(record, new Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCompletion(RecordMetadata metadata, Exception exception) &#123;</span><br><span class="line">        if (metadata !&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;消息发送成功&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;消息发送失败&quot;);</span><br><span class="line">            System.out.println(exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">producer.send(record, (metadata, exception) -&gt; &#123;</span><br><span class="line">    if (metadata !&#x3D; null) &#123;</span><br><span class="line">        System.out.println(&quot;消息发送成功&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;消息发送失败&quot;);</span><br><span class="line">        System.out.println(exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2）、存储阶段</p>
<p>在存储阶段正常情况下，只要Broker在正常运行，就不会出现丢失消息的问题，但是如果Broker出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失消息的</p>
<p>如果对消息的可靠性要求非常高，可以通过配置Broker参数来避免因为宕机丢消息</p>
<p>对于单个节点的Broker，需要配置Broker参数，在收到消息后，将消息写入磁盘后再给Producer返回确认响应，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消息，恢复后还可以继续消费。例如，在RocketMQ中，需要将刷盘方式flushDiskType配置为SYNC_FLUSH同步刷盘</p>
<p>如果Broker是由多个节点组成的集群，需要将Broker集群配置成：至少将消息发送到2个以上的节点，再给客户端回复发送确认响应。这样当某个Broker宕机后，其他的Broker可以替代宕机的Broker，也不会发生消息丢失</p>
<p>3）、消费阶段</p>
<p>消费阶段采用和生产阶段类似的确认机制来保证消息的可靠传递，客户端从Broker拉取消息后，执行用户的消费业务逻辑，成功后，才会给Broker发送消费确认响应。如果Broker没有收到消费确认响应，下次拉消息的时候还会返回同一条消息，确认消息不会在网络传输过程中丢失，也不会因为客户端在执行消费逻辑中出错导致丢失</p>
<p>在编写消费代码时需要注意的是，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认</p>
<p>以SpringBoot整合RabbitMQ为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(bindings &#x3D; @QueueBinding(</span><br><span class="line">        value &#x3D; @Queue(value &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.queue.name&#125;&quot;,</span><br><span class="line">                durable &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.queue.durable&#125;&quot;),</span><br><span class="line">        exchange &#x3D; @Exchange(value &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.exchange.name&#125;&quot;,</span><br><span class="line">                durable &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.exchange.durable&#125;&quot;,</span><br><span class="line">                type &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.exchange.type&#125;&quot;,</span><br><span class="line">                ignoreDeclarationExceptions &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.exchange.ignoreDeclarationExceptions&#125;&quot;),</span><br><span class="line">        key &#x3D; &quot;$&#123;spring.rabbitmq.listener.order.key&#125;&quot;</span><br><span class="line">))</span><br><span class="line">@RabbitHandler</span><br><span class="line">&#x2F;&#x2F;Order需要实现序列化接口</span><br><span class="line">public void onMessage(@Payload Order order, @Headers Map&lt;String, Object&gt; headers, Channel channel) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;处理业务逻辑</span><br><span class="line">    System.out.println(&quot;消费端:&quot; + order);</span><br><span class="line">    &#x2F;&#x2F;手工ACK</span><br><span class="line">    Long deliveryTag &#x3D; (Long) headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">    channel.basicAck(deliveryTag, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">3、小结</a></h3><ul>
<li>在生产阶段，需要捕获消息发送的错误，并重发消息</li>
<li>在存储阶段，可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个Broker宕机或者磁盘损坏而丢失</li>
<li>在消费阶段，需要在处理完全部消费业务逻辑之后，再发送消费确认</li>
</ul>
<h2 id="二、如何处理消费过程中的重复消息？"><a href="#二、如何处理消费过程中的重复消息？" class="headerlink" title="二、如何处理消费过程中的重复消息？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">二、如何处理消费过程中的重复消息？</a></h2><h3 id="1、消息重复的情况必然存在"><a href="#1、消息重复的情况必然存在" class="headerlink" title="1、消息重复的情况必然存在"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">1、消息重复的情况必然存在</a></h3><p>在MQTT协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：</p>
<ul>
<li>At most once：至多一次。消息在传递时，最多会被送达一次。也就是说，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失</li>
<li>At least once：至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现</li>
<li>Exactly once：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级</li>
</ul>
<p>这个服务质量标准不仅适用于MQTT，对所有的消息队列都是适用的。现在常用的绝大部分消息队列提供的服务质量都是At least once，包括RocketMQ、RabbitMQ和Kafka都是这样。也就是说，消息队列很难保证消息不重复</p>
<h3 id="2、用幂等性解决重复消息问题"><a href="#2、用幂等性解决重复消息问题" class="headerlink" title="2、用幂等性解决重复消息问题"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">2、用幂等性解决重复消息问题</a></h3><p>一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备幂等性</p>
<p>一个幂等操作的特点是，其任意多次执行所产生的影响均与一次执行的影响相同。一个幂等的方法使用同样的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的。所以，对于幂等的方法，不用担心重复执行会对系统造成任何改变</p>
<p>从对系统的影响结果来说：At least once+幂等消费=Exactly once</p>
<p>几种常用的设计幂等操作的方法：</p>
<p>1）、利用数据库的唯一约束实现幂等</p>
<p>举个例子：将账户X的余额加100元。可以通过改造业务逻辑，让它具备幂等性</p>
<p>首先，可以限定对于每个转账单每个账户只可以执行一次变更操作，最简单的是在数据库建一张转账流水表，这个表有三个字段：转账单ID、账户ID和变更金额，然后给转账单ID和账户ID这两个字段联合起来创建一个唯一约束，这样对于相同的转账单ID和账户ID，表里至多只能存在一条记录</p>
<p>这样，消费消息的逻辑可以变为：在转账流水表中增加一条转账记录，然后再根据转账记录，异步操作更新用户余额即可。在转账流水表增加一条转账记录这个操作中，由于在这个表中预先定义了账户ID转账单ID的唯一索引，对于同一个转账单同一个账户只能插入一条记录，后续重复的插入操作都会失败，这样就实现了一个幂等的操作</p>
<p>只要是支持类似INSERT IF NOT EXIST语义的存储类系统都可以用于实现幂等，比如，可以用Redis的SETNX命令来替代数据库中的唯一约束，来实现幂等消费</p>
<p>2）、为更新的数据设置前置条件</p>
<p>另外一种实现幂等的思路是，给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据。这样，重复执行这个操作时，由于第一次更新数据的时候已经变更了前置条件中需要判断的数据，不满足前置条件，则不会重复执行更新数据操作</p>
<p>比如，将账户X的余额增加100元这个操作并不满足幂等性，可以把这个操作加上一个前置条件，变为：如果账户X当前的月为500元，将余额加100元，这个操作就具备了幂等性。对应到消息队列中的使用时，可以在发消息时在消息体中带上当前的余额，在消费的时候判断数据库中当前余额是否与消息中的余额相等，只有相等才执行变更操作</p>
<p>更加通用的方法是，给数据增加一个版本号属性，每次更新数据前，比较当前数据的版本号是否和消息中的版本号一直，如果不一致就拒绝更新数据，更新数据的同时将版本号+1，一样可以实现幂等更新</p>
<p>3）、记录并检查操作</p>
<p>还有一种通用性最强的实现幂等性方法：记录并检查操作，也称为Token机制或者GUID（全局唯一ID）机制，实现思路：在执行数据更新操作之前，先检查一下是否执行过这个更新操作</p>
<p>具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的ID，消费时，先根据这个ID检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费</p>
<p>但在分布式系统中，这个方法非常难以实现。首先，给每个消息指定一个全局唯一的ID就是一件不那么简单的事情，方法有很多，但都不太好同时满足简单、高可用和高性能，或多或少都要有些牺牲。更加麻烦的是，检查消费状态，然后更新数据并且设置消费状态这三个操作必须作为一组操作保证原子性，才能真正实现幂等，否则就会出现Bug</p>
<h2 id="三、消息积压了该如何处理？"><a href="#三、消息积压了该如何处理？" class="headerlink" title="三、消息积压了该如何处理？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">三、消息积压了该如何处理？</a></h2><p>消息积压的直接原因一定是系统中的某个部分出现了性能问题，来不及处理上游发送的消息，才会导致消息积压</p>
<h3 id="1、优化性能来避免消息积压"><a href="#1、优化性能来避免消息积压" class="headerlink" title="1、优化性能来避免消息积压"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">1、优化性能来避免消息积压</a></h3><p>1）、发送端性能优化</p>
<p>对于发送消息的业务逻辑，只需要设置合适的并发和批量大小，就可以达到很多的发送性能</p>
<p>Producer发送消息的过程包括：Producer发送消息给Broker，Broker收到消息返回确认响应。假设这一次交互的平均时延是1ms，这1ms包括了下面这些步骤的耗时：</p>
<ul>
<li>发送端准备数据、序列化消息、构造请求等逻辑的时间，也就是发送端在网络请求之前的耗时</li>
<li>发送消息和返回响应在网络传输中的耗时</li>
<li>Broker处理消息的时延</li>
</ul>
<p>如果是单线程发送，每次只发送1条消息，那么每秒只能发送1000ms/1ms*1条/ms=1000条消息。无论是增加每次发送消息的批量大小，还是增加并发都能成倍地提升发送性能</p>
<p>比如说，消息发送端主要接收RPC请求处理在线业务，因为所有RPC框架都是多线程支持多并发的，自然就实现了并行发送消息。并且在线业务比较在意的是请求响应时延，选择批量发送会影响RPC服务的时延</p>
<p>如果是一个离线系统，它在性能上更注重整个系统的吞吐量，发送端的数据都是来自于数据库，这种情况就更适合批量发送。可以批量从数据库读取数据，然后批量来发送消息，同样用少量的并发就可以获得非常高的吞吐量</p>
<p>2）、消费端性能优化</p>
<p>使用消息队列的时候，大部分的性能问题都出现在消费端，如果消费的速度跟不上发送生产消息的速度，就会造成消息积压。如果这种性能倒挂的问题只是暂时的，只要消费单的性能恢复之后，超过发送端的性能，那积压的消息是可以逐渐被消化掉的</p>
<p>要是消费速度一直比生产速度慢，时间长了，整个系统就会出现问题，要么，消息队列的存储被填满无法提供服务，要么消息丢失，这对于整个系统来说都是严重故障</p>
<p>在设计系统的时候，一定要保证消费端的消费性能要高于生产端的发送性能</p>
<p>消费端的性能优化除了优化消费业务逻辑之外，也可以通过水平扩容，增加消费端的并发数来提升总体的消费性能。在扩容Consumer的实例数量的同时，必须同步扩容主题中的分区数量，确保Consumer的实例数和分区数量是相等的。如果Consumer的实例数量超过分区数量，这样的扩容是无效的</p>
<h3 id="2、消息积压了该如何处理？"><a href="#2、消息积压了该如何处理？" class="headerlink" title="2、消息积压了该如何处理？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">2、消息积压了该如何处理？</a></h3><p>还有一种消息积压的情况是，日常系统正常运转的时候，没有积压或者只有少量积压很快就消费掉了，但是某一时刻，突然就开始积压消息并且积压持续上涨。这种情况下需要在短时间内找到消息积压的原因，迅速解决问题</p>
<p>能导致积压突然增加，最粗粒度的原因，只有两种：要么是发送变快了，要么是消费变慢了</p>
<p>大部分消息队列都内置了监控的功能，只要通过监控数据，很容易确定是哪种原因。如果是单位事件发送的消息增多，比如说是赶上大促或者抢购，短时间内不太可能优化消费端的代码来提升消费性能，唯一的方法是通过扩容消费端的实例来提升总体的消费能力</p>
<p>如果短时间内没有足够的服务器资源进行扩容，没办法的办法是将系统降级，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务</p>
<p>还有一种不太常见的情况，通过监控发现，无论是发送消息的速度还是消费消息的速度和原来都没什么变化，这时候需要检查一下消费端是不是消费失败导致的一条消息发福消费这种情况比较多，这种情况也会拖垮整个系统的消费速度</p>
<h2 id="四、如何利用事务消息实现分布式事务？"><a href="#四、如何利用事务消息实现分布式事务？" class="headerlink" title="四、如何利用事务消息实现分布式事务？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">四、如何利用事务消息实现分布式事务？</a></h2><p>消息队列中的事务主要解决的是消息生产者和消息消费者的数据一致性问题</p>
<p>拿电商来举个例子，一般来说，用户在电商APP上购物时，先把商品加到购物车里，然后几件商品一起下单，最后支付，完成购物流程，就可以等待收货了。这个过程中有一个需要用到消息队列的步骤，订单系统创建订单后，发消息给购物车系统，将已下单的商品从购物车中删除。因为从购物车删除已下单商品这个步骤，并不是用户下单支付这个主要流程中必需的步骤，使用消息队里来异步清理购物车是更加合理的设计<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlGMbnCeRktibY94szIPr8E6nUjqeQKMxKgPPS0161jyokCYOfB7YyIhQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">对于订单系统来说，它创建订单的过程中实际上执行了2个步骤的操作：</p>
<ul>
<li>在订单库中插入一条订单数据，创建订单</li>
<li>发消息给消息队列，消息的内容就是刚刚创建的订单</li>
</ul>
<p>购物车系统订阅相应的主题，接收订单创建的消息，然后清理购物车，在购物车中删除订单中的商品</p>
<p>问题的关键点集中在订单系统，创建订单和发送消息这两个步骤要么都操作成功，要么都操作失败，不允许一个成功而另一个失败的情况出现</p>
<h3 id="1、什么是分布式事务？"><a href="#1、什么是分布式事务？" class="headerlink" title="1、什么是分布式事务？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">1、什么是分布式事务？</a></h3><p>事务的4个特性（ACID）：</p>
<ul>
<li>原子性：指一个事务操作不可分割，要么成功，要么失败，不能有一半成功一半失败的情况</li>
<li>一致性：指这些数据在事务执行完成这个时间点之前，读到的一定是更新前的数据，之后读到的一定是更新后的数据，不应该存在一个时刻，让用户读到更新过程中的数据</li>
<li>隔离性：指一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对正在进行的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</li>
<li>持久性：指一个事务一旦完成提交，后续的其他操作和故障都不会对事务的结果产生任何影响</li>
</ul>
<p>事务消息适用的场景主要是那些需要异步更新数据，并且对数据实时性要求不太高的场景。比如订单系统的例子，在创建订单后，如果出现短暂的几秒，购物车里的商品没有及时情况，也不是完全不可接受的，只要最终购物车的数据和订单数据保持一致就可以了</p>
<h3 id="2、消息队列是如何实现分布式事务的？"><a href="#2、消息队列是如何实现分布式事务的？" class="headerlink" title="2、消息队列是如何实现分布式事务的？"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">2、消息队列是如何实现分布式事务的？</a></h3><p>回到订单和购物车这个例子，来看下如何用消息队列来实现分布式事务<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlV5BRd0XsIByhpibicozM73wK0ja32LPdjaQTQicM1gdNiadojWpL7sYxgQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">首先，订单系统在消息队列上开启了一个事务。然后订单系统给消息服务器发送一个半消息，这个半消息包含的内容是完整的消息内容，和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的</p>
<p>半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。然后根据本地事务的执行结果决定提交或者回滚事务消息。如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。这样就基本实现了要么都成功，要么都失败的一致性要求</p>
<p>如果在第四步提交事务消息时失败了，Kafka会直接抛出异常，让用户自行处理，可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿</p>
<h3 id="3、RocketMQ中的分布式事务实现"><a href="#3、RocketMQ中的分布式事务实现" class="headerlink" title="3、RocketMQ中的分布式事务实现"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect">3、RocketMQ中的分布式事务实现</a></h3><p>在RocketMQ中的事务实现中，增加了事务反查的机制来解决事务消息提交失败的问题。如果Producer也就是订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ的Broker没有收到提交或者回滚的请求，Broker会定期去Producer上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务</p>
<p>为了支撑这个事务反查机制，业务代码中需要实现一个反查本地事务状态的接口，告知RocketMQ本地事务是成功还是失败</p>
<p>在订单系统的例子中，反查本地事务的逻辑只要根据消息中的订单ID，在订单库中查询这个订单是否存在即可，如果订单存在则返回成功，否则返回失败。RocketMQ会自动根据事务反查的结果提交或者回滚事务消息</p>
<p>这个反查本地事务的实现，并不依赖消息的发送方，也就是订单服务的某个实例节点上的任何数据。这种情况下，即使是发送事务消息的那个订单服务节点宕机了，RocketMQ依然可以通过其他订单服务的节点来执行反查，确保事务的完整性</p>
<p>使用RocketMQ事务消息功能实现分布式事务的流程如下图：<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdgoeEN1mmBx8UOp1v5zhhlTamIm2YNibZSckOAQXA2vs1TpUU2U0mZzicFs6FExqdiaZVrUFwIKIasQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%88%A9%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/" data-id="cm6lsyz54000nk2dl2ytm53a1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/">juc</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/oom/">oom</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/oom/">oom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/spring/">spring</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/" rel="tag">JDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/annotation/" rel="tag">annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cluster/" rel="tag">cluster</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jstack/" rel="tag">jstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock/" rel="tag">lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/net/" rel="tag">net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/next/" rel="tag">next</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/" rel="tag">reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-starter/" rel="tag">spring starter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/startup/" rel="tag">startup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transaction/" rel="tag">transaction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtual-machine/" rel="tag">virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vm/" rel="tag">vm</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDK/" style="font-size: 11.11px;">JDK</a> <a href="/tags/annotation/" style="font-size: 10px;">annotation</a> <a href="/tags/cluster/" style="font-size: 10px;">cluster</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/hexo/" style="font-size: 12.22px;">hexo</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/jstack/" style="font-size: 14.44px;">jstack</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/lock/" style="font-size: 10px;">lock</a> <a href="/tags/mysql/" style="font-size: 16.67px;">mysql</a> <a href="/tags/net/" style="font-size: 10px;">net</a> <a href="/tags/next/" style="font-size: 11.11px;">next</a> <a href="/tags/redis/" style="font-size: 15.56px;">redis</a> <a href="/tags/reflect/" style="font-size: 10px;">reflect</a> <a href="/tags/spring-starter/" style="font-size: 10px;">spring starter</a> <a href="/tags/springboot/" style="font-size: 18.89px;">springboot</a> <a href="/tags/startup/" style="font-size: 17.78px;">startup</a> <a href="/tags/transaction/" style="font-size: 11.11px;">transaction</a> <a href="/tags/virtual-machine/" style="font-size: 12.22px;">virtual machine</a> <a href="/tags/vm/" style="font-size: 13.33px;">vm</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%A1%86%E6%9E%B6-04-bean%E5%8C%85-Bean/">spring框架-04-bean包-Bean</a>
          </li>
        
          <li>
            <a href="/2022/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-HashMap/">JDK-util-HashMap</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E5%9C%BA%E6%99%AF/">mysql - 常见事务问题解决方案</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">mysql - 面试问题</a>
          </li>
        
          <li>
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">交换排序-冒泡排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 Fei Qi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>