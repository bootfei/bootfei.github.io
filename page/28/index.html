<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/28/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/28/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/21/database/mysql/mysql-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96-03-%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/database/mysql/mysql-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96-03-%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">mysql:哪些因素会导致慢查询</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-21 09:58:49" itemprop="dateCreated datePublished" datetime="2020-11-21T09:58:49+08:00">2020-11-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-27 14:50:04" itemprop="dateModified" datetime="2021-05-27T14:50:04+08:00">2021-05-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>它山之石可以攻玉</p>
<h3 id="ref-links"><a href="#ref-links" class="headerlink" title="ref links:"></a>ref links:</h3><ol>
<li>从底层硬件、操作系统、mysql软件层面分析<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Edn_gPwcAHo5sYIzLJghzA">https://mp.weixin.qq.com/s/Edn_gPwcAHo5sYIzLJghzA</a></li>
</ol>
<h3 id="Explain命令原理"><a href="#Explain命令原理" class="headerlink" title="Explain命令原理"></a>Explain命令原理</h3><h4 id="id列原理"><a href="#id列原理" class="headerlink" title="id列原理"></a>id列原理</h4><p>这一列总是包含一个编号，标示select所属的行。数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表示这是一个结果集，不需要使用它来进行查询。</p>
<h4 id="rows-计算原理"><a href="#rows-计算原理" class="headerlink" title="rows 计算原理"></a>rows 计算原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">    c.*</span><br><span class="line">from</span><br><span class="line">    hotel_info_original c </span><br><span class="line">left join</span><br><span class="line">    hotel_info_collection h </span><br><span class="line">on</span><br><span class="line">    c.hotel_type&#x3D;h.hotel_type </span><br><span class="line">and</span><br><span class="line">    c.hotel_id &#x3D;h.hotel_id </span><br><span class="line">where</span><br><span class="line">    h.hotel_id is null</span><br></pre></td></tr></table></figure>

<p>这个sql是用来查询出 c 表中有 h 表中无的记录，所以想到了用 left join 的特性（返回左边全部记录，右表不满足匹配条件的记录对应行返回 null）来满足需求，不料这个查询非常慢。先来看查询计划：</p>
<p><strong><img src="https://images2015.cnblogs.com/blog/544496/201707/544496-20170711162211978-591320154.jpg" alt="img"></strong></p>
<p>　　rows代表这个步骤相对上一步结果的每一行需要扫描的行数，可以看到这个sql需要扫描的行数为35773*8134，非常大的一个数字。</p>
<p>　　<strong>在EXPLAIN结果中，第一行出现的表就是驱动表。</strong></p>
<blockquote>
<p><strong>rows (JSON name: rows)</strong></p>
<p>The rows column indicates the number of rows MySQL believes it must examine to execute the query.</p>
<p>For [InnoDB] tables, this number is an estimate, and may not always be exact.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_rows">http://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_rows</a></p>
<p>查找 MYSQL 源码来看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件1：sql&#x2F;opt_explain_traditional.cc   关键部分：push(&amp;items, column_buffer.col_rows, nil)</span><br><span class="line"></span><br><span class="line">文件2：sql&#x2F;opt_explain.cc   关键部分：select-&gt;quick-&gt;records</span><br><span class="line"></span><br><span class="line">文件3：sql&#x2F;opt_range.cc   关键部分：check_quick_select</span><br></pre></td></tr></table></figure>

<p>而 check_quick_select 的功能，在 MySQL 源码中的注释为：</p>
<blockquote>
<p>Calculate estimate of number records that will be retrieved by a range scan on given index using given SEL_ARG intervals tree.</p>
</blockquote>
<p>MySQL Explain 里的 rows 这个值</p>
<ul>
<li>是 MySQL 认为它要检查的行数（仅做参考），而不是结果集里的行数；</li>
<li>同时 SQL 里的 LIMIT 和这个也是没有直接关系的。</li>
</ul>
<p>另外，很多优化手段，例如关联缓冲区和查询缓存，都无法影响到 rows 的显示。MySQL 可能不必真的读所有它估计到的行，它也不知道任何关于操作系统或硬件缓存的信息。</p>
<h3 id="慢查询优化基本步骤"><a href="#慢查询优化基本步骤" class="headerlink" title="慢查询优化基本步骤"></a>慢查询优化基本步骤</h3><p>0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE</p>
<p>1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</p>
<p>2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</p>
<p>3.order by limit 形式的sql语句让排序的表优先查</p>
<p>4.了解业务方使用场景</p>
<p>5.加索引时参照建索引的几大原则</p>
<p>6.观察结果，不符合预期继续从0分析</p>
<h3 id="慢查询案例"><a href="#慢查询案例" class="headerlink" title="慢查询案例"></a><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/06/30/mysql-index.html">慢查询案例</a></h3><h4 id="复杂语句写法"><a href="#复杂语句写法" class="headerlink" title="复杂语句写法"></a>复杂语句写法</h4><p>很多情况下，我们写SQL只是为了实现功能，这只是第一步，不同的语句书写方式对于效率往往有本质的差别，这要求我们对mysql的执行计划和索引原则有非常清楚的认识，请看下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="keyword">distinct</span> cert.emp_id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         emp.id <span class="keyword">as</span> emp_id,</span><br><span class="line">         emp_cert.id <span class="keyword">as</span> cert_id </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         employee emp </span><br><span class="line">      <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">         emp_certificate emp_cert </span><br><span class="line">            <span class="keyword">on</span> emp.id = emp_cert.emp_id </span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">         emp.is_deleted=<span class="number">0</span></span><br><span class="line">   ) cert </span><br><span class="line">      <span class="keyword">on</span> (</span><br><span class="line">         cl.ref_table=<span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid= cert.emp_id</span><br><span class="line">      ) </span><br><span class="line">      <span class="keyword">or</span> (</span><br><span class="line">         cl.ref_table=<span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid= cert.cert_id</span><br><span class="line">      ) </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date &gt;=<span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date&lt;=<span class="string">&#x27;2013-11-08 16:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>0.先运行一下，53条记录 1.87秒，又没有用聚合语句，比较慢</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">53 rows in <span class="keyword">set</span> (<span class="number">1.87</span> sec)</span><br></pre></td></tr></table></figure>

<p>1.explain</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;font size=1&gt;</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br><span class="line">| id | select_type | table      | type  | possible_keys                   | key                   | key_len | ref               | rows  | Extra                          |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br><span class="line">|  1 | PRIMARY     | cl         | range | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date     | 8       | NULL              |   379 | Using where; Using temporary   |</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | ALL   | NULL                            | NULL                  | NULL    | NULL              | 63727 | Using where; Using join buffer |</span><br><span class="line">|  2 | DERIVED     | emp        | ALL   | NULL                            | NULL                  | NULL    | NULL              | 13317 | Using where                    |</span><br><span class="line">|  2 | DERIVED     | emp_cert   | ref   | emp_certificate_empid           | emp_certificate_empid | 4       | meituanorg.emp.id |     1 | Using index                    |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br><span class="line">&lt;/font&gt;</span><br></pre></td></tr></table></figure>

<p>简述一下执行计划，</p>
<p>首先mysql根据idx_last_upd_date索引扫描cm_log表获得379条记录；然后查表扫描了63727条记录，分为两部分，derived表示构造表，也就是不存在的表，可以简单理解成是一个语句形成的结果集，后面的数字表示语句的ID。derived2表示的是ID = 2的查询构造了虚拟表，并且返回了63727条记录。我们再来看看ID = 2的语句究竟做了写什么返回了这么大量的数据，首先全表扫描employee表13317条记录 <!--第1个derive-->，然后根据索引emp_certificate_empid关联emp_certificate表 <!--第2个derive-->，rows = 1表示，每个关联都只锁定了一条记录，效率比较高。获得后，再和cm_log的379条记录根据规则关联 <!--379 * 63727，最后只有53条记录满足要求-->。从执行过程上可以看出返回了太多的数据，返回的数据绝大部分cm_log都用不到，因为cm_log只锁定了379条记录。</p>
<p>如何优化呢？</p>
<p>可以看到我们在运行完后还是要和cm_log做join,那么我们能不能之前和cm_log做join呢？仔细分析语句不难发现，其基本思想是如果cm_log的ref_table是EmpCertificate就关联emp_certificate表，如果ref_table是Employee就关联employee表。我们完全可以拆成两部分，并用union连接起来。</p>
<blockquote>
<p>注意这里用union，而不用union all是因为原语句有“distinct”来得到唯一的记录，而union恰好具备了这种功能。如果原语句中没有distinct不需要去重，我们就可以直接使用union all了，因为使用union需要去重的动作，会影响SQL性能。</p>
</blockquote>
<p>优化过的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table = <span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid = emp.id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date &gt;=<span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date&lt;=<span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   emp_certificate ec </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table = <span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid = ec.id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> emp.id = ec.emp_id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date &gt;=<span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date&lt;=<span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>4.不需要了解业务场景，只需要改造的语句和改造之前的语句保持结果一致</p>
<p>5.现有索引可以满足，不需要建索引</p>
<p>6.用改造后的语句实验一下，只需要10ms 降低了近200倍！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line">| id | select_type  | table      | type   | possible_keys                   | key               | key_len | ref                   | rows | Extra       |</span><br><span class="line">+<span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line">|  1 | PRIMARY      | cl         | range  | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date | 8       | NULL                  |  379 | Using where |</span><br><span class="line">|  1 | PRIMARY      | emp        | eq_ref | PRIMARY                         | PRIMARY           | 4       | meituanorg.cl.ref_oid |    1 | Using where |</span><br><span class="line">|  2 | UNION        | cl         | range  | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date | 8       | NULL                  |  379 | Using where |</span><br><span class="line">|  2 | UNION        | ec         | eq_ref | PRIMARY,emp_certificate_empid   | PRIMARY           | 4       | meituanorg.cl.ref_oid |    1 |             |</span><br><span class="line">|  2 | UNION        | emp        | eq_ref | PRIMARY                         | PRIMARY           | 4       | meituanorg.ec.emp_id  |    1 | Using where |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL    | NULL                            | NULL              | NULL    | NULL                  | NULL |             |</span><br><span class="line">+<span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line">53 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="明确应用场景"><a href="#明确应用场景" class="headerlink" title="明确应用场景"></a>明确应用场景</h4><p>举这个例子的目的在于颠覆我们对列的区分度的认知，一般上我们认为区分度越高的列，越容易锁定更少的记录，但在一些特殊的情况下，这种理论是有局限性的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   * </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   stage_poi sp </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   sp.accurate_result=<span class="number">1</span> </span><br><span class="line">   <span class="keyword">and</span> (</span><br><span class="line">      sp.sync_status=<span class="number">0</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status=<span class="number">2</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status=<span class="number">4</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<p>0.先看看运行多长时间,951条数据6.22秒，真的很慢。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">951 rows in <span class="keyword">set</span> (<span class="number">6.22</span> sec)</span><br></pre></td></tr></table></figure>

<p>1.先explain，rows达到了361万，type = ALL表明是全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows    | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | sp    | ALL  | NULL          | NULL | NULL    | NULL | 3613155 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>2.所有字段都应用查询返回记录数，因为是单表查询 0已经做过了951条。</p>
<p>3.让explain的rows 尽量逼近951。</p>
<p>看一下accurate_result = 1的记录数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),accurate_result <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> accurate_result;</span><br><span class="line">+<span class="comment">----------+-----------------+</span></span><br><span class="line">| count(*) | accurate_result |</span><br><span class="line">+<span class="comment">----------+-----------------+</span></span><br><span class="line">|     1023 |              -1 |</span><br><span class="line">|  2114655 |               0 |</span><br><span class="line">|   972815 |               1 |</span><br><span class="line">+<span class="comment">----------+-----------------+</span></span><br></pre></td></tr></table></figure>

<p>我们看到accurate_result这个字段的区分度非常低，整个表只有-1,0,1三个值，加上索引也无法锁定特别少量的数据。</p>
<p>再看一下sync_status字段的情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),sync_status <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> sync_status;</span><br><span class="line">+<span class="comment">----------+-------------+</span></span><br><span class="line">| count(*) | sync_status |</span><br><span class="line">+<span class="comment">----------+-------------+</span></span><br><span class="line">|     3080 |           0 |</span><br><span class="line">|  3085413 |           3 |</span><br><span class="line">+<span class="comment">----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>同样的区分度也很低，根据理论，也不适合建立索引。</p>
<p>问题分析到这，好像得出了这个表无法优化的结论，两个列的区分度都很低，即便加上索引也只能适应这种情况，很难做普遍性的优化，比如当sync_status 0、3分布的很平均，那么锁定记录也是百万级别的。</p>
<p>4.找业务方去沟通，看看使用场景。业务方是这么来使用这个SQL语句的，每隔五分钟会扫描符合条件的数据，处理完成后把sync_status这个字段变成1,五分钟符合条件的记录数并不会太多，1000个左右。了解了业务方的使用场景后，优化这个SQL就变得简单了，因为业务方保证了数据的不平衡，如果加上索引可以过滤掉绝大部分不需要的数据。</p>
<p>5.根据建立索引规则，使用如下语句建立索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stage_poi <span class="keyword">add</span> <span class="keyword">index</span> idx_acc_status(accurate_result,sync_status);</span><br></pre></td></tr></table></figure>

<p>6.观察预期结果,发现只需要200ms，快了30多倍。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">952 rows in <span class="keyword">set</span> (<span class="number">0.20</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们再来回顾一下分析问题的过程，单表查询相对来说比较好优化，大部分时候只需要把where条件里面的字段依照规则加上索引就好，如果只是这种“无脑”优化的话，显然一些区分度非常低的列，不应该加索引的列也会被加上索引，这样会对插入、更新性能造成严重的影响，同时也有可能影响其它的查询语句。所以我们第4步调差SQL的使用场景非常关键，我们只有知道这个业务场景，才能更好地辅助我们更好的分析和优化查询语句。</p>
<h4 id="无法优化的语句"><a href="#无法优化的语句" class="headerlink" title="无法优化的语句"></a>无法优化的语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   c.id,</span><br><span class="line">   c.name,</span><br><span class="line">   c.position,</span><br><span class="line">   c.sex,</span><br><span class="line">   c.phone,</span><br><span class="line">   c.office_phone,</span><br><span class="line">   c.feature_info,</span><br><span class="line">   c.birthday,</span><br><span class="line">   c.creator_id,</span><br><span class="line">   c.is_keyperson,</span><br><span class="line">   c.giveup_reason,</span><br><span class="line">   c.status,</span><br><span class="line">   c.data_source,</span><br><span class="line">   from_unixtime(c.created_time) <span class="keyword">as</span> created_time,</span><br><span class="line">   from_unixtime(c.last_modified) <span class="keyword">as</span> last_modified,</span><br><span class="line">   c.last_modified_user_id  </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   contact c  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   contact_branch cb </span><br><span class="line">      <span class="keyword">on</span>  c.id = cb.contact_id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   branch_user bu </span><br><span class="line">      <span class="keyword">on</span>  cb.branch_id = bu.branch_id </span><br><span class="line">      <span class="keyword">and</span> bu.status <span class="keyword">in</span> (</span><br><span class="line">         <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>)  </span><br><span class="line">   <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">      org_emp_info oei </span><br><span class="line">         <span class="keyword">on</span>  oei.data_id = bu.user_id </span><br><span class="line">         <span class="keyword">and</span> oei.node_left &gt;= <span class="number">2875</span> </span><br><span class="line">         <span class="keyword">and</span> oei.node_right &lt;= <span class="number">10802</span> </span><br><span class="line">         <span class="keyword">and</span> oei.org_category = - <span class="number">1</span>  </span><br><span class="line">   <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">      c.created_time <span class="keyword">desc</span>  <span class="keyword">limit</span> <span class="number">0</span> ,</span><br><span class="line">      <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>还是几个步骤。</p>
<p>0.先看语句运行多长时间，10条记录用了13秒，已经不可忍受。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">13.06</span> sec)</span><br></pre></td></tr></table></figure>

<p>1.explain</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------------+-------+--------+-------------------------------------+-------------------------+---------+--------------------------+------+----------------------------------------------+</span></span><br><span class="line">| id | select_type | table | type   | possible_keys                       | key                     | key_len | ref                      | rows | Extra                                        |</span><br><span class="line">+<span class="comment">----+-------------+-------+--------+-------------------------------------+-------------------------+---------+--------------------------+------+----------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | oei   | ref    | idx_category_left_right,idx_data_id | idx_category_left_right | 5       | const                    | 8849 | Using where; Using temporary; Using filesort |</span><br><span class="line">|  1 | SIMPLE      | bu    | ref    | PRIMARY,idx_userid_status           | idx_userid_status       | 4       | meituancrm.oei.data_id   |   76 | Using where; Using index                     |</span><br><span class="line">|  1 | SIMPLE      | cb    | ref    | idx_branch_id,idx_contact_branch_id | idx_branch_id           | 4       | meituancrm.bu.branch_id  |    1 |                                              |</span><br><span class="line">|  1 | SIMPLE      | c     | eq_ref | PRIMARY                             | PRIMARY                 | 108     | meituancrm.cb.contact_id |    1 |                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+--------+-------------------------------------+-------------------------+---------+--------------------------+------+----------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>从执行计划上看，mysql先查org_emp_info表扫描8849记录，再用索引idx_userid_status关联branch_user表，再用索引idx_branch_id关联contact_branch表，最后主键关联contact表。</p>
<p>rows返回的都非常少，看不到有什么异常情况。我们在看一下语句，发现后面有order by + limit组合，会不会是排序量太大搞的？于是我们简化SQL，去掉后面的order by 和 limit，看看到底用了多少记录来排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   contact c  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   contact_branch cb </span><br><span class="line">      <span class="keyword">on</span>  c.id = cb.contact_id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   branch_user bu </span><br><span class="line">      <span class="keyword">on</span>  cb.branch_id = bu.branch_id </span><br><span class="line">      <span class="keyword">and</span> bu.status <span class="keyword">in</span> (</span><br><span class="line">         <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>)  </span><br><span class="line">   <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">      org_emp_info oei </span><br><span class="line">         <span class="keyword">on</span>  oei.data_id = bu.user_id </span><br><span class="line">         <span class="keyword">and</span> oei.node_left &gt;= <span class="number">2875</span> </span><br><span class="line">         <span class="keyword">and</span> oei.node_right &lt;= <span class="number">10802</span> </span><br><span class="line">         <span class="keyword">and</span> oei.org_category = - <span class="number">1</span>  </span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| <span class="keyword">count</span>(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|   <span class="number">778878</span> |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">5.19</span> sec)</span><br></pre></td></tr></table></figure>

<p>发现排序之前居然锁定了778878条记录，如果针对70万的结果集排序，将是灾难性的，怪不得这么慢，那我们能不能换个思路，先根据contact的created_time排序，再来join会不会比较快呢？</p>
<p>于是改造成下面的语句，也可以用straight_join来优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">   c.id,</span><br><span class="line">   c.name,</span><br><span class="line">   c.position,</span><br><span class="line">   c.sex,</span><br><span class="line">   c.phone,</span><br><span class="line">   c.office_phone,</span><br><span class="line">   c.feature_info,</span><br><span class="line">   c.birthday,</span><br><span class="line">   c.creator_id,</span><br><span class="line">   c.is_keyperson,</span><br><span class="line">   c.giveup_reason,</span><br><span class="line">   c.status,</span><br><span class="line">   c.data_source,</span><br><span class="line">   from_unixtime(c.created_time) as created_time,</span><br><span class="line">   from_unixtime(c.last_modified) as last_modified,</span><br><span class="line">   c.last_modified_user_id   </span><br><span class="line">from</span><br><span class="line">   contact c  </span><br><span class="line">where</span><br><span class="line">   exists (</span><br><span class="line">      select</span><br><span class="line">         1 </span><br><span class="line">      from</span><br><span class="line">         contact_branch cb  </span><br><span class="line">      inner join</span><br><span class="line">         branch_user bu        </span><br><span class="line">            on  cb.branch_id &#x3D; bu.branch_id        </span><br><span class="line">            and bu.status in (</span><br><span class="line">               1,</span><br><span class="line">            2)      </span><br><span class="line">         inner join</span><br><span class="line">            org_emp_info oei           </span><br><span class="line">               on  oei.data_id &#x3D; bu.user_id           </span><br><span class="line">               and oei.node_left &gt;&#x3D; 2875           </span><br><span class="line">               and oei.node_right &lt;&#x3D; 10802           </span><br><span class="line">               and oei.org_category &#x3D; - 1      </span><br><span class="line">         where</span><br><span class="line">            c.id &#x3D; cb.contact_id    </span><br><span class="line">      )    </span><br><span class="line">   order by</span><br><span class="line">      c.created_time desc  limit 0 ,</span><br><span class="line">      10;</span><br></pre></td></tr></table></figure>

<p>验证一下效果 预计在1ms内，提升了13000多倍！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>本以为至此大工告成，但我们在前面的分析中漏了一个细节，先排序再join和先join再排序理论上开销是一样的，为何提升这么多是因为有一个limit！大致执行过程是：mysql先按索引排序得到前10条记录，然后再去join过滤，当发现不够10条的时候，再次去10条，再次join，这显然在内层join过滤的数据非常多的时候，将是灾难的，极端情况，内层一条数据都找不到，mysql还傻乎乎的每次取10条，几乎遍历了这个数据表！</p>
<p>用不同参数的SQL试验下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   sql_no_cache   c.id,</span><br><span class="line">   c.name,</span><br><span class="line">   c.position,</span><br><span class="line">   c.sex,</span><br><span class="line">   c.phone,</span><br><span class="line">   c.office_phone,</span><br><span class="line">   c.feature_info,</span><br><span class="line">   c.birthday,</span><br><span class="line">   c.creator_id,</span><br><span class="line">   c.is_keyperson,</span><br><span class="line">   c.giveup_reason,</span><br><span class="line">   c.status,</span><br><span class="line">   c.data_source,</span><br><span class="line">   from_unixtime(c.created_time) <span class="keyword">as</span> created_time,</span><br><span class="line">   from_unixtime(c.last_modified) <span class="keyword">as</span> last_modified,</span><br><span class="line">   c.last_modified_user_id    </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   contact c   </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   <span class="keyword">exists</span> (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         <span class="number">1</span>        </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         contact_branch cb         </span><br><span class="line">      <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">         branch_user bu                     </span><br><span class="line">            <span class="keyword">on</span>  cb.branch_id = bu.branch_id                     </span><br><span class="line">            <span class="keyword">and</span> bu.status <span class="keyword">in</span> (</span><br><span class="line">               <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span>)                </span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">            org_emp_info oei                           </span><br><span class="line">               <span class="keyword">on</span>  oei.data_id = bu.user_id                           </span><br><span class="line">               <span class="keyword">and</span> oei.node_left &gt;= <span class="number">2875</span>                           </span><br><span class="line">               <span class="keyword">and</span> oei.node_right &lt;= <span class="number">2875</span>                           </span><br><span class="line">               <span class="keyword">and</span> oei.org_category = - <span class="number">1</span>                </span><br><span class="line">         <span class="keyword">where</span></span><br><span class="line">            c.id = cb.contact_id           </span><br><span class="line">      )        </span><br><span class="line">   <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">      c.created_time <span class="keyword">desc</span>  <span class="keyword">limit</span> <span class="number">0</span> ,</span><br><span class="line">      <span class="number">10</span>;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">2</span> <span class="keyword">min</span> <span class="number">18.99</span> sec)</span><br></pre></td></tr></table></figure>

<p>2 min 18.99 sec！比之前的情况还糟糕很多。由于mysql的nested loop机制，遇到这种情况，基本是无法优化的。这条语句最终也只能交给应用系统去优化自己的逻辑了。</p>
<p>通过这个例子我们可以看到，并不是所有语句都能优化，而往往我们优化时，由于SQL用例回归时落掉一些极端情况，会造成比原来还严重的后果。所以，第一：不要指望所有语句都能通过SQL优化，第二：不要过于自信，只针对具体case来优化，而忽略了更复杂的情况。</p>
<p>慢查询的案例就分析到这儿，以上只是一些比较典型的案例。我们在优化过程中遇到过超过1000行，涉及到16个表join的“垃圾SQL”，也遇到过线上线下数据库差异导致应用直接被慢查询拖死，也遇到过varchar等值比较没有写单引号，还遇到过笛卡尔积查询直接把从库搞死。再多的案例其实也只是一些经验的积累，如果我们熟悉查询优化器、索引的内部原理，那么分析这些案例就变得特别简单了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter13-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter13-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">chapter13:线程安全与锁优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-16 22:17:11" itemprop="dateCreated datePublished" datetime="2020-11-16T22:17:11+08:00">2020-11-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-31 22:39:35" itemprop="dateModified" datetime="2021-03-31T22:39:35+08:00">2021-03-31</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ref:</p>
<ol>
<li>Java并发-atomic原子类包源码剖析<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/27e07df2672e">https://www.jianshu.com/p/27e07df2672e</a></li>
</ol>
<h2 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h2><p>本章将介绍如何保证并发的正确性和如何实现线程安全。</p>
<h2 id="13-2-线程安全"><a href="#13-2-线程安全" class="headerlink" title="13.2 线程安全"></a>13.2 线程安全</h2><p>见JCP的定义吧，这本书的定义不太好。</p>
<h3 id="13-2-1-Java-语言中的线程安全"><a href="#13-2-1-Java-语言中的线程安全" class="headerlink" title="13.2.1 Java 语言中的线程安全"></a>13.2.1 Java 语言中的线程安全</h3><p>我们可以不把线程安全当做一个非真即假的二元排他选项来看待，按照线程安全的“安全程度”由强至弱来排序，我们可以将 Java 语言中各种操作共享的数据分为以下 5 类：</p>
<h4 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1. 不可变"></a>1. 不可变</h4><p>不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要采取任何的线程安全保障措施，final 关键字带来的可见性就提到这一点，只有一个不可变的对象被正确地构建出来（没有发生 this 逃逸的情况），那其外部的可见状态永远不会改变，永远也不会看到它在多线程之中处于不一致的状态。</p>
<p>保障对象行为不影响自己状态的途径很多，最简单的就是把对象中带有状态的变量都声明为 final，这样在构造函数结束之后，它就是不可变的。</p>
<h4 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2. 绝对线程安全"></a>2. 绝对线程安全</h4><p> “不管运行时环境如何，调用者都不需要任何额外的同步措施” 通常需要付出很大的，甚至是不切实际的代价。在 Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。</p>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>java.util.Vector 是一个线程安全的容器，它的 add()、get()、size() 这方法都是被 synchronized 修饰的，但是，也不意味着调用它的时候永远不需要同步手段。</p>
<p>很明显，尽管这里调用的 Vector 的 get()、remove()、size() 方法都是同步的，但是在多线程环境中，如果不在方法调用端做额外的同步措施，这段代码仍然是不安全的。因为如果另一个线程恰好在错误的时间里删除一个元素，导致序号 i 已经不再可用的话，再用 i 访问数组就会抛出一个 ArrayIndexOutOfBoundsException。</p>
<h4 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3. 相对线程安全"></a>3. 相对线程安全</h4><!--相对线程安全就是我们通常意义上讲的线程安全-->，**它需要保证这个对象单独的操作时线程安全的**，我们调用的时候不需要做额外的保障措施，但是对一些特定顺序的连续调用，就可能需要在调用端使用额外的不同手段来保证调用的正确性。

<p>Java 中大部分的线程安全类都属于这种类型，如果 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p>
<h4 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4. 线程兼容"></a>4. 线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。比如 ArrayList 和 HashMap 等。</p>
<h4 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5. 线程对立"></a>5. 线程对立</h4><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。略。</p>
<h3 id="13-2-2-线程安全的实现方法"><a href="#13-2-2-线程安全的实现方法" class="headerlink" title="13.2.2 线程安全的实现方法"></a>13.2.2 线程安全的实现方法</h3><p>本节，代码编写如何实现线程安全和虚拟机如何实现同步与锁这两者都会有所涉及，相对而言更偏重后者一些。</p>
<h4 id="1-互斥同步（悲观锁）"><a href="#1-互斥同步（悲观锁）" class="headerlink" title="1. 互斥同步（悲观锁）"></a>1. 互斥同步（悲观锁）</h4><p>互斥同步是常见的一种并发正确性保障手段<!--其实我认为是牺牲一定的并发性能，使得串行化和阻塞化，以保证正确性-->。</p>
<p><strong>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用</strong>。</p>
<p><strong>互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这 4 个字面里，互斥是因，同步时果；互斥是方法，同步是目的。</strong></p>
<blockquote>
<p>互斥同步也叫阻塞同步。</p>
</blockquote>
<p>Java 中最基本的互斥同步手段就是 synchronized 关键字，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码指令都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指明了对象参数，那就是说这个对象的 reference；如果没有明确指明，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。</p>
<p>根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，相应的，在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就释放了。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p>
<p>首先，synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的情况。其次，同步块在已经进入的线程执行完成之前，会阻塞后面其他线程的进入。</p>
<p>Java 的线程是映射到操作系统的原生线程上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态上，因此状态转换需要耗费很多的处理器时间。对代码简单的同步块（如被 synchronized 修饰的 getter()或 setter() 方法），状态转换消耗的时间可能比用户代码执行的时间还要长。所以 synchronized 是 Java 语言中的一个重量级的操作。<!--而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，而避免频繁的切入到核心态之中。--></p>
<p>除了 synchronized 之外，我们还可以使用 juc 包中的重入锁（ReentrantLock）来实现同步。它还有一些高级功能：等待可中断、可实现公平锁、以及锁可以绑定多个条件。</p>
<ul>
<li>等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理器执行时间非常长的同步块很有帮助。比如 tryLock(long timeout, TimeUnit unit) 方法。</li>
<li>公平锁：指多个线程在等待同一个锁时，必须要按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 的锁是非公平的，ReentrantLock 默认情况下也是非公平的，可以通过带布尔值的构造函数创建公平锁。</li>
<li>锁绑定条件：指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外的添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition() 方法即可。</li>
</ul>
<p>JDK 1.6  或以上的版本 synchronized 与 ReentrantLock 的性能基本上完全持平了。优先考虑使用 synchronized 来进行同步。</p>
<h4 id="2-非阻塞同步（乐观锁）"><a href="#2-非阻塞同步（乐观锁）" class="headerlink" title="2. 非阻塞同步（乐观锁）"></a>2. 非阻塞同步（乐观锁）</h4><p>互斥（阻塞）同步最主要的问题时进行线程阻塞和唤醒所带来的的性能问题。<strong>它属于一种悲观的并发策略</strong>，<!--总是认为只要不去做正确的同步措施（如加锁），那肯定会出现问题，无论是数据共享还是真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作-->。随着指令集的发展，我们有了另一个选择：基于冲突检测的并发策略，通俗的说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止）。这种<strong>乐观的并发策略</strong>的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。</p>
<p>因为我们需要操作和检测这两个步骤是具备原子性，硬件可以保证一个从遇上看起来需要多次操作的行为只通过一条处理器指令就能完成，这样指令常用的有：</p>
<ul>
<li>测试并设置（test-and-set）。</li>
<li>获取并增加（fetch-and-increment）。</li>
<li>交换（swap）。</li>
<li>比较并交换（compare-and-swap，下文称为 CAS）。</li>
<li>加载链接/条件存储（load-linked/store-conditional，下文称 LL/SC）。</li>
</ul>
<p>CAS 指令需要 3 个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 指令执行时，当前仅当 V 符合预期值 A 时，处理器就用新值更新 V 值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。</p>
<blockquote>
<p>CAS比较与交换的伪代码可以表示为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	备份旧数据；</span><br><span class="line">	基于旧数据构造新数据；</span><br><span class="line">&#125;<span class="keyword">while</span>(!CAS( 内存地址，备份的旧数据，新数据 ))</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/5954965-b88918b03518f254?imageMogr2/auto-orient/strip%7CimageView2/2/w/320/format/webp" alt="img"></p>
<p>注：t1，t2线程是同时更新同一变量56的值</p>
<p>因为t1和t2线程都同时去访问同一变量56，所以他们会把主内存的值完全拷贝一份到自己的工作内存空间，所以t1和t2线程的预期值都为56。</p>
<p>假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败。（失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试）。t1线程去更新变量值改为57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了（想改的值不再是原来的值）。</p>
<p>（上图通俗的解释是：CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值。）</p>
<p>就是指当两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。<!--容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的commit-retry 的模式, 和redis的watch模式。-->当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。</p>
</blockquote>
<p>JDK 1.5 之后，Java 程序才可以使用 CAS 操作，该操作是由 sun.misc.Unsafe 类里面的 compareAndSwapInt() 等几个方法包装提供的。</p>
<p>JUC 中的 AtomicInteger 类中的 incrementAndGet() 方法就是使用 Unsafe 类的 getAndAddInt() 方法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... AtomicInteger 类 ...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... Unsafe 类 ...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>CAS 还有一个逻辑漏洞：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，如果这期间它的值曾经被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的“ABA”问题。JUC 包中提供了一个一个带有标记的原子引用类“AtomicStampedReference”类来解决这个问题，它可以保证 CAS 的正确性。</p>
<blockquote>
<p><a href="">使用版本号解决ABA问题</a></p>
<p>只是简单的数据结构，确实不会有什么问题，如果是复杂的数据结构可能就会有问题了（<strong>使用<code>AtomicReference</code>可以把<code>C A S</code>使用在对象上</strong>），以链表数据结构为例，两个线程通过<code>C A S</code>去删除头节点，假设现在链表有<code>A-&gt;B</code>节点</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8ny1VNcSscicjAax5qNibFxqiabJLQZYt6OMXoBHbMIlLoNjgVt85LZlT0FGAoWB09ScvI5KITMSr9qxg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:50%;" />

<ul>
<li>线程<code>1</code>删除<code>A</code>节点，<code>B</code>节点成为头节点，正要执行<code>C A S(A,A,B)</code>时，时间片用完，切换到线程<code>2</code></li>
<li>线程<code>2</code>删除<code>A、B</code>节点</li>
<li>线程<code>2</code>加入<code>C、A</code>节点，链表节点变成<code>A-&gt;C</code></li>
<li>线程<code>1</code>重新获取时间片，执行<code>C A S(A,A,B)</code></li>
<li>丢失<code>C</code>节点</li>
</ul>
<p>要解决<code>A B A</code>问题也非常简单，只要追加版本号即可，每次改变时加<code>1</code>，即<code>A —&gt; B —&gt; A</code>，变成<code>1A —&gt; 2B —&gt; 3A</code>，在<code>Java</code>中提供了<code>AtomicStampedRdference</code>可以实现这个方案</p>
</blockquote>
<p>不过目前这个类比较“鸡肋”。大部分情况下 ABA 问题不会影响程序的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h4 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3. 无同步方案"></a>3. 无同步方案</h4><p>要保证线程安全，并不是一定要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性手段。如果一个方法本来就不涉及共享数据，那就自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。</p>
<h5 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h5><p>可重入代码也叫做纯代码，可以额在代码执行的任意时刻中断它，转而去执行另一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入的代码有一些公共的特征，比如不依赖存储在堆上的数据和公共系统资源、用到的状态量都是由参数传入、不可调用非可重入的方法等。<!--其实就是JCP说的线程封闭中的栈封闭，比如局部变量--></p>
<h5 id="线程本地存储（Thread-Local-Storage）"><a href="#线程本地存储（Thread-Local-Storage）" class="headerlink" title="线程本地存储（Thread Local Storage）"></a>线程本地存储（Thread Local Storage）</h5><p>如果一段代码所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样就无须同步也能保证线程之间不会出现数据争用的问题。</p>
<p>符合这种特点的应用程序有很多，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的应用实例就是经典 web 交互模式中的“一个请求对应一个服务器线程”的处理方式，这种处理方式的广泛应用使得很多 web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>在 Java 中可以通过 ThreadLocal类来实现线程本地存储的功能，每一个线程 Thread 对象都一个 ThreadLocalMap 对象，这个对象存储了一组以 ThreadLocal.threadLocalHashCode 为键，以本地线程变量为值的 K-V 值对，ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个 ThreadLocal 对象都包含了一个独一无二的 threadLocalHashCode 值，这个值就可以在线程 K-V 值对中找回对应的本地线程变量。</p>
<h2 id="13-3-锁优化"><a href="#13-3-锁优化" class="headerlink" title="13.3 锁优化"></a>13.3 锁优化</h2><p>高效并发是从 JDK 1.5 到 JDK 1.6 的一个重要改进，HotSpot 虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<h3 id="13-3-1-自旋锁与自适应自旋"><a href="#13-3-1-自旋锁与自适应自旋" class="headerlink" title="13.3.1 自旋锁与自适应自旋"></a>13.3.1 自旋锁与自适应自旋</h3><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机开发团队发现很多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍微等一下”，但不放弃处理器的执行时间，看看持有的锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p>
<p><strong>自旋锁等待不能代替阻塞，它本身虽然避免了线程切换的开销，但是它要占用处理器时间的</strong></p>
<blockquote>
<p>如果锁被占用的时间很短，自旋等待的效果会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。</p>
</blockquote>
<p>JDK 1.6 引入了自适应的自旋锁，意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。</p>
<h3 id="13-3-2-锁消除"><a href="#13-3-2-锁消除" class="headerlink" title="13.3.2 锁消除"></a>13.3.2 锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除技术主要判定来源于逃逸分析的数据支持，如果判断在一段代码上，堆上所有的数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然无须进行。</p>
<h3 id="13-3-3-锁粗化"><a href="#13-3-3-锁粗化" class="headerlink" title="13.3.3 锁粗化"></a>13.3.3 锁粗化</h3><p>原则上我们编写代码时，总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>大部分情况下，上面的原则是正确的，但是如果发生一系列的连续操作都是对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>如果虚拟机检测到这样的操作，就会将锁同步的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。</p>
<h3 id="13-3-4-轻量级锁"><a href="#13-3-4-轻量级锁" class="headerlink" title="13.3.4 轻量级锁"></a>13.3.4 轻量级锁</h3><p>轻量级锁是 JDK 1.6 中加入的新型加锁机制。它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<p>HotSpot 虚拟机的对象（对象头部分）的内存布局分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希吗（HashCode）、GC 分代年龄等，这部分数据的长度在 32 位和 64 位的虚拟机中分别为 32bit 和 64bit，官方它称为“Mark Word”，它是实现轻量级锁和偏向锁的关键。另一部分用户存储指向方法区对象类型的指针，如果是数据对象，还会有一个额外的部分用于存储数组长度。</p>
<p>对象头信息食欲对象自身定义的数据无关的额外存储成功，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如 32 位的 HotSpot 虚拟机中对象未被锁定的状态下，Mark Word 的 32bit 空间中的 25bit 用于存储对象哈希吗（HashCode），4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0；在其他状态（轻量级锁定、重量级锁定、GC 标记、可偏向）下对象的存储内容如下表：</p>
<p><img src="https://note.youdao.com/yws/public/resource/e5ba56d8a5585cac6e73e80de14f2f32/xmlnote/60906136B69B4E1080B14474EC105C1A/84583" alt="image"></p>
<p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（lock record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀），这时候线程堆栈与对象头的状态如图 13-3 所示。</p>
<p>然后，虚拟机将使用 CAS 操作尝试将这个对象的 Mark Word 更新为指向 Lock Record 的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（ Mark Word 的最后 2bit）将转变为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图 13-4 所示。</p>
<p><img src="https://note.youdao.com/yws/public/resource/e5ba56d8a5585cac6e73e80de14f2f32/xmlnote/5F5DFBE021EC430993AF678E1A506CD2/84596" alt="image"></p>
<p>如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p>
<p>上面描述的是轻量级锁的加锁过程，它的解锁过程就是通过 CAS 操作来进行的，如果对象的 Mark Word 仍然指向着线程的锁记录，那就用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取锁，那就要在释放锁的同时，唤醒被挂起的线程。</p>
<p>轻量级锁能提升程序同步性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，但是如果存在竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p>
<h3 id="13-3-5-偏向锁"><a href="#13-3-5-偏向锁" class="headerlink" title="13.3.5 偏向锁"></a>13.3.5 偏向锁</h3><p>偏向锁也是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了。</p>
<p>偏向锁的“偏”是偏心、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p>当锁对象第一次被线程获取的时候，虚拟机将会把这个对象头中的标志位设为“01”，即偏向模式。同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如 Locking、Unlocking 以及 Mark Word 的 Update 等）。</p>
<p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定状态（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如上面接收的轻量级锁那样执行。偏向锁、轻量级锁的状态转化以及对象 Mark Word 的关系如图所示。</p>
<p><img src="https://note.youdao.com/yws/public/resource/e5ba56d8a5585cac6e73e80de14f2f32/xmlnote/EAC7A78FC409443FA484195330BC73B0/84653" alt="image"></p>
<p>偏向锁可以提高带有同步但无竞争的程序性能，它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向锁就是多余的。在具体问题分析的前提下，有时候使用 -XX:-UseBiasedLocking 来禁止偏向锁优化反而可以提升性能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/16/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp/%E7%94%B1%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%9D%A5%E7%90%86%E8%A7%A3%E4%B8%8BTCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/16/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp/%E7%94%B1%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%9D%A5%E7%90%86%E8%A7%A3%E4%B8%8BTCP/" class="post-title-link" itemprop="url">由一次线上故障来理解下TCP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-16 12:23:23" itemprop="dateCreated datePublished" datetime="2020-11-16T12:23:23+08:00">2020-11-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2024-10-06 17:43:26" itemprop="dateModified" datetime="2024-10-06T17:43:26+08:00">2024-10-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>它山之石可以攻玉</p>
<h3 id="ref-links"><a href="#ref-links" class="headerlink" title="ref links:"></a>ref links:</h3><ol>
<li>原文链接，有2行查看jstack和netstat的组合shell脚本<br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903970146615310">https://juejin.im/post/6844903970146615310</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter2-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter2-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/" class="post-title-link" itemprop="url">chapter2:java内存模型与内存溢出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-14 08:17:53" itemprop="dateCreated datePublished" datetime="2020-11-14T08:17:53+08:00">2020-11-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-01 15:45:01" itemprop="dateModified" datetime="2021-06-01T15:45:01+08:00">2021-06-01</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java 虚拟机会在程序执行时将数据划分为几个不同的数据区域。 这些区域有着**<code>不同的用途</code><strong>，</strong><code>创建和销毁的时间</code>**，有的区域随着虚拟机进程的启动而一直存在，有的区域则随着用户线程的启动和结束而建立和销毁。</p>
<p>根据 <strong>《Java虚拟机规范》</strong>的规定，Java虚拟机管理的内存区域包括以下几个**<code>运行时</code>**区域：</p>
<img src="https://img-blog.csdn.net/20161026225551801" style="zoom: 67%;"/>


<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>**<code>性质：线程私有，占用空间小，不会发生OOM，是当前线程执行字节码的行号指示器。</code>**这块空间是线程私有的，因为每个线程都有自己的执行进度。</p>
<p>在 <strong><code>Java 虚拟机的概念模型</code>  **①中：</strong><code>字节码解释器</code><strong>工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，</strong><code>分支</code><strong>、</strong><code>循环</code><strong>、</strong><code>跳转</code><strong>、</strong><code>依赖</code><strong>、</strong><code>异常处理</code><strong>、</strong><code>线程恢复</code>**等基础功能都需要依赖这个计数器来完成。</p>
<p>Java 虚拟机中的**<code>多线程</code><strong>是通过</strong><code>线程轮流切换，分配CPU执行时间片</code>**的方式实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说，是其中的一个内核）都只会执行一条线程中的指令。而程序计数器就担任着线程切换后继续执行线程代码的责任。</p>
<p><strong><code>程序计数器存储的内容：</code></strong></p>
<ul>
<li>如果线程执行的是 <code>Java 方法</code>，则记录的是正在执行**<code>的 虚拟机字节码指令地址</code>**</li>
<li>如果正在执行的是<code>本地方法</code>（<code>Native</code>），则**<code>程序计数器的值为空</code>**（<code>Undefined</code>）</li>
</ul>
<p><strong><code>该区域是《Java虚拟机规范》中唯一一个没有规定任何OOM发生的区域，即该区域不会产生内存溢出错误。</code></strong></p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><strong><code>性质：线程私有，生命周期与线程相同</code></strong></p>
<p><strong><code>虚拟机栈描述的是 Java 方法执行的线程内存模型</code>**：每个方法被执行的时候，Java虚拟机都会同步的创建一个「</strong>栈桢」①（<code>Stack Frame</code>）<strong>，用于存储 「</strong><code>局部变量表</code><strong>」、「</strong><code>操作数栈</code><strong>」，「</strong><code>动态连接</code><strong>」，「</strong><code>方法出口</code>**」 等信息。</p>
<p>每一个方法从被<strong>调用</strong>到<strong>执行完毕</strong>这个过程就对应着一个<code>栈桢</code>在<code>虚拟机</code>中从<code>入栈</code>到<code>出栈</code>的过程。</p>
<blockquote>
<p>方法调用 ==&gt; 栈帧入栈</p>
<p>方法执行完成 ==&gt;栈帧出栈</p>
</blockquote>
<p>我们经常将 Java 中的内存区域简单粗暴的划分为 「**<code>堆</code><strong>」 和 「</strong><code>栈</code><strong>」，所谓的栈指的就是这里的「</strong><code>虚拟机栈</code><strong>」了，或者更多情况下其内容仅仅对应的是 虚拟机栈中的「</strong><code>局部变量表</code>**」 部分。</p>
<p>**<code>局部变量表</code>**：存放了<code>编译期</code>间可知的各种</p>
<ul>
<li><code>Java 虚拟机基本数据类型</code>（<code>boolean</code>，<code>byte</code>，<code>char</code>，<code>short</code>，<code>int</code>，<code>float</code>，<code>long</code>，<code>double</code>）</li>
<li><strong><code>对象引用</code>**（</strong><code>reference</code>** 类型，它可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）</li>
<li><strong><code>returnAddress</code></strong> 类型（**<code>指向一条字节码指令的地址</code>**）</li>
</ul>
<p><strong>局部变量表中的具体存储模式</strong>：使用**<code>变量槽（Slot）存储数据</code>**，64位长度的 long 和 double 类型的会占用2个变量槽，其余数据类型占用1个。</p>
<p><code>局部变量表</code>所需的内存空间在编译期就已经完成分配（因为是可知的），当进入一个方法时，这个<code>方法</code>需要在<code>栈桢中</code>分配多大的<code>局部变量空间是完全确定</code>的，<code>在方法运行期间不会改变局部变量表的大小。</code><!--这里的大小指的是变量槽的数量，而每个槽对应的真实内存占用大小则是虚拟机自行实现。--></p>
<p>虚拟机栈中可能发生的2种异常：</p>
<ul>
<li><strong><code>StackOverflowError</code>**：当</strong><code>线程请求的栈深度大于虚拟机允许的栈深度</code>**时，出现该异常。</li>
<li><strong><code>OutOfMemoryError</code></strong>:  如果虚拟机栈可以动态拓展，而且拓展时无法申请到足够的内存</li>
</ul>
<blockquote>
<p>**<code>①</code>**：栈桢是方法运行时期很重要的数据结构，在本书的 第8章 中对其进行详细讲解。</p>
</blockquote>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用**<code>非常相似</code>**，<code>区别</code>是本地方法栈为虚拟机使用到的<code>本地方法</code>服务，而虚拟机栈则是为虚拟机使用到的 <code>Java 方法</code>服务。</p>
<p>《Java 虚拟机规范》对本地方法栈中的方法使用的<code>语言</code>，<code>使用方式</code>，<code>数据结构</code>**<code>没有任何强制规定</code>**，具体的虚拟机可以根据需要自由地实现。例如 **<code>HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一</code>**。</p>
<h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p>对于 Java 应用程序来说，「**<code>堆</code><strong>」 是 虚拟机所管理的内存中</strong><code>最大的一块</code><strong>，堆也是线程中</strong><code>共享</code><strong>的一块内存区域，在</strong><code>虚拟机启动时创建</code>**。</p>
<blockquote>
<p>**<code>Java 堆中存放着几乎所有的对象实例</code>**。<code>《Java 虚拟机规范》</code> 中这样描述堆：所有的<code>对象实例</code>以及<code>数组</code>都应当在堆上分配。</p>
</blockquote>
<p><strong><code>Java 堆是垃圾收集器管理的内存区域</code>**，因此一些资料中它也被称为 GC 堆。从回收内存的角度来看，由于现代垃圾收集器大部分都是基于「</strong><code>分代收集</code><strong>」理论设计，所以 Java 堆中经常出现</strong><code>「新生代」、「老年代」、「永久代」、「Eden空间」、「From Survivor 空间」、「To Survivor 空间」</code><strong>等名词、这些区域的划分仅仅是一些垃圾收集器的</strong><code>共同特性</code><strong>或者</strong><code>设计风格</code><strong>而已，</strong><code>而非某个 Java 虚拟机具体实现的固有内存布局，更不是《Java 虚拟机规范》里对 Java 堆的进一步细致划分。</code>**</p>
<p>在**<code>十年前</code><strong>，以 <code>G1</code> 收集器的出现作为分界，作为业界绝对主流的 <code>HotSpot</code> 虚拟机的内部垃圾收集器全部基于「</strong><code>经典分代</code><strong>」设计，需要 <code>新生代</code>、<code>老年代</code>收集器搭配才能工作，在这样的背景下，上面的说法还算是不会产生太大歧义。但是</strong><code>到了今天</code><strong>，垃圾收集器技术与十年前已经不可用同日而语，</strong><code>HotSpot</code>** 里也出现了**<code>不采用 分代设计的新垃圾收集器</code>**，再按之前的说法来定义就有很多不准确的地方了。</p>
<blockquote>
<p>从分配内存的角度看：所有线程共享的 Java 堆中可以划分出多个<code>线程私有</code>的「**<code>分配缓冲区</code><strong>」（<a href="">Thread Local Allocation Buffer TLAB</a>）来</strong><code>提升对象分配时的效率</code>**。</p>
</blockquote>
<p>但是不管如何划分，都不会改变 <strong>Java堆中存储的内容的性质</strong>：无论哪个区域，存储的都只能是「<code>对象实例</code>」，将Java 堆进行细分的目的是为了**<code>更好地回收内存，或者更快的分配内存</code>**。</p>
<p>根据 <code>《Java 虚拟机规范》</code> 规定，<strong>Java 堆可以处于<code>物理上不连续</code>的内存空间中，但是<code>逻辑上是连续</code>的</strong>，这就像是用磁盘存储文件一样，并不要求每个文件连续存放，但对于大对象（比如数组）多数虚拟机实现出于简单、存储高效的考虑，很可能会要求连续的内存空间来存放数组。</p>
<p>Java堆可以是**<code>固定大小</code><strong>，也可以是</strong><code>可扩展</code><strong>的，通过 <code>-Xmx</code> 和 <code>-Xms</code> 参数设定。如果Java堆中没有足够的内存完成实例分配，并且堆也无法继续扩展，则抛出</strong><code>OOM内存溢出异常</code>**。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p><strong><code>方法区（Method Area)</code></strong> ：<strong>线程共享</strong>，存储已被虚拟机加载的<code>类型信息</code>、<code>常量</code>、<code>静态变量</code>、<code>即时编译器编译后的代码缓存</code>等数据。</p>
<blockquote>
<p>《Java 虚拟机规范》中把方法区描述为「**<code>堆的一个逻辑部分</code><strong>」，但是方法区有一个别名叫做「</strong><code>非堆</code>**」（Non-Heap），目的是与 Java堆区分开。</p>
</blockquote>
<p>到了 <strong><code>JDK8</code>**，</strong><code>完全废弃</code>了<code>永久代</code>的概念<strong>，此时<code>HotSpot</code> 与 <code>JRockit</code> 、<code>J9</code>一样，在</strong><code>本地内存</code><strong>中实现的</strong><code>元空间</code><strong>（Meta-sapace）代替了之前的永久代，将 JDK7 中永久代的剩余内容（主要是</strong><code>类型信息</code>**）移动到元空间中。</p>
<p><code>《Java 虚拟机规范》</code>对于方法区的约束非常宽松，<strong>该区域可以使用不连续的内存，可以选择固定大小和可扩展大小，甚至可以选择不实现垃圾收集</strong>。这部分区域的内存回收目标主要是针对「**<code>常量池</code><strong>」的<code>回收</code>和对Java **<code>类型的卸载</code>**，一般来说针对这个区域的回收<code>效果并不令人满意</code>，尤其是类型卸载的条件非常苛刻，但是对于这部分的回收又是必要的，之前出现过若干严重bug就是这部分区域的回收出现问题导致</strong><code>内存泄漏</code>**。</p>
<p>根据<code>《Java虚拟机规范》</code>规定，<code>方法区如果无法满足新的内存分配需求</code>，抛出 <code>OOM</code> 异常。</p>
<p><strong>为什么要将永久代（PermGen）替换为元空间（MetaSpace）呢？</strong></p>
<blockquote>
<p>其中一个原因是因为 <strong>永久代受 JVM本身设置影响，有固定的内存大小上限</strong>，而元空间使用的是机器的<code>直接内存</code>，只受本机可用内存限制，不会出现 <code>OOM</code> 异常。</p>
<p>可以使用 <code>-XX:MaxMetaSpaceSize</code> 设置最大元空间大小，默认值 <code>unlimited</code>。</p>
</blockquote>
<h3 id="运行时常量池-属于方法区"><a href="#运行时常量池-属于方法区" class="headerlink" title="运行时常量池(属于方法区)"></a>运行时常量池(属于方法区)</h3><p><strong><code>运行时常量池（Runtime Constant Pool）是方法区的一部分。</code></strong> <code>Class 文件</code>中除了有 <code>类的版本</code>、<code>字段</code>、<code>方法</code>、<code>接口</code>等**<code>描述信息</code><strong>外，还有一项信息是「</strong><code>常量池表</code><strong>」（Constant Pool Table），用于存放编译期生成的各种</strong><code>字面量</code><strong>与</strong><code>符号引用</code><strong>，这部分内容将在</strong>类加载后<strong>放到</strong><code>方法区的运行时常量池</code>**中。</p>
<p><strong><code>Java虚拟机对于 Class 文件的每一部分都有严格规定</code></strong> —— 例如每个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机<code>认可</code>、<code>加载</code>和<code>执行</code>，但<strong>对于运行时常量池，《Java 虚拟机规范》没有做任何细节要求</strong>，这使得不同提供商实现的虚拟机可以按照自己的需求来实现这个内存区域。</p>
<p>一般来说，除了保存 Class 文件中描述的**<code>符号引用</code><strong>外，还会把</strong><code>符号引用翻译出来的直接引用</code><strong>也</strong>存储在运行时常量池中**。①</p>
<p><strong><code>运行时常量池</code>**相对于 **<code>Class 文件常量池</code>**的另外一个重要特征是：</strong>具备动态性<strong>。 Java 语言并不要求常量一定只有在编译期才能产生，也就是说，并非只有预置在 Class 文件常量池中的内容才能进入方法区运行时常量池，在程序运行期间也可以将新的常量添加到池中。比如 <code>String</code> 类的 **<code>intern()</code></strong> 方法就是将字符串添加到运行时常量池中。</p>
<p><strong>运行时常量池是方法区的一部分，所以当常量池无法再申请到内存时会抛出 OOM 异常。</strong></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p><strong>直接内存不是虚拟机运行时数据区域的一部分</strong>，也不是《Java 虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且可能导致 OOM 异常出现，所以作者在这里一起进行讲解。</p>
<p><code>JDK 1.4</code> 中加入了 <code>NIO</code>（New Input/Output)类，引入了一种「**<code>基于通道</code><strong>」（Channel）与「</strong><code>缓冲区</code><strong>」（Buffer）的<code>I/O</code> 方式，</strong>它可以使用 <code>Native</code> 函数库直接分配堆外内存<strong>，然后通过一个存储在 <code>Java</code> 堆中的 **<code>DirectByteBuffer</code></strong> 对象作为这块内存的<strong>引用</strong>进行<strong>操作</strong>。<strong>这样在一些场景中能显著提高性能，因为避免了 <code>Java 堆</code>和 <code>Native 堆</code>之间来回<code>复制数据</code>的开销。</strong></p>
<p><code>本机直接内存</code>是不会受到 <code>Java堆</code>大小的限制，但是既然是内存，则肯定还是受到本机总内存（包括物理内存，SWAP 分区或者分页文件）大小以及处理器寻址空间的限制，一般<strong>配置虚拟机参数</strong>时，会根据实际内存设置 <code>-Xmx</code>等参数信息，但经常<code>忽略了直接内存</code>，如果<strong>各个内存区域的综合大于物理内存限制</strong>（包括实际物理内存和操作系统级的内存限制）从而导致动态扩展时内存不够，就会发生**<code>OOM异常</code>**。</p>
<h1 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h1><p><strong>本章主要内容：</strong> <code>HotSpot</code> 虚拟机在Java 堆 中<strong>对象分配</strong>、<strong>布局</strong>和<strong>访问</strong>的全过程。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>最简单最常用的创建对象的方式：使用 <code>new</code> 操作符。在虚拟机中，以下是虚拟机中普通对象（仅限普通 Java 对象，不包括数组和 Class 类型对象）的创建过程：</p>
<ol>
<li><p>当JVM 遇到一条内容是 <code>new</code> 的字节码指令时，**<code>首先检查</code>**这个指令的参数是否能在常量池<!--这里指的应该是方法区的运行常量池-->中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被<code>加载</code>、<code>解析</code>和<code>初始化</code>过。</p>
<ul>
<li><strong>如果没有，则执行</strong>「**<code>类加载</code>**」过程。这个过程在第7章中详细探讨。</li>
</ul>
</li>
<li><p>当类加载检查通过后，**<code>接下来虚拟机为新生对象分配内存</code>**。 对象所需的内存大小在类加载完成后就可以完全确定下来，为对象分配空间相当于把一块确定大小的内存块从 Java 堆中划分出来。</p>
<ul>
<li><p>如果Java 堆中的内存是绝对规整的，所有被使用过的内存都放在一边，没有使用的放在另一边，中间存在一个指针作为分界点的指示器，那么分配内存只需要将指向向空闲空间方向挪动一段与对象大小相等的距离即可，这种方式叫做「**<code>指针碰撞</code>**」（Bump The Pointer）。</p>
</li>
<li><p>如果 Java 堆中的内存并不是规整的，已被使用的内存和空间内存相互交错，那就没有办法简单地通过指针碰撞完成了，则虚拟机需要维护一个「**<code>空闲列表</code>**」（Free List）。</p>
</li>
<li><p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又取决于采用的垃圾收集器是否带有 「<strong>空间压缩整理</strong>」（Compact）能力决定。</p>
<ul>
<li>当使用 <strong><code>Serial</code>**、</strong><code>ParNew</code>**  <!--新生代收集器,serial,parnew,parallel scanvage都是标记复制--> 等带压缩整理过程的收集器时，系统采用的分配方法是「指针碰撞」，既简单又高效；</li>
<li>当使用 <strong><code>CMS</code></strong> 这种基于<code>清除（Sweep）算法</code>的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</li>
</ul>
</li>
<li><p>除了划分可用空间，还需要考虑对象的创建是非常频繁的行为，有可能存在正在给对象A 分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况，针对这个问题有两种解决方案：</p>
<ul>
<li>对分配内存空间的动作进行同步处理 —— 实际上虚拟机是采用 **<code>CAS（Compare And Swap）</code>**配上失败重试的方式保证更新操作的原子性</li>
<li>把内存分配动作按线程划分在不同的空间之中进行 —— 每个线程在 Java 堆中预先分配一小块内存空间，称为「本地线程缓冲（TLAB）」，哪个线程要分配内存，就在那个线程的本地缓冲区中进行分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。是否使用TLAB 可以使用参数 <code>XX: +/- UseTLAB</code> 参数设定</li>
</ul>
</li>
</ul>
</li>
<li><p>从<strong>虚拟机的视角</strong>来看，<strong>初始化零值之后</strong>一个<code>新的对象</code>就<code>已经产生</code>了。但是从<strong>Java程序视角</strong>来看，对象的创建才<code>刚刚开始</code>——构造函数还没有执行，所有的类实例字段都是默认的零值，对象需要的其他资源和状态信息也没有按照预定的意图构造好。<!--哈哈，这也是面试常常问的点--></p>
<ul>
<li>一般来说，由字节码流中的 <code>new</code> 指令后面是否跟随 <code>invoke special</code> 指令所决定， <strong>Java 编译器</strong>会在遇到 <code>new</code> 关键字的地方<strong>同时生成这两条字节码指令</strong>，但如果直接通过其他方式产生的对象则不一定如此。 new 指令之后会接着执行 <code>&lt;init&gt;()</code>方法，也就是构造函数中的对象初始化的内容，这样一个真正可用的对象才完全被构建完成。</li>
</ul>
</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MDE3MTQwLTgwMzc0ZTY1YzZiMjBjYmU" style="zoom: 50%;" />

<p>HotSpot虚拟机对象在堆内存的<strong>存储布局</strong>分为3个部分：</p>
<ul>
<li><code>对象头 Header</code></li>
<li><code>实例数据 InstnaceData</code></li>
<li><code>对齐填充 Padding</code></li>
</ul>
<p>对象头包括两类信息：</p>
<p><strong><code>第一类</code>**用于存储「</strong>对象自身的运行时数据<strong>」，如 <code>哈希码</code>（HashCode）、<code>GC 分代年龄</code>、<code>锁状态标志</code>、<code>线程持有的锁</code>、<code>偏向线程ID</code>、<code>偏向时间戳等</code>。这部分数据在 32位和64位虚拟机中的长度分别为 32 和 64 个比特，官方称这部分为 “**Mark Word</strong>“</p>
<p>对象需要存储的运行时数据很多，其实已经超出了 32、64位 <code>Bitmap</code> 结构所能记录的最大限度，但是对象头里的信息是<strong>与对象自身定义的数据无关的额外存储成本</strong>，考虑到虚拟机的空间效率，Mark Word 被设计成一个有着<strong>动态定义的数据结构</strong>，目的是在<strong>极小的空间内存储尽可能多的数据，根据对象的状态复用自己的存储空间</strong>。</p>
<p>例如在 32位 的 HotSpot 虚拟机中，对象未被同步锁锁定的状态下， Mark Word 的 32个 比特存储空间中的 <code>25个 比特存储对象哈希吗，4个比特存储对象分代年龄，2个比特存储锁标志位，1个比特固定为0</code>.</p>
<p>在其他状态（轻量级锁定，重量级锁定，GC标记、可偏向）下对象的存储内容如下表所示：</p>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>对象哈希码、对象分代年龄</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向锁记录的指针</td>
<td>00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td>10</td>
<td>膨胀（重量级锁定）</td>
</tr>
<tr>
<td>空、不需要记录信息</td>
<td>11</td>
<td>GC 标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
</tbody></table>
<p>对象头中的另一部分存储的是 「<strong>类型指针</strong>」，即对象指向它的类型元数据的指针（也就是 Class类？），Java 虚拟机通过这个指针来确定该对象是哪个类的实例。</p>
<p>并不是所有虚拟机实现都必须在对象数据上保留类型指针，也就是说查<strong>找对象的元数据信息并不一定要经过对象本身</strong>。</p>
<p>如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录<strong>数组长度</strong>的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是如果数组的长度是不确定的，则无法通过元数据中的信息推断出数组的大小。</p>
<h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p>创建对象的目的当然是访问对象，访问对象首先需要定位对象。 Java 程序通过<strong>栈上</strong> <code>reference</code> 数据来操作堆上的具体对象。对象的具体访问方式由虚拟机自己实现，《Java 虚拟机规范》中对于 reference 只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问对象。</p>
<p>目前的主流方式有两种：</p>
<ol>
<li>**<code>使用句柄</code>**。</li>
<li>**<code>直接指针</code>**。</li>
</ol>
<ul>
<li>如果使用句柄，则 Java 堆中可能会划分出一块内存用来作为「**<code>句柄池</code><strong>」，<code>reference</code> 中存储的就是对象的<code>句柄地址</code>，而句柄中包含了「</strong><code>对象实例数据</code><strong>」与「</strong><code>类型数据</code>**」各自具体的地址信息。</li>
</ul>
<p><img src="http://static.oschina.net/uploads/space/2012/0219/232926_WTnX_103999.png"></p>
<ul>
<li>如果使用直接指针访问， Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li>
</ul>
<p><img src="http://static.oschina.net/uploads/space/2012/0219/232935_FM5T_103999.png"></p>
<p>这两种访问方式<code>各有优势</code>：使用句柄访问最大的好处是在 <code>reference</code> 中存储的是<strong>稳定句柄地址</strong>，在<strong>对象被移动</strong>（垃圾收集时移动对象是非常普遍的行为）<strong>时</strong>只需要<code>改变句柄中的实例数据指针</code>，而 <code>reference</code> <strong>本身不需要被修改。</strong></p>
<p>使用直接指针访问最大的好处就是速度更快，省去了一次指针定位的时间开销，由于对象访问这个操作在虚拟机中非常频繁，所以这类开销积少成多也是一项极为客观的执行成本。</p>
<p><code>HotSpot</code> 主要使用第二种方式进行对象访问（也存在例外，如果使用了 <code>Shenandoah</code> 收集器也会有一次额外的转发）。</p>
<p>但是在各种语言、框架中使用句柄来访问对象的方式也十分常见。</p>
<h2 id="实验课："><a href="#实验课：" class="headerlink" title="实验课："></a>实验课：</h2><p>-XX:+PrintGCDetails</p>
<ol>
<li>堆异常<ol>
<li>通过参数-Xms20M   -Xmx20M 控制</li>
</ol>
</li>
<li>栈异常<ol>
<li>通过-Xss128k</li>
</ol>
</li>
<li>方法区和运行时常量区异常<ol>
<li>通过-XX:PermSize=10M -XX:MaxPermSize=10M</li>
<li>String.intern()方法是一个Native方法，如果字符串常量池中已经包含了一个等于此String对象的字符串，则返回，否则，直接将此String对象包含的字符串加到常量池中，并返回引用。</li>
<li>小补充：比如CGLIB这种类增强技术，需要很大的方法区保证动态生成的Class可以加载到内存</li>
<li>现在jdk越来越“去永久代“</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter3%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter3%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/" class="post-title-link" itemprop="url">chapter3对象的共享</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-13 09:19:03" itemprop="dateCreated datePublished" datetime="2020-11-13T09:19:03+08:00">2020-11-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-20 11:13:16" itemprop="dateModified" datetime="2021-03-20T11:13:16+08:00">2021-03-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Abstract：第二章开头指出，要编写正确的并发程序，关键在与：在访问共享的可变状态时，需要正确的管理。第二章通过<strong>同步</strong>，避免多个线程同时访问相同的变量 (在《高性能MySQL》书中，这叫做<strong>避免并发</strong>)；而本章介绍如何<strong>共享</strong>和<strong>发布对象</strong>，从而使多个线程可以同时安全的访问相同的变量。这两章合在一起就形成了构建线程安全类以及通过java.util.concurrent类库来构建并发应用程序的重要基础。</p>
<p><a href="">synchronized不仅仅只有原子性，还具有内存可见性</a>。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化<!--这种内存可见性像MySQL中所说的Read Uncomitted事务隔离级别的可见性-->。如果没有同步，那么这种情况就无法实现。你可以通过显式地同步或者类库中内置的同步来保证对象被安全地发布。</p>
<!--这里注意：synchronized保障了变量不可修改，但是这个变量必须在同步代码块执行完了，才能被其他线程访问到最新变化。所以，我现在希望这个变量的变化，在同步代码块还没执行完时，就能及时被其他线程获取到最新数据，怎么办呢？就是volatile,使用可见性-->

<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready)</span><br><span class="line">                Thread.yield();</span><br><span class="line"><span class="comment">//这里可能输出0，也可能永远都不会输出</span></span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可能会产生两个问题</p>
<ul>
<li>一是程序可能一直保持循环，因为对于读线程来说，ready的值可能永远不可见。</li>
<li>二是输入的number为0，这是因为重排序引起的，在写线程将ready与number从工作内存中写回到主内存中时，在没有同步的机制下，先写ready还是先写number这是不确定的，也就是说将它们写回到主内存时的顺序可能与程序逻辑顺序恰好相反，这是因为在单个线程下，只要重排序不会对结果产生影响，这是允许的。<!--在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。-->

</li>
</ul>
<h3 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h3><p>除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。</p>
<p>上面NoVisibility程序在多线程环境下还可能读取到过期数据，比如当ready为true时，写线程已将number域的值置为了42，但在它还未来得及将这个新值从工作内存中写回到主内存前，读线程就已将ready从主内存中读取出来了，这时的值还是为初始的默认值0，这个值显然是一个已过期了的值，因为number现在真的值应该为42，而不是0。</p>
<!--拓展：在没有同步的情况下读取数据类似于数据库中使用READ_UNCOMMITTED（未提交读）隔离级别，这时你更愿意用准确性来交换性能。-->

<p>在NoVisibility中，过期数据可能导致它打印错误数值，或者程序无法终止。过期数据可能会使对象引用中的数据更加复杂，比如链指针在链表中的实现。过期数据还可能引发严重且混乱的错误，比如意外的异常，脏的数据结构，错误的计算和无限的循环。</p>
<p>下面的程序更对过期数据尤为敏感：如果一个线程调用了set，但还未来得及将这个新值写回到主内存中时，而另一个线程此时正在调用get，它就可能看不到更新的数据了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将set与get同步，使之成为线程安全的。注，仅仅同步某个方法是没有用的。</p>
<h3 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h3><p>非volatile类型的64位数值变量（double和long）。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，当对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值得低32位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。</p>
<h3 id="锁和可见性"><a href="#锁和可见性" class="headerlink" title="锁和可见性"></a>锁和可见性</h3><p>内置锁可以用来确保一个线程以某种可预见的方法看到另一个线程的影响，像下图一样。当B执行到与A相同的锁监视的同步块时，A在同步块之中所做的每件事，对B都是可见的，如果没有同步，就没有这样的保证。<br><img src="https://img-blog.csdnimg.cn/20190316230729391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTUxOTgz,size_16,color_FFFFFF,t_70" style="zoom:67%;" /></p>
<p>现在我们可以进一步理解为什么在访问某个共享且可变的变量时要求所有线程在<strong>同一个锁上同步</strong>，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果一个线程在未持有正确锁的情况下去读某个变量，那么读到的可能是一个失效值。</p>
<blockquote>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
</blockquote>
<h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><p>volatile是一种弱同步的形式，它确保对一个变量的更新后对其他线程是可见的。当一个域声明为volatile类型后，编译器与运行时会监视这个变量：它是共享的，而且对它的操作不会与其他的内存操作一起被重排序。volatile变量不会缓存在寄存器或者缓存其他处理器隐藏的地方 ==&gt; 所以，<strong>读一个volatile类型的变量时，总会返回由某一线程所写入的最新值</strong>。</p>
<p><strong>读取volatile变量的操作不会加锁，也就不会引起执行线程的阻塞</strong>，<!--允许并发访问进行读-->这使得volatile变量相对于sychronized而言，只是轻量级的同步机制<!--针对可见性而言-->。</p>
<p>volatile变量对可见性的影响所产生的价值远远高于变量本身。线程A向volatile变量写入值，随后线程B读取该变量，所有A执行写操作前可见的变量的值，在B读取了这个volatile变量后，对B也是可见的（与解锁前所有动作对后继加锁后的动作可见是一样的）。所以<a href="">从内存可见性的角度来看</a>，写入volatile变量就像退出同步块，读取volatile变量就像进入同步块。但是我们并不推荐过度依赖volatile变量所提供的可见性。因为依赖volatile变量来控制状态可见性的代码，比使用锁的代码更脆弱，更难以理解。</p>
<blockquote>
<p>仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标示一些重要的程序生命周期事件的发生（例如，初始化或关闭）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一定要加上volatile，否则其他线程更新后可能不可见，因为必须等到执行线程同的步代码块全部执行完，其他线程才能看见</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> asleep;</span><br><span class="line"><span class="keyword">while</span> (!asleep)</span><br><span class="line">    countSomeSheep();</span><br></pre></td></tr></table></figure>

<p>volatile变量固然方便，但也存在限制，它们通常被当作标识完成、中断、状态的标记使用，比如上面程序中的asleep变量。尽管volatile也可以用来标示其他类型的状态信息，但是<strong>决定这样做之前请格外小心，如volatile的语义不足以使用自增操作（i++）原子化。</strong></p>
<blockquote>
<p>加锁可以保证可见性与原子性；volatile变量只能保证可见性。</p>
</blockquote>
<p>只有满足了下面所有的标准后，你才能使用volatile变量：<!--其实就是不需要保证原子性，只需要可见性--><br>1、 写入变量时并不依赖变量的当前值；或者能够能够确保只有单一线程修改变量的值；<br>2、 变量不需要与其他的状态变量共同参与不变约束；<br>3、 访问变量时，没有其他的原因需要加锁。</p>
<h2 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h2><p><strong>发布</strong>一个对象的意思是，使对象能够被当前作用域之外的代码中使用。比如将一个指向该对象的引用存储到其他代码可以访问的地方、在一个非私有的方法中返回这个引用、也可以把它传递到共他类的方法中。在很多情况下，我们需要确保对象及它们的内部状态不被暴露，在另外一些情况下，为了正当的使用目的，我们又的确希望发布一个对象，这时为了线程安全可能需要同步。如果变量发布了内部状态，就可能危及到封装性，并使用程序难以维持稳定；如果发布对象时，它还没有完成构造，同样危及线程安全。一个对象在尚未准备地时就将它发布，这种情况称作<strong>逸出</strong>。下面看看一个对象是如何逸出的。</p>
<h3 id="直接发布对象"><a href="#直接发布对象" class="headerlink" title="直接发布对象"></a>直接发布对象</h3><p>最常见的发布对象的方式是将对象的引用存储到公共静态域，任何类和线程都能看到这个域。initialize方法实例化一个新的HashSet实例，并通过将它存储到knownSecrets引用，从而发布了这个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发布对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    knownSecrets = <span class="keyword">new</span> HashSet&lt;Secret&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="间接发布对象"><a href="#间接发布对象" class="headerlink" title="间接发布对象"></a>间接发布对象</h3><p>发布一个对象还会间接地发布其他对象。如果你将一个Secret对象加入集合knownSecrets中，你就已经发布了这个对象，因为任何代码都可以遍历并获得新Secret对象的引用。类似地，从非私有方法中返回引用，也能发布返回的对象，下面发布了包含洲名的数组，而这个数组本应是私有的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部可变的数据逸出（不要这样做）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">&quot;AK&quot;</span>, <span class="string">&quot;AL&quot;</span> ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123; <span class="keyword">return</span> states; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以这种方式发布states会出问题，这样会允许内部可变的数据逸出，请不要这样做。因为任何一个调用者都能修改它的内容。在这个例子中，数组states已经逸出了它所属的范围，这个本就是私有的数据，事实上已经变成公有的了。</p>
<p><strong>当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。一般来说，如果一个已经发布的对象通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。</strong></p>
<p>假定有一个类C，对于C来说，“外部方法”是指行为并不完全由C来规定的方法，包括其他类中定义的方法以及类C中可以被改写的方法（既不是私有[private]方法也不是终结[final]方法）。当把一个对象传递给某个外部方法时，就相当于发布了这个对象。</p>
<p>无论其他的线程会对已发布的线程执行何种操作，其实都不重要，因为误用该引用的风险始终存在。当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。</p>
<p>最后一种发布对象和它的内部状态的机制是发布一个内部类实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="keyword">new</span> EventListener() &#123;<span class="comment">//会过早地暴露this</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当ThisEscape发布EventListener时，也隐含地发布了ThisEscape实例本身，因为在这个内部类的实例中包含了对ThisEscape实例的隐含引用。</p>
<h3 id="安全对象构造过程"><a href="#安全对象构造过程" class="headerlink" title="安全对象构造过程"></a>安全对象构造过程</h3><p><a href="">当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态</a>。从构造函数内部发布的对象，只是一个未完成构造的对象。甚至即使是在构造函数的最后一行发布的引用也是如此。如果this引用在构造器中逸出，这样的对象被认为是“没有正确构建的”，所以不要让this引用在构造期间逸出。</p>
<blockquote>
<p>不要在构造构造过程中使this引用逸出</p>
</blockquote>
<p>一个导致this引用在构造期间逸出的常见错误，是在构造函数中创建局部、匿名线程并启动它或者启动一个线程并显示地将this传递过去，这都是不安全的，因为新的线程在所属对象完成构造前就能看见了。在构造器中创建线程并没有错，但是最好不要立即启动它，取而代之的是，发布一个start或initialize方法来启动对象拥有的线程。</p>
<p>另外，构造器中调用一个覆盖的实例方法（既不是私有方法，也不是终结方法）同样会导致this引用在构造期间逸出。</p>
<p>如果想要在构造器中注册监听器或启动线程，你可以使用一个私有的构造函数和一个公有的工厂方法，这样避免了不正确的构造过程。<br>下面是使用工厂方法防止this引用在构造期间逸出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span> </span>&#123;<span class="comment">//私有构造器</span></span><br><span class="line">        listener = <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态 工厂方法安全发布对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        SafeListener safe = <span class="keyword">new</span> SafeListener();<span class="comment">//等构造完后再注册</span></span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;<span class="comment">//安全发布对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有当构造函数返回时，this引用才应该从线程中逸出。构造函数可以将this引用保存到某个地方，只要其他线程不会在构造函数完成之前使用它。</p>
</blockquote>
<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭。它是实现线程安全性最简单的方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。</p>
<p>在Java语言中并没有强制规定某个变量由锁来保护，同样在Java语言中也无法强制将对象封闭在某个线程中。线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。Java语言及其核心库提供了一些核心机制来帮助维持线程封闭性，例如局部变量和ThreadLocal类，即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。</p>
<h3 id="Ad-hoc-线程封闭"><a href="#Ad-hoc-线程封闭" class="headerlink" title="Ad-hoc 线程封闭"></a>Ad-hoc 线程封闭</h3><p>Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。由于Ad-hoc 线程封闭技术的脆弱性，因此在程序中尽量很少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或ThreadLocal类）。</p>
<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中<!--更准确的说，是栈帧中-->，其他线程无法访问这个栈。</p>
<p>局部变量是线程安全的，只要我们不要将它们逸出。</p>
<h3 id="ThreadLocal-类"><a href="#ThreadLocal-类" class="headerlink" title="ThreadLocal 类"></a>ThreadLocal 类</h3><p>这个类能使先回城中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前线程在调用set时设置的最新值。</p>
<p>ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。</p>
<p>例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有自己的连接，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder </span><br><span class="line">    = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conncetionHolder.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用这项技术。</p>
<p>当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。从概念上看，你可以将ThreadLocal<T>视为包含了Map&lt; Thread,T&gt;对象，其中保存了特定于该线程的值，当ThreadLocal的实现并非如此。这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。</p>
<p>假设你需要将一个单线程应用程序移植到多程序环境中，通过将共享的全局变量转换为ThreadLocal（如果全局变量的语义允许），可以维护线程安全性。然而，如果将应用程序范围内的转换为线程局部的缓存，就不会有太大作用<!--这是因为缓存本来就是全局唯一，供所有的线程共享，如果转换为ThreadLocal，那么每个线程都会有一个缓存，缓存就失去原本的意义-->。</p>
<p>开发人员经常滥用ThreadLocal，例如将所有全局变量都作为ThreadLocal对象，或者作为一种“隐藏”方法参数的手段。ThreadLocal变量类似于全局变量，他能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。</p>
<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>满足同步需求的另一种方法是使用不可变对象。</p>
<p>创建后状态不能被修改的对象叫做不可变对象。不可变对象天生就是线程安全。它们常量域是在构造函数中创建的。既然它们的状态无法被修改，这些常量永远不会变。所以不可变对象永远是线程安全的。</p>
<blockquote>
<p>不可变对象一定是线程安全的。</p>
</blockquote>
<p>不可变性并不简单地等于将对象中的所有域都声明为final类型，所有域都是final类型的对象仍然可能是可变的，因为final域可以获得一个到可变对象的引用。</p>
<blockquote>
<p>只有满足如下状态，一个对象才是不可变的：<br>1、 对象的状态不能在创建后再被修改；<br>2、 对象的所有域都是final类型；<br>3、 对象被正确创建（创建期间没有发生this引用逸出）。</p>
</blockquote>
<p>在不可变对象的内部，同样可以使用可变性对象来管理它们的状态，如下面代码，虽然域stooges是可变的，但它满足了以上三点，所以是一个不可变对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span><span class="comment">//不可变对象可以基于可变对象来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stooges.add(<span class="string">&quot;Moe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final域"><a href="#final域" class="headerlink" title="final域"></a>final域</h3><p>final类型的域时不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的<!--毕竟final类型的域，其实是个地址，这个地址是不可变的，但是地址指向的对象是可变的-->）。然而，在Java内存模型中，final域还有着特殊的语义。final域能确保初始化过程的安全性 <!--???why？看下边注解-->，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。</p>
<!--
我们认为的执行过程是怎么样的呢？
（1）给Holder对象分配内存
（2）调用Holder的构造函数，也就是给n赋值的过程，初始化了成员字段
（3）将holder引用指向我们分配的内存空间
我们认为既然第3步已经执行了（holder引用已经指向最新了），那1、2步肯定已经完成了。可是，在JVM自身的性能优化中，是允许这个顺序乱序执行的。也就是说，它不能保证执行的顺序是1、2、3，也有可能是1、3、2。假设执行了1、3，这是引用已经是最新的了，但2的构造函数没有执行，那你的对象的状态值就是失效的，另一个线程调用assertSanity自然会报出异常
-->

<!--
对于含有final域的对象，JVM必须保证对对象的初始引用在构造函数之后执行，不能乱序执行（out of order），也就是可以保证一旦你得到了引用，final域的值都是完成了初始化的，也就是书中所说的“初始化安全性”的保证。
-->

<p>仅包含一个或两个可变状态的“基本不可变”对象仍然比包含多个可变状态的对象简单。通过将域声明为final类型的，也相当于告诉维护人员这些域时不会变化的。</p>
<blockquote>
<p>正如“除非需要更高的可见性，否则应将所有的域声明为私有域是一个良好的编程习惯，”除非需要某个域是可变的，否则应将其声明为final域“也是一个良好的编程习惯。</p>
</blockquote>
<h3 id="示例：使用Volatile类型来发布不可变对象-我称之为对象封闭"><a href="#示例：使用Volatile类型来发布不可变对象-我称之为对象封闭" class="headerlink" title="示例：使用Volatile类型来发布不可变对象(我称之为对象封闭)"></a>示例：使用Volatile类型来发布不可变对象(我称之为对象封闭)</h3><h4 id="发生竞态条件"><a href="#发生竞态条件" class="headerlink" title="发生竞态条件"></a>发生竞态条件</h4><p>尽管原子引用自身是线程安全的，不过UnsafeCachingFactorizer中存在竞争条件 <!--"读取-修改-写入"，并且违背了约束条件，读取了过期数据-->，当前线程在执行到A 与 B之间或者C 与 D之间，都有可能切换到其他线程，从而造成错误的结果。<!--这里的线程安全问题，是lastNumber和lastFactors不一致--></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有正确原子化的Servlet试图缓存它的最新结果。</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCachingFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger&gt; lastNumber</span><br><span class="line">         = <span class="keyword">new</span> AtomicReference&lt;BigInteger&gt;();<span class="comment">//缓存最后一次客户请求因式分解的数</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger[]&gt;  lastFactors</span><br><span class="line">         = <span class="keyword">new</span> AtomicReference&lt;BigInteger[]&gt;();<span class="comment">//缓存最后一次客户请求因式分解的结果</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">         BigInteger i = extractFromRequest(req);</span><br><span class="line">       	 <span class="comment">//先检查后执行，必须保证lastNumber不是过期数据</span></span><br><span class="line">         <span class="keyword">if</span> (i.equals(lastNumber.get()))<span class="comment">//A</span></span><br><span class="line">             encodeIntoResponse(resp,  lastFactors.get() );<span class="comment">//B</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             BigInteger[] factors = factor(i);</span><br><span class="line">           	 <span class="comment">//lastNumber和lastFactors必须维持状态的约束条件</span></span><br><span class="line">             lastNumber.set(i);<span class="comment">//C</span></span><br><span class="line">             lastFactors.set(factors);<span class="comment">//D</span></span><br><span class="line">             encodeIntoResponse(resp, factors);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决竞态条件"><a href="#解决竞态条件" class="headerlink" title="解决竞态条件"></a>解决竞态条件</h4><p><a href="">如果上面的A与B这个复合操作操作、以及C与D这个复合操作如果是原子性的，那么将不会出现线程安全性问题。</a><!--比如使用chapter2中synchronized加锁--></p>
<p><a href="">如果为这两组操作创建一个不可变的类，即使在不使用同步的情况也能解决安全共享问题。</a> </p>
<p>下面就为UnsafeCachingFactorizer创建一个OneValueCache类，对以上操作进行了封装，它是一个不可变对象，进（构造时传进的参数）出（使用时）都对状态进行了拷贝。因为BigInteger是不可变的，所以直接使用了Arrays.copyOf来进行拷贝了，如果状态所指引的对象不是不可变对象时，就要不能使用这项技术了，因为外界可以对这些状态所指引的对象进行修改，如果这样只能使用new或深度克隆技术来进行拷贝了。</p>
<blockquote>
<p>每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber  = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于在访问和更新多个相关变量时出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。</p>
<ul>
<li><p>如果是一个可变的对象，那么就必须使用锁来确保原子性。</p>
</li>
<li><p>如果是一个不可变对象，那么当线程获得了对该对象的引用后，就不必担心另一个线程会修改对象的状态。</p>
</li>
<li><p>如果要更新这些变量，那么可以创建一个新的容器对象，但其他使用原有对象的线程仍然会看到对象处于一致的状态。</p>
</li>
</ul>
<p>当一个线程将volatile类型的cache设置为引用一个新的OndeValueCache时，其实线程就会立即看到新缓存的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache =</span><br><span class="line">        <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//使用volatile安全发布</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            <span class="comment">//由于cache为volatile，所以最新值立即能让其它线程可见</span></span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与cache相关的操作不会相互干扰，因为OneValueCache是不可变的，并且在每条相应的代码路径中只会访问它一次 。通过使用包含过个状态变量的容器对象来维护不可变条件，并使用一个volatile类型的引用来确保可见性，使得Volatile Cached Factorizer在没有显式地使用锁的情况下仍然是线程安全的。</p>
<h3 id="我个人的疑惑"><a href="#我个人的疑惑" class="headerlink" title="我个人的疑惑"></a>我个人的疑惑</h3><h4 id="我的分析"><a href="#我的分析" class="headerlink" title="我的分析"></a>我的分析</h4><ul>
<li>程序清单3-13中存在『先检查后执行』（Check-Then-Act）的竞态条件。</li>
<li>OneValueCache类的<strong>不可变性</strong>仅保证了对象的原子性。</li>
<li>volatile仅保证可见性，无法保证线程安全性。</li>
</ul>
<p><strong>综上，对象的不可变性+volatile可见性，并不能解决竞态条件的并发问题，所以原文的这段结论是错误的。</strong></p>
<blockquote>
<p>比如，假设现在缓存lastNumber是x，lastFactor是y</p>
<p>线程A进入cache.getFactor（i）函数中的else语句Arrays.copyOf(lastFactors, lastFactors.length);，</p>
<p>线程B判断没有缓存</p>
<p>线程B更新了OneValueCache，</p>
<p>线程A获取了的是失效的缓存之值1,这不应该啊，线程A获取的不应该是失效的值，这不就线程不安全了吗？</p>
</blockquote>
<p>简单代码1: 对操作封装在一个类中</p>
<ul>
<li>将先检查后执行操作A、B，还有约束条件C、D，封装为一个类的同步方法</li>
<li>这么做，其实和chapter2的代码一样，每个请求阻塞、串行执行，并发效率低</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getFactors</span><span class="params">(BigInteger i)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">if</span> (i.equals(lastNumber.get()))<span class="comment">//A</span></span><br><span class="line">             encodeIntoResponse(resp,  lastFactors.get() );<span class="comment">//B</span></span><br><span class="line">      	<span class="keyword">else</span> &#123;</span><br><span class="line">             BigInteger[] factors = factor(i);</span><br><span class="line">             lastNumber.set(i);<span class="comment">//C</span></span><br><span class="line">             lastFactors.set(factors);<span class="comment">//D</span></span><br><span class="line">             encodeIntoResponse(resp, factors);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单代码2: 鉴于代码1只对方法进行了封装，再考虑对类的数据进行了封装</p>
<ul>
<li>把lastNum和lastFactors变量进行封装，放在一个类中OneValueCache，使得lastNum和lastFactors能维持约束性，从而保证线程安全</li>
<li>以前的A、B操作，是判断lastNum和返回lastFactors; 现在的A、B操作，是交给OneValueCache类判断和OneValueCache类返回。好像线程安全性问题还是没有解决？<ul>
<li>线程安全有没有解决，就是看OneValueCache能不能维持lastNum和lastFactors约束性？当然可以！</li>
<li>写操作：因为OneValueCache能被写入的操作，只有构造函数；而且cache = new OneValueCache(i, factors)中的i和factor(i)属于方法的临时变量，是线程安全的</li>
<li>读操作：因为cache.getFactors(i)第一次用于判断，第二次用于返回，在此期间，其他线程会通过构造函数修改cache，可能会失效，所以线程不安全</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber  = i;</span><br><span class="line">        lastFactors = factors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> lastFactors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req); <span class="comment">//局部变量，没有线程安全性 </span></span><br><span class="line">        <span class="keyword">if</span> ( cache.getFactors(i) != <span class="keyword">null</span>) &#123; <span class="comment">//判断是否命中缓存, 对应以前的A</span></span><br><span class="line">             encodeIntoResponse(resp, cache.getFactors(i)); <span class="comment">//对应以前的B </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         		BigIntegers[] factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">          	encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单代码3: 鉴于代码2中只有读cache时，可能2次获取的cache.getFactors(i)不一致，产生线程不安全，所以现在想办法保证读操作时，保证2次获取的cache.getFactors(i)的约束性，就OK了</p>
<ul>
<li>使用临时变量BigInteger[] factors, 保存cache.getFactors(i)；再使得factors线程安全<ul>
<li>前半部分很简单</li>
<li>后半部分，使factors线程安全，常见的解决方法就是使factors变成临时变量or不可变，那么就可以让cache.getFactors(i)每次返回的都是一个新的句柄和一个新的句柄指向的对象，这样在方法中就成为了一个局部变量，每个线程都有自己的一个句柄和句柄指向的对象，那么factors句柄就不会被其他线程获取</li>
<li>使用Arrays.copyOf()</li>
</ul>
</li>
<li>再想一想，写操作本身维持了约束，但是因为构造函数中lastFactors = factors，把lastFactors通过factors暴露出来了，就是逸出了，调用者可以通过factors修改lastFactors数据，那会不会有什么影响？<ul>
<li>目前来看，没有线程安全问题；但是lastFactors不能逸出被其他调用者修改，所以也需要Arrays.copyOf()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber  = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> Arrays.copyOf(lastFactors,lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req); <span class="comment">//局部变量，没有线程安全性 </span></span><br><span class="line">      	BigIntegers[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> ( factors != <span class="keyword">null</span>) &#123; <span class="comment">//判断是否命中缓存, 此时factors指向的对象，只有该线程能访问，其他线程无法访问，所以对象不可变</span></span><br><span class="line">             encodeIntoResponse(resp, factors); <span class="comment">//对应以前的B，factors由于不可变性，所以安全 </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         		factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">          	encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单代码4: 简单代码3已经做到了很好的线程安全性</p>
<ul>
<li>对象初始化也需要安全，所以使用final修饰</li>
</ul>
<h4 id="作者的本意"><a href="#作者的本意" class="headerlink" title="作者的本意"></a>作者的本意</h4><p><strong>Short answer:</strong></p>
<p><a href="">Thread safety is not really an absolute</a>. You have to determine the desired behavior, and <em>then</em> ask whether the implementation gives you that behavior that in the presence of multithreading.</p>
<p><strong>Longer answer:</strong></p>
<p>So, what’s the desired behavior here? Is it just that the right answer is always given, or is it also that it’s always implemented exactly once if two threads ask for it in a row?</p>
<p>If it’s the latter — that is, if you really want to save every bit of CPU — then you’re right, this isn’t thread-safe. <a href="">Two requests could come in at the same time (or close enough to it) to get the factors for the same number N, and if the timings worked out, both threads could end up calculating that number.</a> <!--这就是我疑惑的地方，但是程序目的并不是这样；如果要达到这种程度的线程安全性，使用锁来保证线程之间的执行顺序，避免重复计算，就像解决Redis缓存击穿--></p>
<p>But with a single-value cache, you already have the problem of recalculating things you already knew. For instance, <a href="">what if three requests come in, for N, K, and N again? The request for K would invalidate the cache at N, and so you’d have to recalculate it.</a><!----></p>
<p>So, this cache is really optimized for “streaks” of the same value, and as such the cost of twice-calculating the first couple (or even few!) answers in that streak might be an acceptable cost: in return, you get code that’s free of any blocking and pretty simple to understand.</p>
<p><a href="">What’s crucial is that it never gives you the <em>wrong</em> answer. That is, if you ask for N and K at the same time, the response for K should never give you the answer for N. This implementation gets you that guarantee, so I would call it thread safe.</a><!--程序的目的是为了保证状态的约束性，就是lastNumbers和lastFactors一致--></p>
<h4 id="使用Arrays-copyOf的目的"><a href="#使用Arrays-copyOf的目的" class="headerlink" title="使用Arrays.copyOf的目的"></a>使用Arrays.copyOf的目的</h4><p><a href="">其实就是返回一个新的句柄和句柄所指向新的对象</a></p>
<p>If you return <code>this.lastFactors</code> instead of returning a copy, the caller can do (for example)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigInteger[] lastFactors = cache.getFactors(...);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastFactors.length; i++) &#123;</span><br><span class="line">    lastFactors[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and thus mutate the state of the cache, which is supposed to be immutable.</p>
<p>The explanation is similar for the constructor. If the constructor didn’t make a copy, the caller could do</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">factors = factor(i);</span><br><span class="line">cache = <span class="keyword">new</span> OneValueCache(i, factors); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastFactors.length; i++) &#123;</span><br><span class="line">    factors[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and thus once again mutate the state of the cache.</p>
<p>Rule of thumb: an array is always mutable (except the empty array). So, if the state of an immutable class contains an array, then the caller must not be able to have a reference to the array.</p>
<h4 id="使用final的目的"><a href="#使用final的目的" class="headerlink" title="使用final的目的"></a>使用final的目的</h4><p>为了保障对象初始化的线程安全</p>
<h4 id="使用volatile的目的"><a href="#使用volatile的目的" class="headerlink" title="使用volatile的目的"></a>使用volatile的目的</h4><p>因为程序并没有使用锁，而是通过不可变对象，使得每个线程获取到的都是一个新句柄和新内存（在线程调用的方法中就是局部变量），所以不会有线程安全性问题</p>
<p>现在程序有个这样的情况</p>
<ul>
<li>比如3个请求R1, R2, R1，第2个R1会再次计算，这其实是正常情况</li>
<li>比如2个请求R2, R1, R1，第1和第2个R1可能也都会计算，所以使用volatile尽可能地将最新的结果通知其他线程，最大可能避免重复计算；比如第1个R1把新的结果写入内存，即使R1线程没执行完，但是R2已经获取了最新结果了。</li>
</ul>
<h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><p>到目前为止，我们重点讨论的是如何确保对象不被发布，比如让对象封闭在线程或者另一个对象内部。当然，我们希望多个线程间安全地进行共享数据。下面程序中简单地将对象的引用存储到public域中，这不足以安全地发布它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不安全的发布：在没有适当的同步情况下就发布对象</span></span><br><span class="line"><span class="keyword">public</span> Holder holder;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于存在可见性问题，其他线程看到的Holder对象将处于不一致的状态，即便在该对象的构造函数中已经正确地构建了不变性条件。这种不正确的发布导致其他线程看到尚未创建完成的对象。</p>
<h3 id="不正确的发布：正确的对象被破坏"><a href="#不正确的发布：正确的对象被破坏" class="headerlink" title="不正确的发布：正确的对象被破坏"></a>不正确的发布：正确的对象被破坏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n != n)<span class="comment">//在不正确的发布中，是很有可能出现不等</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;This statement is false.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序的问题是由于对象的可见性问题引起的，发布的对象可能还处于构造期间，所以是不稳定的。因为没有同步来确保Holder对其他线程可见，所以我们称Holder是“非正确发布”。</p>
<p>由于上面 n != n 会从主存中两次读取，这有可能从这两次读操作间切换到其他线程，这就有可能出 n!=n奇怪的问题。</p>
<!--看看stack上，大神怎么解释的-->

<blockquote>
<p>he reason why this is possible is that Java has a weak memory model. It does not guarantee ordering of read and writes.</p>
<p>This particular problem can be reproduced with the following two code snippets representing two threads.</p>
<p>Thread 1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someStaticVariable = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>Thread 2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someStaticVariable.assertSanity(); <span class="comment">// can throw</span></span><br></pre></td></tr></table></figure>

<p>On the surface it seems impossible that this could ever occur. In order to understand why this can happen, you have to get past the Java syntax and get down to a much lower level. If you look at the code for thread 1, it can essentially be broken down into a series of memory writes and allocations:</p>
<ol>
<li>Alloc memory to pointer1</li>
<li>Write 42 to pointer1 at offset 0</li>
<li>Write pointer1 to someStaticVariable</li>
</ol>
<p>Because Java has a weak memory model, it is perfectly possible for the code to actually execute in the following order from the perspective of thread 2:</p>
<ol>
<li>Alloc Memory to pointer1</li>
<li>Write pointer1 to someStaticVariable</li>
<li>Write 42 to pointer1 at offset 0</li>
</ol>
<p>Scary? Yes but it can happen.</p>
<p>What this means though is that thread 2 can now call into <code>assertSanity</code> before <code>n</code> has gotten the value 42. It is possible for the value <code>n</code> to be read twice during <code>assertSanity</code>, once before operation #3 completes and once after and hence see two different values and throw an exception.</p>
</blockquote>
<h3 id="不可变对象与初始化安全性"><a href="#不可变对象与初始化安全性" class="headerlink" title="不可变对象与初始化安全性"></a>不可变对象与初始化安全性</h3><p>Java内存模型为共享不可变对象提供了特殊的初始化安全性的保证，即对象在完全初始化之后才能被外界引用，所以只要是不可变对象，一旦构建完成，就可以安全地发布了。</p>
<p>即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一致的视图，就必须使用同步。</p>
<p>即使发布对象引用时没有使用同步，不可变对象仍然可以被安全地访问（注，只能保证一旦看到的对象就是完整的，在没有使用同步的情况下是不能保证对象引用的可见性，所以不可变对象只能保证初始化完后的就处于稳定状态）。<strong>为了获得这种初始化安全性的保证上，应该满足所有不可变性的条件</strong>：<!--不可修改的状态、所有域都是final类型的、正确的构造-->。（如果上面的Holder是不可变的，那么即使Holder没有正确的发布，assertSanity也不会抛出AssertionError。）</p>
<blockquote>
<p>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。</p>
</blockquote>
<p>这个保证还会延伸到一个正确创建的对象中所有final类型域的值。final域可以在没有额外的同步情况下被安全地访问（因为只要构造器一旦调用完毕，则final域的也会随之初始化完并可见），然而，如果final域指向可变对象，那么访问这些对象的状态时仍然需要同步的。</p>
<h3 id="安全发布的常用模式（可变对象的安全发布）"><a href="#安全发布的常用模式（可变对象的安全发布）" class="headerlink" title="安全发布的常用模式（可变对象的安全发布）"></a>安全发布的常用模式（可变对象的安全发布）</h3><p>如果一个对象不是不可变的，它就必须要被安全的发布，通常发布线程与消费线程都必须同步。我们要确保消费线程能够看到处于发布当时的对象状态。</p>
<blockquote>
<p>为了安全地发布一个可变对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用；static{}</li>
<li>将对象的引用保存到volatile类型的域或者AtomicReferance对象中</li>
<li>将对象的引用保存到某个正确构造对象的final类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
</blockquote>
<p>线程安全中的容器提供了线程安全保证（即变向地将对象置于了同步器中进行访问），正是遵守了上述最后一条要求。</p>
<p>线程安全库中的容器类提供了以下的安全发布保证：</p>
<ul>
<li>通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。</li>
<li>通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。</li>
<li>通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。</li>
</ul>
<p>类库中的其他数据传递机制（例如Future和Exchanger）同样能实现安全发布。</p>
<p>要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Holder holder &#x3D; new Holder(42);</span><br></pre></td></tr></table></figure>

<p>静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。</p>
<p><strong>如果对象在创建后被修改，那么安全发布仅仅可以保证“发布当时”状态的可见性。不仅仅在发布对象时需要同步，而且在对象发布后修改了对象状态又要让其他线程可见，则也需要对每次状态的访问进行同步。为了安全地共享可变对象，可变对象必须被安全发布，同时对状态的访问需要同步化。</strong></p>
<h3 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h3><p>对于对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布时足够的。</p>
<p>如果对象从技术上来看时可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象”。</p>
<p>用事实不可变对象可以简化开发，并且由于减少了同步的使用，还会提高性能。</p>
<blockquote>
<p>在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。</p>
</blockquote>
<p>比如，Date自身是可变的（这也许是类库设计的一个错误），但是如果你把它当作不可变对象来使用就可以忽略锁。否则，每当Date被跨线程共享时，都要用锁确保安全。假设你正在维护一个Map，它存储了每位用户的最近登录时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Date&gt; lastLogin =</span><br><span class="line">Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Date&gt;());</span><br></pre></td></tr></table></figure>

<p>如果Date值在转入Map中后就不会改变，那么，synchronizedMap中同步的实现就足以将Date安全地发布，并且访问这些Date值时就不再需要额外的同步。</p>
<!--stack上的回答-->

<blockquote>
<p>If you use an <code>un-synchronized</code> <code>mutable map</code> and share it across <code>threads</code> then you will have two <code>thread-safety</code> issues :<code>visibility</code> and <code>atomicity</code>. <code>Thread-1</code> wont know if <code>Thread-2</code> has removed a <code>Map-Entry</code> or it replaced its value by a new <code>Date</code> object.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not atmoic and doesn&#x27;t guarantee visiblity</span></span><br><span class="line"><span class="keyword">if</span>(map.contains(key))&#123;</span><br><span class="line"> map.put(key,newDate); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="可变对象–-gt-对象（不可变-事实不可变-可变）的发布约束"><a href="#可变对象–-gt-对象（不可变-事实不可变-可变）的发布约束" class="headerlink" title="可变对象–&gt;对象（不可变/事实不可变/可变）的发布约束"></a>可变对象–&gt;对象（不可变/事实不可变/可变）的发布约束</h3><p>如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续操作的可见性。<strong>要安全地共享可变对象，这些对象就必须被安全地发布，并且必须是线程安全的活着由某个锁保护起来。</strong></p>
<blockquote>
<p>对象的发布需求取决于它的可变性：<br>* 不可变对象可以通过任意机制来发布<br>* 事实不可变对象必须通过安全方式来发布<br>* 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来</p>
</blockquote>
<h3 id="安全地共享对象"><a href="#安全地共享对象" class="headerlink" title="安全地共享对象"></a>安全地共享对象</h3><p>当获得对象的一个引用时，你需要知道在这个引用上可以执行哪些操作。在使用它之前是否需要获得一个锁？是否可以修改它的状态，或者只能读取它？许多错误都是由于没有理解共享对象的这些“既定规则”而导致。当发布一个对象时，必须明确地说明对象的访问方式。</p>
<blockquote>
<p>在并发程序中使用和共享对象时，可以使用一些使用的策略，包括：<br><strong>线程封闭</strong>。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。<br><strong>只读共享。</strong>在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。<br><strong>线程安全共享。</strong>线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。<br><strong>保护对象。</strong>被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%94%AF%E4%B8%80ID/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80ID/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%94%AF%E4%B8%80ID/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80ID/" class="post-title-link" itemprop="url">分布式集群下生成唯一ID</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-10 13:54:56" itemprop="dateCreated datePublished" datetime="2020-11-10T13:54:56+08:00">2020-11-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-12-22 13:49:36" itemprop="dateModified" datetime="2021-12-22T13:49:36+08:00">2021-12-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>它山之石可以攻玉</p>
<h3 id="ref-links"><a href="#ref-links" class="headerlink" title="ref links:"></a>ref links:</h3><ol>
<li><p>介绍了唯一ID的使用场景以及常见的解决思路<br><a target="_blank" rel="noopener" href="https://www.javazhiyin.com/73643.html">https://www.javazhiyin.com/73643.html</a></p>
</li>
<li><p>如何利用UUID作为唯一ID存储在mysql中，并提高mysql性能 =&gt; 存储为number<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16122934/best-way-to-handle-large-uuid-as-a-mysql-table-primary-key">https://stackoverflow.com/questions/16122934/best-way-to-handle-large-uuid-as-a-mysql-table-primary-key</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/10950202/how-to-store-uuid-as-number">https://stackoverflow.com/questions/10950202/how-to-store-uuid-as-number</a></p>
</li>
<li><p>深入分析mysql为什么不推荐使用uuid或者雪花id作为主键<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wyq178/p/12548864.html">https://www.cnblogs.com/wyq178/p/12548864.html</a></p>
</li>
</ol>
<h2 id="简单分析一下需求"><a href="#简单分析一下需求" class="headerlink" title="简单分析一下需求"></a>简单分析一下需求</h2><p>所谓全局唯一的 id 其实往往对应是<strong>生成唯一记录标识的业务需求</strong>。</p>
<p>这个 id 常常是数据库的主键，数据库上会建立聚集索引（cluster index），即在物理存储上以这个字段排序。这个记录标识上的查询，往往又有分页或者排序的业务需求。所以往往要有一个time字段，并且在time字段上建立普通索引（non-cluster index）。</p>
<p>普通索引存储的是实际记录的指针，其访问效率会比聚集索引慢，如果记录标识在生成时能够基本按照时间有序，则可以省去这个time字段的索引查询。</p>
<p>这就引出了记录标识生成的两大核心需求：</p>
<ul>
<li>全局唯一</li>
<li>趋势有序</li>
</ul>
<h2 id="常见生成策略的优缺点对比"><a href="#常见生成策略的优缺点对比" class="headerlink" title="常见生成策略的优缺点对比"></a>常见生成策略的优缺点对比</h2><h3 id="用数据库的-auto-increment"><a href="#用数据库的-auto-increment" class="headerlink" title="用数据库的 auto_increment"></a>用数据库的 auto_increment</h3><p><strong>优点：</strong></p>
<ul>
<li>此方法使用数据库原有的功能，所以相对简单</li>
<li>能够保证唯一性</li>
<li>能够保证递增性</li>
<li>id 之间的步长是固定且可自定义的</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>可用性难以保证：数据库常见架构是 一主多从 + 读写分离，生成自增ID是写请求 主库挂了就玩不转了</li>
<li>扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且 难以扩展</li>
</ul>
<p><strong>改进方案：</strong></p>
<ul>
<li>冗余主库，避免写入单点</li>
<li>数据水平切分，保证各主库生成的ID不重复</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudlL2EP3TLE6MKFNCg3bJwqicUGPB3zibWNXkibQibHHBZCjhib8Pzz5u7aVnJryuiabDEKgsLiashe8Gj0w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>如上图所述，由1个写库变成3个写库，每个写库设置不同的 auto_increment 初始值，以及相同的增长步长，以保证每个数据库生成的ID是不同的（上图中DB 01生成0,3,6,9…，DB 02生成1,4,7,10，DB 03生成2,5,8,11…）</p>
<p>改进后的架构保证了可用性，但缺点是</p>
<ul>
<li>丧失了ID生成的“绝对递增性”：先访问DB 01生成0,3，再访问DB 02生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，目标是趋势递增，不是绝对递增</li>
<li>数据库的写压力依然很大，每次生成ID都要访问数据库</li>
</ul>
<p>为了解决这些问题，引出了以下方法：</p>
<h3 id="单点批量ID生成服务"><a href="#单点批量ID生成服务" class="headerlink" title="单点批量ID生成服务"></a>单点批量ID生成服务</h3><p>分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。</p>
<p>数据库写压力大，是因为每次生成ID都访问了数据库，可以使用批量的方式降低数据库写压力。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudlL2EP3TLE6MKFNCg3bJwqOP9UXxwIOCibhlXXiaSSGwmSTC80GBCA8LVxLcKxH89BtaO9lqzbMfqg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>如上图所述，<!--数据库使用双master保证可用性-->数据库中只存储当前ID的最大值，例如4。</p>
<p>假设每次批量拉取5个ID，客户端应用访问ID生成服务，</p>
<ol>
<li>ID生成服务将当前ID的最大值修改为4</li>
<li>客户端应用访问ID生成服务索要ID</li>
<li>ID生成服务依次派发0,1,2,3,4这些ID。</li>
<li>当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是数据库的压力就降低到原来的1/6。</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li>保证了ID生成的绝对递增有序</li>
<li>大大的降低了数据库的压力，ID生成可以做到每秒生成几万几十万个</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>服务仍然是单点</li>
<li>如果服务挂了，服务重启起来之后，继续生成ID可能会不连续，中间出现空洞（服务内存是保存着0,1,2,3,4，数据库中max-id是4，分配到3时，服务重启了，下次会从5开始分配，3和4就成了空洞，不过这个问题也不大）</li>
<li>虽然每秒可以生成几万几十万个ID，但毕竟还是有性能上限，无法进行水平扩展</li>
</ul>
<p><strong>改进方案</strong></p>
<ul>
<li>单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点：</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudlL2EP3TLE6MKFNCg3bJwqQvubrmA8V4J1H7UzCe1647T82GToR508bgiaLKLnMQ42MBGIyob1XdA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。这个切换的过程对调用方是透明的，可以自动完成，常用的技术是 vip+keepalived。另外，id generate service 也可以进行水平扩展，以解决上述缺点，但会引发一致性问题。</p>
<h3 id="uuid-guid"><a href="#uuid-guid" class="headerlink" title="uuid / guid"></a>uuid / guid</h3><p>不管是通过数据库，还是通过服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。uuid是一种常见的本地生成ID的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID uuid &#x3D; UUID.randomUUID();</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>本地生成ID，不需要进行远程调用，时延低</li>
<li>扩展性好，基本可以认为没有性能上限</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无法保证趋势递增</li>
<li>uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）</li>
</ul>
<h3 id="取当前毫秒数"><a href="#取当前毫秒数" class="headerlink" title="取当前毫秒数"></a>取当前毫秒数</h3><p>uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？- 取当前毫秒数是一种常见方案。（搜索公众号Java知音，回复“2021”，送你一份Java面试题宝典）</p>
<p><strong>优点：</strong></p>
<ul>
<li>本地生成ID，不需要进行远程调用，时延低</li>
<li>生成的ID趋势递增</li>
<li>生成的ID是整数，建立索引后查询效率高</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果并发量超过1000，会生成重复的ID</li>
<li>这个缺点要了命了，不能保证ID的唯一性。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。</li>
</ul>
<h3 id="使用-Redis-来生成-id"><a href="#使用-Redis-来生成-id" class="headerlink" title="使用 Redis 来生成 id"></a>使用 Redis 来生成 id</h3><p>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR 和 INCRBY 来实现。</p>
<p><strong>优点：</strong></p>
<ul>
<li>依赖于数据库，灵活方便，且性能优于数据库。</li>
<li>数字ID天然排序，对分页或者需要排序的结果很有帮助。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。</li>
<li>需要编码和配置的工作量比较大。</li>
</ul>
<h3 id="Twitter-开源的-Snowflake-算法"><a href="#Twitter-开源的-Snowflake-算法" class="headerlink" title="Twitter 开源的 Snowflake 算法"></a>Twitter 开源的 Snowflake 算法</h3><p>snowflake 是 twitter 开源的分布式ID生成算法，其核心思想为，一个long型的ID：</p>
<ul>
<li>41 bit 作为毫秒数 - 41位的长度可以使用69年</li>
<li>10 bit 作为机器编号 （5个bit是数据中心，5个bit的机器ID） - 10位的长度最多支持部署1024个节点</li>
<li>12 bit 作为毫秒内序列号 - 12位的计数顺序号支持每个节点每毫秒产生4096个ID序号</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudlL2EP3TLE6MKFNCg3bJwqoQPdvS7rxC9Z3VG6wryFPzah882ZqyIgfK9eoQsHuq9SQWdJYnibhAg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">Snowflake图示</p>
<p>算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。</p>
<p>该算法 java 版本的实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public class SnowflakeIdGenerator &#123;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 系统开始时间截 (UTC 2017-06-28 00:00:00)</span><br><span class="line">    private final long startTime &#x3D; 1498608000000L;</span><br><span class="line">    &#x2F;&#x2F; 机器id所占的位数</span><br><span class="line">    private final long workerIdBits &#x3D; 5L;</span><br><span class="line">    &#x2F;&#x2F; 数据标识id所占的位数</span><br><span class="line">    private final long dataCenterIdBits &#x3D; 5L;</span><br><span class="line">    &#x2F;&#x2F; 支持的最大机器id(十进制)，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)</span><br><span class="line">    &#x2F;&#x2F; -1L 左移 5位 (worker id 所占位数) 即 5位二进制所能获得的最大十进制数 - 31</span><br><span class="line">    private final long maxWorkerId &#x3D; -1L ^ (-1L &lt;&lt; workerIdBits);</span><br><span class="line">    &#x2F;&#x2F; 支持的最大数据标识id - 31</span><br><span class="line">    private final long maxDataCenterId &#x3D; -1L ^ (-1L &lt;&lt; dataCenterIdBits);</span><br><span class="line">    &#x2F;&#x2F; 序列在id中占的位数</span><br><span class="line">    private final long sequenceBits &#x3D; 12L;</span><br><span class="line">    &#x2F;&#x2F; 机器ID 左移位数 - 12 (即末 sequence 所占用的位数)</span><br><span class="line">    private final long workerIdMoveBits &#x3D; sequenceBits;</span><br><span class="line">    &#x2F;&#x2F; 数据标识id 左移位数 - 17(12+5)</span><br><span class="line">    private final long dataCenterIdMoveBits &#x3D; sequenceBits + workerIdBits;</span><br><span class="line">    &#x2F;&#x2F; 时间截向 左移位数 - 22(5+5+12)</span><br><span class="line">    private final long timestampMoveBits &#x3D; sequenceBits + workerIdBits + dataCenterIdBits;</span><br><span class="line">    &#x2F;&#x2F; 生成序列的掩码(12位所对应的最大整数值)，这里为4095 (0b111111111111&#x3D;0xfff&#x3D;4095)</span><br><span class="line">    private final long sequenceMask &#x3D; -1L ^ (-1L &lt;&lt; sequenceBits);</span><br><span class="line">   </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 工作机器ID(0~31)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private long workerId;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 数据中心ID(0~31)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private long dataCenterId;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 毫秒内序列(0~4095)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private long sequence &#x3D; 0L;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 上次生成ID的时间截</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private long lastTimestamp &#x3D; -1L;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构造函数</span><br><span class="line">     *</span><br><span class="line">     * @param workerId     工作ID (0~31)</span><br><span class="line">     * @param dataCenterId 数据中心ID (0~31)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public SnowflakeIdGenerator(long workerId, long dataCenterId) &#123;</span><br><span class="line">        if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;Worker Id can&#39;t be greater than %d or less than 0&quot;, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        if (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;DataCenter Id can&#39;t be greater than %d or less than 0&quot;, maxDataCenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        this.workerId &#x3D; workerId;</span><br><span class="line">        this.dataCenterId &#x3D; dataCenterId;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Methods&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    &#x2F;&#x2F; 线程安全的获得下一个 ID 的方法</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long timestamp &#x3D; currentTime();</span><br><span class="line">        &#x2F;&#x2F;如果当前时间小于上一次ID生成的时间戳: 说明系统时钟回退过 - 这个时候应当抛出异常</span><br><span class="line">        if (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果是同一时间生成的，则进行毫秒内序列</span><br><span class="line">        if (lastTimestamp &#x3D;&#x3D; timestamp) &#123;</span><br><span class="line">            sequence &#x3D; (sequence + 1) &amp; sequenceMask;</span><br><span class="line">            &#x2F;&#x2F;毫秒内序列溢出 即 序列 &gt; 4095</span><br><span class="line">            if (sequence &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;阻塞到下一个毫秒,获得新的时间戳</span><br><span class="line">                timestamp &#x3D; blockTillNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;时间戳改变，毫秒内序列重置</span><br><span class="line">        else &#123;</span><br><span class="line">            sequence &#x3D; 0L;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;上次生成ID的时间截</span><br><span class="line">        lastTimestamp &#x3D; timestamp;</span><br><span class="line">        &#x2F;&#x2F;移位并通过或运算拼到一起组成64位的ID</span><br><span class="line">        return ((timestamp - startTime) &lt;&lt; timestampMoveBits) &#x2F;&#x2F;</span><br><span class="line">                | (dataCenterId &lt;&lt; dataCenterIdMoveBits) &#x2F;&#x2F;</span><br><span class="line">                | (workerId &lt;&lt; workerIdMoveBits) &#x2F;&#x2F;</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 阻塞到下一个毫秒 即 直到获得新的时间戳</span><br><span class="line">    protected long blockTillNextMillis(long lastTimestamp) &#123;</span><br><span class="line">        long timestamp &#x3D; currentTime();</span><br><span class="line">        while (timestamp &lt;&#x3D; lastTimestamp) &#123;</span><br><span class="line">            timestamp &#x3D; currentTime();</span><br><span class="line">        &#125;</span><br><span class="line">        return timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获得以毫秒为单位的当前时间</span><br><span class="line">    protected long currentTime() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Test Case&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SnowflakeIdGenerator idWorker &#x3D; new SnowflakeIdGenerator(0, 0);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            long id &#x3D; idWorker.nextId();</span><br><span class="line">            &#x2F;&#x2F;System.out.println(Long.toBinaryString(id));</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="美团的leaf算法"><a href="#美团的leaf算法" class="headerlink" title="美团的leaf算法"></a>美团的leaf算法</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/%E6%9F%A5%E6%89%BECPU%E9%A3%99%E5%8D%87%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/%E6%9F%A5%E6%89%BECPU%E9%A3%99%E5%8D%87%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">查找CPU飙升的原因</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 09:24:42" itemprop="dateCreated datePublished" datetime="2020-11-05T09:24:42+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-04-22 13:40:03" itemprop="dateModified" datetime="2022-04-22T13:40:03+08:00">2022-04-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="第一步：找到耗费CPU的进程"><a href="#第一步：找到耗费CPU的进程" class="headerlink" title="第一步：找到耗费CPU的进程"></a>第一步：找到耗费CPU的进程</h2><p>使用TOP命令</p>
<img src="/Users/qifei/Library/Application Support/typora-user-images/image-20201202174921436.png" alt="image-20201202174921436" style="zoom:50%;" />

<h2 id="第二步：找到耗费CPU的线程（10进制）"><a href="#第二步：找到耗费CPU的线程（10进制）" class="headerlink" title="第二步：找到耗费CPU的线程（10进制）"></a>第二步：找到耗费CPU的线程（10进制）</h2><p>进程号116664的CPU很高。所以，需要进一步锁定该进程内部的线程耗费CPU, 所以需要使用top -H -p [pid]命令查看线程， (也可使用shift -h进行切换)</p>
<p>![image-20201202175704489](/Users/qifei/Library/Application Support/typora-user-images/image-20201202175704489.png)</p>
<h2 id="第三步：找到耗费CPU的线程（16进制）"><a href="#第三步：找到耗费CPU的线程（16进制）" class="headerlink" title="第三步：找到耗费CPU的线程（16进制）"></a>第三步：找到耗费CPU的线程（16进制）</h2><p>根据2nd step中的返回内容，可以看到线程号117296(10进制)的java线程耗费CPU，所以需要查看该线程的详细信息，所以需要是一个jstack命令，但是，记住jstack中的nid（Native Thread ID)是系统线程id, 为16进制，需要使用top -Hp pid找到该线程的10进制pid，然后使用下边的命令打印出16进制线程nid</p>
<p>![image-20201202180132749](/Users/qifei/Library/Application Support/typora-user-images/image-20201202180132749.png)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf  &quot;%x\n&quot; 10进制nid</span><br></pre></td></tr></table></figure>

<h2 id="第四步：打印CPU的线程-16进制-栈信息"><a href="#第四步：打印CPU的线程-16进制-栈信息" class="headerlink" title="第四步：打印CPU的线程(16进制)栈信息"></a>第四步：打印CPU的线程(16进制)栈信息</h2><p>根据3rd step中的16进制线程号，使用 <!--注意：linux下进程和线程都用10进制pid表示--></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack pid | grep [nid]</span><br></pre></td></tr></table></figure>

<p>命令，查询该线程的详细信息</p>
<p>![image-20201202180409819](/Users/qifei/Library/Application Support/typora-user-images/image-20201202180409819.png)</p>
<h2 id="第五步：分析栈信息中的线程状态"><a href="#第五步：分析栈信息中的线程状态" class="headerlink" title="第五步：分析栈信息中的线程状态"></a>第五步：分析栈信息中的线程状态</h2><p>当然更常见的是我们对整个 jstack 文件进行分析，通常我们会比较关注 WAITING 和 TIMED_WAITING 的部分，BLOCKED 就不用说了。我们可以使用命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat jstack.log | grep &quot;java.lang.Thread.State&quot; | sort -nr | uniq -c</span><br></pre></td></tr></table></figure>

<p>来对 jstack 的状态有一个整体的把握，如果 WAITING 之类的特别多，那么多半是有问题啦。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9zpsDC09P5ww0K7GTAYZbhxfc6VfyucR5Lf7TGY2mbfBN14UicSbOPIQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="正则表达式消耗CPU"><a href="#正则表达式消耗CPU" class="headerlink" title="正则表达式消耗CPU"></a>正则表达式消耗CPU</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; patternList = <span class="keyword">new</span> ArrayList&lt;&gt;;</span><br><span class="line">patternList.add(<span class="string">&quot;Here I am&quot;</span>);</span><br><span class="line">patternList.add ....;</span><br><span class="line"></span><br><span class="line">String[] patternMatch = &#123;<span class="string">&quot;[\\\w\\\\s]....&quot;</span>, <span class="string">&quot;[\\\s\\\\w]&quot;</span>,...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:patternList)&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;patternMatch.length; i++)&#123;</span><br><span class="line">		Pattern pattern = Pattern.compile(patternMatch[i]);</span><br><span class="line">    </span><br><span class="line">    Matcher matcher = pattern.matcher(s);</span><br><span class="line">    <span class="keyword">if</span>(matcher.matches()) system.out.println(<span class="string">&quot;match!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用第五步时：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State: Running</span><br><span class="line">		at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/%E6%9F%A5%E6%89%BE%E5%86%85%E5%AD%98%E9%A3%99%E5%8D%87%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/%E6%9F%A5%E6%89%BE%E5%86%85%E5%AD%98%E9%A3%99%E5%8D%87%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">查找内存飙升的原因</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 09:24:42" itemprop="dateCreated datePublished" datetime="2020-11-05T09:24:42+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-06 13:40:10" itemprop="dateModified" datetime="2021-04-06T13:40:10+08:00">2021-04-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>内存问题排查起来相对比 CPU 麻烦一些，场景也比较多。主要包括 OOM、GC 问题和堆外内存。一般来讲，我们会先用free命令先来检查一发内存的各种情况。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9gR3via3V6ebgfOicYMjKPMQ3iaLjs0icnM97myJbYVibXfiaiaThhzbgHetrA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>堆内内存</p>
<p>内存问题大多还都是堆内内存问题。表象上主要分为 OOM 和 Stack Overflo。</p>
<p>OOM</p>
<p>JMV 中的内存不足，OOM 大致可以分为以下几种：</p>
<p><strong>Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread</strong></p>
<p>这个意思是没有足够的内存空间给线程分配 Java 栈，基本上还是线程池代码写的有问题，比如说忘记 shutdown，所以说应该首先从代码层面来寻找问题，使用 jstack 或者 jmap。如果一切都正常，JVM 方面可以通过指定Xss来减少单个 thread stack 的大小。另外也可以在系统层面，可以通过修改/etc/security/limits.confnofile 和 nproc 来增大 os 对线程的限制</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9hpBEFNxR6KgLN9R8sI8ZrnichpqPmVlVvsPcH84O4tWTAv2diaoEFMNg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><strong>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</strong></p>
<p>这个意思是堆的内存占用已经达到-Xmx 设置的最大值，应该是最常见的 OOM 错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过 jstack 和 jmap 去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。</p>
<p><strong>Caused by: java.lang.OutOfMemoryError: Meta space</strong></p>
<p>这个意思是元数据区的内存占用已经达到XX:MaxMetaspaceSize设置的最大值，排查思路和上面的一致，参数方面可以通过XX:MaxPermSize来进行调整(这里就不说 1.8 以前的永久代了)。</p>
<p>Stack Overflow</p>
<p>栈内存溢出，这个大家见到也比较多。</p>
<p><strong>Exception in thread “main” java.lang.StackOverflowError</strong></p>
<p>表示线程栈需要的内存大于 Xss 值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起 OOM。</p>
<p>使用 JMAP 定位代码内存泄漏</p>
<p>上述关于 OOM 和 Stack Overflo 的代码排查方面，我们一般使用 JMAPjmap -dump:format=b,file=filename pid来导出 dump 文件</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9e8gQWnOAvmXjvHOCSHcyicIstYlacBsMW2YcHxeOepTnvXVNfYCp9Pg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>通过 mat(Eclipse Memory Analysis Tools)导入 dump 文件进行分析，内存泄漏问题一般我们直接选 Leak Suspects 即可，mat 给出了内存泄漏的建议。另外也可以选择 Top Consumers 来查看最大对象报告。和线程相关的问题可以选择 thread overview 进行分析。除此之外就是选择 Histogram 类概览来自己慢慢分析，大家可以搜搜 mat 的相关教程。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9oRjPiazyEkL5xF1xnvbIfibnBz5JTnkw1vyuNficNuIpNZvYg5JpXiauFw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都 new 对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发 gc；ByteBuffer 缓存分配不合理等都会造成代码 OOM。</p>
<p>另一方面，我们可以在启动参数中指定-XX:+HeapDumpOnOutOfMemoryError来保存 OOM 时的 dump 文件。</p>
<p>gc 问题和线程</p>
<p>gc 问题除了影响 CPU 也会影响内存，排查思路也是一致的。一般先使用 jstat 来查看分代变化情况，比如 youngGC 或者 fullGC 次数是不是太多呀；EU、OU 等指标增长是不是异常呀等。</p>
<p>线程的话太多而且不被及时 gc 也会引发 oom，大部分就是之前说的unable to create new native thread。除了 jstack 细细分析 dump 文件外，我们一般先会看下总体线程，通过pstreee -p pid |wc -l。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9Qiby29R0TM1vleXDqBVlgok2fvBEbwDrbxSzvibE1W38R52MhcF4XSCg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>或者直接通过查看/proc/pid/task的数量即为线程数量。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9ELzXlh7ibibJgEiakg91XynOmiaKETIpA4YAh2IR0aBW2e9TdczzXCDiauw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>堆外内存</p>
<p>如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用 Netty 导致的，那错误日志里可能会出现OutOfDirectMemoryError错误，如果直接是 DirectByteBuffer，那会报OutOfMemoryError: Direct buffer memory。</p>
<p>堆外内存溢出往往是和 NIO 的使用相关，一般我们先通过 pmap 来查看下进程占用的内存情况pmap -x pid | sort -rn -k3 | head -30，这段意思是查看对应 pid 倒序前 30 大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9wPvdqWzauQRPCon769dudGQP6B0zj7ucdX5xBnlLjqrQzukrT3N5Cw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>我们如果确定有可疑的内存端，需要通过 gdb 来分析gdb –batch –pid {pid} -ex “dump memory filename.dump {内存起始地址} {内存起始地址+内存块大小}”</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9XHyuhia3QJankbxnDNwJ11yKX7NQ6VlicWmIB1miblPHeKNH6b58wJtAg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>获取 dump 文件后可用 heaxdump 进行查看hexdump -C filename | less，不过大多数看到的都是二进制乱码。</p>
<p>NMT 是 Java7U40 引入的 HotSpot 新特性，配合 jcmd 命令我们就可以看到具体内存组成了。需要在启动参数中加入 -XX:NativeMemoryTracking=summary 或者 -XX:NativeMemoryTracking=detail，会有略微性能损耗。</p>
<p>一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线jcmd pid VM.native_memory baseline。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs982vnIibTNvCxibgdt8z16Hj1M1VRxxwlgxjtXvn9VEHQMXWx4qic7wvJQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>然后等放一段时间后再去看看内存增长的情况，通过jcmd pid VM.native_memory detail.diff(summary.diff)做一下 summary 或者 detail 级别的 diff。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs93mricZdIwEGYzKKeiacqOeibDDy4bJbwA59kV6ianWQHiaHqDYoq5EL4ricA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9D5UwssOfdZoKY6583NPxPxudbLo9YTIZ9zBVGbeL71ChVw6GSPrsfw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>可以看到 jcmd 分析出来的内存十分详细，包括堆内、线程以及 gc(所以上述其他内存异常其实都可以用 nmt 来分析)，这边堆外内存我们重点关注 Internal 的内存增长，如果增长十分明显的话那就是有问题了。</p>
<p>detail 级别的话还会有具体内存段的增长情况，如下图。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9LUccDnQ3onwXfgibP0icNftOx6U9Q5acw8iaD34l3DMJVYgUBSpSJM0tg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>此外在系统层面，我们还可以使用 strace 命令来监控内存分配 strace -f -e “brk,mmap,munmap” -p pid</p>
<p>这边内存分配信息主要包括了 pid 和内存地址。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9fv1wibbYCBLLIalwWQ442BQmEdagRw0Boob3tmo1Rq1TNb1QQpQxqLQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如 DirectByteBuffer 分配内存的话，是需要 full GC 或者手动 system.gc 来进行回收的(所以最好不要使用-XX:+DisableExplicitGC)。那么其实我们可以跟踪一下 DirectByteBuffer 对象的内存情况，通过jmap -histo:live pid手动触发 fullGC 来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过-XX:MaxDirectMemorySize进行调整。如果没有什么变化，那就要使用 jmap 去分析那些不能被 gc 的对象，以及和 DirectByteBuffer 之间的引用关系了。</p>
<h1 id="GC-问题"><a href="#GC-问题" class="headerlink" title="GC 问题"></a>GC 问题</h1><p>堆内内存泄漏总是和 GC 异常相伴。不过 GC 问题不只是和内存问题相关，还有可能引起 CPU 负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下 GC 相关问题。</p>
<p>我们在 CPU 章介绍了使用 jstat 来获取当前 GC 分代变化信息。而更多时候，我们是通过 GC 日志来排查问题的，在启动参数中加上-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps来开启 GC 日志。</p>
<p>常见的 Young GC、Full GC 日志含义在此就不做赘述了。</p>
<p>针对 gc 日志，我们就能大致推断出 youngGC 与 fullGC 是否过于频繁或者耗时过长，从而对症下药。我们下面将对 G1 垃圾收集器来做分析，这边也建议大家使用 G1-XX:+UseG1GC。</p>
<p><strong>youngGC 过频繁</strong></p>
<p>youngGC 频繁一般是短周期小对象较多，先考虑是不是 Eden 区/新生代设置的太小了，看能否通过调整-Xmn、-XX:SurvivorRatio 等参数设置来解决问题。如果参数正常，但是 young gc 频率还是太高，就需要使用 Jmap 和 MAT 对 dump 文件进行进一步排查了。</p>
<p><strong>youngGC 耗时过长</strong></p>
<p>耗时过长问题就要看 GC 日志里耗时耗在哪一块了。以 G1 日志为例，可以关注 Root Scanning、Object Copy、Ref Proc 等阶段。Ref Proc 耗时长，就要注意引用相关的对象。Root Scanning 耗时长，就要注意线程数、跨代引用。Object Copy 则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的 Root Scanning 和正常时间段比增长较多，那就是起的线程太多了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs95F2hYyL4XzKclBfIYcA1tZOrXqSXrJLystsoULld4PhyWPrJsaEXzQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><strong>触发 fullGC</strong></p>
<p>G1 中更多的还是 mixedGC，但 mixedGC 可以和 youngGC 思路一样去排查。触发 fullGC 了一般都会有问题，G1 会退化使用 Serial 收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。</p>
<p>fullGC 的原因可能包括以下这些，以及参数调整方面的一些思路：</p>
<ul>
<li>并发阶段失败：在并发标记阶段，MixGC 之前老年代就被填满了，那么这时候 G1 就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数-XX:ConcGCThreads。</li>
<li>晋升失败：在 GC 的时候没有足够的内存供存活/晋升对象使用，所以触发了 Full GC。这时候可以通过-XX:G1ReservePercent来增加预留内存百分比，减少-XX:InitiatingHeapOccupancyPercent来提前启动标记，-XX:ConcGCThreads来增加标记线程数也是可以的。</li>
<li>大对象分配失败：大对象找不到合适的 region 空间进行分配，就会进行 fullGC，这种情况下可以增大内存或者增大-XX:G1HeapRegionSize。</li>
<li>程序主动执行 System.gc()：不要随便写就对了。</li>
</ul>
<p>另外，我们可以在启动参数中配置-XX:HeapDumpPath=/xxx/dump.hprof来 dump fullGC 相关的文件，并通过 jinfo 来进行 gc 前后的 dump</p>
<p>jinfo -flag +HeapDumpBeforeFullGC pid</p>
<p>jinfo -flag +HeapDumpAfterFullGC pid</p>
<p>jinfo -flag +HeapDumpBeforeFullGC pid</p>
<p>jinfo -flag +HeapDumpAfterFullGC pid</p>
<p>这样得到 2 份 dump 文件，对比后主要关注被 gc 掉的问题对象来定位问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/%E6%9F%A5%E8%AF%A2%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E8%BF%87%E5%A4%9A%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/%E6%9F%A5%E8%AF%A2%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E8%BF%87%E5%A4%9A%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">查询CPU在线程上下文切换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 09:24:42" itemprop="dateCreated datePublished" datetime="2020-11-05T09:24:42+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-06 13:39:19" itemprop="dateModified" datetime="2021-04-06T13:39:19+08:00">2021-04-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="使用vm命令"><a href="#使用vm命令" class="headerlink" title="使用vm命令"></a>使用vm命令</h2><p>针对频繁上下文问题，我们可以使用vmstat命令来进行查看</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9P2IZ2fVgz8z03pyhRm5cIqch7ytg9hmpoO64iapPlUjjiaUZ1PuRJd8Q/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h2 id="查看具体状态"><a href="#查看具体状态" class="headerlink" title="查看具体状态"></a>查看具体状态</h2><p>cs(context switch)一列则代表了上下文切换的次数。</p>
<p>如果我们希望对特定的 pid 进行监控那么可以使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -w pid</span><br></pre></td></tr></table></figure>

<p>命令，cswch 和 nvcswch 表示自愿及非自愿切换。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9clBLQdNkmNResib4bKMzSjClHpTXHJSaBWia0buP1uoahp4qVcgx2oDg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/%E6%9F%A5%E6%89%BE%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/%E6%9F%A5%E6%89%BE%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">查找内存飙升的原因</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 09:24:42" itemprop="dateCreated datePublished" datetime="2020-11-05T09:24:42+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-06 13:45:21" itemprop="dateModified" datetime="2021-04-06T13:45:21+08:00">2021-04-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>磁盘问题和 CPU 一样是属于比较基础的。首先是磁盘空间方面，我们直接使用df -hl来查看文件系统状态</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs91rAhM7DCqdDZ3TPIj3qicJ9XBZvh5gs6hUqFbmFuG3BjqD3VEgzO5KA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>更多时候，磁盘问题还是性能上的问题。我们可以通过 iostatiostat -d -k -x来进行分析</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9kicWZHgeMphDonPQtaIpZvgsDtMXxXI6Thxj73jjuthFFYtsNscMlTw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>最后一列%util可以看到每块磁盘写入的程度，而rrqpm/s以及wrqm/s分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。</p>
<p>另外我们还需要知道是哪个进程在进行读写，一般来说开发自己心里有数，或者用 iotop 命令来进行定位文件读写的来源。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9UOwicNicwS7ep640BTUJSqvBthicFV3Aqnf5icOHzEzpojGxhTapRrdVug/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>不过这边拿到的是 tid，我们要转换成 pid，可以通过 readlink 来找到 pidreadlink -f /proc/*/task/tid/../..。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9QWIicSI5EmMFHkIlR9yAl1WrPHdiafIOuiaVGiaEt4JuF8b6mcGQXVsmOQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>找到 pid 之后就可以看这个进程具体的读写情况cat /proc/pid/io</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs9AHPZScGmI5wr9EfaLHibwO5ovVL4Yiccb6E03KuOSGiaM55vPC2jrCTLA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>我们还可以通过 lsof 命令来确定具体的文件读写情况lsof -p pid</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x4q4SxZeO5N1RicXwYTjxYs977LolSkIQ1coxHc5ibhfpQFiakUeWs0IYMDmib207Vx6aCK8tDyelW1rQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/27/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><span class="page-number current">28</span><a class="page-number" href="/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/29/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
