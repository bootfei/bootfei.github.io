<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/21/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/21/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/12/database/elastic/Lucene-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/12/database/elastic/Lucene-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Lucene-底层结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-12 20:04:10" itemprop="dateCreated datePublished" datetime="2021-03-12T20:04:10+08:00">2021-03-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-13 00:18:47" itemprop="dateModified" datetime="2021-03-13T00:18:47+08:00">2021-03-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p> Elasticsearch最强大的就是为每个字段提供了倒排索引，当查询的时候不用担心没有索引可以利用，什么是倒排索引，举个简单例子：</p>
<table>
<thead>
<tr>
<th>文档ID</th>
<th>年龄</th>
<th>性别</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>25</td>
<td>女</td>
</tr>
<tr>
<td>2</td>
<td>32</td>
<td>女</td>
</tr>
<tr>
<td>3</td>
<td>25</td>
<td>男</td>
</tr>
</tbody></table>
<p> 每一行是一个文档（document），每个document都有一个文档ID。那么给这些文档建立的倒排索引就是：</p>
<p>年龄的索引：</p>
<table>
<thead>
<tr>
<th>年龄</th>
<th>文档ID列表：posting list</th>
</tr>
</thead>
<tbody><tr>
<td>25</td>
<td>[1,3]</td>
</tr>
<tr>
<td>32</td>
<td>[2]</td>
</tr>
</tbody></table>
<p>性别的索引：</p>
<table>
<thead>
<tr>
<th>性别</th>
<th>文档ID列表：posting list</th>
</tr>
</thead>
<tbody><tr>
<td>男</td>
<td>[3]</td>
</tr>
<tr>
<td>女</td>
<td>[1,2]</td>
</tr>
</tbody></table>
<p>可以看到，倒排索引是针对每个字段的，每个字段都有自己的倒排索引，25、32这些叫做term，[1,3]这种叫做posting list，</p>
<p>它是一个int的数组，存储了所有符合某个term的文档id，这时候我们想找出年龄为25的人，就会很快速。</p>
<p>但是这里只有两个term，如果有成百上千个term呢，那找出某个term就会很慢，因为term还没有排序，解决这个问题需要了解两个概念：Term Dictionary 和 Term Index。<!--这就是ES比Mysql的原因--></p>
<h1 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h1><h2 id="Term-Dictionary"><a href="#Term-Dictionary" class="headerlink" title="Term Dictionary"></a>Term Dictionary</h2><p>Elasticsearch为了能快速找到某个term，将所有的term进行了排序，然后二分法查找term，类似于上学时候老师教我们的翻新华字典的方式，所以这叫做Term Dictionary，这种查询方式其实和传统关系型数据库的B-Tree的方式很相似，所以这并不是Elasticsearch快的原因。</p>
<table>
<thead>
<tr>
<th>Term（已经排过序了a -&gt; z）</th>
<th>Posting List</th>
</tr>
</thead>
<tbody><tr>
<td>ab</td>
<td>[….]</td>
</tr>
<tr>
<td>abc</td>
<td>[….]</td>
</tr>
<tr>
<td>b</td>
<td>[….]</td>
</tr>
</tbody></table>
<p>查询abc的时候，使用二分查找，hi = term.size(), lo = 0;</p>
<p>可以看到，整个Term列 = Term Dictionary</p>
<h2 id="Term-Index"><a href="#Term-Index" class="headerlink" title="Term Index"></a>Term Index</h2><p>如果说Term Dictionary是直接去二分法翻字典，那么Term Index就是字典的目录页。</p>
<p>假设我们的term如果全是英文单词，那么Term Index就是26个字母表，但是通常term未必都是英文，而可以是任意的byte数组。因为就算26个英文字符也不一定都有对应的term，比如：a开头的term只有一个，c开头的term有一百万个，x开头的term一个也没有，这样查询到c的时候又会很慢了。所以通常情况下Term Index 是包含term的一些前缀的一棵树，例如这样的一个Term Index：</p>
<img src="https://img-blog.csdn.net/20181010140158769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjg5Mzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:80%;" />

<p>这样的情况下通过Term Index据可以快速定位到某个offset(分支的开端)，然后以此位置向下查找，再加上<a href="">FST</a>（Finite-State Transducer，Lucene4.0开始使用该算法来查找Term 在Dictionary中的位置）的<a href="">压缩技术</a>，将Term Index 缓存到内存中，通过Term Index 找到对应的Term Dictionary的 block，然后再去磁盘直接找到term，减少磁盘的随机读写次数，大大的提升查询效率。（FST在下个章节单独介绍）</p>
<h1 id="Posting-List压缩技术"><a href="#Posting-List压缩技术" class="headerlink" title="Posting List压缩技术"></a>Posting List压缩技术</h1><p>谈到roaring bitmaps就要先了解bitset 或者bitmap，Bitset是一种的数据结构，对应posting list如果是：[2,3,5,7,9] 那么对于对应的bitset就是：[0,1,1,0,1,0,1,0,1,0]，用0和1来表示该位置的数值的有无，这种做法就是一个byte可以代表8个文档，当大数据量时，仍然会消耗很多内存，所以直接将bitset结构存入内存不太理想。</p>
<p>Elasticsearch不仅压缩了Term Index，还对posting list 进行了压缩，posting list虽然只存储了文档id，但是当文档id很大的时候，比PB级的数据，Elasticsearch对posting list的压缩做了两件事：排序和大数变小数，引用一张被引用无数次的图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL05ld2F5NjY1NS9uZXdheTY2NTUuZ2l0aHViLmNvbS9tYXN0ZXIvaW1hZ2VzL2VsYXN0aWNzZWFyY2gtc3R1ZHkvZnJhbWVPZlJlZmVyZW5jZS5wbmc?x-oss-process=image/format,png" alt="Alt text"></p>
<h2 id="压缩技巧1解读"><a href="#压缩技巧1解读" class="headerlink" title="压缩技巧1解读"></a>压缩技巧1解读</h2><p>step1：在对posting list进行压缩时进行了正序排序。<br>step2：通过增量将73后面的大数变成小数存储增量值。<br>step3:  转换成二进制，取占最大位的数，227占8位，前三个占八位，30占五位，后三个数每个占五位。</p>
<h2 id="压缩技巧2解读"><a href="#压缩技巧2解读" class="headerlink" title="压缩技巧2解读"></a>压缩技巧2解读</h2><p>从第三步可以看出，这种压缩方式仍然不够高效，所以Lucene使用的数据结构叫做Roaring Bitmap，其压缩的原理可以理解为，与其保存100个0，占用100个bit，还不如保存0一次，然后声明这个0有100个，它以两个自己可以表示的最大数65535为界，将posting list分块bloack，比如第一块block是0-65535，第二块block是65536-131071，如图:</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL05ld2F5NjY1NS9uZXdheTY2NTUuZ2l0aHViLmNvbS9tYXN0ZXIvaW1hZ2VzL2VsYXN0aWNzZWFyY2gtc3R1ZHkvUm9hcmluZ2JpdG1hcHMucG5n?x-oss-process=image/format,png" alt="Alt text"></p>
<p>step1：从小到大进行排序。<br>step2：将大数除以65536，用除得的结果和余数来表示这个大数。<br>step3:    以65535为界进行分块。<br>注意：如果一块block存储了超过了4096 个value，直接用bitset存，2个字节就用个简单的数组存放好了，比如short[]，修正一下：1KB=1024B=1024byte=8192bit，每个值一个bytes，4096*2bytes = 8192bytes，刚好达到每一个block的界限 4096 = 65536 / 2 / 8</p>
<h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><p>如何使用联合索引查询？</p>
<ul>
<li>Skip List 数据结构，同时遍历多个term的posting list，互相skip</li>
<li>使用bitset数据结构，对多个term分别求出bitset，对bitset做AND操作</li>
</ul>
<h2 id="Skip-List-跳表原理"><a href="#Skip-List-跳表原理" class="headerlink" title="Skip List 跳表原理"></a>Skip List 跳表原理</h2><p>先了解跳表需要先知道跳表应该具有以下性质：</p>
<ul>
<li>由多层有序链表组成。</li>
<li>最底层Level 1的链表包含所有的其他链表的元素。</li>
<li>如果一个元素在链表Level n中存在，那么他在Level n以下的所有链表中都存在。</li>
<li>每个节点都包含连个指针，分别指同Level链表的下一个元素和下一层的元素。</li>
</ul>
<p>这是一个有序列链表：</p>
<p><img src="https://img-blog.csdn.net/2018101116263239?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjg5Mzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>从链表中搜索（27，44，61）需要查找的次数为：2+4+6 = 12次，可以得到所有结果，这样做其实没有用到链表的有序性，我们在查询44、66时候其实都做了一些重复查找，势必会造成效率低的问题，这时候可以用Skip List算法来优化查找次数，把某些节点提取出来，将链表分成两级：</p>
<p><img src="https://img-blog.csdn.net/20181011162409919?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjg5Mzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>这样我们在查找44和61的时候次数就得到了简化，因为列表时有序的，所以当我们查到27的时候，44的大概位置就知道了，查到44的时候，61的大概位置也就知道了，避免了一部分重复查查找，这时候我们找到所以结果的次数为2+3+4 = 9次 <!--我一开始以为是2+4+5=11次，后来发现Level2和Level1的36是同一个地址，50也是同一个地址，不该算做一次查询--> ，查询61的时候似乎又对44的查找重复了一次，似乎还有优化的空间，那我们再对二级链表再进行一次分级：</p>
<p><img src="https://img-blog.csdn.net/20181011163014593?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjg5Mzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>这时候可以看到我们查找61的时候只需要从15-50-61，三次就可以查找到结果，没有去走查找44时的36，所以现在查询次数得到了再次优化，也就是2+3+3 = 8次，有人说：就优化了一次查询，需要做得这么复杂吗，能有那么大的性能优势吗？的确，这里数据量很少，组合查询的索引也只有三个，看起来确实没有优势，但是当面对PB级数据的时候，链表的分级将无限扩大大，我们在查询结果时所”跳” 的跨度也会非常大，原先需要查找一百万次的结果，可能仅仅三次就查找到了，这个时候就会显得非常高效。</p>
<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p>从Skip List的查找原理可以看出，它的高效其实是牺牲了一定的空间冗余换来的，所以在有些情况下还是使用bitset更加的直观，比如下面这种数据结构：</p>
<p>111    222    333    444<br>111    222    333    444    555    666    777<br>111    222    333    444    555    666    777    888</p>
<p>如果使用跳表，查找第一行数据在另外两行中查找看是否存在，为了得到最后得到交集的结果，操作就要繁琐的多。</p>
<p>如果使用bitset直接进行压缩，按位与，得到的结果就是最后的交集。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/08/database/elastic/elastic-%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/database/elastic/elastic-%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">elastic-安装</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-08 17:05:46" itemprop="dateCreated datePublished" datetime="2021-03-08T17:05:46+08:00">2021-03-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-14 10:22:17" itemprop="dateModified" datetime="2021-03-14T10:22:17+08:00">2021-03-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-单机安装"><a href="#Elasticsearch-单机安装" class="headerlink" title="Elasticsearch 单机安装"></a><strong>Elasticsearch</strong> 单机安装</h1><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;elasticsearch&#x2F;elasticsearch-6.6.2.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="解压缩并且修改配置文件"><a href="#解压缩并且修改配置文件" class="headerlink" title="解压缩并且修改配置文件"></a>解压缩并且修改配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf elasticsearch-6.6.2.tar.gz</span><br><span class="line"></span><br><span class="line">cd elasticsearch-6.6.2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color='red'>注意：把elasticsearch软件必须放入/home/es（es是新建用户）的目录下，并把elasticsearch设置为es用户所属</font></p>
<h2 id="修改Linux配置"><a href="#修改Linux配置" class="headerlink" title="修改Linux配置"></a>修改Linux配置</h2><h3 id="max-file-descriptors-4096-for-elasticsearch-process-is-too-low-increase-to-at-least-65536"><a href="#max-file-descriptors-4096-for-elasticsearch-process-is-too-low-increase-to-at-least-65536" class="headerlink" title="max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]"></a>max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</h3><p>每个进程最大同时打开文件数太小，可通过下面2个命令查看当前数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulimit -Hn</span><br><span class="line"></span><br><span class="line">ulimit -Sn</span><br></pre></td></tr></table></figure>

<p>修改/etc/security/limits.conf文件，增加配置，用户退出后重新登录生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line"></span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure>

<h3 id="max-number-of-threads-3818-for-user-qf-is-too-low-increase-to-at-least-4096"><a href="#max-number-of-threads-3818-for-user-qf-is-too-low-increase-to-at-least-4096" class="headerlink" title="max number of threads [3818] for user [qf] is too low, increase to at least [4096]"></a>max number of threads [3818] for user [qf] is too low, increase to at least [4096]</h3><p>可通过命令查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulimit -Hu</span><br><span class="line"></span><br><span class="line">ulimit -Su</span><br></pre></td></tr></table></figure>

<p>问题同上，最大线程个数太低。修改配置文件/etc/security/limits.conf，增加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* soft nproc 4096</span><br><span class="line"></span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure>

<h3 id="max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least-262144"><a href="#max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least-262144" class="headerlink" title="max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]"></a>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</h3><p>修改/etc/sysctl.conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line">sysctl -p #执行命令sysctl -p生效</span><br></pre></td></tr></table></figure>

<p>增加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count&#x3D;262144</span><br></pre></td></tr></table></figure>

<p>错误解决完毕：重新启动</p>
<h2 id="修改ES配置"><a href="#修改ES配置" class="headerlink" title="修改ES配置"></a>修改ES配置</h2><h3 id="创建日志、数据存储目录：（留作备用，初次先创建）"><a href="#创建日志、数据存储目录：（留作备用，初次先创建）" class="headerlink" title="创建日志、数据存储目录：（留作备用，初次先创建）"></a><strong>创建日志、数据存储目录：（留作备用，初次先创建）</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;data&#x2F;logs&#x2F;es</span><br><span class="line">mkdir -p &#x2F;data&#x2F;es&#x2F;&#123;data,work,plugins,scripts&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a><strong>创建用户</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd es -s &#x2F;bin&#x2F;bash #es不能在root用户下启动，必须创建新的用户，用来启动es</span><br></pre></td></tr></table></figure>

<p>注意：es不能在root用户下启动，必须创建新的用户，用来启动es</p>
<h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a><strong>切换用户</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su es</span><br></pre></td></tr></table></figure>

<p>再次启动，发现还是报错，原因：当前用户没有执行权限</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R es &#x2F;home&#x2F;qifei&#x2F;elasticsearch-6.2.4</span><br></pre></td></tr></table></figure>

<h3 id="允许外网访问"><a href="#允许外网访问" class="headerlink" title="允许外网访问"></a>允许外网访问</h3><p>授权成功，发现elasticsearch已经在es用户下面了，可以启动了，但是启动成功，浏览器不能访问，因此还需要做如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi confifig&#x2F;Elasticsearch.yml</span><br><span class="line"></span><br><span class="line">network.host: 0.0.0.0 #设置外网访问，默认禁止外网访问</span><br></pre></td></tr></table></figure>



<h3 id="修改ES的JVM大小"><a href="#修改ES的JVM大小" class="headerlink" title="修改ES的JVM大小"></a>修改ES的JVM大小</h3><p>vi config/jvm.options</p>
<p>-Xms1g</p>
<p>-Xmx1g</p>
<p>必须保持一样大</p>
<blockquote>
<p>* soft nofile 65536</p>
<p>* hard nofile 65536</p>
<p>* soft nproc 4096</p>
<p>* hard nproc 4096</p>
</blockquote>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>不要root启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd qf</span><br><span class="line">echo &quot;Password&quot; | passwd qf --stdin</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;elasticsearch</span><br><span class="line"></span><br><span class="line">bin&#x2F;elasticsearch -d #后台启动（守护模式）</span><br></pre></td></tr></table></figure>



<h3 id="验证环境"><a href="#验证环境" class="headerlink" title="验证环境"></a>验证环境</h3><p>not run elasticsearch as root </p>
<p>curl <a target="_blank" rel="noopener" href="http://localhost:9200/?pretty">http://localhost:9200/?pretty</a></p>
<h1 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h1><p>下载后解压到elasticsearch的plugins目录下</p>
<p>POST /_analyze { “analyzer”: “simple”, “text”: “ 我是中国人” }</p>
<h2 id="ik分词器"><a href="#ik分词器" class="headerlink" title="ik分词器"></a>ik分词器</h2><p>wget <a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v6.6.2">https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v6.6.2</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;_analyze </span><br><span class="line">&#123; </span><br><span class="line">    &quot;analyzer&quot;: &quot;ik_smart&quot;, </span><br><span class="line">    &quot;text&quot;: &quot;我是中国人 &quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pinyin分词器"><a href="#pinyin分词器" class="headerlink" title="pinyin分词器"></a>pinyin分词器</h2><p>wget <a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-pinyin/releases/tag/v6.6.2">https://github.com/medcl/elasticsearch-analysis-pinyin/releases/tag/v6.6.2</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;medcl&#x2F;_analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;text&quot;:[&quot;河南濮阳&quot;],</span><br><span class="line">    &quot;analyzer&quot;: &quot;pinyin_analyzer&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>wget <a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/kibana/kibana-6.6.2-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/kibana/kibana-6.6.2-linux-x86_64.tar.gz</a></p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi kibana-6.4.2-linux-x86_64&#x2F;config&#x2F;kibana.yml</span><br><span class="line"></span><br><span class="line">server.port: 5601 ## Kibana服务端口</span><br><span class="line"></span><br><span class="line">server.host: &quot;0.0.0.0&quot; ## Kibana服务地址</span><br><span class="line"></span><br><span class="line">elasticsearch.url: &quot;http:&#x2F;&#x2F;localhost:9200&quot; ##elasticsearch服务地址</span><br></pre></td></tr></table></figure>

<h2 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./bin/kibana</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">后台启动</span></span><br><span class="line">./bin/kibana &amp; disown </span><br></pre></td></tr></table></figure>

<h2 id="验证环境-1"><a href="#验证环境-1" class="headerlink" title="验证环境"></a>验证环境</h2><p>访问<a target="_blank" rel="noopener" href="http://192.168.199.216:5601/app/kibana">http://192.168.199.216:5601/app/kibana</a></p>
<p>如果失败，关闭防火墙</p>
<h1 id="HeadNode安装"><a href="#HeadNode安装" class="headerlink" title="HeadNode安装"></a>HeadNode安装</h1><h1 id="head插件主要用途"><a href="#head插件主要用途" class="headerlink" title="head插件主要用途"></a><strong>head</strong>插件主要用途</h1><p>elasticsearch-head是一个用来浏览、与Elastic Search簇进行交互的web前端展示插件。</p>
<p>elasticsearch-head是一个用来监控Elastic Search状态的客户端插件。</p>
<p>elasticsearch主要有以下三个主要操作——</p>
<p>1）簇浏览，显示簇的拓扑并允许你执行索引（index)和节点层面的操作。</p>
<p>2）查询接口，允许你查询簇并以原始json格式或表格的形式显示检索结果。</p>
<p>3）显示簇状态，有许多快速访问的tabs用来显示簇的状态。 </p>
<p>4）支持RestfulAPI接口，包含了许多选项产生感兴趣的结果，包括： </p>
<p>第一，请求方式:get,put,post,delete;json请求数据，节点node， 路径path。 </p>
<p>第二，JSON验证器。 </p>
<p>第三，定时请求的能力。</p>
<p>第四，用javascript表达式传输结果的能力。 </p>
<p>第五，统计一段时间的结果或该段时间结果比对的能力。</p>
<p>第六，以简单图标的形式绘制传输结果</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><p>安装步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#下载nodejs,head插件运行依赖node</span><br><span class="line">wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v9.9.0&#x2F;node-v9.9.0-linux-x64.tar.xz</span><br><span class="line"></span><br><span class="line">#解压</span><br><span class="line">tar -xf node-v9.9.0-linux-x64.tar.xz</span><br><span class="line"></span><br><span class="line">#重命名</span><br><span class="line">mv node-v9.9.0-linux-x64 nodeJs</span><br><span class="line"></span><br><span class="line">#配置文件</span><br><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">export NODE_HOME&#x3D;&#x2F;home&#x2F;coder&#x2F;server&#x2F;node- v8.12.0-linux-x64 </span><br><span class="line">export PATH&#x3D;$PATH:$NODE_HOME&#x2F;bin</span><br><span class="line"></span><br><span class="line">#刷新配置</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">#查询node版本，同时查看是否安装成功</span><br><span class="line">node -v</span><br><span class="line"></span><br><span class="line">#下载head插件</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head&#x2F;archive&#x2F;master.zip</span><br><span class="line"></span><br><span class="line">#解压</span><br><span class="line">unzip master.zip</span><br><span class="line"></span><br><span class="line">#使用淘宝的镜像库进行下载，速度很快</span><br><span class="line"></span><br><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">#进入head插件解压目录，执行安装命令</span><br><span class="line">cnpm install</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>此时未连接，需要配置才能连接：<br>修改 Gruntfile.js文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改_site/app.js：<br>修改IP地址，连接elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启用CORS: 当head插件访问es时，您必须在elasticsearch中启用CORS，否则您的浏览器将拒绝跨域。</span><br><span class="line">在elasticsearch配置中：</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">您还必须设置，http.cors.allow-origin因为默认情况下不允许跨域。http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">是允许配置的，但由于这样配置的任何地方都可以访问，所以有安全风险。</span><br><span class="line">我在集群安装的时候已经配好了、如果你刚配置、需要重启ElasticSearch服务</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">访问head插件</span><br></pre></td></tr></table></figure>



<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a><strong>运行</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start #启动head插件</span><br></pre></td></tr></table></figure>

<p>启动运行端口为：9100</p>
<p>访问：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell-02-%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell-02-%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux常用命令集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-07 21:07:42" itemprop="dateCreated datePublished" datetime="2021-03-07T21:07:42+08:00">2021-03-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-06 15:04:40" itemprop="dateModified" datetime="2021-10-06T15:04:40+08:00">2021-10-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">[-l limit] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">[[user@]host1:]file1 [...] [[user@]host2:]file2</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [可选参数] file_source file_target </span><br></pre></td></tr></table></figure>

<ul>
<li>-r： 递归复制整个目录。</li>
<li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
<li>-P port：注意是大写的P, port是指定数据传输用到的端口号</li>
<li>-F: 使用指定的配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、*.tar 用 tar –xvf 解压 </span><br><span class="line">2、*.gz 用 gzip -d或者gunzip 解压 </span><br><span class="line">3、*.tar.gz和*.tgz 用 tar –xzf 解压 </span><br><span class="line">4、*.bz2 用 bzip2 -d或者用bunzip2 解压 </span><br><span class="line">5、*.tar.bz2用tar –xjf 解压 </span><br><span class="line">6、*.Z 用 uncompress 解压 </span><br><span class="line">7、*.tar.Z 用tar –xZf 解压 </span><br><span class="line">8、*.rar 用 unrar e解压 </span><br><span class="line">9、*.zip 用 unzip 解压</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1、从本地将文件传输到服务器</span><br><span class="line">scp【本地文件的路径】【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】</span><br><span class="line">scp /Users/mac_pc/Desktop/test.png root@192.168.1.1:/root</span><br><span class="line"></span><br><span class="line">2、从本地将文件夹传输到服务器</span><br><span class="line">scp -r【本地文件的路径】【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】</span><br><span class="line">sup -r /Users/mac_pc/Desktop/test root@192.168.1.1:/root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、将服务器上的文件传输到本地</span><br><span class="line">scp 【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】【本地文件的路径】</span><br><span class="line">scp root@192.168.1.1:/data/wwwroot/default/111.png /Users/mac_pc/Desktop</span><br><span class="line"></span><br><span class="line">4、将服务器上的文件夹传输到本地</span><br><span class="line">scp -r 【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】【本地文件的路径】</span><br><span class="line">scp -r root@192.168.1.1:/data/wwwroot/default/test /Users/mac_pc/Desktop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.使用ssh配置文件</span><br><span class="line"> scp -F ~/.ssh/ssh_config www@172.17.47.235:/tmp/core_cronjob_jstack ~/Downloads</span><br></pre></td></tr></table></figure>



<h1 id="文件压缩解压命令"><a href="#文件压缩解压命令" class="headerlink" title="文件压缩解压命令"></a>文件压缩解压命令</h1><h2 id="unzip解压zip文件"><a href="#unzip解压zip文件" class="headerlink" title="unzip解压zip文件"></a>unzip解压zip文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip [-cflptuvz][-agCjLMnoqsVX][-P &lt;密码&gt;][.zip文件][文件][-d &lt;目录&gt;][-x &lt;文件&gt;] 或 unzip [-Z]</span><br></pre></td></tr></table></figure>

<ul>
<li>-d&lt;目录&gt; 指定文件解压缩后所要存储的目录。</li>
</ul>
<h2 id="tar解压-gz、tar、bz2"><a href="#tar解压-gz、tar、bz2" class="headerlink" title="tar解压.gz、tar、bz2"></a>tar解压.gz、tar、bz2</h2><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c: 建立压缩档案 </span><br><span class="line">-x：解压 </span><br><span class="line">-t：查看内容 </span><br><span class="line">-r：向压缩归档文件末尾追加文件 </span><br><span class="line">-u：更新原压缩包中的文件</span><br></pre></td></tr></table></figure>

<p>下面的参数是根据需要在压缩或解压档案时可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-z：有gzip属性的 </span><br><span class="line">-j：有bz2属性的 </span><br><span class="line">-Z：有compress属性的 </span><br><span class="line">-v：显示所有过程 </span><br><span class="line">-O：将文件解开到标准输出</span><br></pre></td></tr></table></figure>

<p>下面的参数 -f 是必须的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 </span><br></pre></td></tr></table></figure>



<h1 id="文件夹命令"><a href="#文件夹命令" class="headerlink" title="文件夹命令"></a>文件夹命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-p] dirName</span><br><span class="line"></span><br><span class="line">mkdir -p &#x2F;data&#x2F;qifei&#x2F;&#123;data,work,plugins,scripts&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>-p 确保目录名称存在，不存在的就建一个。</li>
</ul>
<h1 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h1><h2 id="查看压缩日志文件命令zcat"><a href="#查看压缩日志文件命令zcat" class="headerlink" title="查看压缩日志文件命令zcat"></a>查看压缩日志文件命令zcat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看gz类型的压缩日志</span><br><span class="line">gunzip -c service.log.gz | less</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/rpc-dubbo/dubbo-01-%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/rpc-dubbo/dubbo-01-%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">dubbo-01-入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-04 09:53:30" itemprop="dateCreated datePublished" datetime="2021-03-04T09:53:30+08:00">2021-03-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Dubbo概述"><a href="#Dubbo概述" class="headerlink" title="Dubbo概述"></a>Dubbo概述</h1><h2 id="什么是-PRC"><a href="#什么是-PRC" class="headerlink" title="什么是 PRC?"></a>什么是 <strong>PRC</strong>?</h2><p>RPC(Remote Procedure Call Protocol)——远程过程调用协议，它是一种通过网络从远 程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 协议假定某些传输协议 的存在，如 TCP 或 UDP，为通信程序之间携带信息数据。在 OSI 网络通信模型(OSI 七层网 络模型，OSI，Open System Interconnection，开放系统互联)中，RPC 跨越了传输层和应用 层。RPC 使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<p>RPC 采用客户机/服务器模式(即 C/S 模式)。请求程序就是一个客户机，而服务提供程 序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然 后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息 到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后， 客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p>
<h2 id="Dubbo-四大组件"><a href="#Dubbo-四大组件" class="headerlink" title="Dubbo 四大组件"></a><strong>Dubbo</strong> 四大组件</h2><p>Dubbo 中存在四大组件:</p>
<ul>
<li><p><strong>Provider</strong>:服务提供者。</p>
</li>
<li><p><strong>Consumer</strong>:服务消费者。<font color="red">会从Registry下载Provider注册列表，负载均衡、限流等操作，都是Consumer自己根据这个注册列表中的Provider进行操作。</font></p>
</li>
<li><p><strong>Registry</strong>:服务注册与发现的中心，提供目录服务，亦称为服务注册中心</p>
</li>
<li><p><strong>Monitor</strong>:统计服务的调用次数、调用时间等信息的日志服务，并可以对服务设置权限、降级处理等，称为服务管控中心</p>
</li>
</ul>
<h1 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h1><p>注意：业务接口已经打成jar包，消费者和生产者直接导入jar包即可。</p>
<h2 id="直连方式"><a href="#直连方式" class="headerlink" title="直连方式"></a>直连方式</h2><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><ul>
<li><p>pom依赖</p>
<ul>
<li><p>业务接口依赖</p>
</li>
<li><p>Dubbo 依赖(2.7.0 版本) </p>
</li>
<li><p>Spring 依赖(4.3.16 版本)</p>
</li>
<li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.abc&lt;/groupId&gt;
    &lt;artifactId&gt;01-consumer&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
        &lt;!-- 自定义版本号 --&gt;
        &lt;spring-version&gt;4.3.16.RELEASE&lt;/spring-version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!--业务接口工程依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.abc&lt;/groupId&gt;
            &lt;artifactId&gt;00-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- dubbo依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
            &lt;version&gt;2.7.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- Spring依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- commons-logging依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-logging&lt;/groupId&gt;
            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 配置文件： src&#x2F;main&#x2F;resources 下定义 spring-consumer.xml 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">           xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&quot;</span><br><span class="line">           xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定当前工程在管控平台中的名称--&gt;</span><br><span class="line">        &lt;dubbo:application name&#x3D;&quot;01-consumer&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定注册中心：不使用注册中心--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;N&#x2F;A&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--直连式连接提供者--&gt;</span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;someService&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                         url&#x3D;&quot;dubbo:&#x2F;&#x2F;localhost:20880&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>main：作为测试类</p>
<ul>
<li><pre><code class="java">public class ConsumerRun &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
        SomeService service = (SomeService) ac.getBean(&quot;someService&quot;);
        String hello = service.hello(&quot;China&quot;);
        System.out.println(hello);
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### 生产者</span><br><span class="line"></span><br><span class="line">- pom依赖</span><br><span class="line"></span><br><span class="line">  -  业务接口依赖</span><br><span class="line">  - Dubbo 依赖(2.7.0 版本) </span><br><span class="line">  - Spring 依赖(4.3.16 版本)</span><br><span class="line"></span><br><span class="line">- 定义接口实现类（略）</span><br><span class="line"></span><br><span class="line">- 配置文件： src&#x2F;main&#x2F;resources 下定义 spring-provider.xml 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">           xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&quot;</span><br><span class="line">           xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定当前工程在管控平台中的名称--&gt;</span><br><span class="line">        &lt;dubbo:application name&#x3D;&quot;01-provider&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定注册中心：不使用注册中心--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;N&#x2F;A&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--注册业务接口实现类，它是真正的服务提供者--&gt;</span><br><span class="line">        &lt;bean id&#x3D;&quot;someService&quot; class&#x3D;&quot;com.abc.provider.SomeServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--服务暴露--&gt;</span><br><span class="line">        &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                       ref&#x3D;&quot;someService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>main: 启动类</p>
<ul>
<li><pre><code class="java">    public static void main(String[] args) throws IOException &#123;
        // 创建Spring容器
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-provider.xml&quot;);
        // 启动Spring容器
        ((ClassPathXmlApplicationContext) ac).start();
        // 使主线程阻塞
        System.in.read();
    &#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **Zookeeper** **注册中心**</span><br><span class="line"></span><br><span class="line">### 消费者</span><br><span class="line"></span><br><span class="line">- 导入依赖</span><br><span class="line">  </span><br><span class="line">- 复制前面的提供者工程 01-provider，并更名为 02-provider-zk。修改 pom 文件，并在其中导入 Zookeeper 客户端依赖 curator。</span><br><span class="line">  </span><br><span class="line">- 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:application name&#x3D;&quot;02-consumer-zk&quot;&gt;</span><br><span class="line">            &lt;dubbo:parameter key&#x3D;&quot;qos.port&quot; value&#x3D;&quot;33333&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;dubbo:application&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定服务注册中心：zk单机--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--指定服务注册中心：zk集群--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS1:2181?backup&#x3D;zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS1:2181,zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;someService&quot; check&#x3D;&quot;false&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ul>
<li><p>导入依赖</p>
<ul>
<li><p>复制前面的提供者工程 01-provider，并更名为 02-provider-zk。修改 pom 文件，并在其中导入 Zookeeper 客户端依赖 curator。</p>
</li>
<li><pre><code class="java"> &lt;!-- zk客户端依赖：curator --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
            &lt;version&gt;2.13.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
            &lt;version&gt;2.13.0&lt;/version&gt;
        &lt;/dependency&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">      &lt;dubbo:application name&#x3D;&quot;02-provider-zk&quot;&#x2F;&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;!--声明注册中心：单机版zk--&gt;</span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;!--声明注册中心：zk群集--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS1:2181?backup&#x3D;zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zkOS1:2181,zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;&#x2F;&gt;--&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;bean id&#x3D;&quot;someService&quot; class&#x3D;&quot;com.abc.provider.SomeServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">      </span><br><span class="line">        &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                ref&#x3D;&quot;someService&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>zk集群 + 不同协议</p>
<ul>
<li><pre><code class="xml">    &lt;dubbo:application name=&quot;02-provider-zk&quot; /&gt;

    &lt;!--声明注册中心：单机版zk--&gt;
    &lt;dubbo:registry address=&quot;zookeeper://zkOS:2181&quot;/&gt;
    &lt;!--&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;zkOS:2181&quot;/&gt;--&gt;

    &lt;!--声明注册中心：zk群集--&gt;
    &lt;!--&lt;dubbo:registry address=&quot;zookeeper://zkOS1:2181?backup=zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;/&gt;--&gt;
    &lt;!--&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;zkOS1:2181,zkOS2:2181,zkOS3:2181,zkOS4:2181&quot;/&gt;--&gt;

    &lt;bean id=&quot;someService&quot; class=&quot;com.abc.provider.SomeServiceImpl&quot;/&gt;

    &lt;dubbo:protocol id=&quot;dp&quot; name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;
    &lt;dubbo:protocol id=&quot;dp2&quot; name=&quot;dubbo&quot; port=&quot;20881&quot;/&gt;
    &lt;dubbo:protocol id=&quot;rp&quot; name=&quot;rmi&quot; port=&quot;9411&quot;/&gt;

    &lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; protocol=&quot;dp,dp2&quot;/&gt;

    &lt;dubbo:provider id=&quot;xxx&quot; timeout=&quot;2000&quot; protocol=&quot;dp&quot; default=&quot;true&quot;/&gt;
    &lt;dubbo:provider id=&quot;ooo&quot; delay=&quot;2000&quot; protocol=&quot;dp2&quot; default=&quot;true&quot;/&gt;
    &lt;dubbo:provider id=&quot;jjj&quot;  /&gt;
    &lt;dubbo:provider id=&quot;kkk&quot;  /&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">- 添加日志</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;properties</span><br><span class="line">    log4j.appender.console&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">    log4j.appender.console.Target&#x3D;System.out</span><br><span class="line">    log4j.appender.console.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">    log4j.appender.console.layout.ConversionPattern&#x3D;[%-5p] %m%n</span><br><span class="line">    log4j.rootLogger&#x3D;info,console</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="将-Dubbo-应用到-web-工程"><a href="#将-Dubbo-应用到-web-工程" class="headerlink" title="将 Dubbo 应用到 web 工程"></a><strong>将</strong> <strong>Dubbo</strong> <strong>应用到</strong> <strong>web</strong> <strong>工程</strong></h2><p>前面所有提供者与消费者均是 Java 工程，而在生产环境中，它们都应是 web 工程，Dubbo如何应用于 Web 工程中呢？</p>
<h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><ul>
<li><p>pom依赖</p>
<ul>
<li><p> dubbo2.7.0 版本依赖</p>
<p> zk 客户端 curator 依赖</p>
<p> servlet 与 jsp 依赖</p>
<p> spring 相关依赖</p>
<p> spring 需要的 commons-logging 依赖</p>
<p> 自定义 00-api 依赖</p>
</li>
<li><pre><code class="xml">&lt;!-- Servlet 依赖 --&gt; 
&lt;dependency&gt; 
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; 
    &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- JSP 依赖 --&gt; 
&lt;dependency&gt; 
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; 
    &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; 
    &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **定义** **web.xml**</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">             xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">             xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_1.xsd&quot;</span><br><span class="line">             version&#x3D;&quot;3.1&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--注册Spring配置文件--&gt;</span><br><span class="line">        &lt;context-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:spring-*.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;context-param&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--注册ServletContext监听器--&gt;</span><br><span class="line">        &lt;listener&gt;</span><br><span class="line">            &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">        &lt;&#x2F;listener&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>修改</strong> <strong>spring-provider.xml</strong>：略</p>
</li>
</ul>
<h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><ul>
<li><p>pom依赖</p>
<ul>
<li><p> dubbo2.7.0 版本依赖</p>
<p> zk 客户端 curator 依赖</p>
<p> servlet 与 jsp 依赖</p>
<p> spring 相关依赖</p>
<p> spring 需要的 commons-logging 依赖</p>
<p> 自定义 00-api 依赖</p>
</li>
</ul>
</li>
<li><p><strong>定义</strong> <strong>web.xml</strong></p>
<ul>
<li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

    &lt;!--对于2.6.4版本，其Spring配置文件必须指定从&lt;context-param&gt;中加载--&gt;
    &lt;!--&lt;context-param&gt;--&gt;
        &lt;!--&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;--&gt;
        &lt;!--&lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;--&gt;
    &lt;!--&lt;/context-param&gt;--&gt;

    &lt;!--字符编码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!--注册中央调度器--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--不能写/*，不建议写/，建议扩展名方式--&gt;
        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **修改** **spring-consumer.xml**：略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># **Dubbo** **管理控制台**</span><br><span class="line"></span><br><span class="line">2019 年初，官方发布了 Dubbo 管理控制台 0.1 版本。结构上采取了前后端分离的方式，前端使用 Vue 和 Vuetify 分别作为 Javascript 框架和 UI 框架，后端采用 Spring Boot 框架。</span><br><span class="line"></span><br><span class="line"> **下载**</span><br><span class="line"></span><br><span class="line">Dubbo 管理控制台的下载地址为：https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;incubator-dubbo-ops</span><br><span class="line"></span><br><span class="line">**配置**</span><br><span class="line"></span><br><span class="line">在下载的 zip 文件的解压目录的 dubbo-admin-server\src\main\resources 下，修改配置文件 application.properties。主要就是修改注册中心、配置中心，与元数据中心的 zk 地址。这是一个 springboot 工程，默认端口号为 8080，若要修改端口号，则在配置文件中增加形如 server.port&#x3D;8888 的配置。</span><br><span class="line"></span><br><span class="line">**打包**</span><br><span class="line"></span><br><span class="line">在命令行窗口中进入到解压目录根目录，执行打包命令。mvn clean package。</span><br><span class="line"></span><br><span class="line">打包结束后，进入到解压目录下的 dubbo-admin-distribution 目录下的 target 目录。目录下有个 dubbo-admin-0.1.jar 文件。该 Jar 包文件即为 Dubbo 管理控制台的运行文件，可以将其放到任意目录下运行。</span><br><span class="line"></span><br><span class="line">**启动zk**</span><br><span class="line"></span><br><span class="line">**启动管控台**</span><br><span class="line"></span><br><span class="line">将 dubbo-admin-0.1.jar 文件存放到任意目录下，例如 D 盘根目录下，直接运行。</span><br><span class="line"></span><br><span class="line">**访问**</span><br><span class="line"></span><br><span class="line">在浏览器地址栏中输入 http:&#x2F;&#x2F;localhost:8080 ，即可看到 Dubbo 管理控制台界面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># **Dubbo** **高级配置**</span><br><span class="line"></span><br><span class="line">&gt; 注意：consumer是从Registry获取provider注册表，所以consumer端也可以设置负载均衡等配置，从而覆盖从Registry获取的注册表</span><br><span class="line">&gt;</span><br><span class="line">&gt; | interface + version + group | provider host | 负载均衡设置 | 请求次数 |</span><br><span class="line">&gt; | --------------------------- | ------------- | ------------ | -------- |</span><br><span class="line">&gt; | someService, 1.00, beijing  | h1, h2,h3     | random       | 3        |</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 关闭服务检查</span><br><span class="line"></span><br><span class="line">默认情况下，若服务消费者先于服务提供者启动，则消费者端会报错。因为默认情况下消费者会在启动时查检其要消费的服务的提供者是否已经注册，若未注册则抛出异常。可以在消费者端的 spring 配置文件中添加 check&#x3D;”false”属性，则可关闭服务检查功能。</span><br><span class="line"></span><br><span class="line">## **多版本控制**</span><br><span class="line"></span><br><span class="line">消费者和生产者都要同步改</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&lt;dubbo:application name=&quot;04-consumer-version&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>&lt;dubbo:registry address=”zookeeper://zkOS:2181” /&gt;</p>
<!--指定消费0.0.1版本，即oldService提供者-->
<!--<dubbo:reference id="someService"  version="0.0.1"-->
<pre><code>             &lt;!--interface=&quot;com.abc.service.SomeService&quot;/&gt;--&gt;</code></pre>
<!--指定消费0.0.2版本，即newService提供者-->
<p>&lt;dubbo:reference id=”someService”  version=”0.0.2”<br>                 interface=”com.abc.service.SomeService”/&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## **服务分组**</span><br><span class="line"></span><br><span class="line">服务分组与多版本控制的使用方式几乎是相同的，只要将 version 替换为 group 即可。</span><br><span class="line"></span><br><span class="line">但使用目的不同。使用版本控制的目的是为了升级，将原有老版本替换掉，将来不再提供老版本的服务，所以不同版本间不能出现相互调用。而分组的目的则不同，其也是针对相同接口，给出了多种实现类。但不同的是，这些不同实现并没有谁替换掉谁的意思，是针对不同需求，或针对不同功能模块所给出的不同实现。这些实现所提供的服务是并存的，所以它们间可以出现相互调用关系。例如，对于支付服务的实现，可以有微信支付实现与支付宝支付实现等。</span><br><span class="line"></span><br><span class="line">## **同一服务支持多种协议**</span><br><span class="line"></span><br><span class="line">这里需要理解这个服务暴露协议的意义。其是指出，消费者若要连接当前的服务，就需要通过这里指定的协议及端口号进行访问。这里的端口号可以是任意的，不一定非要使用默认的端口号（Dubbo 默认为 20880，rmi 默认为 1099）。这里指定的协议名称及端口号，在当前服务注册到注册中心时会一并写入到服务映射表中。当消费者根据服务名称查找到相应主机时，其同时会查询出消费此服务的协议、端口号等信息。其底层就是一个 Socket 编程，通过主机名与端口号进行连接。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:application name&#x3D;&quot;05-provider-group&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dubbo:protocal name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20880&quot;&#x2F;&gt;</span><br><span class="line">	&lt;dubbo:protocal name&#x3D;&quot;rmi&quot; port&#x3D;&quot;1099&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册Service实现类--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;weixinService&quot; class&#x3D;&quot;com.abc.provider.WeixinServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;zhifubaoService&quot; class&#x3D;&quot;com.abc.provider.ZhifubaoServiceImpl&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--暴露服务--&gt;</span><br><span class="line">    &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                   ref&#x3D;&quot;weixinService&quot; group&#x3D;&quot;pay.weixin&quot; protocal&#x3D;&quot;dubbo,rmi&quot;&#x2F;&gt;</span><br><span class="line">    &lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">                   ref&#x3D;&quot;zhifubaoService&quot; group&#x3D;&quot;pay.zhifubao&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="不同服务使用不同协议"><a href="#不同服务使用不同协议" class="headerlink" title="不同服务使用不同协议"></a><strong>不同服务使用不同协议</strong></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;05-provider-group&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://zkOS:2181&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocal</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocal</span> <span class="attr">name</span>=<span class="string">&quot;rmi&quot;</span> <span class="attr">port</span>=<span class="string">&quot;1099&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--注册Service实现类--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.abc.provider.WeixinServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;zhifubaoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.abc.provider.ZhifubaoServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--暴露服务--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">ref</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.weixin&quot;</span> <span class="attr">protocal</span>=<span class="string">&quot;rmi&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">ref</span>=<span class="string">&quot;zhifubaoService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.zhifubao&quot;</span> <span class="attr">protocal</span>=<span class="string">&quot;dubbo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h2><p>Dubbo 内置了四种负载均衡算法。</p>
<ul>
<li>random</li>
</ul>
<p>随机算法，是 Dubbo 默认的负载均衡算法。存在服务堆积问题。</p>
<ul>
<li><strong>roundrobin</strong></li>
</ul>
<p>轮询算法。按照设定好的权重依次进行调度。</p>
<ul>
<li><strong>leastactive</strong> </li>
</ul>
<p>最少活跃度调度算法。即被调度的次数越少，其优选级就越高，被调度到的机率就越高。</p>
<ul>
<li>consistent hash</li>
</ul>
<p>一致性 hash 算法。对于相同参数的请求，其会被路由到相同的提供者。</p>
<h3 id="消费者端指定"><a href="#消费者端指定" class="headerlink" title="消费者端指定"></a><strong>消费者端指定</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--暴露服务--&gt;</span><br><span class="line">&lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">               ref&#x3D;&quot;weixinService&quot; group&#x3D;&quot;pay.weixin&quot; protocal&#x3D;&quot;rmi&quot; loadBalance&#x3D;&quot;random&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="服务端指定"><a href="#服务端指定" class="headerlink" title="服务端指定"></a>服务端指定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--暴露服务--&gt;</span><br><span class="line">&lt;dubbo:service interface&#x3D;&quot;com.abc.service.SomeService&quot;</span><br><span class="line">               ref&#x3D;&quot;weixinService&quot; group&#x3D;&quot;pay.weixin&quot; protocal&#x3D;&quot;rmi&quot; loadBalance&#x3D;&quot;random&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="集群容错策略与重试次数"><a href="#集群容错策略与重试次数" class="headerlink" title="集群容错策略与重试次数"></a><strong>集群容错策略与重试次数</strong></h2><p>集群容错指的是，当消费者调用提供者集群时发生异常的处理方案。</p>
<p>Dubbo 内置了 6 种集群容错策略。</p>
<p> <strong>Failover</strong> </p>
<p>故障转移策略。当消费者调用提供者集群中的某个服务器失败时，其会自动尝试着调用</p>
<p>其它服务器。该策略通常用于读操作，例如，消费者要通过提供者从 DB 中读取某数据。但</p>
<p>重试会带来服务延迟。</p>
<p> <strong>Failfast</strong> </p>
<p>快速失败策略。消费者端只发起一次调用，若失败则立即报错。通常用于非幂等性的写</p>
<p>操作，比如新增记录。</p>
<p>幂等：在请求参数相同的前提下，请求一次与请求 n 次，对系统产生的影响是相同的。</p>
<p> GET：幂等</p>
<p> POST：非幂等</p>
<p> PUT：幂等</p>
<p> DELETE：幂等</p>
<p><strong>Failsafe</strong> </p>
<p>失败安全策略。当消费者调用提供者出现异常时，直接忽略本次消费操作。该策略通常用于执行相对不太重要的服务，例如，写入审计日志等操作。</p>
<p> <strong>Failback</strong> </p>
<p>失败自动恢复策略。消费者调用提供者失败后，Dubbo 会记录下该失败请求，然后定时</p>
<p>自动重新发送该请求。该策略通常用于实时性要求不太高的服务，例如消息通知操作。</p>
<p><strong>Forking</strong> </p>
<p>并行策略。消费者对于同一服务并行调用多个提供者服务器，只要一个成功即调用结束</p>
<p>并返回结果。通常用于实时性要求较高的读操作，但其会浪费较多服务器资源。</p>
<p><strong>Broadcast</strong> </p>
<p>广播策略。广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有</p>
<p>提供者更新缓存或日志等本地资源信息。</p>
<h3 id="消费者端指定-1"><a href="#消费者端指定-1" class="headerlink" title="消费者端指定"></a><strong>消费者端指定</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--暴露服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:ref</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">ref</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.weixin&quot;</span> <span class="attr">cluster</span>=<span class="string">&quot;failfast&quot;</span> <span class="attr">reties</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务端指定-1"><a href="#服务端指定-1" class="headerlink" title="服务端指定"></a>服务端指定</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--暴露服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.abc.service.SomeService&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">ref</span>=<span class="string">&quot;weixinService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;pay.weixin&quot;</span> <span class="attr">cluster</span>=<span class="string">&quot;failfast&quot;</span> <span class="attr">reties</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="服务降级基础（面试题）"><a href="#服务降级基础（面试题）" class="headerlink" title="服务降级基础（面试题）"></a><strong>服务降级基础（面试题）</strong></h2><p> <strong>什么是服务降级</strong></p>
<p>服务降级，当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务有策略的降低服务级别，以释放服务器资源，保证核心任务的正常运行。</p>
<p><strong>服务降级方式</strong></p>
<p>能够实现服务降级方式很多，常见的有如下几种情况：</p>
<p> 部分服务暂停    </p>
<p> 全部服务暂停</p>
<p> 随机拒绝服务</p>
<p> 部分服务延迟</p>
<p><strong>服务降级与</strong> <strong>Mock</strong> <strong>机制</strong></p>
<p>Dubbo的服务降级采用的是mock机制。其具有两种降级处理方式：Mock Null降级处理，与 Mock Class 降级处理。</p>
<h3 id="Mock-Null降级处理"><a href="#Mock-Null降级处理" class="headerlink" title="Mock Null降级处理"></a>Mock Null降级处理</h3><p>只需要修改服务端</p>
<ul>
<li><p><strong>修改</strong> <strong>pom</strong> <strong>文件</strong>：由于这里不再需要 00-api 工程了，所以在 pom 文件中将对 00-api 工程的依赖删除即可。改为消费者和提供者在自己的项目中保留一份相同的接口</p>
<ul>
<li><pre><code class="java">//consumer自己保留的接口，provider也是如此
package com.abc.service;

public interface UserService &#123;
    String getUsernameById(int id);
    void addUser(String username);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- **修改** **spring-consumer.xml**: mock&#x3D;&quot;return null&quot;</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;userService&quot; mock&#x3D;&quot;return null&quot; check&#x3D;&quot;false&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.UserService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>修改消费者启动类</strong></p>
<ul>
<li><pre><code class="java">public static void main(String[] args) &#123;
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
    UserService service = (UserService) ac.getBean(&quot;userService&quot;);

    // 对于有返回值的方法，其返回结果为null
    String username = service.getUsernameById(3);
    System.out.println(&quot;username = &quot; + username);
    // 对于没有返回值的方法，其没有任何结果
    service.addUser(&quot;China&quot;);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### Mock Class 降级处理</span><br><span class="line"></span><br><span class="line">降级都是指的调用端(consumer)，所以是consumer需要修改</span><br><span class="line"></span><br><span class="line">- **定义** **Mock Class**</span><br><span class="line"></span><br><span class="line">  - 在业务接口所在的包中，本例为 com.abc.service 包，定义一个类，该类的命名需要满足以下规则：业务接口简单类名 + Mock</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    package com.abc.service;</span><br><span class="line">    </span><br><span class="line">    public class UserServiceMock implements UserService &#123;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public String getUsernameById(int id) &#123;</span><br><span class="line">            return &quot;没有该用户：&quot; + id;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">        public void addUser(String username) &#123;</span><br><span class="line">            System.out.println(&quot;添加该用户失败：&quot; + username);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>修改</strong> <strong>spring-consumer.xml</strong>: mock=”true”</p>
<ul>
<li><pre><code class="xml">    &lt;dubbo:reference id=&quot;userService&quot; mock=&quot;true&quot; check=&quot;false&quot;
                     interface=&quot;com.abc.service.UserService&quot;/&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **服务调用超时**</span><br><span class="line"></span><br><span class="line">前面的服务降级的发生，其实是由于消费者调用服务超时引起的，即从发出调用请求到获取到提供者的响应结果这个时间超出了设定的时限。默认服务调用超时时限为 1 秒。可以在消费者端与提供者端设置超时时限。</span><br><span class="line"></span><br><span class="line">### 生产者</span><br><span class="line"></span><br><span class="line">- **修改依赖**：由于这里不再需要 00-api 工程了，所以在 pom 文件中将对 00-api 工程的依赖删除即可。因为provider and consumer share the same interface in their responding projecct.</span><br><span class="line">- **定义接口实现类**</span><br><span class="line">  - 在 com.abc.provider 包中定义接口的实现类。该实现类中的业务方法添加一个 2 秒的Sleep，以延长向消费者返回结果的时间。</span><br><span class="line"></span><br><span class="line">### 消费者</span><br><span class="line"></span><br><span class="line">- 配置类：timeout&#x3D;&quot;2000&quot;</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;userService&quot; mock&#x3D;&quot;true&quot; timeout&#x3D;&quot;2000&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.UserService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h2><blockquote>
<ul>
<li><p><strong>直接限流</strong></p>
<ul>
<li><p>*executes** <strong>限流</strong> <strong>–</strong> <strong>仅提供者端</strong></p>
<ul>
<li><p>该属性仅能设置在提供者端。可以设置为接口级别，也可以设置为方法级别。限制的是服务（方法）并发执行数量。execute=”10”</p>
</li>
<li><pre><code>    &lt;dubbo:reference ref=&quot;userService&quot;  execute=&quot;10&quot;
                     interface=&quot;com.abc.service.UserService&quot;/&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **accepts** **限流** **–** **仅提供者端**</span><br><span class="line"></span><br><span class="line">  - 该属性仅可设置在提供者端的&lt;dubbo:provider&#x2F;&gt;与&lt;dubbo:protocol&#x2F;&gt;。用于对指定协议的连接数量进行限制。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    限制当前提供者在使用dubbo协议时最多接受10个消费者链接</span><br><span class="line">    &lt;dubbo:provider protocal&#x3D;&quot;dubbo&quot; accepts&#x3D;10&gt;&lt;&#x2F;dubbo:provider&gt;</span><br><span class="line">    </span><br><span class="line">    限制当前提供者在使用dubbo协议时最多接受10个消费者链接</span><br><span class="line">    &lt;dubbo:protocal name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20880&quot; accepts&#x3D;10&gt;&lt;&#x2F;dubbo:protocal&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>actives</strong> <strong>限流</strong> <strong>–</strong> <strong>两端</strong></p>
<ul>
<li><p>该限流方式与前两种不同的是，其可以设置在提供者端，也可以设置在消费者端。可以设置为接口级别，也可以设置为方法级别。</p>
</li>
<li><p><strong>提供者端限流</strong></p>
<p>根据消费者与提供者间建立的连接类型的不同，其意义也不同：</p>
<p> 长连接：表示当前长连接最多可以处理的请求个数。与长连接的数量没有关系。</p>
<p> 短连接：表示当前服务可以同时处理的短连接数量。</p>
<ul>
<li><pre><code class="xml">&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot; actives=&quot;10&quot;/&gt;

&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot;&gt;
    &lt;dubbo:method name=&quot;hello&quot; actives=&quot;10&quot;&gt;&lt;/dubbo:method&gt;
&lt;/dubbo:service&gt;

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **消费者端限流**</span><br><span class="line"></span><br><span class="line">  根据消费者与提供者间建立的连接类型的不同，其意义也不同：</span><br><span class="line"></span><br><span class="line">   长连接：表示当前消费者所发出的长连接中最多可以提交的请求个数。与长连接的数量没有关系。</span><br><span class="line"></span><br><span class="line">   短连接：表示当前消费者可以提交的短连接数量。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot; actives&#x3D;&quot;10&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot;&gt;</span><br><span class="line">    	&lt;dubbo:method name&#x3D;&quot;hello&quot; actives&#x3D;&quot;10&quot;&gt;&lt;&#x2F;dubbo:method&gt;</span><br><span class="line">    &lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>connections</strong> <strong>限流 - 两端</strong> </p>
<ul>
<li><p>可以设置在提供者端，也可以设置在消费者端。限定连接的个数。对于短连接，该属性效果与 actives 相同。但对于长连接，其限制的是长连接的个数。一般情况下，我们会使 connectons 与 actives 联用，让 connections 限制长连接个数，让actives 限制一个长连接中可以处理的请求个数。联用前提：使用默认的 Dubbo 服务暴露协议。</p>
</li>
<li><p><strong>提供者端限流</strong></p>
<ul>
<li><pre><code class="xml">&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot; connections=&quot;10&quot;/&gt;

&lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot; ref=&quot;someService&quot;&gt;
    &lt;dubbo:method name=&quot;hello&quot; connections=&quot;10&quot;&gt;&lt;/dubbo:method&gt;
&lt;/dubbo:service&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **消费者端限流**</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot; connections&#x3D;&quot;10&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot;&gt;</span><br><span class="line">    	&lt;dubbo:method name&#x3D;&quot;hello&quot; connections&#x3D;&quot;10&quot;&gt;&lt;&#x2F;dubbo:method&gt;</span><br><span class="line">    &lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>间接限流</strong></p>
<ul>
<li><p><strong>延迟连接 **– **仅消费者端</strong></p>
<ul>
<li><p>仅可设置在消费者端，且不能设置为方法级别。仅作用于 Dubbo 服务暴露协议。将长连接的建立推迟到消费者真正调用提供者时。可以减少长连接的数量。</p>
</li>
<li><pre><code class="xml">//消费者端该接口的所有方法都是延迟建立连接
&lt;dubbo:ref interface=&quot;com.abc.service.SomeService&quot; id=&quot;someService&quot; lazy=&quot;true&quot;/&gt;

//消费者端所有接口的所有方法都是延迟建立连接
&lt;dubbo:consumer lazy=&quot;true&quot;&gt;&lt;/dubbo:consumer&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **粘连连接** **–** **仅消费者**</span><br><span class="line"></span><br><span class="line">  - 仅能设置在消费者端，其可以设置为接口级别，也可以设置为方法级别。仅作用于Dubbo 服务暴露协议。其会使客户端尽量向同一个提供者发起调用，除非该提供者挂了，其会连接另一台。只要启用了粘连连接，其就会自动启用延迟连接。其限制的是流向，而非流量。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;xml</span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot; sticky&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dubbo:ref interface&#x3D;&quot;com.abc.service.SomeService&quot; id&#x3D;&quot;someService&quot;&gt;</span><br><span class="line">    	&lt;dubbo:method name&#x3D;&quot;hello&quot; connections&#x3D;&quot;10&quot; sticky&#x3D;&quot;true&quot;&gt;&lt;&#x2F;dubbo:method&gt;</span><br><span class="line">    &lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p><strong>负载均衡 - 双端</strong></p>
<ul>
<li><p>可以设置在消费者端，亦可设置在提供者端；可以设置在接口级别，亦可设置在方法级别。其限制的是流向，而非流量。</p>
</li>
<li><pre><code>loadBalance=&quot;leastactive&quot;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">## **声明式缓存** - 仅消费者</span><br><span class="line"></span><br><span class="line">为了进一步提高消费者对用户的响应速度，减轻提供者的压力，Dubbo 提供了基于结果的声明式缓存。该缓存是基于消费者端的，所以使用很简单，只需修改消费者配置文件，与提供者无关。</span><br><span class="line"></span><br><span class="line">- **修改消费者配置文件**：仅需在&lt;dubbo:reference&#x2F;&gt;中添加 cache&#x3D;”true”属性即可。</span><br><span class="line">- **默认缓存** **1000** **个结果**: 声明式缓存中可以缓存多少个结果呢？默认可以缓存 1000 个结果。若超出 1000，将采用 LRU 策略来删除缓存，以保证最热的数据被缓存。注意，该删除缓存的策略不能修改。</span><br><span class="line">- **应用场景**: 应用于查询结果不会发生改变的情况，例如，查询某产品的序列号、订单、身份证号等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 多注册中心</span><br><span class="line"></span><br><span class="line">- 消费者</span><br><span class="line"></span><br><span class="line"> - 配置文件</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;xml</span><br><span class="line">         &lt;!--声明注册中心--&gt;</span><br><span class="line">         &lt;dubbo:registry id&#x3D;&quot;bjCenter&quot; address&#x3D;&quot;zookeeper:&#x2F;&#x2F;bjZK:2181&quot;&#x2F;&gt;</span><br><span class="line">         &lt;dubbo:registry id&#x3D;&quot;gzCenter&quot; address&#x3D;&quot;zookeeper:&#x2F;&#x2F;gzZK:2181&quot;&#x2F;&gt;</span><br><span class="line">         &lt;dubbo:registry id&#x3D;&quot;cqCenter&quot; address&#x3D;&quot;zookeeper:&#x2F;&#x2F;cqZK:2181&quot;&#x2F;&gt;</span><br><span class="line">     </span><br><span class="line">         &lt;!--指定调用bjCenter注册中心微信服务--&gt;</span><br><span class="line">         &lt;dubbo:reference id&#x3D;&quot;weixin&quot;  group&#x3D;&quot;pay.weixin&quot; registry&#x3D;&quot;bjCenter&quot;</span><br><span class="line">                          interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br><span class="line">     </span><br><span class="line">         &lt;!--指定调用gzCenter与cqCenter注册中心支付宝服务--&gt;</span><br><span class="line">         &lt;dubbo:reference id&#x3D;&quot;gzZhifubao&quot;  group&#x3D;&quot;pay.zhifubao&quot; registry&#x3D;&quot;gzCenter&quot;</span><br><span class="line">                          interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br><span class="line">         &lt;dubbo:reference id&#x3D;&quot;cqZhifubao&quot;  group&#x3D;&quot;pay.zhifubao&quot; registry&#x3D;&quot;cqCenter&quot;</span><br><span class="line">                          interface&#x3D;&quot;com.abc.service.SomeService&quot;&#x2F;&gt;</span><br><span class="line">     </span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>生产者</p>
<ul>
<li><p>配置文件</p>
<ul>
<li><pre><code class="xml">    &lt;!--声明注册中心--&gt;
    &lt;dubbo:registry id=&quot;bjCenter&quot; address=&quot;zookeeper://bjZK:2181&quot;/&gt;  &lt;!--北京中心--&gt;
    &lt;dubbo:registry id=&quot;shCenter&quot; address=&quot;zookeeper://shZK:2181&quot;/&gt;  &lt;!--上海中心--&gt;
    &lt;dubbo:registry id=&quot;gzCenter&quot; address=&quot;zookeeper://gzZK:2181&quot;/&gt;  &lt;!--广州中心--&gt;
    &lt;dubbo:registry id=&quot;cqCenter&quot; address=&quot;zookeeper://cqZK:2181&quot;/&gt;  &lt;!--重庆中心--&gt;

    &lt;!--注册Service实现类--&gt;
    &lt;bean id=&quot;weixinService&quot; class=&quot;com.abc.provider.WeixinServiceImpl&quot;/&gt;
    &lt;bean id=&quot;zhifubaoService&quot; class=&quot;com.abc.provider.ZhifubaoServiceImpl&quot;/&gt;

    &lt;!--暴露服务：同一个服务注册到不同的中心；不同的服务注册到不同的中心--&gt;
    &lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot;
                   ref=&quot;weixinService&quot; group=&quot;pay.weixin&quot; register=&quot;bjCenter, shCenter&quot;/&gt;
    &lt;dubbo:service interface=&quot;com.abc.service.SomeService&quot;
                   ref=&quot;zhifubaoService&quot; group=&quot;pay.zhifubao&quot; register=&quot;gzCenter, cqCenter&quot;/&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">## **单功能注册中心** -- 仅提供者，但是提供者和消费者是相对概念</span><br><span class="line"></span><br><span class="line">注册中心提供服务发现、服务注册两种功能，但是某些场景下，我们只想用其中一个功能。</span><br><span class="line"></span><br><span class="line">这些仅订阅或仅注册，只对当前配置文件中的服务起作用，不会影响注册中心本身的功能。</span><br><span class="line"></span><br><span class="line">- **仅订阅**</span><br><span class="line"></span><br><span class="line">  - 概念: 对于某服务来说，其可以发现和调用注册中心中的其它服务，但不能被其它服务发现和调用，这种情形称为仅订阅。简单说就是，仅可去发现，但不能被发现。其底层的实现是，当前服务可以从注册中心下载注册列表，但其不会将自己的信息写入到注册列表。</span><br><span class="line"></span><br><span class="line">  - **设置方式**：对于“仅订阅”注册中心的实现，只需修改提供者配置文件，在&lt;dubbo:registry&#x2F;&gt;标签中添加 register&#x3D;”false”属性。即对于当前服务来说，注册中心不再接受其注册，但该服务可以通过注册中心去发现和调用其它服务。</span><br><span class="line"></span><br><span class="line">- **仅注册**</span><br><span class="line"></span><br><span class="line">  - 概念：对于某服务来说，其可以被注册中心的其它服务发现和调用，但不能发现和调用注册中心中的其它服务，这种情形称为仅注册。简单来说就是，仅可被发现，但不能去发现。[从底层实现来说就是，当前服务可以写入到注册列表，但其不能下载注册列表。]()</span><br><span class="line">  - 设置方式：对于“仅注册”注册中心的实现，[只需修改提供者配置文件]()，在&lt;dubbo:registry&#x2F;&gt;标签中添加 subscribe&#x3D;”false”的属性。即对于当前服务来说，注册中心中的其它服务可以发现和调用当前服务，但其不能发现和调用其它服务。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **服务暴露延迟 -- 仅提供者**</span><br><span class="line"></span><br><span class="line">如果我们的服务启动过程需要 warmup 事件，就可以使用 delay 进行服务延迟暴露。只需在服务提供者的&lt;dubbo:service&#x2F;&gt;标签中添加 delay 属性。其值可以有三类：</span><br><span class="line"></span><br><span class="line"> 正数：单位为毫秒，表示在提供者对象创建完毕后的指定时间后再发布服务。</span><br><span class="line"></span><br><span class="line"> 0：默认值，表示当前提供者创建完毕后马上向注册中心暴露服务。</span><br><span class="line"></span><br><span class="line"> -1：表示在 Spring 容器初始化完毕后再向注册中心暴露服务。</span><br><span class="line"></span><br><span class="line">&gt; [先提供者创建完成，然后Spring容器初始化完成]()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 消费者的异步调用</span><br><span class="line"></span><br><span class="line">在 Dubbo 简介时，我们分析了 Dubbo 的四大组件工作原理图，其中消费者调用提供者采用的是同步调用方式。其实，消费者对于提供者的调用，也可以采用异步方式进行调用。异步调用一般应用于提供者提供的是耗时性 IO 服务。</span><br><span class="line"></span><br><span class="line">比如consumer 需要同时调用 provider 的a服务消耗3ms，b服务5ms</span><br><span class="line"></span><br><span class="line">- 同步的话：消耗&#x3D;3+5</span><br><span class="line">- 异步的话：消耗&#x3D;min（3，5）</span><br><span class="line"></span><br><span class="line">### Future异步执行原理  -- 仅消费者</span><br><span class="line"></span><br><span class="line">异步方法调用执行原理如下图所示，其中实线为同步调用，而虚线为异步调用。</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190803211841665.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5NjUyMDM&#x3D;,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line"> UserThread：消费者线程</span><br><span class="line"></span><br><span class="line"> IOThrea：提供者线程</span><br><span class="line"></span><br><span class="line"> Server：对 IO 型操作的真正执行者</span><br><span class="line"></span><br><span class="line">&gt; get&#x2F;wait方法时阻塞的</span><br><span class="line"></span><br><span class="line">#### 提供者 -- 不需要做任何修改</span><br><span class="line"></span><br><span class="line">#### 消费者</span><br><span class="line"></span><br><span class="line">- 配置文件</span><br><span class="line"></span><br><span class="line">  - Third, Fourth异步方式</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;</span><br><span class="line">        &lt;dubbo:application name&#x3D;&quot;10-consumer-async&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;zkOS:2181&quot; &#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;dubbo:reference id&#x3D;&quot;otherService&quot;  timeout&#x3D;&quot;20000&quot;</span><br><span class="line">                         interface&#x3D;&quot;com.abc.service.OtherService&quot; &gt;</span><br><span class="line">            &lt;dubbo:method name&#x3D;&quot;doThird&quot; async&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;dubbo:method name&#x3D;&quot;doFourth&quot; async&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;dubbo:reference&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>测试类</p>
<ul>
<li><p>测试异步调用的请求时间</p>
<ul>
<li><p>请求非常快，但是没数据</p>
</li>
<li><pre><code>  public static void main(String[] args)
            throws ExecutionException, InterruptedException &#123;
        ApplicationContext ac =
                new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
        OtherService service = (OtherService) ac.getBean(&quot;otherService&quot;);

        // 记录异步调用开始时间
        long asyncStart = System.currentTimeMillis();

        // 异步调用
        service.doThird();
        service.doFourth();

        long syncInvokeTime = System.currentTimeMillis() - asyncStart;
        System.out.println(&quot;两个异步调用共计用时（毫秒）：&quot; + syncInvokeTime);
    &#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 测试异步调用，获取结果的时间</span><br><span class="line"></span><br><span class="line">  - 就比较慢，等待结果返回</span><br><span class="line"></span><br><span class="line">  - 注意：RpcContext.getContext().getFuture()是和异步调用成对出现的</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;java</span><br><span class="line">      String result1 &#x3D; service.doThird();</span><br><span class="line">      System.out.println(&quot;调用结果1 &#x3D; &quot; + result1);</span><br><span class="line">      Future&lt;String&gt; thirdFuture &#x3D; RpcContext.getContext().getFuture();</span><br><span class="line">      </span><br><span class="line">      String result3 &#x3D; service.doFourth();</span><br><span class="line">      System.out.println(&quot;调用结果3 &#x3D; &quot; + result3);</span><br><span class="line">      Future&lt;String&gt; fourFuture &#x3D; RpcContext.getContext().getFuture();</span><br></pre></td></tr></table></figure>

- 错误写法是: 导致thirdFuture和fourFuture都是最近的调用service.doFourth()的结果

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String result1 = service.doThird();</span><br><span class="line">String result3 = service.doFourth();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;调用结果1 = &quot;</span> + result1);</span><br><span class="line">Future&lt;String&gt; thirdFuture = RpcContext.getContext().getFuture();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;调用结果3 = &quot;</span> + result3);</span><br><span class="line">Future&lt;String&gt; fourFuture = RpcContext.getContext().getFuture();</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- ```java
  public static void main(String[] args)
              throws ExecutionException, InterruptedException &#123;
          ApplicationContext ac =
                  new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);
          OtherService service = (OtherService) ac.getBean(&quot;otherService&quot;);

          // 记录异步调用开始时间
          long asyncStart = System.currentTimeMillis();

          // 异步调用
          String result1 = service.doThird();
          System.out.println(&quot;调用结果1 = &quot; + result1);
          Future&lt;String&gt; thirdFuture = RpcContext.getContext().getFuture();

          String result3 = service.doFourth();
          System.out.println(&quot;调用结果3 = &quot; + result3);
          Future&lt;String&gt; fourFuture = RpcContext.getContext().getFuture();

          // 阻塞
          String result2 = thirdFuture.get();
          System.out.println(&quot;调用结果2 = &quot; + result2);
          String result4 = fourFuture.get();
          System.out.println(&quot;调用结果4 = &quot; + result4);

          long useTime = System.currentTimeMillis() - asyncStart;
          System.out.println(&quot;获取到异步调用结果共计用时：&quot; + useTime);
      &#125;
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">### **CompletableFuture** **异步调用**  -- 消费者和生产者</span><br><span class="line"></span><br><span class="line">使用 Future 实现异步调用，对于无需获取返回值的操作来说不存在问题，但消费者若需要获取到最终的异步执行结果，则会出现问题：消费者在使用 Future 的 get()方法获取返回值时被阻塞, CPU被无意义的轮休消耗。</span><br><span class="line"></span><br><span class="line">为了解决这个问题，Dubbo 又引入了 CompletableFuture 来实现对提供者的异步调用。</span><br><span class="line"></span><br><span class="line">#### 消费者</span><br><span class="line"></span><br><span class="line">- 配置文件去除asyn属性</span><br><span class="line"></span><br><span class="line">- 公共接口类</span><br><span class="line"></span><br><span class="line">  - 以前是</span><br><span class="line"></span><br></pre></td></tr></table></figure>
public interface OtherService &#123;
    String doFirst();
    String doSecond();
    String doThird();
    String doFourth();
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 现在是</span><br><span class="line"></span><br></pre></td></tr></table></figure>
public interface OtherService &#123;
    String doFirst();
    String doSecond();

    CompletableFuture&lt;String&gt; doThird();
    CompletableFuture&lt;String&gt; doFourth();
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 主函数使用CompletableFuture</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">     public static void main(String[] args)</span><br><span class="line">                throws ExecutionException, InterruptedException &#123;</span><br><span class="line">            ApplicationContext ac &#x3D;</span><br><span class="line">                    new ClassPathXmlApplicationContext(&quot;spring-consumer.xml&quot;);</span><br><span class="line">            OtherService service &#x3D; (OtherService) ac.getBean(&quot;otherService&quot;);</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; 记录异步调用开始时间</span><br><span class="line">            long asyncStart &#x3D; System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; 异步调用</span><br><span class="line">            CompletableFuture&lt;String&gt; doThirdFuture &#x3D; service.doThird();</span><br><span class="line">            CompletableFuture&lt;String&gt; doFourthFuture &#x3D; service.doFourth();</span><br><span class="line">    </span><br><span class="line">            long syncInvokeTime &#x3D; System.currentTimeMillis() - asyncStart;</span><br><span class="line">            System.out.println(&quot;两个异步调用共计用时（毫秒）：&quot; + syncInvokeTime);</span><br><span class="line">    </span><br><span class="line">            &#x2F;&#x2F; 回调方法</span><br><span class="line">            doThirdFuture.whenComplete((result, throwable) -&gt; &#123;</span><br><span class="line">                if(throwable !&#x3D; null) &#123;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;异步调用提供者的doThird()返回值：&quot; + result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">            doFourthFuture.whenComplete((result, throwable) -&gt; &#123;</span><br><span class="line">                if(throwable !&#x3D; null) &#123;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;异步调用提供者的doFourth()返回值：&quot; + result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">            long getResultTime &#x3D; System.currentTimeMillis() - asyncStart;</span><br><span class="line">            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;（毫秒）：&quot; + getResultTime);</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><ul>
<li><p>和consumer一样，把公共接口类改了</p>
<ul>
<li><p>以前具体的接口实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String doThird() &#123;</span><br><span class="line">	sleep();</span><br><span class="line">	return &quot;doThird()&quot;;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>现在具体的接口实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="comment">// 耗时操作仍由业务线程调用</span></span><br><span class="line">       sleep();</span><br><span class="line">       CompletableFuture&lt;String&gt; future =</span><br><span class="line">               CompletableFuture.completedFuture(<span class="string">&quot;doThird()-----&quot;</span>);</span><br><span class="line">       <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">long</span> useTime = endTime - startTime;</span><br><span class="line">       System.out.println(<span class="string">&quot;doThird()方法执行用时：&quot;</span> + useTime);</span><br><span class="line">       <span class="keyword">return</span> future;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>Future 与 CompletableFuture 的对比：</p>
<ul>
<li><p>Future：Dubbo2.7.0 版本之前消费者异步调用提供者的实现方式。源自于 JDK5，对异步结果的获取采用了阻塞与轮询方式。</p>
</li>
<li><p>CompletableFuture：Dubbo2.7.0 版本之后消费者异步调用提供者的实现方式。源自于JDK8，对异步结果的获取采用了回调的方式。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://deepakvadgama.com/blog/completable-future-internals/">介绍Future与CompletableFuture的文章</a></p>
<h2 id="提供者的异步执行"><a href="#提供者的异步执行" class="headerlink" title="提供者的异步执行"></a><strong>提供者的异步执行</strong></h2><p>从前面“对提供者的异步调用”例子可以看出，消费者对提供者实现了异步调用，消费者线程的执行过程不再发生阻塞，但提供者对 IO 耗时操作仍采用的是同步调用，即 IO 操作仍会阻塞 Dubbo 的提供者线程。</p>
<blockquote>
<p>但需要注意，提供者对 IO 操作的异步调用，并不会提升 RPC 响应速度，因为耗时操作终归是需要消耗那么多时间后才能给出结果的。</p>
<p>对用户体验没什么提升，就是接口延迟；但是极大的提升了吞吐量，不再阻塞业务线程。</p>
</blockquote>
<ul>
<li><p>以前接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 耗时操作仍由业务线程调用, 所以阻塞了业务线程</span></span><br><span class="line">    sleep();</span><br><span class="line">    CompletableFuture&lt;String&gt; future =</span><br><span class="line">        CompletableFuture.completedFuture(<span class="string">&quot;doThird()-----&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> useTime = endTime - startTime;</span><br><span class="line">    System.out.println(<span class="string">&quot;doThird()方法执行用时：&quot;</span> + useTime);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在具体的接口实现:<font color="red"> 耗时操作不再由业务线程直接调用</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="comment">// 异步调用耗时操作</span></span><br><span class="line">       CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           <span class="comment">// 耗时操作是由CompletableFuture调用的，而不是由业务线程直接调用，所以不再阻塞业务线程</span></span><br><span class="line">           sleep();</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;doThird()&quot;</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;doThird()方法执行用时：&quot;</span> + (endTime - startTime));</span><br><span class="line">       <span class="keyword">return</span> future;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="属性配置优先级"><a href="#属性配置优先级" class="headerlink" title="属性配置优先级"></a><strong>属性配置优先级</strong></h2><p>Dubbo 配置文件中各个标签属性配置的优先级总原则是：</p>
<ul>
<li><p>方法级优先，接口级(服务级)次之，全局配置再次之。</p>
</li>
<li><p>如果级别一样，则消费方优先，提供方次之。</p>
</li>
</ul>
<p>另外，还有两个标签需要说明一下：</p>
<ul>
<li><p><a href="dubbo:consumer/">dubbo:consumer/</a>设置在消费者端，用于设置消费者端的默认配置，即消费者端的全局设置。当然也可以设置在提供者端。但是以消费者优先级高</p>
</li>
<li><p><a href="dubbo:provider/">dubbo:provider/</a>设置在提供者端，用于设置提供者端的默认配置，即提供者端的默认配置。当然也可以设置在消费者端。但是以消费者优先级高</p>
</li>
</ul>
<p><strong>配置建议</strong></p>
<p><strong>provider</strong> <strong>上配置合理的</strong> <strong>provider</strong> <strong>端属性</strong></p>
<p><strong>在</strong> <strong>provider</strong> <strong>上尽量多配置</strong> <strong>consumer</strong> <strong>端属性</strong></p>
<ul>
<li>因为provider更清楚自己的性能和服务</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ-01-%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ-01-%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">RocketMQ-01-入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-01 17:33:31" itemprop="dateCreated datePublished" datetime="2021-03-01T17:33:31+08:00">2021-03-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/20/database/redis/redis-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/20/database/redis/redis-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">redis-面试问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-20 10:22:35" itemprop="dateCreated datePublished" datetime="2021-02-20T10:22:35+08:00">2021-02-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-21 14:14:32" itemprop="dateModified" datetime="2023-03-21T14:14:32+08:00">2023-03-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p>【问题】</p>
<ul>
<li>Redis 有哪些数据类型？</li>
<li>Redis 的数据类型分别适用于什么样的场景？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 数据类型和应用\</em></strong></p>
<p>数据类型的特性和应用细节点较多，详情可以参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial/blob/master/docs/nosql/redis/redis-datatype.md">Redis 数据类型(opens new window)</a></p>
</blockquote>
<p>（1）Redis 支持五种基本数据类型：</p>
<ul>
<li>String：常用于 KV 缓存</li>
<li>Hash：存储结构化数据，如：产品信息、用户信息等。</li>
<li>List：存储列表，如：粉丝列表、文章评论列表等。可以通过 lrange 命令进行分页查询。</li>
<li>Set：存储去重列表，如：粉丝列表等。可以基于 set 玩儿交集、并集、差集的操作。例如：求两个人的共同好友列表。</li>
<li>Sorted Set：存储含评分的去重列表，如：各种排行榜。</li>
</ul>
<p>（2）除此以外，还有 Bitmaps、HyperLogLogs、GEO、Streams 等高级数据类型。</p>
<h2 id="Redis-zset跳表和压缩表"><a href="#Redis-zset跳表和压缩表" class="headerlink" title="Redis zset跳表和压缩表"></a>Redis zset跳表和压缩表</h2><p>ZSet 有两种不同的实现，分别是 ziplist 和 skiplist。具体使用哪种结构进行存储，规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ziplist：满足以下两个条件</span><br><span class="line"></span><br><span class="line">- [value,score] 键值对数量少于 128 个</span><br><span class="line"></span><br><span class="line">- 每个元素的长度小于 64 字节</span><br><span class="line"></span><br><span class="line">skiplist：不满足以上两个条件时使用跳表、组合了 hash 和 skiplist</span><br><span class="line"></span><br><span class="line">- hash 用来存储 value 到 score 的映射，这样就可以在 O(1) 时间内找到 value 对应的分数</span><br><span class="line"></span><br><span class="line">- skiplist 按照从小到大的顺序存储分数</span><br></pre></td></tr></table></figure>

<p>skiplist 每个元素的值都是 [value,score] 对使用 ziplist 的示意图如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210516211822874.png" alt="在这里插入图片描述"><br>使用跳表时的示意图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210516211842414.png" alt="在这里插入图片描述"><br>ziplist 压缩列表本文不是重点讨论范围，我们着重来看下跳跃表 skiplist。</p>
<h2 id="Redis-内存淘汰"><a href="#Redis-内存淘汰" class="headerlink" title="Redis 内存淘汰"></a>Redis 内存淘汰</h2><p>【问题】</p>
<ul>
<li>Redis 有哪些内存淘汰策略？</li>
<li>这些淘汰策略分别适用于什么场景？</li>
<li>Redis 有哪些删除失效 key 的方法？</li>
<li>如何设置 Redis 中键的过期时间？</li>
<li>如果让你实现一个 LRU 算法，怎么做？</li>
</ul>
<hr>
<p>【解答】</p>
<p>（1）Redis 过期策略是：<strong>定期删除+惰性删除</strong>。</p>
<ul>
<li>消极方法（passive way），在主键被访问时如果发现它已经失效，那么就删除它。</li>
<li>主动方法（active way），定期从设置了失效时间的主键中选择一部分失效的主键删除。</li>
</ul>
<p>（2）Redis 内存淘汰策略：</p>
<ul>
<li><strong><code>noeviction</code></strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。</li>
<li><strong><code>allkeys-lru</code></strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>allkeys-random</code></strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-lru</code></strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>volatile-random</code></strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-ttl</code></strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li>
</ul>
<p>（3）如何选择内存淘汰策略：</p>
<ul>
<li>如果数据呈现幂等分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 <code>allkeys-lru</code>。</li>
<li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 <code>allkeys-random</code>。</li>
<li><code>volatile-lru</code> 策略和 <code>volatile-random</code> 策略适合我们将一个 Redis 实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果。</li>
<li>将 key 设置过期时间实际上会消耗更多的内存，因此我们建议使用 <code>allkeys-lru</code> 策略从而更有效率的使用内存。</li>
</ul>
<p>（4）LRU 算法实现思路：可以继承 LinkedHashMap，并覆写 removeEldestEntry 方法来实现一个最简单的 LRUCache</p>
<h2 id="Redis大Key删除"><a href="#Redis大Key删除" class="headerlink" title="Redis大Key删除"></a>Redis大Key删除</h2><h3 id="1-异步删除"><a href="#1-异步删除" class="headerlink" title="(1) 异步删除"></a>(1) 异步删除</h3><ul>
<li>开启lazy free功能，如果触发自动过期删除，则会异步执行</li>
<li>使用unlink命令手动触发，会异步执行删除操作</li>
</ul>
<h3 id="2-使用分批删除"><a href="#2-使用分批删除" class="headerlink" title="(2) 使用分批删除"></a>(2) 使用分批删除</h3><p>对于集合类型的数据，可以通过客户端手动scan轮询的方式，每次只删除一部分的数据</p>
<h2 id="Redis实现限流"><a href="#Redis实现限流" class="headerlink" title="Redis实现限流"></a>Redis实现限流</h2><h3 id="第一种：基于Redis的setnx的操作"><a href="#第一种：基于Redis的setnx的操作" class="headerlink" title="第一种：基于Redis的setnx的操作"></a>第一种：基于Redis的setnx的操作</h3><p>我们在使用Redis的分布式锁的时候，大家都知道是依靠了setnx的指令，在CAS（Compare and swap）的操作的时候，同时给指定的key设置了过期实践（expire），我们在限流的主要目的就是为了在单位时间内，有且仅有N数量的请求能够访问我的代码程序。所以依靠setnx可以很轻松的做到这方面的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setNx(key, 20, 10,TimeUnit.Seconds)</span><br></pre></td></tr></table></figure>

<p>比如我们需要在10秒内限定20个请求，那么我们在setnx的时候可以设置过期时间10，当请求的setnx数量达到20时候即达到了限流效果。代码比较简单就不做展示了。当然这种做法的弊端是很多的，比如当统计1-10秒的时候，无法统计2-11秒之内，如果需要统计N秒内的M个请求，那么我们的Redis中需要保持N个key等等问题</p>
<h3 id="第二种：基于Redis的数据结构zset"><a href="#第二种：基于Redis的数据结构zset" class="headerlink" title="第二种：基于Redis的数据结构zset"></a>第二种：基于Redis的数据结构zset</h3><p>其实限流涉及的最主要的就是滑动窗口，上面也提到1-10怎么变成2-11。其实也就是起始值和末端值都各+1即可。</p>
<p>而我们如果用Redis的list数据结构可以轻而易举的实现该功能</p>
<p>我们可以将请求打造成一个zset数组，当每一次请求进来的时候，value保持唯一，可以用UUID生成，而score可以用当前时间戳表示，因为score我们可以用来计算当前时间戳之内有多少的请求数量。而zset数据结构也提供了range方法让我们可以很轻易的获取到2个时间戳内有多少请求</p>
<img src="https://img-blog.csdnimg.cn/img_convert/e15884cf9931cea8d8c2e88b94c7858c.webp?x-oss-process=image/format,png" alt="image.png" style="zoom:50%;" />





<img src="https://img-blog.csdnimg.cn/img_convert/cca8d7792e4958d52a43ff661ef7de74.webp?x-oss-process=image/format,png" alt="image.png" style="zoom:67%;" />

<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>【问题】</p>
<ul>
<li>Redis 有几种持久化方式？</li>
<li>Redis 的不同持久化方式的特性和原理是什么？</li>
<li>RDB 和 AOF 各有什么优缺点？分别适用于什么样的场景？</li>
<li>Redis 执行持久化时，可以处理请求吗？</li>
<li>AOF 有几种同步频率？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 持久化\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-persistence.html">Redis 持久化</a></p>
</blockquote>
<p>（1）Redis 支持两种持久化方式：RDB 和 AOF。</p>
<p>（2）RDB 即某一时刻的二进制数据快照。</p>
<p>Redis 会周期性生成 RDB 文件。</p>
<p>生成 RDB 流程：Redis fork 一个子进程，负责生成 RDB；生成 RDB 采用 Copy On Write 模式，此时，如果收到写请求，会在原副本上操作，不影响工作。</p>
<p>RDB 只能恢复生成快照时刻的数据，之后的数据无法恢复。生成 RDB 的资源开销高昂。RDB 适合做冷备。</p>
<p>（3）AOF 会将写命令不断追加到 AOF 文本日志末尾。</p>
<p>AOF 丢数据比 RDB 少，但文件会比 RDB 文件大很多。</p>
<p>一般，AOF 设置 <code>appendfsync</code> 同步频率为 <strong><code>everysec</code></strong> 即可。</p>
<p>（4）RDB or AOF</p>
<p>建议同时使用 RDB 和 AOF。用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>【问题】</p>
<ul>
<li>Redis 的并发竞争问题是什么？如何解决这个问题？</li>
<li>Redis 支持事务吗？</li>
<li>Redis 事务是严格意义的事务吗？Redis 为什么不支持回滚。</li>
<li>Redis 事务如何工作？</li>
<li>了解 Redis 事务中的 CAS 行为吗？</li>
</ul>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 的事务特性、原理\</em></strong></p>
<p>详情参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-quickstart.html#%E5%85%ADredis-%E4%BA%8B%E5%8A%A1">Redis 应用指南之 事务</a></p>
</blockquote>
<p><strong>Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去</strong>。</p>
<p>Redis 不支持回滚的理由：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p><code>MULTI</code> 、 <code>EXEC</code> 、 <code>DISCARD</code> 和 <code>WATCH</code> 是 Redis 事务相关的命令。</p>
<p>Redis 有天然解决这个并发竞争问题的类 CAS 乐观锁方案：每次要<strong>写之前，先判断</strong>一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>
<h2 id="Redis-管道"><a href="#Redis-管道" class="headerlink" title="#Redis 管道"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E7%AE%A1%E9%81%93">#</a>Redis 管道</h2><p>【问题】</p>
<ul>
<li>除了事务，还有其他批量执行 Redis 命令的方式吗？</li>
</ul>
<p>【解答】</p>
<p>Redis 是一种基于 C/S 模型以及请求/响应协议的 TCP 服务。Redis 支持管道技术。管道技术允许请求以异步方式发送，即旧请求的应答还未返回的情况下，允许发送新请求。这种方式可以大大提高传输效率。使用管道发送命令时，Redis Server 会将部分请求放到缓存队列中（占用内存），执行完毕后一次性发送结果。如果需要发送大量的命令，会占用大量的内存，因此应该按照合理数量分批次的处理。</p>
<h2 id="Redis-高并发"><a href="#Redis-高并发" class="headerlink" title="#Redis 高并发"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E9%AB%98%E5%B9%B6%E5%8F%91">#</a>Redis 高并发</h2><p>【问题】</p>
<ul>
<li>Redis 是单线程模型，为何吞吐量还很高？</li>
<li>Redis 的 IO 多路复用原理是什么？</li>
<li>Redis 集群如何分片和寻址？</li>
<li>Redis 集群如何扩展？</li>
<li>Redis 集群如何保证数据一致？</li>
<li>Redis 集群如何规划？你们公司的生产环境上如何部署 Redis 集群？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 集群\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-cluster.html">Redis 集群</a></p>
</blockquote>
<p>（1）单线程</p>
<p>Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 单机吞吐量也很高，能达到几万 QPS。</p>
<p>Redis 单线程模型，依然有很高的并发吞吐，原因在于：</p>
<ul>
<li>Redis 读写都是内存操作。</li>
<li>Redis 基于<strong>非阻塞的 IO 多路复用机制</strong>，同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</li>
<li>单线程，避免了线程创建、销毁、上下文切换的开销，并且避免了资源竞争。</li>
</ul>
<p>（2）扩展并发吞吐量、存储容量</p>
<p>Redis 的高性能（扩展并发吞吐量、存储容量）通过主从架构来实现。</p>
<p>Redis 集群采用主从模型，提供复制和故障转移功能，来保证 Redis 集群的高可用。通常情况，一主多从模式已经可以满足大部分项目的需要。根据实际的并发量，可以通过增加节点来扩展并发吞吐。</p>
<p>一主多从模式下，主节点负责写操作（单机几万 QPS），从节点负责查询操作（单机十万 QPS）。</p>
<p>进一步，如果需要缓存大量数据，就需要分区（sharding）。Redis 集群通过划分虚拟 hash 槽来分片，每个主节点负责一定范围的 hash 槽。当需要扩展集群节点时，重新分配 hash 槽即可，redis-trib 会自动迁移变更 hash 槽中所属的 key。</p>
<p>（3）Redis 集群数据一致性</p>
<p>Redis 集群基于复制特性实现节点间的数据一致性。</p>
<h2 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="#Redis 复制"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E5%A4%8D%E5%88%B6">#</a>Redis 复制</h2><p>【问题】</p>
<ul>
<li>Redis 复制的工作原理？Redis 旧版复制和新版复制有何不同？</li>
<li>Redis 主从节点间如何复制数据？</li>
<li>Redis 的数据一致性是强一致性吗？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 复制\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-replication.html">Redis 复制</a></p>
</blockquote>
<p>（1）旧版复制基于 <code>SYNC</code> 命令实现。分为同步（sync）和命令传播（command propagate）两个操作。这种方式存在缺陷：不能高效处理断线重连后的复制情况。</p>
<p>（2）新版复制基于 <code>PSYNC</code> 命令实现。同步操作分为了两块：</p>
<ul>
<li><p><strong><code>完整重同步（full resychronization）</code></strong> 用于初次复制；</p>
</li>
<li><p><code>部分重同步（partial resychronization）</code></p>
</li>
</ul>
<p>  用于断线后重复制。</p>
<ul>
<li>主从服务器的<strong>复制偏移量（replication offset）</strong></li>
<li>主服务器的<strong>复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行 ID</strong></li>
</ul>
<p>（3）Redis 集群主从节点复制的工作流程：</p>
<ul>
<li>步骤 1. 设置主从服务器</li>
<li>步骤 2. 主从服务器建立 TCP 连接。</li>
<li>步骤 3. 发送 PING 检查通信状态。</li>
<li>步骤 4. 身份验证。</li>
<li>步骤 5. 发送端口信息。</li>
<li>步骤 6. 同步。</li>
<li>步骤 7. 命令传播。</li>
</ul>
<h2 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="#Redis 哨兵"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E5%93%A8%E5%85%B5">#</a>Redis 哨兵</h2><p>【问题】</p>
<ul>
<li>Redis 如何实现高可用？</li>
<li>Redis 哨兵的功能？</li>
<li>Redis 哨兵的原理？</li>
<li>Redis 哨兵如何选举 Leader？</li>
<li>Redis 如何实现故障转移？</li>
</ul>
<hr>
<p>【解答】</p>
<blockquote>
<p><strong><em>Redis 哨兵\</em></strong></p>
<p>详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-sentinel.html">Redis 哨兵</a></p>
</blockquote>
<p>（1）Redis 的高可用是通过哨兵来实现（Raft 协议的 Redis 实现）。Sentinel（哨兵）可以监听主服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<p>由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="http://dunwu.test.upcdn.net/snap/20200131135847.png" alt="img"></p>
<h2 id="Redis-vs-Memcached"><a href="#Redis-vs-Memcached" class="headerlink" title="#Redis vs. Memcached"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-vs-memcached">#</a>Redis vs. Memcached</h2><p>【问题】</p>
<p>Redis 和 Memcached 有什么区别？</p>
<p>分布式缓存技术选型，选 Redis 还是 Memcached，为什么？</p>
<p>Redis 和 Memcached 各自的线程模型是怎样的？</p>
<p>为什么单线程的 Redis 性能却不输于多线程的 Memcached？</p>
<p>【解答】</p>
<p>Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。memcache 支持简单的数据类型，String。</p>
<p>Redis 支持数据的备份，即 master-slave 模式的数据备份。</p>
<p>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中</p>
<p>redis 的速度比 memcached 快很多</p>
<p>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的 IO 复用模型。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/19/database/redis/redis-6-%E9%94%81%E4%B8%8E3%E7%A7%8D%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/19/database/redis/redis-6-%E9%94%81%E4%B8%8E3%E7%A7%8D%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">redis-6-锁与常见缓存问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-19 17:54:12" itemprop="dateCreated datePublished" datetime="2021-02-19T17:54:12+08:00">2021-02-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-09 14:11:38" itemprop="dateModified" datetime="2021-06-09T14:11:38+08:00">2021-06-09</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis实现乐观锁"><a href="#Redis实现乐观锁" class="headerlink" title="Redis实现乐观锁"></a>Redis实现乐观锁</h1><h2 id="Redis乐观锁"><a href="#Redis乐观锁" class="headerlink" title="Redis乐观锁"></a>Redis乐观锁</h2><p>乐观锁基于CAS(Compare And Swap)思想(比较并替换)，是不具有互斥性，不会产生锁等待而消 耗资源，但是需要反复的重试，但也是因为重试的机制，能比较快的响应。因此我们可以利用redis来 实现乐观锁。</p>
<p>具体思路如下:</p>
<ul>
<li>监控 锁定量</li>
<li>如果该值被修改成功则表示该请求被通过， 反之表示该请求未通过。</li>
<li>从监控到修改到执行都需要在redis里操作，这样就需要用 到Redis事务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String watchKeys = <span class="string">&quot;watchKeys&quot;</span>; </span><br><span class="line">        <span class="comment">//初始值 </span></span><br><span class="line">        value=<span class="number">1</span> jedis.set(watchKeys, <span class="number">1</span>); </span><br><span class="line">        <span class="comment">//监听key为watchKeys的值 </span></span><br><span class="line">      	jedis.watch(watchkeys);</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        Transaction tx = jedis.multi();</span><br><span class="line">        <span class="comment">//watchKeys自增加一 </span></span><br><span class="line">      	tx.incr(watchKeys);</span><br><span class="line">        <span class="comment">//执行事务，如果其他线程对watchKeys中的value进行修改，则该事务将不会执行 </span></span><br><span class="line">      	<span class="comment">//通过redis事务以及watch命令实现乐观锁</span></span><br><span class="line">        List&lt;Object&gt; exec = tx.exec();</span><br><span class="line">        <span class="keyword">if</span> (exec == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;事务未执行&quot;</span>); &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;事务成功执行，watchKeys的value成功修改&quot;</span>); &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis乐观锁实现秒杀"><a href="#Redis乐观锁实现秒杀" class="headerlink" title="Redis乐观锁实现秒杀"></a>Redis乐观锁实现秒杀</h2><p>在生产环境里，经常会利用redis乐观锁来实现秒杀，Redis乐观锁是Redis事务的经典应用。</p>
<p>由于秒杀只有少部分请求能够成功，而大量的请求是并发产生的，所以如何确定哪个请求成功了，就是 由redis乐观锁来实现。</p>
<p>具体思路如下:</p>
<ul>
<li>监控锁定量，如果该值被修改了，那么则会失败，反之，成功。<a href="">用户首先尝试获取秒杀的资格。(通过事务watch()函数)</a></li>
<li><a href="">用户获取秒杀资格后，再去检查库存是否有库存(通过事务检查库存)</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKill</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//库存key</span></span><br><span class="line">          String redisKey = <span class="string">&quot;stock&quot;</span>;</span><br><span class="line">          ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6378</span>); </span><br><span class="line">              <span class="comment">// 可以被秒杀的库存的初始值，库存总共20个 </span></span><br><span class="line">              jedis.set(redisKey, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">              jedis.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">          executorService.execute(() -&gt; &#123;</span><br><span class="line">            Jedis jedis1 = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6378</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jedis1.watch(redisKey);<span class="comment">//乐观锁的核心业务</span></span><br><span class="line">                String redisValue = jedis1.get(redisKey);</span><br><span class="line">                <span class="keyword">int</span> valInteger = Integer.valueOf(redisValue);</span><br><span class="line">                String userInfo = UUID.randomUUID().toString();</span><br><span class="line">                <span class="comment">//用户成功获取抢夺的资格，然后检查库存量</span></span><br><span class="line">                <span class="keyword">if</span> (valInteger &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                    Transaction tx = jedis1.multi(); </span><br><span class="line">                  	tx.incr(redisKey);</span><br><span class="line">                    List list = tx.exec();</span><br><span class="line">                    <span class="comment">// 秒成功 失败返回空list而不是空</span></span><br><span class="line">                    <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;用户:&quot;</span> + userInfo + <span class="string">&quot;，秒杀成功!当前成功人数:&quot;</span> +(valInteger + <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 版本变化，被别人抢了。 </span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;用户:&quot;</span> + userInfo + <span class="string">&quot;，秒杀失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 秒完了 </span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;已经有20人秒杀成功，秒杀结束&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              	e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              	jedis1.close();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>



<h1 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h1><ul>
<li>单应用中使用锁(单进程多线程)： synchronized、ReentrantLock </li>
<li>分布式应用中使用锁(多进程多线程) ：分布式锁是控制分布式系统之间同步访问共享资源的一种方式</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用Redis的单线程特性对共享资源进行串行化处理</p>
<h2 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h2><h3 id="方式1（使用set命令实现）–推荐"><a href="#方式1（使用set命令实现）–推荐" class="headerlink" title="方式1（使用set命令实现）–推荐"></a>方式1（使用set命令实现）–推荐</h3><ul>
<li>“NX”:没有键值则设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 使用redis的set命令实现获取分布式锁 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> lockKey 可以就是锁 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> requestId 请求ID，保证同一性 uuid+threadID </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> expireTime 过期时间，避免死锁 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String lockKey,String requestId,<span class="keyword">int</span> expireTime)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//NX:保证互斥性 // hset 原子性操作 </span></span><br><span class="line">    String result = jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTime); </span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;OK&quot;</span>.equals(result)) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方式2（使用setnx命令实现）-–-并发会产生问题"><a href="#方式2（使用setnx命令实现）-–-并发会产生问题" class="headerlink" title="方式2（使用setnx命令实现） – 并发会产生问题"></a>方式2（使用setnx命令实现） – 并发会产生问题</h3><p><a href="">因为2个redis操作，即设置key和设置expireTime，不是原子性的复合操作，所以会有并发问题</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String lockKey,String requestId,<span class="keyword">int</span> expireTime)</span> </span>&#123; </span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId); </span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//成功设置 失效时间 </span></span><br><span class="line">        jedis.expire(lockKey, expireTime); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><h3 id="方式1（del命令实现）-–-并发会产生问题"><a href="#方式1（del命令实现）-–-并发会产生问题" class="headerlink" title="方式1（del命令实现） – 并发会产生问题"></a>方式1（del命令实现） – 并发会产生问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 释放分布式锁 * <span class="doctag">@param</span> lockKey * <span class="doctag">@param</span> requestId */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(String lockKey,String requestId)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123; </span><br><span class="line">        jedis.del(lockKey); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题在于如果调用jedis.del()方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的 锁。</p>
<p>那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行 jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将 客户端B的锁给解除了。</p>
</blockquote>
<h3 id="方式2（redis-lua脚本实现）–-推荐"><a href="#方式2（redis-lua脚本实现）–-推荐" class="headerlink" title="方式2（redis+lua脚本实现）– 推荐"></a>方式2（redis+lua脚本实现）– 推荐</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String lockKey, String requestId)</span> </span>&#123; </span><br><span class="line">    String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); </span><br><span class="line">    <span class="keyword">if</span> (result.equals(<span class="number">1L</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Redis常见缓存问题"><a href="#Redis常见缓存问题" class="headerlink" title="Redis常见缓存问题"></a>Redis常见缓存问题</h1><h2 id="数据读"><a href="#数据读" class="headerlink" title="数据读"></a>数据读</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote>
<p>查询缓存中永远不存在的一个值。因为这个值数据库没有。 </p>
</blockquote>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。</p>
<p>也就是说，对不存在的key进行高并发访问，导致数据库压力瞬间增大，这就叫做【缓存穿透】。</p>
<h4 id="解决方案1：缓存null数据"><a href="#解决方案1：缓存null数据" class="headerlink" title="解决方案1：缓存null数据"></a>解决方案1：缓存null数据</h4><p>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>
<h4 id="解决方案2：布隆空滤器"><a href="#解决方案2：布隆空滤器" class="headerlink" title="解决方案2：布隆空滤器"></a>解决方案2：布隆空滤器</h4><p>布隆过滤器是一种比较特殊的数据结构，有点类似与HashMap，在业务中我们可能会通过使用HashMap来判断一个值是否存在，它可以在<code>O(1)</code>时间复杂度内返回结果，效率极高，但是受限于存储容量，如果可能需要去判断的值超过亿级别，那么HashMap所占的内存就很可观了。</p>
<p>而<code>BloomFilter</code>解决这个问题的方案很简单。首先用多个bit位去代替HashMap中的数组，这样的话储存空间就下来了，之后就是对 Key 进行多次哈希，将 Key 哈希后的值所对应的 bit 位置为1。</p>
<p>当判断一个元素是否存在时，就去判断这个值哈希出来的比特位是否都为1，如果都为1，那么可能存在，也可能不存在（如下图F）。但是如果有一个bit位不为1，那么这个Key就肯定不存在。</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfeFWzvYrEVaicV3KqbocH8QeDrvYaTl9MH3iaCkYujx3fnWKa6ic9deA6Yff2owR1qiaJ5aYh9DJm6JHQ/640" alt="Image" style="zoom:50%;" />

<blockquote>
<p>注意：<code>BloomFilter</code>并不支持删除操作，只支持添加操作。这一点很容易理解，因为你如果要删除数据，就得将对应的bit位置为0，但是你这个Key对应的bit位可能其他的Key也对应着。</p>
</blockquote>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>缓存雪崩发生有几种情况，比如大量缓存集中在或者缓存同时在大范围中失效，出现了大量请求去访问数据库，从而导致CPU和内存过载，甚至停机。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">解决方案:</span><br><span class="line"></span><br><span class="line">1、 key的失效期分散开 不同的key设置不同的有效期</span><br><span class="line"></span><br><span class="line">2、设置二级缓存</span><br><span class="line"></span><br><span class="line">3、高可用</span><br><span class="line"></span><br><span class="line">4、服务降级</span><br></pre></td></tr></table></figure>

<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote>
<p>缓存击穿是指当前热点数据存储到期时，多个线程同时并发访问热点数据。因为缓存刚过期，所有并发请求都会到数据库中查询数据。（导致这些请求都访问到数据库）。 </p>
</blockquote>
<p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p>
<h4 id="解决方案1：将热点数据设置为永不过期"><a href="#解决方案1：将热点数据设置为永不过期" class="headerlink" title="解决方案1：将热点数据设置为永不过期"></a>解决方案1：将热点数据设置为永不过期</h4><p>会出现”写一致”问题</p>
<h4 id="解决方案2：加互斥锁"><a href="#解决方案2：加互斥锁" class="headerlink" title="解决方案2：加互斥锁"></a>解决方案2：加互斥锁</h4><p>分布式互斥锁可以控制查询数据库的线程访问，这样其他线程就处于等待状态，保证不会有大并发操作去操作数据库。但这种方案会导致系统的吞吐量下降，需要根据实际情况使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String value = redis.get(key);</span><br><span class="line"> <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// 代表缓存值过期</span></span><br><span class="line">     <span class="comment">// 设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">     <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">// 代表设置成功</span></span><br><span class="line">         value = db.get(key);</span><br><span class="line">         redis.set(key, value, expire_secs);</span><br><span class="line">         redis.del(key_mutex);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">         sleep(<span class="number">50</span>);</span><br><span class="line">         get(key);  <span class="comment">// 重试</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据写"><a href="#数据写" class="headerlink" title="数据写"></a>数据写</h2><blockquote>
<p>数据不一致的根源 ： 数据源不一样</p>
</blockquote>
<p>如何解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">强一致性很难，追求最终一致性</span><br><span class="line">互联网业务数据处理的特点</span><br><span class="line">高吞吐量</span><br><span class="line">低延迟</span><br><span class="line">数据敏感性低于金融业</span><br><span class="line">时序控制是否可行？</span><br><span class="line">先更新数据库再更新缓存或者先更新缓存再更新数据库</span><br><span class="line">本质上不是一个原子操作，所以时序控制不可行</span><br><span class="line">保证数据的最终一致性(延时双删)</span><br><span class="line">1、先更新数据库同时删除缓存项(key)，等读的时候再填充缓存</span><br><span class="line">2、2秒后再删除一次缓存项(key)</span><br><span class="line">3、设置缓存过期时间 Expired Time 比如 10秒 或1小时</span><br><span class="line">4、将缓存删除失败记录到日志中，利用脚本提取失败记录再次删除（缓存失效期过长 7*24）</span><br></pre></td></tr></table></figure>

<p>升级方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过数据库的binlog来异步淘汰key，利用工具(canal)将binlog日志采集发送到MQ中，然后通过ACK机制确认处理删除缓存。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/18/My%20Lord%20Jesus/%E4%B8%BB%E6%97%A5%E8%AE%B2%E9%81%93/2021-02-28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/My%20Lord%20Jesus/%E4%B8%BB%E6%97%A5%E8%AE%B2%E9%81%93/2021-02-28/" class="post-title-link" itemprop="url">2021-02-28主日讲道</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-18 13:54:56" itemprop="dateCreated datePublished" datetime="2021-02-18T13:54:56+08:00">2021-02-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-02-28 11:28:19" itemprop="dateModified" datetime="2021-02-28T11:28:19+08:00">2021-02-28</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>《拓展神国》 于宏杰</p>
<p>被神的爱激励，是我们敬拜神、亲近神的动力</p>
<blockquote>
<p>伊甸园的后遗症：我们在罪中，属于亚当的</p>
<ul>
<li>我们的家庭一直under attack by our enenmy</li>
</ul>
<p>客西马尼园：耶稣基督给了我们盼望</p>
</blockquote>
<p>神的国：</p>
<ul>
<li>属灵的实际：神的旨意、耶稣的心意、圣灵的工作</li>
<li>神国的实际：神的旨意、耶稣的心意、圣灵的工作通过我们彰显<ul>
<li>小到不和妻子吵架</li>
<li>大到为神xundao</li>
</ul>
</li>
</ul>
<p>使徒行传：圣灵的带领</p>
<ul>
<li>一个不变的属灵原则：<ul>
<li>人种的是什么，收的就是什么（加拉太书）<ul>
<li>比如我没有朋友，因为我们没有花时间和朋友交流</li>
<li>比如我没有快乐，因为我们没有感恩</li>
</ul>
</li>
<li>少种的少收，多种的多收，<font color="red">这话是真的</font>（哥林多）</li>
</ul>
</li>
</ul>
<blockquote>
<p>这两句话能不能顺序颠倒？</p>
<ul>
<li>属世界的人也知道第二句话，为了金钱、为了名利、为了自己，不断的种。但是他们不知道种的是什么。</li>
<li>我们必须首先知道我们要种的是什么。</li>
</ul>
</blockquote>
<ul>
<li>每次遵从圣灵，我们就是在圣灵里的撒种</li>
<li>神国的拓展是圣灵的工作<ul>
<li>不过是托付给教会，托付给我们百姓</li>
<li>不是我们自己做，圣灵通过我们做工作<ul>
<li>比如电风扇不是自己转，而是电驱动</li>
<li>比如我们用吸尘器打扫家很仔细，但是吸尘器却没有插电源。这就是仇敌的工作</li>
<li>仇敌惧怕的是地与天结合，惧怕我们与圣灵结合</li>
</ul>
</li>
<li>主耶稣：但圣灵降临在你们身上，你们就必得着能力。所以我们自己没有能力，但是圣灵给我们能力</li>
<li>初期教会面临着各种困难，甚至丧命<ul>
<li>当我们与神的关系不对，我们什么都做不对。而且我们会将自己微小的困难巨大化。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>我们是有影响力的</p>
<ul>
<li>我们2、3个人奉主的名祷告，神必与我们同在</li>
</ul>
<p>我们的影响力必须是正面的、洁净的</p>
<ul>
<li>我们时常造成负面影响，比如背后议论</li>
</ul>
<p>我们的影响力必须要扩大</p>
<ul>
<li>耶路撒冷被不断鞭打，使徒走出去，福音拓展</li>
<li>外面充满了需要</li>
<li>我们不要在自己的舒适区，我们知道的够多了，但是<font color="red">我们知道的是真的</font></li>
</ul>
</blockquote>
<p>圣灵的水流，就是圣灵的工作（以西结书）</p>
<ul>
<li>所到之处，带来改变、带来生命</li>
</ul>
<p>圣灵是神赐给顺从之人</p>
<ul>
<li>基督借着圣灵内住在我们身上</li>
<li>客观真理，圣灵永远在我们身上</li>
<li>主观来说，我们常常没有经历圣灵的喜乐</li>
<li>顺从圣灵的，乃是平安；顺从肉体的，乃是死</li>
<li>神只在乎我愿不愿意顺服，做光</li>
</ul>
<p>榜样</p>
<blockquote>
<ul>
<li>安提阿教会作为榜样<ul>
<li>他们侍奉主禁食，放弃了最理所当然的神赐给我们的权利<ul>
<li>为了在主面前有影响力、为了破坏敌人的工作</li>
</ul>
</li>
<li>圣灵不是一种supernature的经历、能力（可能是邪恶的灵），而是有位格的<ul>
<li>「他们侍奉主、禁食的时候，圣灵说：“<em>要为我分派巴拿巴</em>和扫罗，去做我召他们所做的工。” 」</li>
</ul>
</li>
</ul>
</li>
<li>保罗的榜样<ul>
<li><font color="red">圣灵不许，耶稣禁止</font>。保罗听从。也是我们需要学的，顺服圣灵说的no</li>
<li>神从来不轻看我们的顺服</li>
</ul>
</li>
</ul>
</blockquote>
<p>我们在职场上做榜样</p>
<ul>
<li>要有使命感，换工作是为了建立神的国<ul>
<li>比如泰国的职场弟兄，换一次工作就建立一个职场教会</li>
</ul>
</li>
<li>不要追求更好的生活，否则就被巴比伦掳走了</li>
<li>「活物的灵在轮中(以西结书)」：灵无论往在哪里去，我们都跟随。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/18/My%20Lord%20Jesus/%E4%B8%BB%E6%97%A5%E8%AE%B2%E9%81%93/2021-03-07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/My%20Lord%20Jesus/%E4%B8%BB%E6%97%A5%E8%AE%B2%E9%81%93/2021-03-07/" class="post-title-link" itemprop="url">2021-03-07主日讲道</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-18 13:54:56" itemprop="dateCreated datePublished" datetime="2021-02-18T13:54:56+08:00">2021-02-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-07 21:06:17" itemprop="dateModified" datetime="2021-03-07T21:06:17+08:00">2021-03-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>哥林多后书第10章<br>讲员：赫纬洲弟兄</p>
<p>保罗向哥林多教会解释自己的使徒权柄，不是出于自己，乃是为了主交账，除掉敌人的诡计。</p>
<p>哥林多要求保罗证明自己的使徒权柄：</p>
<ul>
<li>哥林多人本来就是保罗养育信主的，反而质疑保罗。好比儿子要求爸爸证明是他自己的父亲</li>
<li>哥林多城是多元文化的城市。哥林多人崇尚高谈阔论、崇拜知识，爱用自己的标准要求别人，爱小群体。比如他们有属于保罗，有属于亚波罗的，但是保罗坚决反对。</li>
<li>行事为人凭信心，而不是凭眼界。</li>
</ul>
<p>假使徒成功哄骗哥林多人的原因：</p>
<ul>
<li>哥林多人要看基督在保罗彰显的凭据，但是他们用自己的标准考量凭据。</li>
<li>哥林多人认为保罗的软弱，是他们觉得基督的能力在保罗身上没有彰显。根本原因是因为他们没有认识到主的道</li>
<li>假使徒说的，哥林多人听着舒服；保罗说的，他们听着不舒服。我们要顺服 神在教会设立的权柄。</li>
<li>哥林多人不愿意舍己。但我们中间住着圣灵，顺应圣灵的带领，就不顺服肉体了。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/17/My%20Lord%20Jesus/%E5%86%B3%E5%BF%97%E7%A5%B7%E5%91%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/17/My%20Lord%20Jesus/%E5%86%B3%E5%BF%97%E7%A5%B7%E5%91%8A/" class="post-title-link" itemprop="url">决志祷告</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-17 22:17:44" itemprop="dateCreated datePublished" datetime="2021-02-17T22:17:44+08:00">2021-02-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-10-19 09:35:12" itemprop="dateModified" datetime="2022-10-19T09:35:12+08:00">2022-10-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>《得胜者》：</p>
<p>主耶稣，我是个罪人，我需要一个救赎主，我相信你是那个救赎主，所以今天我把我的信心放在唯一的你，唯独耶稣基督，才能赦免我的罪请与我同在，以耶稣之名。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
