<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/15/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/15/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">177</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/26/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/%E9%AB%98%E5%B9%B6%E5%8F%91/%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%B2%92%E5%BA%A6%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/26/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/%E9%AB%98%E5%B9%B6%E5%8F%91/%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%B2%92%E5%BA%A6%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">高并发：并发粒度与线程间通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-26 12:16:50 / Modified: 12:25:21" itemprop="dateCreated datePublished" datetime="2020-11-26T12:16:50+08:00">2020-11-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>它山之石可以攻玉</p>
<h3 id="ref-links"><a href="#ref-links" class="headerlink" title="ref links:"></a>ref links:</h3><ol>
<li>使用CountDownLatch + CyclicBarrier解决高并发中，线程通信的问题<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66036256">https://zhuanlan.zhihu.com/p/66036256</a></li>
</ol>
<p>思考：</p>
<ol>
<li><p>最基本的线程通信方式:  </p>
<ol>
<li><p>实现：threadA.join() 执行线程加入threadA线程，等待threadA结束</p>
</li>
<li><p>场景：实现简单并行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">        </span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<p> 2. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/%E9%AB%98%E5%B9%B6%E5%8F%91/%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9A%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/%E9%AB%98%E5%B9%B6%E5%8F%91/%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9A%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">高并发：限流实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-24 19:02:44" itemprop="dateCreated datePublished" datetime="2020-11-24T19:02:44+08:00">2020-11-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-07 21:07:29" itemprop="dateModified" datetime="2021-03-07T21:07:29+08:00">2021-03-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>它山之石可以攻玉</p>
<h3 id="ref-links"><a href="#ref-links" class="headerlink" title="ref links:"></a>ref links:</h3><ol>
<li>SpringBoot使用AOP和Guava实现对Request的限流<br><a target="_blank" rel="noopener" href="https://www.lagou.com/lgeduarticle/17171.html">https://www.lagou.com/lgeduarticle/17171.html</a></li>
<li>Guava的令牌桶算法的实现<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60979444">https://zhuanlan.zhihu.com/p/60979444</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/23/database/mysql/mysql-%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1sql%E8%AF%AD%E5%8F%A501/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/database/mysql/mysql-%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1sql%E8%AF%AD%E5%8F%A501/" class="post-title-link" itemprop="url">mysql:工作中常用的组合sql语句</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-23 19:03:17" itemprop="dateCreated datePublished" datetime="2020-11-23T19:03:17+08:00">2020-11-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-14 14:48:44" itemprop="dateModified" datetime="2021-04-14T14:48:44+08:00">2021-04-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="统计销量最高的员工"><a href="#统计销量最高的员工" class="headerlink" title="统计销量最高的员工"></a>统计销量最高的员工</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> orderinfo.UserID,<span class="keyword">sum</span>(OrderAmount) <span class="keyword">from</span> orderinfo <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> userinfo</span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span> orderinfo.UserID = userinfo.userid</span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> orderinfo.UserID <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">sum</span>(OrderAmount) <span class="keyword">desc</span> <span class="keyword">LIMIT</span> <span class="number">10</span> ;</span><br></pre></td></tr></table></figure>

<p>求出最畅销的十个商品 所属的品牌中各个不同尺码的销售额(锻炼sql，分步写，思路清晰)</p>
<p>4.4.1、先查到10个畅销商品所属于的品牌</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE table top10brand(</span><br><span class="line"></span><br><span class="line">SELECT typeid from orderdetail left JOIN goodsinfo</span><br><span class="line"></span><br><span class="line">on orderdetail.GoodsID&#x3D; goodsinfo.goodsid</span><br><span class="line"></span><br><span class="line">GROUP BY orderdetail.GoodsID</span><br><span class="line"></span><br><span class="line">ORDER BY sum(GoodsPrice*Amount) desc LIMIT 10</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>SELECT * from top10brand;</p>
<p>4.4.2、内连接各个表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT orderdetail.SizeID,sum(GoodsPrice*Amount) from goodsinfo</span><br><span class="line"></span><br><span class="line">INNER JOIN top10brand on top10brand.typeid&#x3D;goodsinfo.typeid</span><br><span class="line"></span><br><span class="line">INNER JOIN orderdetail ON orderdetail.GoodsID &#x3D; goodsinfo.goodsid</span><br><span class="line"></span><br><span class="line">GROUP BY orderdetail.SizeID</span><br><span class="line"></span><br><span class="line">ORDER BY sum(GoodsPrice*Amount) desc;</span><br></pre></td></tr></table></figure>





<h1 id="select结果update到表中"><a href="#select结果update到表中" class="headerlink" title="select结果update到表中"></a>select结果update到表中</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UPDATE sale</span><br><span class="line">INNER JOIN (</span><br><span class="line">	SELECT</span><br><span class="line">		sale.FNo,</span><br><span class="line">		sale.FEntryID,</span><br><span class="line">		(finishin.FQty) AS qty</span><br><span class="line">	FROM</span><br><span class="line">		sale,</span><br><span class="line">		finishin</span><br><span class="line">	WHERE</span><br><span class="line">		sale.FNo &#x3D; finishin.FNo</span><br><span class="line">	AND sale.FEntryID &#x3D; finishin.FEntryID</span><br><span class="line">	ORDER BY</span><br><span class="line">		sale.FNo</span><br><span class="line">) sale2 ON sale2.FNo &#x3D; sale.FNo</span><br><span class="line">AND sale2.FEntryID &#x3D; sale.FEntryID</span><br><span class="line">SET sale.FqtyIn &#x3D; sale2.qty</span><br></pre></td></tr></table></figure>



<h1 id="select结果insert到表中"><a href="#select结果insert到表中" class="headerlink" title="select结果insert到表中"></a>select结果insert到表中</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A中有3例，B表中你只能获得2列，可以用常量占位解决</span><br><span class="line">insert into tableA (列1，列2，列3) select 列1，列2，常量  from tableB WHERE 条件表达式;</span><br></pre></td></tr></table></figure>





<h1 id="Get-Last-Record-In-Each-Group"><a href="#Get-Last-Record-In-Each-Group" class="headerlink" title="Get Last Record In Each Group"></a>Get Last Record In Each Group</h1><p><strong>我现在需要取出每个分类中最新的内容</strong><br>select * from test group by category_id order by <code>date</code><br>结果如下<br><img src="https://img-blog.csdn.net/20160830142144744" alt="这里写图片描述"><br>明显。这不是我想要的数据，原因是msyql已经的执行顺序是：</p>
<blockquote>
<p>写的顺序：select … from… where…. group by… having… order by..<br>执行顺序：from… where…group by… having…. select … order by…</p>
</blockquote>
<p>所以在order by拿到的结果里已经是分组的完的最后结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select product_sales.* from product_sales,</span><br><span class="line">           (select product,max(order_date) as order_date</span><br><span class="line">                from product_sales</span><br><span class="line">                group by product) max_sales</span><br><span class="line">             where product_sales.product&#x3D;max_sales.product</span><br><span class="line">             and product_sales.order_date&#x3D;max_sales.order_date;</span><br></pre></td></tr></table></figure>

<p>This will return the posts with the latest record in each group.</p>
<h1 id="Combine-results-of-2-queries-to-multiple-columns"><a href="#Combine-results-of-2-queries-to-multiple-columns" class="headerlink" title="Combine results of 2 queries to multiple columns"></a>Combine results of 2 queries to multiple columns</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非常基础的sql</span><br><span class="line"></span><br><span class="line">select a.id, bi.name from (select id from a) a, (select name from b) b</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/23/database/mysql/mysql-%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1sql%E8%AF%AD%E5%8F%A502/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/database/mysql/mysql-%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1sql%E8%AF%AD%E5%8F%A502/" class="post-title-link" itemprop="url">mysql:工作中常用的组合sql语句</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-23 19:03:17" itemprop="dateCreated datePublished" datetime="2020-11-23T19:03:17+08:00">2020-11-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-12 13:57:58" itemprop="dateModified" datetime="2021-04-12T13:57:58+08:00">2021-04-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="存在则更新否则插入"><a href="#存在则更新否则插入" class="headerlink" title="存在则更新否则插入"></a>存在则更新否则插入</h2><p>这里有个系统设计的难点，就是<a href="">保障“先检查，后更新”这个复合操作一定是原子性的</a></p>
<p>如果使用分布式锁，来保证原子性（类似cas）,会出现严重性能问题，因为所有的服务获取锁失败后，仍然不断尝试获取锁，浪费cpu。</p>
<p>所有，原子操作要交给数据库解决。</p>
<h2 id="需要插入数据中有主键or唯一索引"><a href="#需要插入数据中有主键or唯一索引" class="headerlink" title="需要插入数据中有主键or唯一索引"></a>需要插入数据中有主键or唯一索引</h2><h3 id="insert-ignore-into"><a href="#insert-ignore-into" class="headerlink" title="insert ignore into"></a>insert ignore into</h3><p>即插入数据时，如果数据存在，则忽略此次插入，前提条件是插入的数据字段设置了主键或唯一索引，测试SQL语句如下，当插入本条数据时，MySQL数据库会首先检索已有数据（也就是idx_username索引），如果存在，则忽略本次插入，如果不存在，则正常插入数据：</p>
<p><img src="https://pic3.zhimg.com/80/v2-b64c607f476438fcf61476541f5282f2_1440w.jpg" alt="img"></p>
<h3 id="on-duplicate-key-update"><a href="#on-duplicate-key-update" class="headerlink" title="on duplicate key update"></a>on duplicate key update</h3><p>即插入数据时，如果数据存在，则执行更新操作，前提条件同上，也是插入的数据字段设置了主键或唯一索引，测试SQL语句如下，当插入本条记录时，MySQL数据库会首先检索已有数据（idx_username索引），如果存在，则执行update更新操作，如果不存在，则直接插入：</p>
<p><img src="https://pic2.zhimg.com/80/v2-f19efc8f2d231e0d78c674b4f687698d_1440w.jpg" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mybatis的写法 </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;batchAdd&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">       INSERT INTO t_student(uid,student_id,study_days)</span><br><span class="line">       VALUES</span><br><span class="line">       <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">           (#&#123;item.uid&#125;,#&#123;item.studentId&#125;,#&#123;item.studyDays&#125;)</span><br><span class="line">       <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">       ON DUPLICATE KEY UPDATE</span><br><span class="line">       uid = values(uid),</span><br><span class="line">  		 student_id = values(student_id)</span><br><span class="line">   <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="replace-into"><a href="#replace-into" class="headerlink" title="replace into"></a>replace into</h3><p>即插入数据时，如果数据存在，则删除再插入，前提条件同上，插入的数据字段需要设置主键或唯一索引，测试SQL语句如下，当插入本条记录时，MySQL数据库会首先检索已有数据（idx_username索引），如果存在，则先删除旧数据，然后再插入，如果不存在，则直接插入：</p>
<p><img src="https://pic2.zhimg.com/80/v2-7c30f2c0e1930f14020d5041379ca525_1440w.jpg" alt="img"></p>
<h2 id="不需要插入数据中有主键or唯一索引"><a href="#不需要插入数据中有主键or唯一索引" class="headerlink" title="不需要插入数据中有主键or唯一索引"></a>不需要插入数据中有主键or唯一索引</h2><h3 id="insert-if-not-exists"><a href="#insert-if-not-exists" class="headerlink" title="insert if not exists"></a>insert if not exists</h3><p>即insert into … select … where not exist … ，这种方式适合于插入的数据字段没有设置主键或唯一索引，当插入一条数据时，首先判断MySQL数据库中是否存在这条数据，如果不存在，则正常插入，如果存在，则忽略：</p>
<p><img src="https://pic4.zhimg.com/80/v2-f44696934ba126b67e6ab5477c9eaed3_1440w.jpg" alt="img"></p>
<p>目前，就分享这4种MySQL处理重复数据的方式吧，前3种方式适合字段设置了主键或唯一索引，最后一种方式则没有此限制，只要你熟悉一下使用过程，很快就能掌握的，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/21/database/mysql/mysql-%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%85%A2%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/database/mysql/mysql-%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%85%A2%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">mysql:哪些因素会导致慢查询</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-21 09:58:49" itemprop="dateCreated datePublished" datetime="2020-11-21T09:58:49+08:00">2020-11-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-01-15 21:06:36" itemprop="dateModified" datetime="2021-01-15T21:06:36+08:00">2021-01-15</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>它山之石可以攻玉</p>
<h3 id="ref-links"><a href="#ref-links" class="headerlink" title="ref links:"></a>ref links:</h3><ol>
<li>从底层硬件、操作系统、mysql软件层面分析<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Edn_gPwcAHo5sYIzLJghzA">https://mp.weixin.qq.com/s/Edn_gPwcAHo5sYIzLJghzA</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/apache-http-client%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%ADsocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/apache-http-client%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%ADsocket/" class="post-title-link" itemprop="url">apache http client如何正确关闭socket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-19 17:33:26" itemprop="dateCreated datePublished" datetime="2020-11-19T17:33:26+08:00">2020-11-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-02 18:10:48" itemprop="dateModified" datetime="2020-12-02T18:10:48+08:00">2020-12-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>它山之石可以攻玉</p>
<h3 id="ref-links"><a href="#ref-links" class="headerlink" title="ref links:"></a>ref links:</h3><ol>
<li>从http client 4.x源码分析，该如何关闭socket<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54832733">https://zhuanlan.zhihu.com/p/54832733</a></li>
<li>分析服务器端口的状态与http client关闭方法的对应关系<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiao--y/p/7878170.html">https://www.cnblogs.com/xiao--y/p/7878170.html</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter13-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter13-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">chapter13:线程安全与锁优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-16 22:17:11" itemprop="dateCreated datePublished" datetime="2020-11-16T22:17:11+08:00">2020-11-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-31 22:39:35" itemprop="dateModified" datetime="2021-03-31T22:39:35+08:00">2021-03-31</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ref:</p>
<ol>
<li>Java并发-atomic原子类包源码剖析<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/27e07df2672e">https://www.jianshu.com/p/27e07df2672e</a></li>
</ol>
<h2 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h2><p>本章将介绍如何保证并发的正确性和如何实现线程安全。</p>
<h2 id="13-2-线程安全"><a href="#13-2-线程安全" class="headerlink" title="13.2 线程安全"></a>13.2 线程安全</h2><p>见JCP的定义吧，这本书的定义不太好。</p>
<h3 id="13-2-1-Java-语言中的线程安全"><a href="#13-2-1-Java-语言中的线程安全" class="headerlink" title="13.2.1 Java 语言中的线程安全"></a>13.2.1 Java 语言中的线程安全</h3><p>我们可以不把线程安全当做一个非真即假的二元排他选项来看待，按照线程安全的“安全程度”由强至弱来排序，我们可以将 Java 语言中各种操作共享的数据分为以下 5 类：</p>
<h4 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1. 不可变"></a>1. 不可变</h4><p>不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要采取任何的线程安全保障措施，final 关键字带来的可见性就提到这一点，只有一个不可变的对象被正确地构建出来（没有发生 this 逃逸的情况），那其外部的可见状态永远不会改变，永远也不会看到它在多线程之中处于不一致的状态。</p>
<p>保障对象行为不影响自己状态的途径很多，最简单的就是把对象中带有状态的变量都声明为 final，这样在构造函数结束之后，它就是不可变的。</p>
<h4 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2. 绝对线程安全"></a>2. 绝对线程安全</h4><p> “不管运行时环境如何，调用者都不需要任何额外的同步措施” 通常需要付出很大的，甚至是不切实际的代价。在 Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。</p>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>java.util.Vector 是一个线程安全的容器，它的 add()、get()、size() 这方法都是被 synchronized 修饰的，但是，也不意味着调用它的时候永远不需要同步手段。</p>
<p>很明显，尽管这里调用的 Vector 的 get()、remove()、size() 方法都是同步的，但是在多线程环境中，如果不在方法调用端做额外的同步措施，这段代码仍然是不安全的。因为如果另一个线程恰好在错误的时间里删除一个元素，导致序号 i 已经不再可用的话，再用 i 访问数组就会抛出一个 ArrayIndexOutOfBoundsException。</p>
<h4 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3. 相对线程安全"></a>3. 相对线程安全</h4><!--相对线程安全就是我们通常意义上讲的线程安全-->，**它需要保证这个对象单独的操作时线程安全的**，我们调用的时候不需要做额外的保障措施，但是对一些特定顺序的连续调用，就可能需要在调用端使用额外的不同手段来保证调用的正确性。

<p>Java 中大部分的线程安全类都属于这种类型，如果 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p>
<h4 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4. 线程兼容"></a>4. 线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。比如 ArrayList 和 HashMap 等。</p>
<h4 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5. 线程对立"></a>5. 线程对立</h4><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。略。</p>
<h3 id="13-2-2-线程安全的实现方法"><a href="#13-2-2-线程安全的实现方法" class="headerlink" title="13.2.2 线程安全的实现方法"></a>13.2.2 线程安全的实现方法</h3><p>本节，代码编写如何实现线程安全和虚拟机如何实现同步与锁这两者都会有所涉及，相对而言更偏重后者一些。</p>
<h4 id="1-互斥同步（悲观锁）"><a href="#1-互斥同步（悲观锁）" class="headerlink" title="1. 互斥同步（悲观锁）"></a>1. 互斥同步（悲观锁）</h4><p>互斥同步是常见的一种并发正确性保障手段<!--其实我认为是牺牲一定的并发性能，使得串行化和阻塞化，以保证正确性-->。</p>
<p><strong>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用</strong>。</p>
<p><strong>互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这 4 个字面里，互斥是因，同步时果；互斥是方法，同步是目的。</strong></p>
<blockquote>
<p>互斥同步也叫阻塞同步。</p>
</blockquote>
<p>Java 中最基本的互斥同步手段就是 synchronized 关键字，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码指令都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指明了对象参数，那就是说这个对象的 reference；如果没有明确指明，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。</p>
<p>根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，相应的，在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就释放了。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p>
<p>首先，synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的情况。其次，同步块在已经进入的线程执行完成之前，会阻塞后面其他线程的进入。</p>
<p>Java 的线程是映射到操作系统的原生线程上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态上，因此状态转换需要耗费很多的处理器时间。对代码简单的同步块（如被 synchronized 修饰的 getter()或 setter() 方法），状态转换消耗的时间可能比用户代码执行的时间还要长。所以 synchronized 是 Java 语言中的一个重量级的操作。<!--而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，而避免频繁的切入到核心态之中。--></p>
<p>除了 synchronized 之外，我们还可以使用 juc 包中的重入锁（ReentrantLock）来实现同步。它还有一些高级功能：等待可中断、可实现公平锁、以及锁可以绑定多个条件。</p>
<ul>
<li>等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理器执行时间非常长的同步块很有帮助。比如 tryLock(long timeout, TimeUnit unit) 方法。</li>
<li>公平锁：指多个线程在等待同一个锁时，必须要按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 的锁是非公平的，ReentrantLock 默认情况下也是非公平的，可以通过带布尔值的构造函数创建公平锁。</li>
<li>锁绑定条件：指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外的添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition() 方法即可。</li>
</ul>
<p>JDK 1.6  或以上的版本 synchronized 与 ReentrantLock 的性能基本上完全持平了。优先考虑使用 synchronized 来进行同步。</p>
<h4 id="2-非阻塞同步（乐观锁）"><a href="#2-非阻塞同步（乐观锁）" class="headerlink" title="2. 非阻塞同步（乐观锁）"></a>2. 非阻塞同步（乐观锁）</h4><p>互斥（阻塞）同步最主要的问题时进行线程阻塞和唤醒所带来的的性能问题。<strong>它属于一种悲观的并发策略</strong>，<!--总是认为只要不去做正确的同步措施（如加锁），那肯定会出现问题，无论是数据共享还是真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作-->。随着指令集的发展，我们有了另一个选择：基于冲突检测的并发策略，通俗的说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止）。这种<strong>乐观的并发策略</strong>的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。</p>
<p>因为我们需要操作和检测这两个步骤是具备原子性，硬件可以保证一个从遇上看起来需要多次操作的行为只通过一条处理器指令就能完成，这样指令常用的有：</p>
<ul>
<li>测试并设置（test-and-set）。</li>
<li>获取并增加（fetch-and-increment）。</li>
<li>交换（swap）。</li>
<li>比较并交换（compare-and-swap，下文称为 CAS）。</li>
<li>加载链接/条件存储（load-linked/store-conditional，下文称 LL/SC）。</li>
</ul>
<p>CAS 指令需要 3 个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 指令执行时，当前仅当 V 符合预期值 A 时，处理器就用新值更新 V 值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。</p>
<blockquote>
<p>CAS比较与交换的伪代码可以表示为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	备份旧数据；</span><br><span class="line">	基于旧数据构造新数据；</span><br><span class="line">&#125;<span class="keyword">while</span>(!CAS( 内存地址，备份的旧数据，新数据 ))</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/5954965-b88918b03518f254?imageMogr2/auto-orient/strip%7CimageView2/2/w/320/format/webp" alt="img"></p>
<p>注：t1，t2线程是同时更新同一变量56的值</p>
<p>因为t1和t2线程都同时去访问同一变量56，所以他们会把主内存的值完全拷贝一份到自己的工作内存空间，所以t1和t2线程的预期值都为56。</p>
<p>假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败。（失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试）。t1线程去更新变量值改为57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了（想改的值不再是原来的值）。</p>
<p>（上图通俗的解释是：CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值。）</p>
<p>就是指当两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。<!--容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的commit-retry 的模式, 和redis的watch模式。-->当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。</p>
</blockquote>
<p>JDK 1.5 之后，Java 程序才可以使用 CAS 操作，该操作是由 sun.misc.Unsafe 类里面的 compareAndSwapInt() 等几个方法包装提供的。</p>
<p>JUC 中的 AtomicInteger 类中的 incrementAndGet() 方法就是使用 Unsafe 类的 getAndAddInt() 方法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... AtomicInteger 类 ...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... Unsafe 类 ...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>CAS 还有一个逻辑漏洞：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，如果这期间它的值曾经被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的“ABA”问题。JUC 包中提供了一个一个带有标记的原子引用类“AtomicStampedReference”类来解决这个问题，它可以保证 CAS 的正确性。</p>
<blockquote>
<p><a href="">使用版本号解决ABA问题</a></p>
<p>只是简单的数据结构，确实不会有什么问题，如果是复杂的数据结构可能就会有问题了（<strong>使用<code>AtomicReference</code>可以把<code>C A S</code>使用在对象上</strong>），以链表数据结构为例，两个线程通过<code>C A S</code>去删除头节点，假设现在链表有<code>A-&gt;B</code>节点</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8ny1VNcSscicjAax5qNibFxqiabJLQZYt6OMXoBHbMIlLoNjgVt85LZlT0FGAoWB09ScvI5KITMSr9qxg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:50%;" />

<ul>
<li>线程<code>1</code>删除<code>A</code>节点，<code>B</code>节点成为头节点，正要执行<code>C A S(A,A,B)</code>时，时间片用完，切换到线程<code>2</code></li>
<li>线程<code>2</code>删除<code>A、B</code>节点</li>
<li>线程<code>2</code>加入<code>C、A</code>节点，链表节点变成<code>A-&gt;C</code></li>
<li>线程<code>1</code>重新获取时间片，执行<code>C A S(A,A,B)</code></li>
<li>丢失<code>C</code>节点</li>
</ul>
<p>要解决<code>A B A</code>问题也非常简单，只要追加版本号即可，每次改变时加<code>1</code>，即<code>A —&gt; B —&gt; A</code>，变成<code>1A —&gt; 2B —&gt; 3A</code>，在<code>Java</code>中提供了<code>AtomicStampedRdference</code>可以实现这个方案</p>
</blockquote>
<p>不过目前这个类比较“鸡肋”。大部分情况下 ABA 问题不会影响程序的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h4 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3. 无同步方案"></a>3. 无同步方案</h4><p>要保证线程安全，并不是一定要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性手段。如果一个方法本来就不涉及共享数据，那就自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。</p>
<h5 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h5><p>可重入代码也叫做纯代码，可以额在代码执行的任意时刻中断它，转而去执行另一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入的代码有一些公共的特征，比如不依赖存储在堆上的数据和公共系统资源、用到的状态量都是由参数传入、不可调用非可重入的方法等。<!--其实就是JCP说的线程封闭中的栈封闭，比如局部变量--></p>
<h5 id="线程本地存储（Thread-Local-Storage）"><a href="#线程本地存储（Thread-Local-Storage）" class="headerlink" title="线程本地存储（Thread Local Storage）"></a>线程本地存储（Thread Local Storage）</h5><p>如果一段代码所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样就无须同步也能保证线程之间不会出现数据争用的问题。</p>
<p>符合这种特点的应用程序有很多，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的应用实例就是经典 web 交互模式中的“一个请求对应一个服务器线程”的处理方式，这种处理方式的广泛应用使得很多 web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>在 Java 中可以通过 ThreadLocal类来实现线程本地存储的功能，每一个线程 Thread 对象都一个 ThreadLocalMap 对象，这个对象存储了一组以 ThreadLocal.threadLocalHashCode 为键，以本地线程变量为值的 K-V 值对，ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个 ThreadLocal 对象都包含了一个独一无二的 threadLocalHashCode 值，这个值就可以在线程 K-V 值对中找回对应的本地线程变量。</p>
<h2 id="13-3-锁优化"><a href="#13-3-锁优化" class="headerlink" title="13.3 锁优化"></a>13.3 锁优化</h2><p>高效并发是从 JDK 1.5 到 JDK 1.6 的一个重要改进，HotSpot 虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<h3 id="13-3-1-自旋锁与自适应自旋"><a href="#13-3-1-自旋锁与自适应自旋" class="headerlink" title="13.3.1 自旋锁与自适应自旋"></a>13.3.1 自旋锁与自适应自旋</h3><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机开发团队发现很多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍微等一下”，但不放弃处理器的执行时间，看看持有的锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p>
<p><strong>自旋锁等待不能代替阻塞，它本身虽然避免了线程切换的开销，但是它要占用处理器时间的</strong></p>
<blockquote>
<p>如果锁被占用的时间很短，自旋等待的效果会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。</p>
</blockquote>
<p>JDK 1.6 引入了自适应的自旋锁，意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。</p>
<h3 id="13-3-2-锁消除"><a href="#13-3-2-锁消除" class="headerlink" title="13.3.2 锁消除"></a>13.3.2 锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除技术主要判定来源于逃逸分析的数据支持，如果判断在一段代码上，堆上所有的数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然无须进行。</p>
<h3 id="13-3-3-锁粗化"><a href="#13-3-3-锁粗化" class="headerlink" title="13.3.3 锁粗化"></a>13.3.3 锁粗化</h3><p>原则上我们编写代码时，总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>大部分情况下，上面的原则是正确的，但是如果发生一系列的连续操作都是对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>如果虚拟机检测到这样的操作，就会将锁同步的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。</p>
<h3 id="13-3-4-轻量级锁"><a href="#13-3-4-轻量级锁" class="headerlink" title="13.3.4 轻量级锁"></a>13.3.4 轻量级锁</h3><p>轻量级锁是 JDK 1.6 中加入的新型加锁机制。它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<p>HotSpot 虚拟机的对象（对象头部分）的内存布局分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希吗（HashCode）、GC 分代年龄等，这部分数据的长度在 32 位和 64 位的虚拟机中分别为 32bit 和 64bit，官方它称为“Mark Word”，它是实现轻量级锁和偏向锁的关键。另一部分用户存储指向方法区对象类型的指针，如果是数据对象，还会有一个额外的部分用于存储数组长度。</p>
<p>对象头信息食欲对象自身定义的数据无关的额外存储成功，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如 32 位的 HotSpot 虚拟机中对象未被锁定的状态下，Mark Word 的 32bit 空间中的 25bit 用于存储对象哈希吗（HashCode），4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0；在其他状态（轻量级锁定、重量级锁定、GC 标记、可偏向）下对象的存储内容如下表：</p>
<p><img src="https://note.youdao.com/yws/public/resource/e5ba56d8a5585cac6e73e80de14f2f32/xmlnote/60906136B69B4E1080B14474EC105C1A/84583" alt="image"></p>
<p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（lock record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀），这时候线程堆栈与对象头的状态如图 13-3 所示。</p>
<p>然后，虚拟机将使用 CAS 操作尝试将这个对象的 Mark Word 更新为指向 Lock Record 的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（ Mark Word 的最后 2bit）将转变为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图 13-4 所示。</p>
<p><img src="https://note.youdao.com/yws/public/resource/e5ba56d8a5585cac6e73e80de14f2f32/xmlnote/5F5DFBE021EC430993AF678E1A506CD2/84596" alt="image"></p>
<p>如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p>
<p>上面描述的是轻量级锁的加锁过程，它的解锁过程就是通过 CAS 操作来进行的，如果对象的 Mark Word 仍然指向着线程的锁记录，那就用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取锁，那就要在释放锁的同时，唤醒被挂起的线程。</p>
<p>轻量级锁能提升程序同步性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，但是如果存在竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p>
<h3 id="13-3-5-偏向锁"><a href="#13-3-5-偏向锁" class="headerlink" title="13.3.5 偏向锁"></a>13.3.5 偏向锁</h3><p>偏向锁也是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了。</p>
<p>偏向锁的“偏”是偏心、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p>当锁对象第一次被线程获取的时候，虚拟机将会把这个对象头中的标志位设为“01”，即偏向模式。同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如 Locking、Unlocking 以及 Mark Word 的 Update 等）。</p>
<p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定状态（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如上面接收的轻量级锁那样执行。偏向锁、轻量级锁的状态转化以及对象 Mark Word 的关系如图所示。</p>
<p><img src="https://note.youdao.com/yws/public/resource/e5ba56d8a5585cac6e73e80de14f2f32/xmlnote/EAC7A78FC409443FA484195330BC73B0/84653" alt="image"></p>
<p>偏向锁可以提高带有同步但无竞争的程序性能，它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向锁就是多余的。在具体问题分析的前提下，有时候使用 -XX:-UseBiasedLocking 来禁止偏向锁优化反而可以提升性能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B1%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%9D%A5%E7%90%86%E8%A7%A3%E4%B8%8BTCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B1%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%9D%A5%E7%90%86%E8%A7%A3%E4%B8%8BTCP/" class="post-title-link" itemprop="url">由一次线上故障来理解下TCP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-16 12:23:23" itemprop="dateCreated datePublished" datetime="2020-11-16T12:23:23+08:00">2020-11-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-02 18:09:27" itemprop="dateModified" datetime="2020-12-02T18:09:27+08:00">2020-12-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>它山之石可以攻玉</p>
<h3 id="ref-links"><a href="#ref-links" class="headerlink" title="ref links:"></a>ref links:</h3><ol>
<li>原文链接，有2行查看jstack和netstat的组合shell脚本<br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903970146615310">https://juejin.im/post/6844903970146615310</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter2-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter2-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/" class="post-title-link" itemprop="url">chapter2:java内存模型与内存溢出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-14 08:17:53" itemprop="dateCreated datePublished" datetime="2020-11-14T08:17:53+08:00">2020-11-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-02 09:03:19" itemprop="dateModified" datetime="2021-03-02T09:03:19+08:00">2021-03-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java 虚拟机会在程序执行时将数据划分为几个不同的数据区域。 这些区域有着**<code>不同的用途</code><strong>，</strong><code>创建和销毁的时间</code>**，有的区域随着虚拟机进程的启动而一直存在，有的区域则随着用户线程的启动和结束而建立和销毁。</p>
<p>根据 <strong>《Java虚拟机规范》</strong>的规定，Java虚拟机管理的内存区域包括以下几个**<code>运行时</code>**区域：</p>
<img src="https://img-blog.csdn.net/20161026225551801" style="zoom: 67%;"/>


<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>**<code>性质：线程私有，占用空间小，不会发生OOM，是当前线程执行字节码的行号指示器。</code>**这块空间是线程私有的，因为每个线程都有自己的执行进度。</p>
<p>在 <strong><code>Java 虚拟机的概念模型</code>  **①中：</strong><code>字节码解释器</code><strong>工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，</strong><code>分支</code><strong>、</strong><code>循环</code><strong>、</strong><code>跳转</code><strong>、</strong><code>依赖</code><strong>、</strong><code>异常处理</code><strong>、</strong><code>线程恢复</code>**等基础功能都需要依赖这个计数器来完成。</p>
<p>Java 虚拟机中的**<code>多线程</code><strong>是通过</strong><code>线程轮流切换，分配CPU执行时间片</code>**的方式实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说，是其中的一个内核）都只会执行一条线程中的指令。而程序计数器就担任着线程切换后继续执行线程代码的责任。</p>
<p><strong><code>程序计数器存储的内容：</code></strong></p>
<ul>
<li>如果线程执行的是 <code>Java 方法</code>，则记录的是正在执行**<code>的 虚拟机字节码指令地址</code>**</li>
<li>如果正在执行的是<code>本地方法</code>（<code>Native</code>），则**<code>程序计数器的值为空</code>**（<code>Undefined</code>）</li>
</ul>
<p><strong><code>该区域是《Java虚拟机规范》中唯一一个没有规定任何OOM发生的区域，即该区域不会产生内存溢出错误。</code></strong></p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><strong><code>性质：线程私有，生命周期与线程相同</code></strong></p>
<p><strong><code>虚拟机栈描述的是 Java 方法执行的线程内存模型</code>**：每个方法被执行的时候，Java虚拟机都会同步的创建一个「</strong>栈桢」①（<code>Stack Frame</code>）<strong>，用于存储 「</strong><code>局部变量表</code><strong>」、「</strong><code>操作数栈</code><strong>」，「</strong><code>动态连接</code><strong>」，「</strong><code>方法出口</code>**」 等信息。</p>
<p>每一个方法从被<strong>调用</strong>到<strong>执行完毕</strong>这个过程就对应着一个<code>栈桢</code>在<code>虚拟机</code>中从<code>入栈</code>到<code>出栈</code>的过程。</p>
<blockquote>
<p>方法调用 ==&gt; 栈帧入栈</p>
<p>方法执行完成 ==&gt;栈帧出栈</p>
</blockquote>
<p>我们经常将 Java 中的内存区域简单粗暴的划分为 「**<code>堆</code><strong>」 和 「</strong><code>栈</code><strong>」，所谓的栈指的就是这里的「</strong><code>虚拟机栈</code><strong>」了，或者更多情况下其内容仅仅对应的是 虚拟机栈中的「</strong><code>局部变量表</code>**」 部分。</p>
<p>**<code>局部变量表</code>**：存放了<code>编译期</code>间可知的各种</p>
<ul>
<li><code>Java 虚拟机基本数据类型</code>（<code>boolean</code>，<code>byte</code>，<code>char</code>，<code>short</code>，<code>int</code>，<code>float</code>，<code>long</code>，<code>double</code>）</li>
<li><strong><code>对象引用</code>**（</strong><code>reference</code>** 类型，它可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）</li>
<li><strong><code>returnAddress</code></strong> 类型（**<code>指向一条字节码指令的地址</code>**）</li>
</ul>
<p><strong>局部变量表中的具体存储模式</strong>：使用**<code>变量槽（Slot）存储数据</code>**，64位长度的 long 和 double 类型的会占用2个变量槽，其余数据类型占用1个。</p>
<p><code>局部变量表</code>所需的内存空间在编译期就已经完成分配（因为是可知的），当进入一个方法时，这个<code>方法</code>需要在<code>栈桢中</code>分配多大的<code>局部变量空间是完全确定</code>的，<code>在方法运行期间不会改变局部变量表的大小。</code><!--这里的大小指的是变量槽的数量，而每个槽对应的真实内存占用大小则是虚拟机自行实现。--></p>
<p>虚拟机栈中可能发生的2种异常：</p>
<ul>
<li><strong><code>StackOverflowError</code>**：当</strong><code>线程请求的栈深度大于虚拟机允许的栈深度</code>**时，出现该异常。</li>
<li><strong><code>OutOfMemoryError</code></strong>:  如果虚拟机栈可以动态拓展，而且拓展时无法申请到足够的内存</li>
</ul>
<blockquote>
<p>**<code>①</code>**：栈桢是方法运行时期很重要的数据结构，在本书的 第8章 中对其进行详细讲解。</p>
</blockquote>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用**<code>非常相似</code>**，<code>区别</code>是本地方法栈为虚拟机使用到的<code>本地方法</code>服务，而虚拟机栈则是为虚拟机使用到的 <code>Java 方法</code>服务。</p>
<p>《Java 虚拟机规范》对本地方法栈中的方法使用的<code>语言</code>，<code>使用方式</code>，<code>数据结构</code>**<code>没有任何强制规定</code>**，具体的虚拟机可以根据需要自由地实现。例如 **<code>HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一</code>**。</p>
<h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p>对于 Java 应用程序来说，「**<code>堆</code><strong>」 是 虚拟机所管理的内存中</strong><code>最大的一块</code><strong>，堆也是线程中</strong><code>共享</code><strong>的一块内存区域，在</strong><code>虚拟机启动时创建</code>**。</p>
<blockquote>
<p>**<code>Java 堆中存放着几乎所有的对象实例</code>**。<code>《Java 虚拟机规范》</code> 中这样描述堆：所有的<code>对象实例</code>以及<code>数组</code>都应当在堆上分配。</p>
</blockquote>
<p><strong><code>Java 堆是垃圾收集器管理的内存区域</code>**，因此一些资料中它也被称为 GC 堆。从回收内存的角度来看，由于现代垃圾收集器大部分都是基于「</strong><code>分代收集</code><strong>」理论设计，所以 Java 堆中经常出现</strong><code>「新生代」、「老年代」、「永久代」、「Eden空间」、「From Survivor 空间」、「To Survivor 空间」</code><strong>等名词、这些区域的划分仅仅是一些垃圾收集器的</strong><code>共同特性</code><strong>或者</strong><code>设计风格</code><strong>而已，</strong><code>而非某个 Java 虚拟机具体实现的固有内存布局，更不是《Java 虚拟机规范》里对 Java 堆的进一步细致划分。</code>**</p>
<p>在**<code>十年前</code><strong>，以 <code>G1</code> 收集器的出现作为分界，作为业界绝对主流的 <code>HotSpot</code> 虚拟机的内部垃圾收集器全部基于「</strong><code>经典分代</code><strong>」设计，需要 <code>新生代</code>、<code>老年代</code>收集器搭配才能工作，在这样的背景下，上面的说法还算是不会产生太大歧义。但是</strong><code>到了今天</code><strong>，垃圾收集器技术与十年前已经不可用同日而语，</strong><code>HotSpot</code>** 里也出现了**<code>不采用 分代设计的新垃圾收集器</code>**，再按之前的说法来定义就有很多不准确的地方了。</p>
<blockquote>
<p>从分配内存的角度看：所有线程共享的 Java 堆中可以划分出多个<code>线程私有</code>的「**<code>分配缓冲区</code><strong>」（<a href="">Thread Local Allocation Buffer TLAB</a>）来</strong><code>提升对象分配时的效率</code>**。</p>
</blockquote>
<p>但是不管如何划分，都不会改变 <strong>Java堆中存储的内容的性质</strong>：无论哪个区域，存储的都只能是「<code>对象实例</code>」，将Java 堆进行细分的目的是为了**<code>更好地回收内存，或者更快的分配内存</code>**。</p>
<p>根据 <code>《Java 虚拟机规范》</code> 规定，<strong>Java 堆可以处于<code>物理上不连续</code>的内存空间中，但是<code>逻辑上是连续</code>的</strong>，这就像是用磁盘存储文件一样，并不要求每个文件连续存放，但对于大对象（比如数组）多数虚拟机实现出于简单、存储高效的考虑，很可能会要求连续的内存空间来存放数组。</p>
<p>Java堆可以是**<code>固定大小</code><strong>，也可以是</strong><code>可扩展</code><strong>的，通过 <code>-Xmx</code> 和 <code>-Xms</code> 参数设定。如果Java堆中没有足够的内存完成实例分配，并且堆也无法继续扩展，则抛出</strong><code>OOM内存溢出异常</code>**。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p><strong><code>方法区（Method Area)</code></strong> ：<strong>线程共享</strong>，存储已被虚拟机加载的<code>类型信息</code>、<code>常量</code>、<code>静态变量</code>、<code>即时编译器编译后的代码缓存</code>等数据。</p>
<blockquote>
<p>《Java 虚拟机规范》中把方法区描述为「**<code>堆的一个逻辑部分</code><strong>」，但是方法区有一个别名叫做「</strong><code>非堆</code>**」（Non-Heap），目的是与 Java堆区分开。</p>
</blockquote>
<p>到了 <strong><code>JDK8</code>**，</strong><code>完全废弃</code>了<code>永久代</code>的概念<strong>，此时<code>HotSpot</code> 与 <code>JRockit</code> 、<code>J9</code>一样，在</strong><code>本地内存</code><strong>中实现的</strong><code>元空间</code><strong>（Meta-sapace）代替了之前的永久代，将 JDK7 中永久代的剩余内容（主要是</strong><code>类型信息</code>**）移动到元空间中。</p>
<p><code>《Java 虚拟机规范》</code>对于方法区的约束非常宽松，<strong>该区域可以使用不连续的内存，可以选择固定大小和可扩展大小，甚至可以选择不实现垃圾收集</strong>。这部分区域的内存回收目标主要是针对「**<code>常量池</code><strong>」的<code>回收</code>和对Java **<code>类型的卸载</code>**，一般来说针对这个区域的回收<code>效果并不令人满意</code>，尤其是类型卸载的条件非常苛刻，但是对于这部分的回收又是必要的，之前出现过若干严重bug就是这部分区域的回收出现问题导致</strong><code>内存泄漏</code>**。</p>
<p>根据<code>《Java虚拟机规范》</code>规定，<code>方法区如果无法满足新的内存分配需求</code>，抛出 <code>OOM</code> 异常。</p>
<p><strong>为什么要将永久代（PermGen）替换为元空间（MetaSpace）呢？</strong></p>
<blockquote>
<p>其中一个原因是因为 <strong>永久代受 JVM本身设置影响，有固定的内存大小上限</strong>，而元空间使用的是机器的<code>直接内存</code>，只受本机可用内存限制，不会出现 <code>OOM</code> 异常。</p>
<p>可以使用 <code>-XX:MaxMetaSpaceSize</code> 设置最大元空间大小，默认值 <code>unlimited</code>。</p>
</blockquote>
<h3 id="运行时常量池-属于方法区"><a href="#运行时常量池-属于方法区" class="headerlink" title="运行时常量池(属于方法区)"></a>运行时常量池(属于方法区)</h3><p><strong><code>运行时常量池（Runtime Constant Pool）是方法区的一部分。</code></strong> <code>Class 文件</code>中除了有 <code>类的版本</code>、<code>字段</code>、<code>方法</code>、<code>接口</code>等**<code>描述信息</code><strong>外，还有一项信息是「</strong><code>常量池表</code><strong>」（Constant Pool Table），用于存放编译期生成的各种</strong><code>字面量</code><strong>与</strong><code>符号引用</code><strong>，这部分内容将在</strong>类加载后<strong>放到</strong><code>方法区的运行时常量池</code>**中。</p>
<p><strong><code>Java虚拟机对于 Class 文件的每一部分都有严格规定</code></strong> —— 例如每个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机<code>认可</code>、<code>加载</code>和<code>执行</code>，但<strong>对于运行时常量池，《Java 虚拟机规范》没有做任何细节要求</strong>，这使得不同提供商实现的虚拟机可以按照自己的需求来实现这个内存区域。</p>
<p>一般来说，除了保存 Class 文件中描述的**<code>符号引用</code><strong>外，还会把</strong><code>符号引用翻译出来的直接引用</code><strong>也</strong>存储在运行时常量池中**。①</p>
<p><strong><code>运行时常量池</code>**相对于 **<code>Class 文件常量池</code>**的另外一个重要特征是：</strong>具备动态性<strong>。 Java 语言并不要求常量一定只有在编译期才能产生，也就是说，并非只有预置在 Class 文件常量池中的内容才能进入方法区运行时常量池，在程序运行期间也可以将新的常量添加到池中。比如 <code>String</code> 类的 **<code>intern()</code></strong> 方法就是将字符串添加到运行时常量池中。</p>
<p><strong>运行时常量池是方法区的一部分，所以当常量池无法再申请到内存时会抛出 OOM 异常。</strong></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p><strong>直接内存不是虚拟机运行时数据区域的一部分</strong>，也不是《Java 虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且可能导致 OOM 异常出现，所以作者在这里一起进行讲解。</p>
<p><code>JDK 1.4</code> 中加入了 <code>NIO</code>（New Input/Output)类，引入了一种「**<code>基于通道</code><strong>」（Channel）与「</strong><code>缓冲区</code><strong>」（Buffer）的<code>I/O</code> 方式，</strong>它可以使用 <code>Native</code> 函数库直接分配堆外内存<strong>，然后通过一个存储在 <code>Java</code> 堆中的 **<code>DirectByteBuffer</code></strong> 对象作为这块内存的<strong>引用</strong>进行<strong>操作</strong>。<strong>这样在一些场景中能显著提高性能，因为避免了 <code>Java 堆</code>和 <code>Native 堆</code>之间来回<code>复制数据</code>的开销。</strong></p>
<p><code>本机直接内存</code>是不会受到 <code>Java堆</code>大小的限制，但是既然是内存，则肯定还是受到本机总内存（包括物理内存，SWAP 分区或者分页文件）大小以及处理器寻址空间的限制，一般<strong>配置虚拟机参数</strong>时，会根据实际内存设置 <code>-Xmx</code>等参数信息，但经常<code>忽略了直接内存</code>，如果<strong>各个内存区域的综合大于物理内存限制</strong>（包括实际物理内存和操作系统级的内存限制）从而导致动态扩展时内存不够，就会发生**<code>OOM异常</code>**。</p>
<h1 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h1><p><strong>本章主要内容：</strong> <code>HotSpot</code> 虚拟机在Java 堆 中<strong>对象分配</strong>、<strong>布局</strong>和<strong>访问</strong>的全过程。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>最简单最常用的创建对象的方式：使用 <code>new</code> 操作符。在虚拟机中，以下是虚拟机中普通对象（仅限普通 Java 对象，不包括数组和 Class 类型对象）的创建过程：</p>
<ol>
<li><p>当JVM 遇到一条内容是 <code>new</code> 的字节码指令时，**<code>首先检查</code>**这个指令的参数是否能在常量池<!--这里指的应该是方法区的运行常量池-->中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被<code>加载</code>、<code>解析</code>和<code>初始化</code>过。</p>
<ul>
<li><strong>如果没有，则执行</strong>「**<code>类加载</code>**」过程。这个过程在第7章中详细探讨。</li>
</ul>
</li>
<li><p>当类加载检查通过后，**<code>接下来虚拟机为新生对象分配内存</code>**。 对象所需的内存大小在类加载完成后就可以完全确定下来，为对象分配空间相当于把一块确定大小的内存块从 Java 堆中划分出来。</p>
<ul>
<li><p>如果Java 堆中的内存是绝对规整的，所有被使用过的内存都放在一边，没有使用的放在另一边，中间存在一个指针作为分界点的指示器，那么分配内存只需要将指向向空闲空间方向挪动一段与对象大小相等的距离即可，这种方式叫做「**<code>指针碰撞</code>**」（Bump The Pointer）。</p>
</li>
<li><p>如果 Java 堆中的内存并不是规整的，已被使用的内存和空间内存相互交错，那就没有办法简单地通过指针碰撞完成了，则虚拟机需要维护一个「**<code>空闲列表</code>**」（Free List）。</p>
</li>
<li><p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又取决于采用的垃圾收集器是否带有 「<strong>空间压缩整理</strong>」（Compact）能力决定。</p>
<ul>
<li>当使用 <strong><code>Serial</code>**、</strong><code>ParNew</code>**  <!--新生代收集器,serial,parnew,parallel scanvage都是标记复制--> 等带压缩整理过程的收集器时，系统采用的分配方法是「指针碰撞」，既简单又高效；</li>
<li>当使用 <strong><code>CMS</code></strong> 这种基于<code>清除（Sweep）算法</code>的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</li>
</ul>
</li>
<li><p>除了划分可用空间，还需要考虑对象的创建是非常频繁的行为，有可能存在正在给对象A 分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况，针对这个问题有两种解决方案：</p>
<ul>
<li>对分配内存空间的动作进行同步处理 —— 实际上虚拟机是采用 **<code>CAS（Compare And Swap）</code>**配上失败重试的方式保证更新操作的原子性</li>
<li>把内存分配动作按线程划分在不同的空间之中进行 —— 每个线程在 Java 堆中预先分配一小块内存空间，称为「本地线程缓冲（TLAB）」，哪个线程要分配内存，就在那个线程的本地缓冲区中进行分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。是否使用TLAB 可以使用参数 <code>XX: +/- UseTLAB</code> 参数设定</li>
</ul>
</li>
</ul>
</li>
<li><p>从<strong>虚拟机的视角</strong>来看，<strong>初始化零值之后</strong>一个<code>新的对象</code>就<code>已经产生</code>了。但是从<strong>Java程序视角</strong>来看，对象的创建才<code>刚刚开始</code>——构造函数还没有执行，所有的类实例字段都是默认的零值，对象需要的其他资源和状态信息也没有按照预定的意图构造好。<!--哈哈，这也是面试常常问的点--></p>
<ul>
<li>一般来说，由字节码流中的 <code>new</code> 指令后面是否跟随 <code>invoke special</code> 指令所决定， <strong>Java 编译器</strong>会在遇到 <code>new</code> 关键字的地方<strong>同时生成这两条字节码指令</strong>，但如果直接通过其他方式产生的对象则不一定如此。 new 指令之后会接着执行 <code>&lt;init&gt;()</code>方法，也就是构造函数中的对象初始化的内容，这样一个真正可用的对象才完全被构建完成。</li>
</ul>
</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MDE3MTQwLTgwMzc0ZTY1YzZiMjBjYmU" style="zoom: 50%;" />

<p>HotSpot虚拟机对象在堆内存的<strong>存储布局</strong>分为3个部分：</p>
<ul>
<li><code>对象头 Header</code></li>
<li><code>实例数据 InstnaceData</code></li>
<li><code>对齐填充 Padding</code></li>
</ul>
<p>对象头包括两类信息：</p>
<p><strong><code>第一类</code>**用于存储「</strong>对象自身的运行时数据<strong>」，如 <code>哈希码</code>（HashCode）、<code>GC 分代年龄</code>、<code>锁状态标志</code>、<code>线程持有的锁</code>、<code>偏向线程ID</code>、<code>偏向时间戳等</code>。这部分数据在 32位和64位虚拟机中的长度分别为 32 和 64 个比特，官方称这部分为 “**Mark Word</strong>“</p>
<p>对象需要存储的运行时数据很多，其实已经超出了 32、64位 <code>Bitmap</code> 结构所能记录的最大限度，但是对象头里的信息是<strong>与对象自身定义的数据无关的额外存储成本</strong>，考虑到虚拟机的空间效率，Mark Word 被设计成一个有着<strong>动态定义的数据结构</strong>，目的是在<strong>极小的空间内存储尽可能多的数据，根据对象的状态复用自己的存储空间</strong>。</p>
<p>例如在 32位 的 HotSpot 虚拟机中，对象未被同步锁锁定的状态下， Mark Word 的 32个 比特存储空间中的 <code>25个 比特存储对象哈希吗，4个比特存储对象分代年龄，2个比特存储锁标志位，1个比特固定为0</code>.</p>
<p>在其他状态（轻量级锁定，重量级锁定，GC标记、可偏向）下对象的存储内容如下表所示：</p>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>对象哈希码、对象分代年龄</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向锁记录的指针</td>
<td>00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td>10</td>
<td>膨胀（重量级锁定）</td>
</tr>
<tr>
<td>空、不需要记录信息</td>
<td>11</td>
<td>GC 标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
</tbody></table>
<p>对象头中的另一部分存储的是 「<strong>类型指针</strong>」，即对象指向它的类型元数据的指针（也就是 Class类？），Java 虚拟机通过这个指针来确定该对象是哪个类的实例。</p>
<p>并不是所有虚拟机实现都必须在对象数据上保留类型指针，也就是说查<strong>找对象的元数据信息并不一定要经过对象本身</strong>。</p>
<p>如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录<strong>数组长度</strong>的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是如果数组的长度是不确定的，则无法通过元数据中的信息推断出数组的大小。</p>
<h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p>创建对象的目的当然是访问对象，访问对象首先需要定位对象。 Java 程序通过<strong>栈上</strong> <code>reference</code> 数据来操作堆上的具体对象。对象的具体访问方式由虚拟机自己实现，《Java 虚拟机规范》中对于 reference 只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问对象。</p>
<p>目前的主流方式有两种：</p>
<ol>
<li>**<code>使用句柄</code>**。</li>
<li>**<code>直接指针</code>**。</li>
</ol>
<ul>
<li>如果使用句柄，则 Java 堆中可能会划分出一块内存用来作为「**<code>句柄池</code><strong>」，<code>reference</code> 中存储的就是对象的<code>句柄地址</code>，而句柄中包含了「</strong><code>对象实例数据</code><strong>」与「</strong><code>类型数据</code>**」各自具体的地址信息。</li>
</ul>
<p><img src="http://static.oschina.net/uploads/space/2012/0219/232926_WTnX_103999.png"></p>
<ul>
<li>如果使用直接指针访问， Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li>
</ul>
<p><img src="http://static.oschina.net/uploads/space/2012/0219/232935_FM5T_103999.png"></p>
<p>这两种访问方式<code>各有优势</code>：使用句柄访问最大的好处是在 <code>reference</code> 中存储的是<strong>稳定句柄地址</strong>，在<strong>对象被移动</strong>（垃圾收集时移动对象是非常普遍的行为）<strong>时</strong>只需要<code>改变句柄中的实例数据指针</code>，而 <code>reference</code> <strong>本身不需要被修改。</strong></p>
<p>使用直接指针访问最大的好处就是速度更快，省去了一次指针定位的时间开销，由于对象访问这个操作在虚拟机中非常频繁，所以这类开销积少成多也是一项极为客观的执行成本。</p>
<p><code>HotSpot</code> 主要使用第二种方式进行对象访问（也存在例外，如果使用了 <code>Shenandoah</code> 收集器也会有一次额外的转发）。</p>
<p>但是在各种语言、框架中使用句柄来访问对象的方式也十分常见。</p>
<p>​            </p>
<h2 id="实验课："><a href="#实验课：" class="headerlink" title="实验课："></a>实验课：</h2><p>-XX:+PrintGCDetails</p>
<ol>
<li>堆异常<ol>
<li>通过参数-Xms20M   -Xmx20M 控制</li>
</ol>
</li>
<li>栈异常<ol>
<li>通过-Xss128k</li>
</ol>
</li>
<li>方法区和运行时常量区异常<ol>
<li>通过-XX:PermSize=10M -XX:MaxPermSize=10M</li>
<li>String.intern()方法是一个Native方法，如果字符串常量池中已经包含了一个等于此String对象的字符串，则返回，否则，直接将此String对象包含的字符串加到常量池中，并返回引用。</li>
<li>小补充：比如CGLIB这种类增强技术，需要很大的方法区保证动态生成的Class可以加载到内存</li>
<li>现在jdk越来越“去永久代“</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter3%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter3%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/" class="post-title-link" itemprop="url">chapter3对象的共享</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-13 09:19:03" itemprop="dateCreated datePublished" datetime="2020-11-13T09:19:03+08:00">2020-11-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-20 11:13:16" itemprop="dateModified" datetime="2021-03-20T11:13:16+08:00">2021-03-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Abstract：第二章开头指出，要编写正确的并发程序，关键在与：在访问共享的可变状态时，需要正确的管理。第二章通过<strong>同步</strong>，避免多个线程同时访问相同的变量 (在《高性能MySQL》书中，这叫做<strong>避免并发</strong>)；而本章介绍如何<strong>共享</strong>和<strong>发布对象</strong>，从而使多个线程可以同时安全的访问相同的变量。这两章合在一起就形成了构建线程安全类以及通过java.util.concurrent类库来构建并发应用程序的重要基础。</p>
<p><a href="">synchronized不仅仅只有原子性，还具有内存可见性</a>。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化<!--这种内存可见性像MySQL中所说的Read Uncomitted事务隔离级别的可见性-->。如果没有同步，那么这种情况就无法实现。你可以通过显式地同步或者类库中内置的同步来保证对象被安全地发布。</p>
<!--这里注意：synchronized保障了变量不可修改，但是这个变量必须在同步代码块执行完了，才能被其他线程访问到最新变化。所以，我现在希望这个变量的变化，在同步代码块还没执行完时，就能及时被其他线程获取到最新数据，怎么办呢？就是volatile,使用可见性-->

<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready)</span><br><span class="line">                Thread.yield();</span><br><span class="line"><span class="comment">//这里可能输出0，也可能永远都不会输出</span></span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可能会产生两个问题</p>
<ul>
<li>一是程序可能一直保持循环，因为对于读线程来说，ready的值可能永远不可见。</li>
<li>二是输入的number为0，这是因为重排序引起的，在写线程将ready与number从工作内存中写回到主内存中时，在没有同步的机制下，先写ready还是先写number这是不确定的，也就是说将它们写回到主内存时的顺序可能与程序逻辑顺序恰好相反，这是因为在单个线程下，只要重排序不会对结果产生影响，这是允许的。<!--在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。-->

</li>
</ul>
<h3 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h3><p>除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。</p>
<p>上面NoVisibility程序在多线程环境下还可能读取到过期数据，比如当ready为true时，写线程已将number域的值置为了42，但在它还未来得及将这个新值从工作内存中写回到主内存前，读线程就已将ready从主内存中读取出来了，这时的值还是为初始的默认值0，这个值显然是一个已过期了的值，因为number现在真的值应该为42，而不是0。</p>
<!--拓展：在没有同步的情况下读取数据类似于数据库中使用READ_UNCOMMITTED（未提交读）隔离级别，这时你更愿意用准确性来交换性能。-->

<p>在NoVisibility中，过期数据可能导致它打印错误数值，或者程序无法终止。过期数据可能会使对象引用中的数据更加复杂，比如链指针在链表中的实现。过期数据还可能引发严重且混乱的错误，比如意外的异常，脏的数据结构，错误的计算和无限的循环。</p>
<p>下面的程序更对过期数据尤为敏感：如果一个线程调用了set，但还未来得及将这个新值写回到主内存中时，而另一个线程此时正在调用get，它就可能看不到更新的数据了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将set与get同步，使之成为线程安全的。注，仅仅同步某个方法是没有用的。</p>
<h3 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h3><p>非volatile类型的64位数值变量（double和long）。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，当对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值得低32位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。</p>
<h3 id="锁和可见性"><a href="#锁和可见性" class="headerlink" title="锁和可见性"></a>锁和可见性</h3><p>内置锁可以用来确保一个线程以某种可预见的方法看到另一个线程的影响，像下图一样。当B执行到与A相同的锁监视的同步块时，A在同步块之中所做的每件事，对B都是可见的，如果没有同步，就没有这样的保证。<br><img src="https://img-blog.csdnimg.cn/20190316230729391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTUxOTgz,size_16,color_FFFFFF,t_70" style="zoom:67%;" /></p>
<p>现在我们可以进一步理解为什么在访问某个共享且可变的变量时要求所有线程在<strong>同一个锁上同步</strong>，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果一个线程在未持有正确锁的情况下去读某个变量，那么读到的可能是一个失效值。</p>
<blockquote>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
</blockquote>
<h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><p>volatile是一种弱同步的形式，它确保对一个变量的更新后对其他线程是可见的。当一个域声明为volatile类型后，编译器与运行时会监视这个变量：它是共享的，而且对它的操作不会与其他的内存操作一起被重排序。volatile变量不会缓存在寄存器或者缓存其他处理器隐藏的地方 ==&gt; 所以，<strong>读一个volatile类型的变量时，总会返回由某一线程所写入的最新值</strong>。</p>
<p><strong>读取volatile变量的操作不会加锁，也就不会引起执行线程的阻塞</strong>，<!--允许并发访问进行读-->这使得volatile变量相对于sychronized而言，只是轻量级的同步机制<!--针对可见性而言-->。</p>
<p>volatile变量对可见性的影响所产生的价值远远高于变量本身。线程A向volatile变量写入值，随后线程B读取该变量，所有A执行写操作前可见的变量的值，在B读取了这个volatile变量后，对B也是可见的（与解锁前所有动作对后继加锁后的动作可见是一样的）。所以<a href="">从内存可见性的角度来看</a>，写入volatile变量就像退出同步块，读取volatile变量就像进入同步块。但是我们并不推荐过度依赖volatile变量所提供的可见性。因为依赖volatile变量来控制状态可见性的代码，比使用锁的代码更脆弱，更难以理解。</p>
<blockquote>
<p>仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标示一些重要的程序生命周期事件的发生（例如，初始化或关闭）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一定要加上volatile，否则其他线程更新后可能不可见，因为必须等到执行线程同的步代码块全部执行完，其他线程才能看见</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> asleep;</span><br><span class="line"><span class="keyword">while</span> (!asleep)</span><br><span class="line">    countSomeSheep();</span><br></pre></td></tr></table></figure>

<p>volatile变量固然方便，但也存在限制，它们通常被当作标识完成、中断、状态的标记使用，比如上面程序中的asleep变量。尽管volatile也可以用来标示其他类型的状态信息，但是<strong>决定这样做之前请格外小心，如volatile的语义不足以使用自增操作（i++）原子化。</strong></p>
<blockquote>
<p>加锁可以保证可见性与原子性；volatile变量只能保证可见性。</p>
</blockquote>
<p>只有满足了下面所有的标准后，你才能使用volatile变量：<!--其实就是不需要保证原子性，只需要可见性--><br>1、 写入变量时并不依赖变量的当前值；或者能够能够确保只有单一线程修改变量的值；<br>2、 变量不需要与其他的状态变量共同参与不变约束；<br>3、 访问变量时，没有其他的原因需要加锁。</p>
<h2 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h2><p><strong>发布</strong>一个对象的意思是，使对象能够被当前作用域之外的代码中使用。比如将一个指向该对象的引用存储到其他代码可以访问的地方、在一个非私有的方法中返回这个引用、也可以把它传递到共他类的方法中。在很多情况下，我们需要确保对象及它们的内部状态不被暴露，在另外一些情况下，为了正当的使用目的，我们又的确希望发布一个对象，这时为了线程安全可能需要同步。如果变量发布了内部状态，就可能危及到封装性，并使用程序难以维持稳定；如果发布对象时，它还没有完成构造，同样危及线程安全。一个对象在尚未准备地时就将它发布，这种情况称作<strong>逸出</strong>。下面看看一个对象是如何逸出的。</p>
<h3 id="直接发布对象"><a href="#直接发布对象" class="headerlink" title="直接发布对象"></a>直接发布对象</h3><p>最常见的发布对象的方式是将对象的引用存储到公共静态域，任何类和线程都能看到这个域。initialize方法实例化一个新的HashSet实例，并通过将它存储到knownSecrets引用，从而发布了这个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发布对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    knownSecrets = <span class="keyword">new</span> HashSet&lt;Secret&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="间接发布对象"><a href="#间接发布对象" class="headerlink" title="间接发布对象"></a>间接发布对象</h3><p>发布一个对象还会间接地发布其他对象。如果你将一个Secret对象加入集合knownSecrets中，你就已经发布了这个对象，因为任何代码都可以遍历并获得新Secret对象的引用。类似地，从非私有方法中返回引用，也能发布返回的对象，下面发布了包含洲名的数组，而这个数组本应是私有的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部可变的数据逸出（不要这样做）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">&quot;AK&quot;</span>, <span class="string">&quot;AL&quot;</span> ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123; <span class="keyword">return</span> states; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以这种方式发布states会出问题，这样会允许内部可变的数据逸出，请不要这样做。因为任何一个调用者都能修改它的内容。在这个例子中，数组states已经逸出了它所属的范围，这个本就是私有的数据，事实上已经变成公有的了。</p>
<p><strong>当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。一般来说，如果一个已经发布的对象通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。</strong></p>
<p>假定有一个类C，对于C来说，“外部方法”是指行为并不完全由C来规定的方法，包括其他类中定义的方法以及类C中可以被改写的方法（既不是私有[private]方法也不是终结[final]方法）。当把一个对象传递给某个外部方法时，就相当于发布了这个对象。</p>
<p>无论其他的线程会对已发布的线程执行何种操作，其实都不重要，因为误用该引用的风险始终存在。当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。</p>
<p>最后一种发布对象和它的内部状态的机制是发布一个内部类实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="keyword">new</span> EventListener() &#123;<span class="comment">//会过早地暴露this</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当ThisEscape发布EventListener时，也隐含地发布了ThisEscape实例本身，因为在这个内部类的实例中包含了对ThisEscape实例的隐含引用。</p>
<h3 id="安全对象构造过程"><a href="#安全对象构造过程" class="headerlink" title="安全对象构造过程"></a>安全对象构造过程</h3><p><a href="">当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态</a>。从构造函数内部发布的对象，只是一个未完成构造的对象。甚至即使是在构造函数的最后一行发布的引用也是如此。如果this引用在构造器中逸出，这样的对象被认为是“没有正确构建的”，所以不要让this引用在构造期间逸出。</p>
<blockquote>
<p>不要在构造构造过程中使this引用逸出</p>
</blockquote>
<p>一个导致this引用在构造期间逸出的常见错误，是在构造函数中创建局部、匿名线程并启动它或者启动一个线程并显示地将this传递过去，这都是不安全的，因为新的线程在所属对象完成构造前就能看见了。在构造器中创建线程并没有错，但是最好不要立即启动它，取而代之的是，发布一个start或initialize方法来启动对象拥有的线程。</p>
<p>另外，构造器中调用一个覆盖的实例方法（既不是私有方法，也不是终结方法）同样会导致this引用在构造期间逸出。</p>
<p>如果想要在构造器中注册监听器或启动线程，你可以使用一个私有的构造函数和一个公有的工厂方法，这样避免了不正确的构造过程。<br>下面是使用工厂方法防止this引用在构造期间逸出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span> </span>&#123;<span class="comment">//私有构造器</span></span><br><span class="line">        listener = <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态 工厂方法安全发布对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        SafeListener safe = <span class="keyword">new</span> SafeListener();<span class="comment">//等构造完后再注册</span></span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;<span class="comment">//安全发布对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有当构造函数返回时，this引用才应该从线程中逸出。构造函数可以将this引用保存到某个地方，只要其他线程不会在构造函数完成之前使用它。</p>
</blockquote>
<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭。它是实现线程安全性最简单的方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。</p>
<p>在Java语言中并没有强制规定某个变量由锁来保护，同样在Java语言中也无法强制将对象封闭在某个线程中。线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。Java语言及其核心库提供了一些核心机制来帮助维持线程封闭性，例如局部变量和ThreadLocal类，即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。</p>
<h3 id="Ad-hoc-线程封闭"><a href="#Ad-hoc-线程封闭" class="headerlink" title="Ad-hoc 线程封闭"></a>Ad-hoc 线程封闭</h3><p>Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。由于Ad-hoc 线程封闭技术的脆弱性，因此在程序中尽量很少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或ThreadLocal类）。</p>
<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中<!--更准确的说，是栈帧中-->，其他线程无法访问这个栈。</p>
<p>局部变量是线程安全的，只要我们不要将它们逸出。</p>
<h3 id="ThreadLocal-类"><a href="#ThreadLocal-类" class="headerlink" title="ThreadLocal 类"></a>ThreadLocal 类</h3><p>这个类能使先回城中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前线程在调用set时设置的最新值。</p>
<p>ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。</p>
<p>例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有自己的连接，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder </span><br><span class="line">    = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conncetionHolder.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用这项技术。</p>
<p>当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。从概念上看，你可以将ThreadLocal<T>视为包含了Map&lt; Thread,T&gt;对象，其中保存了特定于该线程的值，当ThreadLocal的实现并非如此。这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。</p>
<p>假设你需要将一个单线程应用程序移植到多程序环境中，通过将共享的全局变量转换为ThreadLocal（如果全局变量的语义允许），可以维护线程安全性。然而，如果将应用程序范围内的转换为线程局部的缓存，就不会有太大作用<!--这是因为缓存本来就是全局唯一，供所有的线程共享，如果转换为ThreadLocal，那么每个线程都会有一个缓存，缓存就失去原本的意义-->。</p>
<p>开发人员经常滥用ThreadLocal，例如将所有全局变量都作为ThreadLocal对象，或者作为一种“隐藏”方法参数的手段。ThreadLocal变量类似于全局变量，他能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。</p>
<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>满足同步需求的另一种方法是使用不可变对象。</p>
<p>创建后状态不能被修改的对象叫做不可变对象。不可变对象天生就是线程安全。它们常量域是在构造函数中创建的。既然它们的状态无法被修改，这些常量永远不会变。所以不可变对象永远是线程安全的。</p>
<blockquote>
<p>不可变对象一定是线程安全的。</p>
</blockquote>
<p>不可变性并不简单地等于将对象中的所有域都声明为final类型，所有域都是final类型的对象仍然可能是可变的，因为final域可以获得一个到可变对象的引用。</p>
<blockquote>
<p>只有满足如下状态，一个对象才是不可变的：<br>1、 对象的状态不能在创建后再被修改；<br>2、 对象的所有域都是final类型；<br>3、 对象被正确创建（创建期间没有发生this引用逸出）。</p>
</blockquote>
<p>在不可变对象的内部，同样可以使用可变性对象来管理它们的状态，如下面代码，虽然域stooges是可变的，但它满足了以上三点，所以是一个不可变对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span><span class="comment">//不可变对象可以基于可变对象来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stooges.add(<span class="string">&quot;Moe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final域"><a href="#final域" class="headerlink" title="final域"></a>final域</h3><p>final类型的域时不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的<!--毕竟final类型的域，其实是个地址，这个地址是不可变的，但是地址指向的对象是可变的-->）。然而，在Java内存模型中，final域还有着特殊的语义。final域能确保初始化过程的安全性 <!--???why？看下边注解-->，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。</p>
<!--
我们认为的执行过程是怎么样的呢？
（1）给Holder对象分配内存
（2）调用Holder的构造函数，也就是给n赋值的过程，初始化了成员字段
（3）将holder引用指向我们分配的内存空间
我们认为既然第3步已经执行了（holder引用已经指向最新了），那1、2步肯定已经完成了。可是，在JVM自身的性能优化中，是允许这个顺序乱序执行的。也就是说，它不能保证执行的顺序是1、2、3，也有可能是1、3、2。假设执行了1、3，这是引用已经是最新的了，但2的构造函数没有执行，那你的对象的状态值就是失效的，另一个线程调用assertSanity自然会报出异常
-->

<!--
对于含有final域的对象，JVM必须保证对对象的初始引用在构造函数之后执行，不能乱序执行（out of order），也就是可以保证一旦你得到了引用，final域的值都是完成了初始化的，也就是书中所说的“初始化安全性”的保证。
-->

<p>仅包含一个或两个可变状态的“基本不可变”对象仍然比包含多个可变状态的对象简单。通过将域声明为final类型的，也相当于告诉维护人员这些域时不会变化的。</p>
<blockquote>
<p>正如“除非需要更高的可见性，否则应将所有的域声明为私有域是一个良好的编程习惯，”除非需要某个域是可变的，否则应将其声明为final域“也是一个良好的编程习惯。</p>
</blockquote>
<h3 id="示例：使用Volatile类型来发布不可变对象-我称之为对象封闭"><a href="#示例：使用Volatile类型来发布不可变对象-我称之为对象封闭" class="headerlink" title="示例：使用Volatile类型来发布不可变对象(我称之为对象封闭)"></a>示例：使用Volatile类型来发布不可变对象(我称之为对象封闭)</h3><h4 id="发生竞态条件"><a href="#发生竞态条件" class="headerlink" title="发生竞态条件"></a>发生竞态条件</h4><p>尽管原子引用自身是线程安全的，不过UnsafeCachingFactorizer中存在竞争条件 <!--"读取-修改-写入"，并且违背了约束条件，读取了过期数据-->，当前线程在执行到A 与 B之间或者C 与 D之间，都有可能切换到其他线程，从而造成错误的结果。<!--这里的线程安全问题，是lastNumber和lastFactors不一致--></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有正确原子化的Servlet试图缓存它的最新结果。</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCachingFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger&gt; lastNumber</span><br><span class="line">         = <span class="keyword">new</span> AtomicReference&lt;BigInteger&gt;();<span class="comment">//缓存最后一次客户请求因式分解的数</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger[]&gt;  lastFactors</span><br><span class="line">         = <span class="keyword">new</span> AtomicReference&lt;BigInteger[]&gt;();<span class="comment">//缓存最后一次客户请求因式分解的结果</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">         BigInteger i = extractFromRequest(req);</span><br><span class="line">       	 <span class="comment">//先检查后执行，必须保证lastNumber不是过期数据</span></span><br><span class="line">         <span class="keyword">if</span> (i.equals(lastNumber.get()))<span class="comment">//A</span></span><br><span class="line">             encodeIntoResponse(resp,  lastFactors.get() );<span class="comment">//B</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             BigInteger[] factors = factor(i);</span><br><span class="line">           	 <span class="comment">//lastNumber和lastFactors必须维持状态的约束条件</span></span><br><span class="line">             lastNumber.set(i);<span class="comment">//C</span></span><br><span class="line">             lastFactors.set(factors);<span class="comment">//D</span></span><br><span class="line">             encodeIntoResponse(resp, factors);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决竞态条件"><a href="#解决竞态条件" class="headerlink" title="解决竞态条件"></a>解决竞态条件</h4><p><a href="">如果上面的A与B这个复合操作操作、以及C与D这个复合操作如果是原子性的，那么将不会出现线程安全性问题。</a><!--比如使用chapter2中synchronized加锁--></p>
<p><a href="">如果为这两组操作创建一个不可变的类，即使在不使用同步的情况也能解决安全共享问题。</a> </p>
<p>下面就为UnsafeCachingFactorizer创建一个OneValueCache类，对以上操作进行了封装，它是一个不可变对象，进（构造时传进的参数）出（使用时）都对状态进行了拷贝。因为BigInteger是不可变的，所以直接使用了Arrays.copyOf来进行拷贝了，如果状态所指引的对象不是不可变对象时，就要不能使用这项技术了，因为外界可以对这些状态所指引的对象进行修改，如果这样只能使用new或深度克隆技术来进行拷贝了。</p>
<blockquote>
<p>每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber  = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于在访问和更新多个相关变量时出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。</p>
<ul>
<li><p>如果是一个可变的对象，那么就必须使用锁来确保原子性。</p>
</li>
<li><p>如果是一个不可变对象，那么当线程获得了对该对象的引用后，就不必担心另一个线程会修改对象的状态。</p>
</li>
<li><p>如果要更新这些变量，那么可以创建一个新的容器对象，但其他使用原有对象的线程仍然会看到对象处于一致的状态。</p>
</li>
</ul>
<p>当一个线程将volatile类型的cache设置为引用一个新的OndeValueCache时，其实线程就会立即看到新缓存的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache =</span><br><span class="line">        <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//使用volatile安全发布</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            <span class="comment">//由于cache为volatile，所以最新值立即能让其它线程可见</span></span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与cache相关的操作不会相互干扰，因为OneValueCache是不可变的，并且在每条相应的代码路径中只会访问它一次 。通过使用包含过个状态变量的容器对象来维护不可变条件，并使用一个volatile类型的引用来确保可见性，使得Volatile Cached Factorizer在没有显式地使用锁的情况下仍然是线程安全的。</p>
<h3 id="我个人的疑惑"><a href="#我个人的疑惑" class="headerlink" title="我个人的疑惑"></a>我个人的疑惑</h3><h4 id="我的分析"><a href="#我的分析" class="headerlink" title="我的分析"></a>我的分析</h4><ul>
<li>程序清单3-13中存在『先检查后执行』（Check-Then-Act）的竞态条件。</li>
<li>OneValueCache类的<strong>不可变性</strong>仅保证了对象的原子性。</li>
<li>volatile仅保证可见性，无法保证线程安全性。</li>
</ul>
<p><strong>综上，对象的不可变性+volatile可见性，并不能解决竞态条件的并发问题，所以原文的这段结论是错误的。</strong></p>
<blockquote>
<p>比如，假设现在缓存lastNumber是x，lastFactor是y</p>
<p>线程A进入cache.getFactor（i）函数中的else语句Arrays.copyOf(lastFactors, lastFactors.length);，</p>
<p>线程B判断没有缓存</p>
<p>线程B更新了OneValueCache，</p>
<p>线程A获取了的是失效的缓存之值1,这不应该啊，线程A获取的不应该是失效的值，这不就线程不安全了吗？</p>
</blockquote>
<p>简单代码1: 对操作封装在一个类中</p>
<ul>
<li>将先检查后执行操作A、B，还有约束条件C、D，封装为一个类的同步方法</li>
<li>这么做，其实和chapter2的代码一样，每个请求阻塞、串行执行，并发效率低</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getFactors</span><span class="params">(BigInteger i)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">if</span> (i.equals(lastNumber.get()))<span class="comment">//A</span></span><br><span class="line">             encodeIntoResponse(resp,  lastFactors.get() );<span class="comment">//B</span></span><br><span class="line">      	<span class="keyword">else</span> &#123;</span><br><span class="line">             BigInteger[] factors = factor(i);</span><br><span class="line">             lastNumber.set(i);<span class="comment">//C</span></span><br><span class="line">             lastFactors.set(factors);<span class="comment">//D</span></span><br><span class="line">             encodeIntoResponse(resp, factors);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单代码2: 鉴于代码1只对方法进行了封装，再考虑对类的数据进行了封装</p>
<ul>
<li>把lastNum和lastFactors变量进行封装，放在一个类中OneValueCache，使得lastNum和lastFactors能维持约束性，从而保证线程安全</li>
<li>以前的A、B操作，是判断lastNum和返回lastFactors; 现在的A、B操作，是交给OneValueCache类判断和OneValueCache类返回。好像线程安全性问题还是没有解决？<ul>
<li>线程安全有没有解决，就是看OneValueCache能不能维持lastNum和lastFactors约束性？当然可以！</li>
<li>写操作：因为OneValueCache能被写入的操作，只有构造函数；而且cache = new OneValueCache(i, factors)中的i和factor(i)属于方法的临时变量，是线程安全的</li>
<li>读操作：因为cache.getFactors(i)第一次用于判断，第二次用于返回，在此期间，其他线程会通过构造函数修改cache，可能会失效，所以线程不安全</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber  = i;</span><br><span class="line">        lastFactors = factors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> lastFactors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req); <span class="comment">//局部变量，没有线程安全性 </span></span><br><span class="line">        <span class="keyword">if</span> ( cache.getFactors(i) != <span class="keyword">null</span>) &#123; <span class="comment">//判断是否命中缓存, 对应以前的A</span></span><br><span class="line">             encodeIntoResponse(resp, cache.getFactors(i)); <span class="comment">//对应以前的B </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         		BigIntegers[] factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">          	encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单代码3: 鉴于代码2中只有读cache时，可能2次获取的cache.getFactors(i)不一致，产生线程不安全，所以现在想办法保证读操作时，保证2次获取的cache.getFactors(i)的约束性，就OK了</p>
<ul>
<li>使用临时变量BigInteger[] factors, 保存cache.getFactors(i)；再使得factors线程安全<ul>
<li>前半部分很简单</li>
<li>后半部分，使factors线程安全，常见的解决方法就是使factors变成临时变量or不可变，那么就可以让cache.getFactors(i)每次返回的都是一个新的句柄和一个新的句柄指向的对象，这样在方法中就成为了一个局部变量，每个线程都有自己的一个句柄和句柄指向的对象，那么factors句柄就不会被其他线程获取</li>
<li>使用Arrays.copyOf()</li>
</ul>
</li>
<li>再想一想，写操作本身维持了约束，但是因为构造函数中lastFactors = factors，把lastFactors通过factors暴露出来了，就是逸出了，调用者可以通过factors修改lastFactors数据，那会不会有什么影响？<ul>
<li>目前来看，没有线程安全问题；但是lastFactors不能逸出被其他调用者修改，所以也需要Arrays.copyOf()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber  = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> Arrays.copyOf(lastFactors,lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req); <span class="comment">//局部变量，没有线程安全性 </span></span><br><span class="line">      	BigIntegers[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> ( factors != <span class="keyword">null</span>) &#123; <span class="comment">//判断是否命中缓存, 此时factors指向的对象，只有该线程能访问，其他线程无法访问，所以对象不可变</span></span><br><span class="line">             encodeIntoResponse(resp, factors); <span class="comment">//对应以前的B，factors由于不可变性，所以安全 </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         		factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">          	encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单代码4: 简单代码3已经做到了很好的线程安全性</p>
<ul>
<li>对象初始化也需要安全，所以使用final修饰</li>
</ul>
<h4 id="作者的本意"><a href="#作者的本意" class="headerlink" title="作者的本意"></a>作者的本意</h4><p><strong>Short answer:</strong></p>
<p><a href="">Thread safety is not really an absolute</a>. You have to determine the desired behavior, and <em>then</em> ask whether the implementation gives you that behavior that in the presence of multithreading.</p>
<p><strong>Longer answer:</strong></p>
<p>So, what’s the desired behavior here? Is it just that the right answer is always given, or is it also that it’s always implemented exactly once if two threads ask for it in a row?</p>
<p>If it’s the latter — that is, if you really want to save every bit of CPU — then you’re right, this isn’t thread-safe. <a href="">Two requests could come in at the same time (or close enough to it) to get the factors for the same number N, and if the timings worked out, both threads could end up calculating that number.</a> <!--这就是我疑惑的地方，但是程序目的并不是这样；如果要达到这种程度的线程安全性，使用锁来保证线程之间的执行顺序，避免重复计算，就像解决Redis缓存击穿--></p>
<p>But with a single-value cache, you already have the problem of recalculating things you already knew. For instance, <a href="">what if three requests come in, for N, K, and N again? The request for K would invalidate the cache at N, and so you’d have to recalculate it.</a><!----></p>
<p>So, this cache is really optimized for “streaks” of the same value, and as such the cost of twice-calculating the first couple (or even few!) answers in that streak might be an acceptable cost: in return, you get code that’s free of any blocking and pretty simple to understand.</p>
<p><a href="">What’s crucial is that it never gives you the <em>wrong</em> answer. That is, if you ask for N and K at the same time, the response for K should never give you the answer for N. This implementation gets you that guarantee, so I would call it thread safe.</a><!--程序的目的是为了保证状态的约束性，就是lastNumbers和lastFactors一致--></p>
<h4 id="使用Arrays-copyOf的目的"><a href="#使用Arrays-copyOf的目的" class="headerlink" title="使用Arrays.copyOf的目的"></a>使用Arrays.copyOf的目的</h4><p><a href="">其实就是返回一个新的句柄和句柄所指向新的对象</a></p>
<p>If you return <code>this.lastFactors</code> instead of returning a copy, the caller can do (for example)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigInteger[] lastFactors = cache.getFactors(...);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastFactors.length; i++) &#123;</span><br><span class="line">    lastFactors[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and thus mutate the state of the cache, which is supposed to be immutable.</p>
<p>The explanation is similar for the constructor. If the constructor didn’t make a copy, the caller could do</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">factors = factor(i);</span><br><span class="line">cache = <span class="keyword">new</span> OneValueCache(i, factors); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastFactors.length; i++) &#123;</span><br><span class="line">    factors[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and thus once again mutate the state of the cache.</p>
<p>Rule of thumb: an array is always mutable (except the empty array). So, if the state of an immutable class contains an array, then the caller must not be able to have a reference to the array.</p>
<h4 id="使用final的目的"><a href="#使用final的目的" class="headerlink" title="使用final的目的"></a>使用final的目的</h4><p>为了保障对象初始化的线程安全</p>
<h4 id="使用volatile的目的"><a href="#使用volatile的目的" class="headerlink" title="使用volatile的目的"></a>使用volatile的目的</h4><p>因为程序并没有使用锁，而是通过不可变对象，使得每个线程获取到的都是一个新句柄和新内存（在线程调用的方法中就是局部变量），所以不会有线程安全性问题</p>
<p>现在程序有个这样的情况</p>
<ul>
<li>比如3个请求R1, R2, R1，第2个R1会再次计算，这其实是正常情况</li>
<li>比如2个请求R2, R1, R1，第1和第2个R1可能也都会计算，所以使用volatile尽可能地将最新的结果通知其他线程，最大可能避免重复计算；比如第1个R1把新的结果写入内存，即使R1线程没执行完，但是R2已经获取了最新结果了。</li>
</ul>
<h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><p>到目前为止，我们重点讨论的是如何确保对象不被发布，比如让对象封闭在线程或者另一个对象内部。当然，我们希望多个线程间安全地进行共享数据。下面程序中简单地将对象的引用存储到public域中，这不足以安全地发布它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不安全的发布：在没有适当的同步情况下就发布对象</span></span><br><span class="line"><span class="keyword">public</span> Holder holder;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于存在可见性问题，其他线程看到的Holder对象将处于不一致的状态，即便在该对象的构造函数中已经正确地构建了不变性条件。这种不正确的发布导致其他线程看到尚未创建完成的对象。</p>
<h3 id="不正确的发布：正确的对象被破坏"><a href="#不正确的发布：正确的对象被破坏" class="headerlink" title="不正确的发布：正确的对象被破坏"></a>不正确的发布：正确的对象被破坏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n != n)<span class="comment">//在不正确的发布中，是很有可能出现不等</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;This statement is false.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序的问题是由于对象的可见性问题引起的，发布的对象可能还处于构造期间，所以是不稳定的。因为没有同步来确保Holder对其他线程可见，所以我们称Holder是“非正确发布”。</p>
<p>由于上面 n != n 会从主存中两次读取，这有可能从这两次读操作间切换到其他线程，这就有可能出 n!=n奇怪的问题。</p>
<!--看看stack上，大神怎么解释的-->

<blockquote>
<p>he reason why this is possible is that Java has a weak memory model. It does not guarantee ordering of read and writes.</p>
<p>This particular problem can be reproduced with the following two code snippets representing two threads.</p>
<p>Thread 1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someStaticVariable = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>Thread 2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someStaticVariable.assertSanity(); <span class="comment">// can throw</span></span><br></pre></td></tr></table></figure>

<p>On the surface it seems impossible that this could ever occur. In order to understand why this can happen, you have to get past the Java syntax and get down to a much lower level. If you look at the code for thread 1, it can essentially be broken down into a series of memory writes and allocations:</p>
<ol>
<li>Alloc memory to pointer1</li>
<li>Write 42 to pointer1 at offset 0</li>
<li>Write pointer1 to someStaticVariable</li>
</ol>
<p>Because Java has a weak memory model, it is perfectly possible for the code to actually execute in the following order from the perspective of thread 2:</p>
<ol>
<li>Alloc Memory to pointer1</li>
<li>Write pointer1 to someStaticVariable</li>
<li>Write 42 to pointer1 at offset 0</li>
</ol>
<p>Scary? Yes but it can happen.</p>
<p>What this means though is that thread 2 can now call into <code>assertSanity</code> before <code>n</code> has gotten the value 42. It is possible for the value <code>n</code> to be read twice during <code>assertSanity</code>, once before operation #3 completes and once after and hence see two different values and throw an exception.</p>
</blockquote>
<h3 id="不可变对象与初始化安全性"><a href="#不可变对象与初始化安全性" class="headerlink" title="不可变对象与初始化安全性"></a>不可变对象与初始化安全性</h3><p>Java内存模型为共享不可变对象提供了特殊的初始化安全性的保证，即对象在完全初始化之后才能被外界引用，所以只要是不可变对象，一旦构建完成，就可以安全地发布了。</p>
<p>即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一致的视图，就必须使用同步。</p>
<p>即使发布对象引用时没有使用同步，不可变对象仍然可以被安全地访问（注，只能保证一旦看到的对象就是完整的，在没有使用同步的情况下是不能保证对象引用的可见性，所以不可变对象只能保证初始化完后的就处于稳定状态）。<strong>为了获得这种初始化安全性的保证上，应该满足所有不可变性的条件</strong>：<!--不可修改的状态、所有域都是final类型的、正确的构造-->。（如果上面的Holder是不可变的，那么即使Holder没有正确的发布，assertSanity也不会抛出AssertionError。）</p>
<blockquote>
<p>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。</p>
</blockquote>
<p>这个保证还会延伸到一个正确创建的对象中所有final类型域的值。final域可以在没有额外的同步情况下被安全地访问（因为只要构造器一旦调用完毕，则final域的也会随之初始化完并可见），然而，如果final域指向可变对象，那么访问这些对象的状态时仍然需要同步的。</p>
<h3 id="安全发布的常用模式（可变对象的安全发布）"><a href="#安全发布的常用模式（可变对象的安全发布）" class="headerlink" title="安全发布的常用模式（可变对象的安全发布）"></a>安全发布的常用模式（可变对象的安全发布）</h3><p>如果一个对象不是不可变的，它就必须要被安全的发布，通常发布线程与消费线程都必须同步。我们要确保消费线程能够看到处于发布当时的对象状态。</p>
<blockquote>
<p>为了安全地发布一个可变对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用；static{}</li>
<li>将对象的引用保存到volatile类型的域或者AtomicReferance对象中</li>
<li>将对象的引用保存到某个正确构造对象的final类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
</blockquote>
<p>线程安全中的容器提供了线程安全保证（即变向地将对象置于了同步器中进行访问），正是遵守了上述最后一条要求。</p>
<p>线程安全库中的容器类提供了以下的安全发布保证：</p>
<ul>
<li>通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。</li>
<li>通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。</li>
<li>通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。</li>
</ul>
<p>类库中的其他数据传递机制（例如Future和Exchanger）同样能实现安全发布。</p>
<p>要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Holder holder &#x3D; new Holder(42);</span><br></pre></td></tr></table></figure>

<p>静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。</p>
<p><strong>如果对象在创建后被修改，那么安全发布仅仅可以保证“发布当时”状态的可见性。不仅仅在发布对象时需要同步，而且在对象发布后修改了对象状态又要让其他线程可见，则也需要对每次状态的访问进行同步。为了安全地共享可变对象，可变对象必须被安全发布，同时对状态的访问需要同步化。</strong></p>
<h3 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h3><p>对于对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布时足够的。</p>
<p>如果对象从技术上来看时可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象”。</p>
<p>用事实不可变对象可以简化开发，并且由于减少了同步的使用，还会提高性能。</p>
<blockquote>
<p>在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。</p>
</blockquote>
<p>比如，Date自身是可变的（这也许是类库设计的一个错误），但是如果你把它当作不可变对象来使用就可以忽略锁。否则，每当Date被跨线程共享时，都要用锁确保安全。假设你正在维护一个Map，它存储了每位用户的最近登录时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Date&gt; lastLogin =</span><br><span class="line">Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Date&gt;());</span><br></pre></td></tr></table></figure>

<p>如果Date值在转入Map中后就不会改变，那么，synchronizedMap中同步的实现就足以将Date安全地发布，并且访问这些Date值时就不再需要额外的同步。</p>
<!--stack上的回答-->

<blockquote>
<p>If you use an <code>un-synchronized</code> <code>mutable map</code> and share it across <code>threads</code> then you will have two <code>thread-safety</code> issues :<code>visibility</code> and <code>atomicity</code>. <code>Thread-1</code> wont know if <code>Thread-2</code> has removed a <code>Map-Entry</code> or it replaced its value by a new <code>Date</code> object.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not atmoic and doesn&#x27;t guarantee visiblity</span></span><br><span class="line"><span class="keyword">if</span>(map.contains(key))&#123;</span><br><span class="line"> map.put(key,newDate); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="可变对象–-gt-对象（不可变-事实不可变-可变）的发布约束"><a href="#可变对象–-gt-对象（不可变-事实不可变-可变）的发布约束" class="headerlink" title="可变对象–&gt;对象（不可变/事实不可变/可变）的发布约束"></a>可变对象–&gt;对象（不可变/事实不可变/可变）的发布约束</h3><p>如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续操作的可见性。<strong>要安全地共享可变对象，这些对象就必须被安全地发布，并且必须是线程安全的活着由某个锁保护起来。</strong></p>
<blockquote>
<p>对象的发布需求取决于它的可变性：<br>* 不可变对象可以通过任意机制来发布<br>* 事实不可变对象必须通过安全方式来发布<br>* 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来</p>
</blockquote>
<h3 id="安全地共享对象"><a href="#安全地共享对象" class="headerlink" title="安全地共享对象"></a>安全地共享对象</h3><p>当获得对象的一个引用时，你需要知道在这个引用上可以执行哪些操作。在使用它之前是否需要获得一个锁？是否可以修改它的状态，或者只能读取它？许多错误都是由于没有理解共享对象的这些“既定规则”而导致。当发布一个对象时，必须明确地说明对象的访问方式。</p>
<blockquote>
<p>在并发程序中使用和共享对象时，可以使用一些使用的策略，包括：<br><strong>线程封闭</strong>。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。<br><strong>只读共享。</strong>在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。<br><strong>线程安全共享。</strong>线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。<br><strong>保护对象。</strong>被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
