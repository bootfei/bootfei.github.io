<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/15/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/15/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/database/redis/redis-7-%E5%8D%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/database/redis/redis-7-%E5%8D%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">redis-7-单多线程以及线程安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-10 13:27:23" itemprop="dateCreated datePublished" datetime="2021-05-10T13:27:23+08:00">2021-05-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-09 15:13:16" itemprop="dateModified" datetime="2021-08-09T15:13:16+08:00">2021-08-09</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>单线程的设计也给Redis带来一些问题：</p>
<ul>
<li>只能使用CPU一个核；</li>
<li>如果删除的键过大（比如Set类型中有上百万个对象），会导致服务端阻塞好几秒；</li>
<li>QPS难再提高。</li>
</ul>
<p>针对上面问题，Redis在4.0版本以及6.0版本分别引入了<code>Lazy Free</code>以及<code>多线程IO</code>，逐步向多线程过渡</p>
<h2 id="单线程体现在哪里？"><a href="#单线程体现在哪里？" class="headerlink" title="单线程体现在哪里？"></a>单线程体现在哪里？</h2><h3 id="版本不同，单线程不同"><a href="#版本不同，单线程不同" class="headerlink" title="版本不同，单线程不同"></a>版本不同，单线程不同</h3><blockquote>
<p><strong>正确的说法是，redis只使用了单个线程去处理客户端的网络请求。到6.0版本，那这个答案还要修正为多线程处理网络请求，但是真正操作数据部分程序是单线程的。</strong></p>
</blockquote>
<ul>
<li>Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问这种问题，是不是有点耍流氓。</li>
<li>限定版本之后 比如4.x，严格意义来说Redis也不是单线程，而是负责处理客户端的请求的线程是单线程。</li>
<li>最新版本的6.0版本，告别了大家印象中的单线程，用一种全新的多线程来解决问题</li>
</ul>
<p><img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/2226BB23364A3092021556482C0880F0.jpg" alt="img"></p>
<h3 id="事件处理是单线程"><a href="#事件处理是单线程" class="headerlink" title="事件处理是单线程"></a>事件处理是单线程</h3><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p>
<ul>
<li><code>文件事件</code>：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象；服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作，比如连接<code>accept</code>，<code>read</code>，<code>write</code>，<code>close</code>等；</li>
<li><code>时间事件</code>：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象，比如过期键清理，服务状态统计等。</li>
</ul>
<img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBGjKoEV1qzhribnDJZeSp9ZGKyAlBBia6Au7U9ScIxh5QsI1KJaCuFaLsoJIWzpuVyCqALjd9dWX8A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom: 33%;" />

<p>如上图，Redis将文件事件和时间事件进行抽象，时间轮训器会监听I/O事件表，一旦有文件事件就绪，Redis就会优先处理文件事件，接着处理时间事件。<a href="">在上述所有事件处理上，Redis都是以<code>单线程</code>形式处理，所以说Redis是单线程的</a></p>
<p>Redis基于Reactor模式开发了自己的I/O事件处理器，也就是文件事件处理器，Redis在I/O事件处理上，采用了I/O多路复用技术，同时监听多个套接字，并为套接字关联不同的事件处理函数，<a href="">通过单线程实现了多客户端并发处理</a>。</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBGjKoEV1qzhribnDJZeSp9ZBrrXaOVX2HR8uoJLd4PIpJBmIUXiaVfsp2UPtl5n3icmsRzhpcgIISdA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:33%;" />

<p>正因为这样的设计，在数据处理上避免了加锁操作，既使得实现上足够简洁，也保证了其高性能。</p>
<h2 id="单线程瓶颈"><a href="#单线程瓶颈" class="headerlink" title="单线程瓶颈"></a>单线程瓶颈</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>通常来说多线程对于提高CPU利用率有重要作用，但是Redis对于提高CPU利用率并不感冒，在Redis看来如果要提高CPU利用率，那在一台机器部署多个实例就好了。</p>
<blockquote>
<p>其实在Redis 4.0就引入了多个线程来实现数据的异步删除等功能，但是其处理读写请求的仍然只有一个线程，所以仍然算是狭义上的单线程。</p>
</blockquote>
<p>抛开CPU之后，影响Redis性能的地方主要就剩下：<strong>内存和网络IO</strong>。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存更多属于硬件范畴的东西，比如我们用容量更大、吞吐率更高的内存介质来进行优化，因此对于Redis来说可以优化的空间有限。</p>
<h3 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h3><p>在优化网络IO之前，我们有必要回顾下Redis单线程整体架构：</p>
<img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/D62600E64DD64120A1AFC7B02C249F05.jpg" alt="img" style="zoom: 50%;" />

<p>Redis采用Reactor模式的网络模型，对于一个客户端请求，主线程负责一个完整的处理过程：</p>
<img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/17AC77F7B141692BBB88D38395BDAB5A.jpg" alt="img" style="zoom: 50%;" />

<p>从socket中读取数据和往socket写数据都是比较耗时的网络IO操作，解析请求和内存交互耗时可能远小于IO操作。</p>
<p>对于这种问题，我们常见的解决方法是标准的多线程化：</p>
<img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/9AE12897F8FCA20AA8BADAF3D04E3E56.jpg" alt="img" style="zoom:50%;" />

<p>该方案中工作线程的功能是一样的，MemCached就是采用这种方案，具体的流程：</p>
<blockquote>
<p>Memcached采用 master-woker 模式进行工作，主线程采用 Libevent 监听和处理事件，主线程将连接请求封装为任务放到队列中，根据算法选择空闲的工作线程，相应的工作线程处理完成后通过soeket与客户端进行数据交互。</p>
</blockquote>
<p>但是Redis 6.0的多线程并没有这么做。</p>
<h2 id="多线程体现在哪里？"><a href="#多线程体现在哪里？" class="headerlink" title="多线程体现在哪里？"></a>多线程体现在哪里？</h2><h3 id="生成RBD日志文件"><a href="#生成RBD日志文件" class="headerlink" title="生成RBD日志文件"></a>生成RBD日志文件</h3><p><a href="">当然，Redis单线程只是指其在事件处理上，实际上，Redis也并不是单线程的，比如生成RDB文件，就会fork一个子进程来实现</a></p>
<h3 id="4-0-Lazy-Free机制"><a href="#4-0-Lazy-Free机制" class="headerlink" title="4.0 Lazy Free机制"></a>4.0 Lazy Free机制</h3><p>如上所知，Redis在处理客户端命令时是以单线程形式运行，而且处理速度很快，期间不会响应其他客户端请求，但若客户端向Redis发送一条耗时较长的命令，比如删除一个含有上百万对象的Set键，或者执行flushdb，flushall操作，Redis服务器需要回收大量的内存空间，导致服务器卡住好几秒，对负载较高的缓存系统而言将会是个灾难。为了解决这个问题，在Redis 4.0版本引入了<code>Lazy Free</code>，将<code>慢操作</code>异步化，这也是在事件处理上向多线程迈进了一步。</p>
<p>要解决<code>慢操作</code>，可以采用渐进式处理，即增加一个时间事件，比如在删除一个具有上百万个对象的Set键时，每次只删除大键中的一部分数据，最终实现大键的删除。但是，该方案可能会导致回收速度赶不上创建速度，最终导致内存耗尽。因此，Redis最终实现上是将大键的删除操作异步化，采用非阻塞删除（对应命令<code>UNLINK</code>），大键的空间回收交由单独线程实现，主线程只做关系解除，可以快速返回，继续处理其他事件，避免服务器长时间阻塞。</p>
<p>以删除（<code>DEL</code>命令）为例，看看Redis是如何实现的，下面就是删除函数的入口，其中，<code>lazyfree_lazy_user_del</code>是是否修改<code>DEL</code>命令的默认行为，一旦开启，执行<code>DEL</code>时将会以<code>UNLINK</code>形式执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void delCommand(client *c) &#123;</span><br><span class="line">    delGenericCommand(c,server.lazyfree_lazy_user_del);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* This command implements DEL and LAZYDEL. *&#x2F;</span><br><span class="line">void delGenericCommand(client *c, int lazy) &#123;</span><br><span class="line">    int numdel &#x3D; 0, j;</span><br><span class="line"></span><br><span class="line">    for (j &#x3D; 1; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        &#x2F;&#x2F; 根据配置确定DEL在执行时是否以lazy形式执行</span><br><span class="line">        int deleted  &#x3D; lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        if (deleted) &#123;</span><br><span class="line">            signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                &quot;del&quot;,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步删除很简单，只要把key和value删除，如果有内层引用，则进行递归删除，这里不做介绍。下面看下异步删除，Redis在回收对象时，会先计算回收收益，只有回收收益在超过一定值时，采用封装成Job加入到异步处理队列中，否则直接同步回收，这样效率更高。回收收益计算也很简单，比如<code>String</code>类型，回收收益值就是1，而<code>Set</code>类型，回收收益就是集合中元素个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Delete a key, value, and associated expiration entry if any, from the DB.</span><br><span class="line"> * If there are enough allocations to free the value object may be put into</span><br><span class="line"> * a lazy free list instead of being freed synchronously. The lazy free list</span><br><span class="line"> * will be reclaimed in a different bio.c thread. *&#x2F;</span><br><span class="line">#define LAZYFREE_THRESHOLD 64</span><br><span class="line">int dbAsyncDelete(redisDb *db, robj *key) &#123;</span><br><span class="line">    &#x2F;* Deleting an entry from the expires dict will not free the sds of</span><br><span class="line">     * the key, because it is shared with the main dictionary. *&#x2F;</span><br><span class="line">    if (dictSize(db-&gt;expires) &gt; 0) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    &#x2F;* If the value is composed of a few allocations, to free in a lazy way</span><br><span class="line">     * is actually just slower... So under a certain limit we just free</span><br><span class="line">     * the object synchronously. *&#x2F;</span><br><span class="line">    dictEntry *de &#x3D; dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        robj *val &#x3D; dictGetVal(de);</span><br><span class="line">        &#x2F;&#x2F; 计算value的回收收益</span><br><span class="line">        size_t free_effort &#x3D; lazyfreeGetFreeEffort(val);</span><br><span class="line"></span><br><span class="line">        &#x2F;* If releasing the object is too much work, do it in the background</span><br><span class="line">         * by adding the object to the lazy free list.</span><br><span class="line">         * Note that if the object is shared, to reclaim it now it is not</span><br><span class="line">         * possible. This rarely happens, however sometimes the implementation</span><br><span class="line">         * of parts of the Redis core may call incrRefCount() to protect</span><br><span class="line">         * objects, and then call dbDelete(). In this case we&#39;ll fall</span><br><span class="line">         * through and reach the dictFreeUnlinkedEntry() call, that will be</span><br><span class="line">         * equivalent to just calling decrRefCount(). *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 只有回收收益超过一定值，才会执行异步删除，否则还是会退化到同步删除</span><br><span class="line">        if (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            atomicIncr(lazyfree_objects,1);</span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,NULL,NULL);</span><br><span class="line">            dictSetVal(db-&gt;dict,de,NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Release the key-val pair, or just the key if we set the val</span><br><span class="line">     * field to NULL in order to lazy free it later. *&#x2F;</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        if (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过引入<code>a threaded lazy free</code>，Redis实现了对于<code>Slow Operation</code>的<code>Lazy</code>操作，避免了在大键删除，<code>FLUSHALL</code>，<code>FLUSHDB</code>时导致服务器阻塞。当然，在实现该功能时，不仅引入了<code>lazy free</code>线程，也对Redis聚合类型在存储结构上进行改进。因为Redis内部使用了很多共享对象，比如客户端输出缓存。当然，Redis并未使用加锁来避免线程冲突，锁竞争会导致性能下降，而是去掉了共享对象，直接采用数据拷贝，如下，在3.x和6.x中<code>ZSet</code>节点value的不同实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 3.2.5版本ZSet节点实现，value定义robj *obj</span><br><span class="line">&#x2F;* ZSETs use a specialized version of Skiplists *&#x2F;</span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    robj *obj;</span><br><span class="line">    double score;</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        unsigned int span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6.0.10版本ZSet节点实现，value定义为sds ele</span><br><span class="line">&#x2F;* ZSETs use a specialized version of Skiplists *&#x2F;</span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    sds ele;</span><br><span class="line">    double score;</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        unsigned long span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>去掉共享对象，不但实现了<code>lazy free</code>功能，也为Redis向多线程跨进带来了可能，正如作者所述：</p>
<blockquote>
<p>Now that values of aggregated data types are fully unshared, and client output buffers don’t contain shared objects as well, there is a lot to exploit. For example it is finally possible to implement threaded I/O in Redis, so that different clients are served by different threads. This means that we’ll have a global lock only when accessing the database, but the clients read/write syscalls and even the parsing of the command the client is sending, can happen in different threads.</p>
</blockquote>
<h3 id="6-0-多线程I-O"><a href="#6-0-多线程I-O" class="headerlink" title="6.0 多线程I/O"></a>6.0 多线程I/O</h3><p>单线程给Redis带来的好处，或许更大。</p>
<p>另外一点如果做成<a href="">标准化的多线程（见单线程瓶颈 - 网络IO）</a>，对于Redis来说可能更不好处理，因为多线程带来的线程安全问题和底层复杂的数据结构操作都十分棘手。</p>
<p>Redis 6.0将处理过程中最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由单线程来完成和内存的数据交互。</p>
<p>这样一来，网络IO操作就变成多线程化了，其他核心部分仍然是线程安全的，确实是个不错的折中办法。</p>
<img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/45B0A1BFD93CE1E776FBD5BFE6D2756D.jpg" alt="img" style="zoom:50%;" />

<blockquote>
<p>画外音：<strong>Redis 6.0 将网络数据读写、请求协议解析通过多个IO线程的来处理 ，对于真正的命令执行来说，仍然使用主线程操作，真是个很特别的多线程啊！</strong></p>
</blockquote>
<img src="https://image.z.itpub.net/zitpub.net/JPG/2021-04-25/0AC4121F88297E685697B648CE50BD5D.jpg" alt="img" style="zoom:50%;" />

<h2 id="多线程瓶颈"><a href="#多线程瓶颈" class="headerlink" title="多线程瓶颈"></a>多线程瓶颈</h2><h4 id="多线程I-O及其局限性"><a href="#多线程I-O及其局限性" class="headerlink" title="多线程I/O及其局限性"></a>多线程I/O及其局限性</h4><p>Redis在4.0版本引入了<code>Lazy Free</code>，自此Redis有了一个<code>Lazy Free</code>线程专门用于大键的回收，同时，也去掉了聚合类型的共享对象，这为多线程带来可能，Redis也不负众望，在6.0版本实现了<code>多线程I/O</code>。</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>正如官方以前的回复，Redis的性能瓶颈并不在CPU上，而是在内存和网络上。因此6.0发布的多线程并未将事件处理改成多线程，而是在I/O上，此外，如果把事件处理改成多线程，不但会导致锁竞争，而且会有频繁的上下文切换，即使用分段锁来减少竞争，对Redis内核也会有较大改动，性能也不一定有明显提升。</p>
<p>是Redis实现的多线程部分，利用多核来分担I/O读写负荷。在<code>事件处理线程</code>每次获取到可读事件时，会将所有就绪的读事件分配给<code>I/O线程</code>，并进行等待，在所有<code>I/O线程</code>完成读操作后，<code>事件处理线程</code>开始执行任务处理，在处理结束后，同样将写事件分配给<code>I/O线程</code>，等待所有<code>I/O</code>线程完成写操作。</p>
<p>以读事件处理为例，看下<code>事件处理线程</code>任务分配流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int handleClientsWithPendingReadsUsingThreads(void) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;* Distribute the clients across N different lists. *&#x2F;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    int item_id &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 将等待处理的客户端分配给I&#x2F;O线程</span><br><span class="line">    while((ln &#x3D; listNext(&amp;li))) &#123;</span><br><span class="line">        client *c &#x3D; listNodeValue(ln);</span><br><span class="line">        int target_id &#x3D; item_id % server.io_threads_num;</span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;* Wait for all the other threads to end their work. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 轮训等待所有I&#x2F;O线程处理完</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        unsigned long pending &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 1; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending +&#x3D; io_threads_pending[j];</span><br><span class="line">        if (pending &#x3D;&#x3D; 0) break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>I/O线程</code>处理流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void *IOThreadMain(void *myid) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; I&#x2F;O线程执行读写操作</span><br><span class="line">        while((ln &#x3D; listNext(&amp;li))) &#123;</span><br><span class="line">            client *c &#x3D; listNodeValue(ln);</span><br><span class="line">            &#x2F;&#x2F; io_threads_op判断是读还是写事件</span><br><span class="line">            if (io_threads_op &#x3D;&#x3D; IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c,0);</span><br><span class="line">            &#125; else if (io_threads_op &#x3D;&#x3D; IO_THREADS_OP_READ) &#123;</span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                serverPanic(&quot;io_threads_op value is unknown&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listEmpty(io_threads_list[id]);</span><br><span class="line">        io_threads_pending[id] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (tio_debug) printf(&quot;[%ld] Done\n&quot;, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h5><p>从上面实现上看，6.0版本的多线程并非彻底的多线程，<code>I/O线程</code>只能同时执行读或者同时执行写操作，期间<code>事件处理线程</code>一直处于等待状态，并非流水线模型，有很多轮训等待开销。</p>
<h5 id="Tair多线程实现原理"><a href="#Tair多线程实现原理" class="headerlink" title="Tair多线程实现原理"></a>Tair多线程实现原理</h5><p>相较于6.0版本的多线程，Tair的多线程实现更加优雅。如下图，Tair的<code>Main Thread</code>负责客户端连接建立等，<code>IO Thread</code>负责请求读取、响应发送、命令解析等，<code>Worker Thread</code>线程专门用于事件处理。<code>IO Thread</code>读取用户的请求并进行解析，之后将解析结果以命令的形式放在队列中发送给<code>Worker Thread</code>处理。<code>Worker Thread</code>将命令处理完成后生成响应，通过另一条队列发送给<code>IO Thread</code>。为了提高线程的并行度，<code>IO Thread</code>和<code>Worker Thread</code>之间采用<strong>无锁队列</strong>和<strong>管道</strong>进行数据交换，整体性能会更好。<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Redis 4.0引入<code>Lazy Free</code>线程，解决了诸如大键删除导致服务器阻塞问题，在6.0版本引入了<code>I/O Thread</code>线程，正式实现了多线程，但相较于Tair，并不太优雅，而且性能提升上并不多，压测看，多线程版本性能是单线程版本的2倍，Tair多线程版本则是单线程版本的3倍。在作者看来，Redis多线程无非两种思路，<code>I/O threading</code>和<code>Slow commands threading</code>，正如作者在其博客中所说：</p>
<blockquote>
<p>I/O threading is not going to happen in Redis AFAIK, because after much consideration I think it’s a lot of complexity without a good reason. Many Redis setups are network or memory bound actually. Additionally I really believe in a share-nothing setup, so the way I want to scale Redis is by improving the support for multiple Redis instances to be executed in the same host, especially via Redis Cluster.</p>
</blockquote>
<blockquote>
<p>What instead I really want a lot is slow operations threading, and with the Redis modules system we already are in the right direction. However in the future (not sure if in Redis 6 or 7) we’ll get key-level locking in the module system so that threads can completely acquire control of a key to process slow operations. Now modules can implement commands and can create a reply for the client in a completely separated way, but still to access the shared data set a global lock is needed: this will go away.</p>
</blockquote>
<p>Redis作者更倾向于采用集群方式来解决<code>I/O threading</code>，尤其是在6.0版本发布的原生Redis Cluster Proxy背景下，使得集群更加易用。此外，作者更倾向于<code>slow operations threading</code>（比如4.0版本发布的<code>Lazy Free</code>）来解决多线程问题。后续版本，是否会将<code>IO Thread</code>实现的更加完善，采用Module实现对慢操作的优化，着实值得期待。</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="读取过期数据"><a href="#读取过期数据" class="headerlink" title="读取过期数据"></a>读取过期数据</h3><p>典型场景是：</p>
<ul>
<li>Redis 内存储了一个用户的状态：<code>user5277=idle</code>；</li>
<li>客户端连接 A 读取了用户状态，获取到用户的空闲状态 <code>status = get(&quot;user5277&quot;)</code>；</li>
<li>客户端连接 B 也同样读取了用户状态；</li>
<li>客户端连接 A 给用户安排了一个任务，并将 Redis 内用户状态置为忙碌 <code>set(&quot;user5277&quot;, &quot;busy&quot;)</code>；</li>
<li>客户端连接 B 同样设置用户为忙碌状态。</li>
<li>可是此时用户却被同时分配了两个任务。</li>
</ul>
<p>解决方法1：给用户状态加锁就行了，使同一时间内只能有一个客户端操作用户状态。不过加锁我们就需要考虑锁粒度、死锁等问题了，无疑添加了程序的复杂性，不利于维护。</p>
<p>解决方法2：使用lua脚本，保证<a href="">复合命令</a>的原子性。java可以使用字符串的方式拼接lua脚本</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-01-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-01-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/" class="post-title-link" itemprop="url">shiro应用-01-使用流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-10 13:25:09" itemprop="dateCreated datePublished" datetime="2021-05-10T13:25:09+08:00">2021-05-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JfTPiahTHJhpmuJOMKBHpBCC00gwWgjwZW67mVRo4ffmBpibDMLQicgZJuicvNNnPaiaeXFxOPYY4OXATuhDj6Wnq6Q/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h2 id="jdk实现"><a href="#jdk实现" class="headerlink" title="jdk实现"></a>jdk实现</h2><h3 id="设置Realm域"><a href="#设置Realm域" class="headerlink" title="设置Realm域"></a>设置Realm域</h3><p>Shiro要从Realm域中获取安全、正确的数据。该类必须继承org.apache.shiro.realm.AuthorizingRealm；</p>
<p>　　并重写doGetAuthorizationInfo与doGetAuthenticationInfo方法。doGetAuthorizationInfo是对角色权限的认证，这里暂且不详述；doGetAuthenticationInfo对用户的认证，这里正是我们要详细讲述的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">implements</span> <span class="title">Realm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationInfo <span class="title">getAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = (String)token.getPrincipal();  <span class="comment">//得到用户名</span></span><br><span class="line">        String password = <span class="keyword">new</span> String((<span class="keyword">char</span>[])token.getCredentials()); <span class="comment">//得到密码</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;zhang&quot;</span>.equals(username)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException(); <span class="comment">//如果用户名错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;123&quot;</span>.equals(password)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncorrectCredentialsException(); <span class="comment">//如果密码错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果身份认证验证成功，返回一个AuthenticationInfo实现；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(username, password, getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件，使securityManager获取到该Realm域"><a href="#配置文件，使securityManager获取到该Realm域" class="headerlink" title="配置文件，使securityManager获取到该Realm域"></a>配置文件，使securityManager获取到该Realm域</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 [main]</span><br><span class="line">2 <span class="comment">#自定义 realm</span></span><br><span class="line">3 customRealm=org.ssm.service.CustomRealm</span><br><span class="line">4 <span class="comment">#将realm设置到securityManager</span></span><br><span class="line">5 securityManager.realms=<span class="variable">$customRealm</span></span><br></pre></td></tr></table></figure>

<h3 id="测试：main函数"><a href="#测试：main函数" class="headerlink" title="测试：main函数"></a>测试：main函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShiro</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过工厂加载配置</span></span><br><span class="line">  Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro-shiro.ini&quot;</span>);</span><br><span class="line">  <span class="comment">//通过工厂获取安全管理器</span></span><br><span class="line">  SecurityManager securityManager = factory.getInstance();</span><br><span class="line">  <span class="comment">//注册Subject工具</span></span><br><span class="line">  SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">  <span class="comment">//获取Subject对象</span></span><br><span class="line">  Subject subject = SecurityUtils.getSubject();</span><br><span class="line">  <span class="comment">//获取验证对象</span></span><br><span class="line">  AuthenticationToken authenticationToken = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="comment">//        验证</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    subject.login(authenticationToken);</span><br><span class="line">    System.out.println(<span class="string">&quot;通过...&quot;</span> + <span class="string">&quot;\t&quot;</span> + authenticationToken.getPrincipal());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未通过:用户不存在&quot;</span> + <span class="string">&quot;\t&quot;</span> + authenticationToken.getPrincipal());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="spring-mvc实现"><a href="#spring-mvc实现" class="headerlink" title="spring mvc实现"></a>spring mvc实现</h2><h3 id="配置Shiro的过滤器"><a href="#配置Shiro的过滤器" class="headerlink" title="配置Shiro的过滤器"></a>配置Shiro的过滤器</h3><p>对所有访问进行过滤；需要在web.xml中加上如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置上shiro过滤器，使其生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置url由servlet容器控制filter的生命周期--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>transformWsdlLocations<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="设置Realm域，且安全数据来源于数据库"><a href="#设置Realm域，且安全数据来源于数据库" class="headerlink" title="设置Realm域，且安全数据来源于数据库"></a>设置Realm域，且安全数据来源于数据库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 引入users操作的整合操作</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="meta">@Qualifier(&quot;usersService&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> UsersService usersService;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *获取授权信息</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> principalCollection</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 获取获取身份验证相关信息</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> authenticationToken</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"> <span class="comment">//        获取用户输入的用户名</span></span><br><span class="line">         String userName = (String) authenticationToken.getPrincipal();</span><br><span class="line"> <span class="comment">//        根据用户名查询该数据</span></span><br><span class="line">         Users user = usersService.selectByName(userName);</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span> (user == <span class="keyword">null</span>)&#123;</span><br><span class="line"> <span class="comment">//            没有找到账号</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();</span><br><span class="line">         &#125;</span><br><span class="line">         SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(user.getUserName(), user.getPassWord(),</span><br><span class="line"> <span class="comment">//                此为realm内的方法，用于获取realm的name</span></span><br><span class="line">                 getName()</span><br><span class="line">         );</span><br><span class="line">         <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件，使securityManager获取到该Realm域，使spring容器获取securityManager"><a href="#配置文件，使securityManager获取到该Realm域，使spring容器获取securityManager" class="headerlink" title="配置文件，使securityManager获取到该Realm域，使spring容器获取securityManager"></a>配置文件，使securityManager获取到该Realm域，使spring容器获取securityManager</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--shiro的配置--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注入自定义的Realm--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;userRealm&quot; class&#x3D;&quot;org.ssm.shiro.realm.UserRealm&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;securityManager&quot; class&#x3D;&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;realm&quot; ref&#x3D;&quot;userRealm&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--配置ShiroFilter的属性--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;shiroFilter&quot; class&#x3D;&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">            &lt;value&gt;</span><br><span class="line">                &#x2F;login &#x3D; anon</span><br><span class="line">            &lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>



<h3 id="测试：拦截器"><a href="#测试：拦截器" class="headerlink" title="测试：拦截器"></a>测试：拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        从该回话中获取subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="comment">//        获取用户信息</span></span><br><span class="line">        String user = (String) subject.getPrincipal();</span><br><span class="line"><span class="comment">//        如果用户信息为空，则进行拦截</span></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.sendRedirect(request.getContextPath() + <span class="string">&quot;/User/login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7-01-%E7%94%9F%E4%BA%A7%E8%80%85%E9%87%8D%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7-01-%E7%94%9F%E4%BA%A7%E8%80%85%E9%87%8D%E8%AF%95/" class="post-title-link" itemprop="url">一致性-01-微服务依赖的一致性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-10 12:52:01" itemprop="dateCreated datePublished" datetime="2021-05-10T12:52:01+08:00">2021-05-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>微服务场景下需要同步信息的场景。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbucvzl7K951Z4AH8AYxOdkVg1FL3c5JL3MOr5cib0OYrlPoJhwyUFOIsTylUFMs70JJ226DJ2LV82gQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li>支付服务：负责完成支付操作，其中有支付流水数据。</li>
<li>账单服务：指定时间生成账单给用户，其中有账单流水数据。</li>
</ul>
<p>此时产品上有个需求，在支付管理端根据是否出账搜索支付流水，而出账是账单服务的功能。所以这里涉及到信息的同步，那么，我们怎么保证同步一定能成功呢（最终一致性）。</p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>保证在队列中的消息，一定会被消费，即不停消费直到成功。</p>
<p>方式：</p>
<ul>
<li>消息队列都使用手动提交，即业务处理结束以后再提交。</li>
<li>尽量遵循<a href="">触发-查询机制</a>，<a href="">提供可重入性</a>，即消息队列只有id这种非实质信息，消费者收到之后再通过rpc查询拉取完整数据来更新。</li>
</ul>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>主要是发送消息到队列这步的可靠性考量</p>
<h4 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h4><p>以递增的时间间隔重试5次。如果失败了，上报到日志和告警，人工介入。同时，具体业务准备好重试的脚本。根据实时的情况进行处理。</p>
<ul>
<li><p>优点：</p>
<ul>
<li>简单，能解决瞬间的网络抖动造成的失败。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>可靠性低：在消息队列故障30分钟这种场景下，无法自动恢复。</li>
<li>同时从日志捞取信息，也不方便。</li>
</ul>
</li>
</ul>
<h4 id="失败重试-重试队列"><a href="#失败重试-重试队列" class="headerlink" title="失败重试 + 重试队列"></a>失败重试 + 重试队列</h4><p>失败之后，内存维护一个重试队列，先由5，10，20， 40， 80， 160， 320s的间隔重试。之后以5分钟一次的间隔请求。同时，也要打入日志系统，告警通知。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbucvzl7K951Z4AH8AYxOdkVgILMjxJQEicWMDTbfibOD5zv7peThKtbVqQZ7OZmOibe7enJh59wsHvsaw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li><p>优点：</p>
<ul>
<li>可靠性，在消息队列故障30分钟这种场景下，也能自动恢复。</li>
<li>可以做成jar的方式，方便接入。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>服务重启或者机器挂了，消息就丢了。</li>
</ul>
</li>
</ul>
<blockquote>
<p>限制：</p>
<ul>
<li>消息处理需要遵循<a href="">触发-查询机制</a></li>
</ul>
</blockquote>
<h4 id="失败重试-重试队列-落盘"><a href="#失败重试-重试队列-落盘" class="headerlink" title="失败重试 + 重试队列(落盘)"></a>失败重试 + 重试队列(落盘)</h4><p>失败之后，内存维护一个重试队列，先由5，10，20， 40， 80，160， 320s的间隔重试。然后append到本地文件，同时以5分钟一次的频率做重试。重试完成之后，从磁盘中删除对应信息。当服务重启，从磁盘把数据导入内存即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbucvzl7K951Z4AH8AYxOdkVg4d43bFqupgKHwzicRaaMqTrDLuiaGWyP1BLsdfYpepFeQtlya33LmpQA/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>优点：</p>
<ul>
<li>可靠性会比一高很多，在<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247493109&idx=2&sn=b916d91c76b47dcbefee1a7ba5f88373&chksm=ebd5dad9dca253cf6b642d65d64ebdaa5bf13d56444ca1ce7d603d8abd390daa37a6b609e54c&scene=21#wechat_redirect">消息队列</a>故障30分钟这种场景下，也能自动恢复，</li>
<li>可以做成jar包的方式。</li>
<li>具有比较强的通用型</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了和磁盘打交道的逻辑，引入了文件io。 <!--我认为，为什么非得用io文件，用高可用的中间件redis会更好，专门的运维团队维护，并且逻辑简单--></li>
</ul>
<blockquote>
<p>限制：</p>
<ul>
<li>消息处理需要遵循触发-查询机制</li>
</ul>
</blockquote>
<h4 id="失败重试-中间服务"><a href="#失败重试-中间服务" class="headerlink" title="失败重试 + 中间服务"></a>失败重试 + 中间服务</h4><p>实现任务重试微服务，该服务通过维护一张任务表，重试任务直到成功。相当于是消息队列这个可靠中间件有问题，就丢给这个重试服务这个自己实现的“中间件”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbucvzl7K951Z4AH8AYxOdkVgOs0bCyPgzibbIia963lib5SjHtvUt3Jicl3a7KpHt5TKW4sYlY47icELeDw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>优点：</p>
<ul>
<li>可靠性会比一高很多，在消息队列故障30分钟这种场景下，也能自动恢复。</li>
<li>具有比较强的通用性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>成本变高，需要额外服务。同时，如果服务也挂了，还是得依赖上报。</li>
</ul>
<p>限制：</p>
<ul>
<li>消息处理需要遵循触发-查询机制</li>
</ul>
<p>以上方案中，三，四基本能解决重试阶段写入消息队列的可靠性问题。但针对另一个场景：正想写本身服务就没了的情况（比如oom导致服务被系统kill了） 还是不行。</p>
<h4 id="失败重试-消息注册"><a href="#失败重试-消息注册" class="headerlink" title="失败重试 + 消息注册"></a>失败重试 + 消息注册</h4><p>要做变更之前，先写入到消息同步<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247503061&idx=3&sn=a26fa47e1537b02a3bde0113b1c2b1cf&chksm=ebd5f3f9dca27aefdaeb07db8a5bacf72d3be382b89944cc17d02c444f59c47bb9b96f112560&scene=21#wechat_redirect">微服务</a>，告诉他要做什么事（把什么消息放入消息队列），和流程最长执行时间，以及发给谁。该服务维护一张任务表，任务初始处于未激活状态。</p>
<p>等业务做完要同步的时候，再rpc请求触发激活。</p>
<p>任务管理微服务如果发现一个任务，超过最长执行时间没有激活。就说明激活rpc失败了，或者是服务崩溃，本身就没做变更。此时，自动激活即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbucvzl7K951Z4AH8AYxOdkVgibQd02LbnuuS9nkmxYPNqVOErqNlMTq3YO7cE3DJ3PZ7tNpCL8vZjbg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>优点：完全可靠（事务可能还是会失败，可靠指数据一定最终一致）。</p>
<p>缺点：</p>
<ul>
<li>开发成本比较大，同时会增加消息调用。</li>
<li>增加一个节点，事务失败得可能性更高。</li>
</ul>
<p>限制：</p>
<ul>
<li>消息处理需要遵循触发-查询机制</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>推荐方案三，成本不高，可靠性较强。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/09/My%20Lord%20Jesus/%E4%B8%BB%E6%97%A5%E8%AE%B2%E9%81%93/2021-05-09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/My%20Lord%20Jesus/%E4%B8%BB%E6%97%A5%E8%AE%B2%E9%81%93/2021-05-09/" class="post-title-link" itemprop="url">2021-05-09主日讲道</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-09 13:54:56" itemprop="dateCreated datePublished" datetime="2021-05-09T13:54:56+08:00">2021-05-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-03 21:49:43" itemprop="dateModified" datetime="2022-09-03T21:49:43+08:00">2022-09-03</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>题目：真假使徒，鉴别的背后真相<br>经文：哥林多后书10:7-11:6<br>讲员：赫纬洲</p>
<p>保罗和假使徒争辩的原因：</p>
<ul>
<li>保罗不是为了自己</li>
<li>关系到教会是否为主忠诚</li>
</ul>
<p>导致教会被诱惑的原因：</p>
<ul>
<li>自以为是，骄傲；但是他们还属肉体，不具备属灵眼光，看不到假使徒，不顺服 神</li>
<li>假使徒自己夸自己，用自己的标准衡量自己，炫耀自己的”权柄”</li>
<li>假使徒攻击保罗，言语粗俗、外部丑陋，</li>
</ul>
<p>保罗的反击：</p>
<ul>
<li>承认自己言语粗俗，但是真理和知识上完全充足，比假使徒更多</li>
<li>不会炫耀基督赐下的权柄</li>
<li>语气越发严厉</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%BA%94%E7%94%A8-01-java%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%BA%94%E7%94%A8-01-java%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">延迟加载应用-01-java语言</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-08 08:57:23" itemprop="dateCreated datePublished" datetime="2021-05-08T08:57:23+08:00">2021-05-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>一般有几种延迟初始化的场景：</p>
<ul>
<li>对于会消耗较多资源的对象：加快对象的创建速度，从而从整体上提升性能；并且如果这些对象可能根本用不到，那么就节省资源了。</li>
<li>某些数据在启动时无法获取：比如一些上下文信息可能在其他拦截器或处理中才能被设置，导致当前bean在加载的时候可能获取不到对应的变量的值 <!--bean被加载的时候？加载是针对类说的，对于bean，只能是实例化。如果说的是bean实例化阶段，那么就是发生在spring容器启动阶段以后。从另一方面来说，如果作者想表达的是bean被spring容器加载，那么bean被容器进行di时，spring推荐的是懒加载（延迟初始化），即只注入对象句柄，不关心这个对象句柄指向的对象是否有值 --> ，使用 延迟初始化可以在真正调用的时候去获取，通过延迟来保证数据的有效性。</li>
</ul>
<p>在Java8中引入的lambda对于我们实现延迟操作提供很大的便捷性，如Stream、Supplier等，下面介绍几个例子。</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><h4 id="Lambda-Supplier"><a href="#Lambda-Supplier" class="headerlink" title="Lambda Supplier"></a>Lambda Supplier</h4><p>通过调用<code>get()</code>方法来实现具体对象的计算和生成并返回，而不是在定义Supplier的时候计算，从而达到了_延迟初始化_的目的。</p>
<blockquote>
<p>但是在使用 中需要考虑并发的问题，即防止多次被实例化，就像Spring的@Lazy注解一样。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认第一次调用heavy.get()时，触发同步方法；不会在此定义的时候触发</span></span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;Heavy&gt; heavy = () -&gt; createAndCacheHeavy(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Holder created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Heavy <span class="title">getHeavy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次调用后heavy已经指向了新的instance，所以后续不再执行synchronized。为什么？？heavy.get()应该是每次调用getHeavy()，都会被执行一次；但是由于</span></span><br><span class="line">        <span class="keyword">return</span> heavy.get(); </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Heavy <span class="title">createAndCacheHeavy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法内定义class，注意和类内的嵌套class在加载时的区别</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">HeavyFactory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Heavy</span>&gt; </span>&#123;</span><br><span class="line">            <span class="comment">// 饥渴初始化</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Heavy heavyInstance = <span class="keyword">new</span> Heavy(); </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Heavy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 每次返回固定的值</span></span><br><span class="line">                <span class="keyword">return</span> heavyInstance; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一次调用方法来会将heavy重定向到新的Supplier实例</span></span><br><span class="line">        <span class="keyword">if</span>(!HeavyFactory.class.isInstance(heavy)) &#123;</span><br><span class="line">            heavy = <span class="keyword">new</span> HeavyFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heavy.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Holder的实例被创建时，其中的Heavy实例还没有被创建。下面我们假设有三个线程会调用getHeavy方法，其中前两个线程会同时调用，而第三个线程会在稍晚的时候调用。</p>
<p>当前两个线程调用该方法的时候，都会调用到createAndCacheHeavy方法，由于这个方法是同步的。因此第一个线程进入方法体，第二个线程开始等待。在createAndCacheHeavy方法体中会首先判断当前的heavy是否是HeavyInstance的一个实例。</p>
<p>如果不是，就会将heavy对象替换成HeavyFactory类型的实例。</p>
<ul>
<li>第一个线程执行判断时，heavy对象还只是一个<code>Supplier的实例</code>，所以heavy会被替换成为<code>HeavyFactory的实例</code>，此时<code>heavy实例</code>会被真正的实例化，然后返回实例heavyInstance</li>
<li>第二个线程执行判断时，heavy已经是HeavyFactory的一个实例了，跳过判断，即不实例化，然后直接返回已存在的实例heavyInstance。</li>
</ul>
<p>当第三个线程执行getHeavy方法时，由于此时的heavy对象已经是内嵌的HeavyFactory的实例了，因此它会直接调用HeavyFactory的get()方法从而返回需要的实例（即heavyInstance），即不再调用Heavy的同步方法createAndCacheHeavy没有任何关系了。<!--因为Heavy的同步方法是createAndCacheHeavy()--></p>
<!--在我看来，这是通过把Heavy类向下转为另一个类HeavyFactory（从新实现get()方法），从而get()方法的执行对象变了，这在JUC书中阐述的使用工厂类来避免初始化阶段的线程安全性，一致-->

<p>以上代码实际上实现了一个轻量级的虚拟代理模式(Virtual Proxy Pattern)。保证了懒加载在各种环境下的正确性。</p>
<h5 id="基于delegate：容易理解"><a href="#基于delegate：容易理解" class="headerlink" title="基于delegate：容易理解"></a>基于delegate：容易理解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoizeSupplier</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> Supplier&lt;T&gt; delegate;</span><br><span class="line"> ConcurrentMap&lt;Class&lt;?&gt;, T&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MemoizeSupplier</span><span class="params">(Supplier&lt;T&gt; delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 利用computeIfAbsent方法的特性，保证只会在key不存在的时候调用一次实例化方法，进而实现单例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.map.computeIfAbsent(MemoizeSupplier.class,k -&gt; <span class="keyword">this</span>.delegate.get());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Supplier&lt;T&gt; <span class="title">of</span><span class="params">(Supplier&lt;T&gt; provider)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MemoizeSupplier&lt;&gt;(provider);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="基于CloseableSupplier-：复杂但功能多"><a href="#基于CloseableSupplier-：复杂但功能多" class="headerlink" title="基于CloseableSupplier ：复杂但功能多"></a>基于CloseableSupplier ：复杂但功能多</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseableSupplier</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;T&gt; delegate;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> resetAfterClose;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> T value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">CloseableSupplier</span><span class="params">(Supplier&lt;T&gt; delegate, <span class="keyword">boolean</span> resetAfterClose)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">            <span class="keyword">this</span>.resetAfterClose = resetAfterClose;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 经典Singleton实现</span></span><br><span class="line">            <span class="keyword">if</span> (!(<span class="keyword">this</span>.initialized)) &#123; <span class="comment">// 注意是volatile修饰的，保证happens-before，t一定实例化完全</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(<span class="keyword">this</span>.initialized)) &#123; <span class="comment">// Double Lock Check</span></span><br><span class="line">                        T t = <span class="keyword">this</span>.delegate.get();</span><br><span class="line">                        <span class="keyword">this</span>.value = t;</span><br><span class="line">                        <span class="keyword">this</span>.initialized = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始化后就直接读取值，不再同步抢锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> initialized;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(ThrowableConsumer&lt;T, X&gt; consumer)</span> <span class="keyword">throws</span> X </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialized &amp;&amp; <span class="keyword">this</span>.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    consumer.accept(<span class="keyword">this</span>.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class="line">            checkNotNull(mapper);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialized &amp;&amp; <span class="keyword">this</span>.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ofNullable(mapper.apply(value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            tryClose(i -&gt; &#123; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">tryClose</span><span class="params">(ThrowableConsumer&lt;T, X&gt; close)</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">                    close.accept(value);</span><br><span class="line">                    <span class="keyword">if</span> (resetAfterClose) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">                        initialized = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;MoreSuppliers.lazy(&quot;</span> + get() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;MoreSuppliers.lazy(&quot;</span> + <span class="keyword">this</span>.delegate + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lambda-Stream"><a href="#Lambda-Stream" class="headerlink" title="Lambda Stream"></a>Lambda Stream</h4><p>Stream中的各种方法分为两类：</p>
<ul>
<li>中间方法(limit()/iterate()/filter()/map())</li>
<li>结束方法(collect()/findFirst()/findAny()/count())</li>
</ul>
<p>前者的调用并不会立即执行，只有结束方法被调用后才会依次从前往后触发整个调用链条。但是需要注意，对于集合来说，是每一个元素依次按照处理链条执行到尾，而不是每一个中间方法都将所有能处理的元素全部处理一遍才触发 下一个中间方法。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Brad&quot;</span>, <span class="string">&quot;Kate&quot;</span>, <span class="string">&quot;Kim&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Joe&quot;</span>, <span class="string">&quot;Mike&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String firstNameWith3Letters = names.stream()</span><br><span class="line">    .filter(name -&gt; length(name) == <span class="number">3</span>)</span><br><span class="line">    .map(name -&gt; toUpper(name))</span><br><span class="line">    .findFirst()</span><br><span class="line">    .get();</span><br><span class="line"></span><br><span class="line">System.out.println(firstNameWith3Letters);</span><br></pre></td></tr></table></figure>

<p>当触发findFirst()这一结束方法的时候才会触发整个Stream链条，每个元素依次经过filter()-&gt;map()-&gt;findFirst()后返回。所以filter()先处理，names中第一个和第二个元素不符合条件，不会触发后续的map方法；继续处理第三个元素符合条件，再触发map()方法，最后将转换的结果返回给findFirst()。所以filter()触发了_3_次，map()触发了_1_次。</p>
<p>Stream类型的一个特点是：它们可以是无限的。Stream之所以可以是无限的也是源于Stream「懒」的这一特点。Stream只会返回你需要的元素，而不会一次性地将整个无限集合返回给你。</p>
<p>Stream接口中有一个静态方法iterate()，这个方法能够为你创建一个无限的Stream对象。它需要接受两个参数：</p>
<blockquote>
<p>public static Stream iterate(final T seed, final UnaryOperator f)</p>
</blockquote>
<p>其中，seed表示的是这个无限序列的起点，而UnaryOperator则表示的是如何根据前一个元素来得到下一个元素，比如序列中的第二个元素可以这样决定：f.apply(seed)。</p>
<p>下面是一个计算从某个数字开始并依次返回后面count个素数的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Primes</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">            <span class="comment">// 依次从2到number的平方根判断number是否可以整除该值，即divisor</span></span><br><span class="line">            IntStream.rangeClosed(<span class="number">2</span>, (<span class="keyword">int</span>) Math.sqrt(number))</span><br><span class="line">                .noneMatch(divisor -&gt; number % divisor == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">primeAfter</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(number + <span class="number">1</span>)) <span class="comment">// 如果当前的数的下一个数是素数，则直接返回该值</span></span><br><span class="line">            <span class="keyword">return</span> number + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 否则继续从下一个数据的后面继续找到第一个素数返回，递归</span></span><br><span class="line">            <span class="keyword">return</span> primeAfter(number + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">primes</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> fromNumber, <span class="keyword">final</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(primeAfter(fromNumber - <span class="number">1</span>), Primes::primeAfter)</span><br><span class="line">            .limit(count)</span><br><span class="line">            .collect(Collectors.&lt;Integer&gt;toList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于iterate和limit，它们只是中间操作，得到的对象仍然是Stream类型。对于collect方法，它是一个结束操作，会触发中间操作来得到需要的结果。</p>
<p>如果用非Stream的方式需要面临两个问题：</p>
<ul>
<li>一是无法提前知晓fromNumber后count个素数的数值边界是什么</li>
<li>二是无法使用有限的集合来表示计算范围，无法计算超大的数值</li>
</ul>
<p>所以，因为不知道第一个素数的位置在哪儿，需要提前计算出来第一个素数，然后用while来处理count次查找后续的素数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter03-%E8%BF%9E%E6%8E%A5%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter03-%E8%BF%9E%E6%8E%A5%E5%99%A8/" class="post-title-link" itemprop="url">chapter03-连接器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-08 07:55:05" itemprop="dateCreated datePublished" datetime="2021-05-08T07:55:05+08:00">2021-05-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-07 19:37:49" itemprop="dateModified" datetime="2021-10-07T19:37:49+08:00">2021-10-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在简介一章里说明了，tomcat由两大模块组成：连接器（connector）和容器（container）。本章将使用连接器来增强Chapter 2的功能。</p>
<ul>
<li>Chapter 2使用Server创建Request和Response; 现在交给connector创建  <!--它们作为参数传递给要调用的某个的servlet的service方法--></li>
<li>Chapter 2的servlet容器仅仅能运行实现了javax.servlet.Servlet接口，并把javax.servlet.ServletRequest和javax.servlet.ServletResponse实例传递给servlet的service方法；但是由于连接器并不知道servlet的具体类型（例如，该servlet是否javax.servlet.Servlet接口，还是继承自javax.servlet.GenericServlet类，或继承自javax.servlet.http.HttpServlet类），因此连接器总是传入HttpServletRequest和HttpServletResponse的实例对象。</li>
</ul>
<p>​     本章中所要建立的connector实际上是tomcat4中的默认连接器（将在第4章讨论）的简化版。本章中，connector和container将分离开。</p>
<p>从本章开始，每章的应用程序都会按照模块进行划分。本章的应用程序可分为3个模块：connector、startup、core。</p>
<ul>
<li>启动类模块仅包括一个启动类，负责启动应用程序。</li>
<li>connector模块的类可分为以下5个部分：<ul>
<li>连接器及其支持类（HttpConnector和HttpProcessor）；</li>
<li>表示http请求的类（HttpRequest）及其支持类；</li>
<li>表示http响应的类（HttpResponse）及其支持类；</li>
<li>外观装饰类（HttpRequestFacade和HttpResponseFacade）；</li>
<li>常量类。</li>
</ul>
</li>
<li>core模块包括ServletProcessor类和StaticResourceProcessor类。</li>
</ul>
<p><img src="https://www.programmersought.com/images/667/a2fa48bccff98a27f6d8df02278f4dab.png" alt="img"></p>
<p><img src="https://www.programmersought.com/images/968/2da5e3f2b2b3ac6ff7712ad78013cc60.png" alt="img">  </p>
<h3 id="启动类（略）"><a href="#启动类（略）" class="headerlink" title="启动类（略）"></a>启动类（略）</h3><h3 id="HttpConnector类"><a href="#HttpConnector类" class="headerlink" title="HttpConnector类"></a>HttpConnector类</h3><ul>
<li><p>HttpConnector类实现了java.lang.Runnable接口，为每个请求创建一个线程；</p>
</li>
<li><p>启动应用程序时，会创建一个HttpConnector对象，其run方法会被调用。其run方法中是一个循环体，执行以下三件事：</p>
<p>l     等待http请求；</p>
<p>l     为每个请求创建一个HttpPorcessor对象；</p>
<p>l     调用HttpProcessor对象的process方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex03.pyrmont.connector.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpConnector</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> stopped;</span><br><span class="line">  <span class="keyword">private</span> String scheme = <span class="string">&quot;http&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scheme;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      serverSocket =  <span class="keyword">new</span> ServerSocket(port, <span class="number">1</span>, InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">      <span class="comment">// Accept the next incoming connection from the server socket</span></span><br><span class="line">      Socket socket = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        socket = serverSocket.accept();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Hand this socket off to an HttpProcessor</span></span><br><span class="line">      HttpProcessor processor = <span class="keyword">new</span> HttpProcessor(<span class="keyword">this</span>);</span><br><span class="line">      processor.process(socket);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="HttpProcessor类的process-socket-方法"><a href="#HttpProcessor类的process-socket-方法" class="headerlink" title="HttpProcessor类的process(socket)方法"></a>HttpProcessor类的process(socket)方法</h3><p>每一个HttpProcessor内部持有一个Request和一个Response，因为要解析http请求，填充到Request里。构造HttpProcessor的时候，调用HttpConnector的createRequest/createResponse创建这两个对象。</p>
<p>HttpProcessor类的process方法从http请求中获取socket。对每个http请求，它要做一下三件事：</p>
<p>l     创建一个HttpRequest对象和一个HttpResponse对象；</p>
<p>l     处理请求行（request line）和请求头（request headers），填充HttpRequest对象；</p>
<p>l     将HttpRequest对象和HttpRespons</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProcessor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> HttpConnector httpConnector; <span class="comment">//通过构造函数，1对1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SocketInputStream inputStream; <span class="comment">//依赖 use</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OutputStream outputStream; <span class="comment">//依赖 use</span></span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">private</span> HttpRequest httpRequest;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">private</span> HttpResponse httpResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> BYTE_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpProcessor</span><span class="params">(HttpConnector httpConnector)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>.httpConnector = httpConnector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">              inputStream = <span class="keyword">new</span> SocketInputStream(socket.getInputStream(), BYTE_SIZE);</span><br><span class="line">              outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Create an httpRequest object</span></span><br><span class="line">              httpRequest = <span class="keyword">new</span> HttpRequest(inputStream);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Create an httpResponse object</span></span><br><span class="line">              httpResponse = <span class="keyword">new</span> HttpResponse(outputStream);</span><br><span class="line">              httpResponse.setRequest(httpRequest);</span><br><span class="line">              httpResponse.setHeader(<span class="string">&quot;Server&quot;</span>, <span class="string">&quot;Pyromont Servlet Container&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Parse the Header and Request parameters</span></span><br><span class="line">              parseRequest(input, output);</span><br><span class="line">              parseHeader(input);</span><br><span class="line"></span><br><span class="line">               / / Determine the url path, whether to call ServletResource</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(httpRequest.getUri().contains(<span class="string">&quot;/servlet/&quot;</span>)) &#123;</span><br><span class="line">                  ServletProcessor servletProcessor = <span class="keyword">new</span> ServletProcessor();</span><br><span class="line">                  servletProcessor.process(httpRequest, httpResponse);                   								<span class="comment">// or call staticResource</span></span><br><span class="line">              &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  StaticResourceProcessor staticResourceProcessor = <span class="keyword">new</span> StaticResourceProcessor();</span><br><span class="line">                  staticResourceProcessor.process(httpRequest, httpResponse);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// close the socket</span></span><br><span class="line">              socket.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-02-%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-02-%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">shiro应用-02-权限配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-07 09:17:57" itemprop="dateCreated datePublished" datetime="2021-05-07T09:17:57+08:00">2021-05-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="配置位置"><a href="#配置位置" class="headerlink" title="配置位置"></a>配置位置</h3><p>认证和授权的存储和交互都在AuthorizingReaml中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Lazy</span> 延迟注入，不然redis注解会因为注入顺序问题失效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        User user = (User) principals.fromRealm(<span class="keyword">this</span>.getClass().getName()).iterator().next();</span><br><span class="line">        List&lt;String&gt; permissionList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; roleNameList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;Role&gt; roleSet = user.getRoles();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(roleSet)) &#123;</span><br><span class="line">            <span class="keyword">for</span>(Role role : roleSet) &#123;</span><br><span class="line">                roleNameList.add(role.getName());</span><br><span class="line">                Set&lt;Permission&gt; permissionSet = role.getPermissions();</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(permissionSet)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Permission permission : permissionSet) &#123;</span><br><span class="line">                        permissionList.add(permission.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        info.addStringPermissions(permissionList);</span><br><span class="line">        info.addRoles(roleNameList);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) token;</span><br><span class="line">        String username = usernamePasswordToken.getUsername();</span><br><span class="line">        User user = userService.findByUsername(username);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(user, user.getPassword(), <span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行位置"><a href="#执行位置" class="headerlink" title="执行位置"></a>执行位置</h3><p>shiro 中的AuthorizingRealm有2个方法doGetAuthorizationInfo()和doGetAuthenticationInfo(),一般实际开发中继承AuthorizingRealm类然后重写doGetAuthorizationInfo和doGetAuthenticationInfo。     </p>
<ul>
<li>doGetAuthenticationInfo方法是在用户登录的时候调用的也就是执SecurityUtils.getSubject().login（）的时候调用，即登录验证</li>
<li>doGetAuthorizationInfo方法是调用SecurityUtils.getSubject().isPermitted（）这个方法时会调用doGetAuthorizationInfo（），<ul>
<li>@RequiresPermissions这个注解起始就是在执行SecurityUtils.getSubject().isPermitted（）。</li>
<li>某个方法上加上@RequiresPermissions，那么访问这个方法就会自动调用SecurityUtils.getSubject().isPermitted（），从而区调用doGetAuthorizationInfo</li>
</ul>
</li>
</ul>
<h4 id="踩的坑"><a href="#踩的坑" class="headerlink" title="踩的坑"></a>踩的坑</h4><p>调用链：isPermitted -&gt; getAuhtorizationInfo -&gt; doGetAuthorizationInfo</p>
<p>但是，如果不做单点登录，一个账号被多个用户登录，那么账户信息会被cache保存，在getAuhtorizationInfo会判断，如果账户信息被cache了，就不执行doGetAuthorizationInfo</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro-spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-04-%E6%9D%83%E9%99%90%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro-spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-04-%E6%9D%83%E9%99%90%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">shiro源码解析-04-权限注解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-07 09:13:54" itemprop="dateCreated datePublished" datetime="2021-05-07T09:13:54+08:00">2021-05-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前不久学习了Shiro 1.4.0提供的权限注解实现权限拦截。最开始猜测实现方式是基于AspectJ方式，即基于<code>@Apsect</code>配合<code>@Pointcut和@After,@AfterReturning,@AfterThrowing,@Around,@Before</code>实现。具体Spring基于Aspect，AOP实现类可以查看<code>AnnotationAwareAspectJAutoProxyCreator</code>。在此提供该类的UML图：</p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/20190915155105740.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190915155105740.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="Spring基于AspectJ实现的AOP实现类UML图"></a></p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/20190915155105740.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70">Spring基于AspectJ实现的AOP实现类UML图</a></p>
<p>你可以看到Spring AOP实现继承类大致为ProxyConfig-&gt;ProxyProcessorSupport-&gt;AbstractAutoProxyCreator</p>
<p>-&gt;AbstractAdvisorAutoProxyCreator这条路线。其中Spring常见AOP实现类有3个。</p>
<ul>
<li><code>DefaultAdvisorAutoProxyCreator</code>：寻找当前BeanFactory中所有的候选<code>Advisor(有一个切点和一个通知构成)</code>，将这些Advisor应用到所有符合切点的Bean中。基于Advisor 匹配规则。</li>
<li><code>BeanNameAutoProxyCreator</code>：基于Bean配置名规则</li>
<li><code>AnnotationAwareAspectJAutoProxyCreator</code>：基于Bean中@AspectJ注解匹配规则。</li>
</ul>
<p>而Shiro权限注解实现原理是基于<code>DefaultAdvisorAutoProxyCreator</code>实现的。其权限注解处理Advisor实现类是<code>AuthorizationAttributeSourceAdvisor</code>。该类继承了<code>StaticMethodMatcherPointcutAdvisor</code>，内部只对Shiro提供的5个权限注解标注的方法或者类进行切面增强。<code>StaticMethodMatcherPointcutAdvisor</code>是静态方法切点基类，默认匹配所有的的类。<code>StaticMethodMatcherPointcut</code>包括两个主要的子类分别是</p>
<p><code>JdkRegexpMethodPointcut</code>和<code>NameMatchMethodPointcut</code>。前者提供正则表达式匹配方法切面，而后者<strong>作为正则表达式的替代，不处理重载方法，默认实现检测xxx*, *xxx 和*xxx*</strong>。</p>
<h3 id="AuthorizationAttributeSourceAdvisor"><a href="#AuthorizationAttributeSourceAdvisor" class="headerlink" title="AuthorizationAttributeSourceAdvisor"></a>AuthorizationAttributeSourceAdvisor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public class AuthorizationAttributeSourceAdvisor extends StaticMethodMatcherPointcutAdvisor &#123;</span><br><span class="line"></span><br><span class="line">    private static final Class&lt;? extends Annotation&gt;[] AUTHZ_ANNOTATION_CLASSES &#x3D;</span><br><span class="line">            new Class[] &#123;</span><br><span class="line">                    RequiresPermissions.class, RequiresRoles.class,</span><br><span class="line">                    RequiresUser.class, RequiresGuest.class, RequiresAuthentication.class</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    protected SecurityManager securityManager &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Create a new AuthorizationAttributeSourceAdvisor.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public AuthorizationAttributeSourceAdvisor() &#123;</span><br><span class="line">        setAdvice(new AopAllianceAnnotationsAuthorizingMethodInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SecurityManager getSecurityManager() &#123;</span><br><span class="line">        return securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSecurityManager(org.apache.shiro.mgt.SecurityManager securityManager) &#123;</span><br><span class="line">        this.securityManager &#x3D; securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean matches(Method method, Class targetClass) &#123;</span><br><span class="line">        Method m &#x3D; method;</span><br><span class="line"></span><br><span class="line">        if ( isAuthzAnnotationPresent(m) ) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;The &#39;method&#39; parameter could be from an interface that doesn&#39;t have the annotation.</span><br><span class="line">        &#x2F;&#x2F;Check to see if the implementation has it.</span><br><span class="line">        if ( targetClass !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                m &#x3D; targetClass.getMethod(m.getName(), m.getParameterTypes());</span><br><span class="line">                return isAuthzAnnotationPresent(m) || isAuthzAnnotationPresent(targetClass);</span><br><span class="line">            &#125; catch (NoSuchMethodException ignored) &#123;</span><br><span class="line">                &#x2F;&#x2F;default return value is false.  If we can&#39;t find the method, then obviously</span><br><span class="line">                &#x2F;&#x2F;there is no annotation, so just use the default return value.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检测类上是否存在权限验证注解</span><br><span class="line">    private boolean isAuthzAnnotationPresent(Class&lt;?&gt; targetClazz) &#123;</span><br><span class="line">        for( Class&lt;? extends Annotation&gt; annClass : AUTHZ_ANNOTATION_CLASSES ) &#123;</span><br><span class="line">            Annotation a &#x3D; AnnotationUtils.findAnnotation(targetClazz, annClass);</span><br><span class="line">            if ( a !&#x3D; null ) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检测方法上是否存在权限验证注解</span><br><span class="line">    private boolean isAuthzAnnotationPresent(Method method) &#123;</span><br><span class="line">        for( Class&lt;? extends Annotation&gt; annClass : AUTHZ_ANNOTATION_CLASSES ) &#123;</span><br><span class="line">            Annotation a &#x3D; AnnotationUtils.findAnnotation(method, annClass);</span><br><span class="line">            if ( a !&#x3D; null ) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Shiro注解权限验证MethodInterceptor"><a href="#Shiro注解权限验证MethodInterceptor" class="headerlink" title="Shiro注解权限验证MethodInterceptor"></a>Shiro注解权限验证MethodInterceptor</h3><p>该类是Shiro权限注解拦截器。初始化时，<code>interceptors</code>添加了5个方法拦截器，分别对5种权限验证方法进行拦截。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class AopAllianceAnnotationsAuthorizingMethodInterceptor</span><br><span class="line">        extends AnnotationsAuthorizingMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public AopAllianceAnnotationsAuthorizingMethodInterceptor() &#123;</span><br><span class="line">        List&lt;AuthorizingAnnotationMethodInterceptor&gt; interceptors &#x3D;</span><br><span class="line">                new ArrayList&lt;AuthorizingAnnotationMethodInterceptor&gt;(5);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;use a Spring-specific Annotation resolver - Spring&#39;s AnnotationUtils is nicer than the</span><br><span class="line">        &#x2F;&#x2F;raw JDK resolution process.</span><br><span class="line">        AnnotationResolver resolver &#x3D; new SpringAnnotationResolver();</span><br><span class="line">        &#x2F;&#x2F;we can re-use the same resolver instance - it does not retain state:</span><br><span class="line">        interceptors.add(new RoleAnnotationMethodInterceptor(resolver));</span><br><span class="line">        interceptors.add(new PermissionAnnotationMethodInterceptor(resolver));</span><br><span class="line">        interceptors.add(new AuthenticatedAnnotationMethodInterceptor(resolver));</span><br><span class="line">        interceptors.add(new UserAnnotationMethodInterceptor(resolver));</span><br><span class="line">        interceptors.add(new GuestAnnotationMethodInterceptor(resolver));</span><br><span class="line"></span><br><span class="line">        setMethodInterceptors(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;</span><br><span class="line">        org.apache.shiro.aop.MethodInvocation mi &#x3D; createMethodInvocation(methodInvocation);</span><br><span class="line">        return super.invoke(mi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类通过调用invoke方法，进而调用超级父类<code>AuthorizingMethodInterceptor</code>的invoke方法，在该方法中会先执行<code>assertAuthorized</code>方法，进行权限校验，校验不通过抛出<code>AuthorizationException</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AuthorizingMethodInterceptor extends MethodInterceptorSupport &#123;</span><br><span class="line"></span><br><span class="line">    public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;</span><br><span class="line">        assertAuthorized(methodInvocation);</span><br><span class="line">        return methodInvocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void assertAuthorized(MethodInvocation methodInvocation) throws AuthorizationException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>assertAuthorized</code>方法最终执行还是<code>AnnotationsAuthorizingMethodInterceptor</code>。而<code>AuthorizingMethodInterceptor</code>有5个具体的实现类。如下：</p>
<ul>
<li>RoleAnnotationMethodInterceptor</li>
<li>PermissionAnnotationMethodInterceptor</li>
<li>AuthenticatedAnnotationMethodInterceptor</li>
<li>UserAnnotationMethodInterceptor</li>
<li>GuestAnnotationMethodInterceptor</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AnnotationsAuthorizingMethodInterceptor extends AuthorizingMethodInterceptor &#123;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    protected void assertAuthorized(MethodInvocation methodInvocation) throws AuthorizationException &#123;</span><br><span class="line">        &#x2F;&#x2F;default implementation just ensures no deny votes are cast:</span><br><span class="line">        Collection&lt;AuthorizingAnnotationMethodInterceptor&gt; aamis &#x3D; getMethodInterceptors();</span><br><span class="line">        if (aamis !&#x3D; null &amp;&amp; !aamis.isEmpty()) &#123;</span><br><span class="line">            for (AuthorizingAnnotationMethodInterceptor aami : aamis) &#123;</span><br><span class="line">                if (aami.supports(methodInvocation)) &#123;</span><br><span class="line">                    aami.assertAuthorized(methodInvocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AuthorizingAnnotationMethodInterceptor</code>首先从子类获取<code>AuthorizingAnnotationHandler</code>，再调用该实现类的<code>assertAuthorized</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AuthorizingAnnotationMethodInterceptor extends AnnotationMethodInterceptor</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    public AuthorizingAnnotationMethodInterceptor( AuthorizingAnnotationHandler handler ) &#123;</span><br><span class="line">        super(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AuthorizingAnnotationMethodInterceptor( AuthorizingAnnotationHandler handler,</span><br><span class="line">                                                   AnnotationResolver resolver) &#123;</span><br><span class="line">        super(handler, resolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;</span><br><span class="line">        assertAuthorized(methodInvocation);</span><br><span class="line">        return methodInvocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void assertAuthorized(MethodInvocation mi) throws AuthorizationException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ((AuthorizingAnnotationHandler)getHandler()).assertAuthorized(getAnnotation(mi));</span><br><span class="line">        &#125;</span><br><span class="line">        catch(AuthorizationException ae) &#123;</span><br><span class="line">            &#x2F;&#x2F; Annotation handler doesn&#39;t know why it was called, so add the information here if possible. </span><br><span class="line">            &#x2F;&#x2F; Don&#39;t wrap the exception here since we don&#39;t want to mask the specific exception, such as </span><br><span class="line">            &#x2F;&#x2F; UnauthenticatedException etc. </span><br><span class="line">            if (ae.getCause() &#x3D;&#x3D; null) ae.initCause(new AuthorizationException(&quot;Not authorized to invoke method: &quot; + mi.getMethod()));</span><br><span class="line">            throw ae;</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RoleAnnotationMethodInterceptor"><a href="#RoleAnnotationMethodInterceptor" class="headerlink" title="RoleAnnotationMethodInterceptor"></a>RoleAnnotationMethodInterceptor</h3><p>下面分析一下RoleAnnotationMethodInterceptor。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class RoleAnnotationMethodInterceptor extends AuthorizingAnnotationMethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public RoleAnnotationMethodInterceptor() &#123;</span><br><span class="line">        super( new RoleAnnotationHandler() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 具体校验逻辑交给RoleAnnotationHandler</span><br><span class="line">    public RoleAnnotationMethodInterceptor(AnnotationResolver resolver) &#123;</span><br><span class="line">        super(new RoleAnnotationHandler(), resolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RoleAnnotationHandler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class RoleAnnotationHandler extends AuthorizingAnnotationHandler &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">    public void assertAuthorized(Annotation a) throws AuthorizationException &#123;</span><br><span class="line">        if (!(a instanceof RequiresRoles)) return;</span><br><span class="line"></span><br><span class="line">        RequiresRoles rrAnnotation &#x3D; (RequiresRoles) a;</span><br><span class="line">        String[] roles &#x3D; rrAnnotation.value();</span><br><span class="line"></span><br><span class="line">        if (roles.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            getSubject().checkRole(roles[0]);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (Logical.AND.equals(rrAnnotation.logical())) &#123;</span><br><span class="line">            getSubject().checkRoles(Arrays.asList(roles));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (Logical.OR.equals(rrAnnotation.logical())) &#123;</span><br><span class="line">            &#x2F;&#x2F; Avoid processing exceptions unnecessarily - &quot;delay&quot; throwing the exception by calling hasRole first</span><br><span class="line">            boolean hasAtLeastOneRole &#x3D; false;</span><br><span class="line">            for (String role : roles) if (getSubject().hasRole(role)) hasAtLeastOneRole &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; Cause the exception if none of the role match, note that the exception message will be a bit misleading</span><br><span class="line">            if (!hasAtLeastOneRole) getSubject().checkRole(roles[0]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现类似编程式AOP"><a href="#实现类似编程式AOP" class="headerlink" title="实现类似编程式AOP"></a>实现类似编程式AOP</h2><ol>
<li>定义一个注解<code>LogPrinter</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface LogPrinter &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>继承StaticMethodMatcherPointcutAdvisor</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class LogPrinterAdvisor extends StaticMethodMatcherPointcutAdvisor &#123;</span><br><span class="line"></span><br><span class="line">    public LogPrinterAdvisor() &#123;</span><br><span class="line">        setAdvice(new LogPrinterMethodInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(@NonNull Method method, Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">        Method m &#x3D; method;</span><br><span class="line">        if (isAnnotationPresent(m)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (targetClass !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                m &#x3D; targetClass.getMethod(m.getName(), m.getParameterTypes());</span><br><span class="line">                return isAnnotationPresent(m);</span><br><span class="line">            &#125; catch (NoSuchMethodException ignored) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isAnnotationPresent(Method method) &#123;</span><br><span class="line">        Annotation a &#x3D; AnnotationUtils.findAnnotation(method, LogPrinter.class);</span><br><span class="line">        return a !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>实现<code>MethodInterceptor</code>接口，定义切面处理逻辑</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class LogPrinterMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">        LogPrinter logPrinter &#x3D; invocation.getMethod().getAnnotation(LogPrinter.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;log printer: &quot;+logPrinter.value());</span><br><span class="line">        return invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义测试类，并添加LogPrinter注解</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">    @LogPrinter(&quot;hello world&quot;)</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>启动类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAdvisorApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">defaultAdvisorAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        defaultAdvisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> defaultAdvisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LogPrinterAdvisor <span class="title">logPrinterAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogPrinterAdvisor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(LogAdvisorApplication.class, args);</span><br><span class="line">        HelloWorld helloWorld = context.getBean(HelloWorld.class);</span><br><span class="line">        helloWorld.hello();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>Shiro的注解式权限，核心配置是一个<code>DefaultAdvisorAutoProxyCreator</code>和继承静态方法顾问<code>StaticMethodMatcherPointcutAdvisor</code>。其中5种权限注解，使用了统一的代码架构，用到了模板</p>
<p>设计模式。在架构实现上要好于<code>AspectJ注解实现</code>。</p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/20190915155201485.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190915155201485.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="Shiro角色权限注解UML示意图"></a></p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/20190915155201485.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70">Shiro角色权限注解UML示意图</a></p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/20190915155130196.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190915155130196.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="Shiro权限注解AOP实现类UML图"></a></p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/20190915155130196.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70">Shiro权限注解AOP实现类UML图</a></p>
<p><strong>文章作者:</strong> <a href="mailto:undefined">知源</a></p>
<p><strong>文章链接:</strong> <a target="_blank" rel="noopener" href="https://crazyblitz.github.io/2019/09/15/Shiro%E6%9D%83%E9%99%90%E6%B3%A8%E8%A7%A3AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">https://crazyblitz.github.io/2019/09/15/Shiro权限注解AOP实现原理分析/</a></p>
<p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a target="_blank" rel="noopener" href="https://crazyblitz.github.io/">知源博客</a>！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01/" class="post-title-link" itemprop="url">shiro源码解析-01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-07 09:12:23" itemprop="dateCreated datePublished" datetime="2021-05-07T09:12:23+08:00">2021-05-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>目录</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://my.oschina.net/huangyong/blog/209339">Shiro 之 入口：EnvironmentLoaderListener</a>【由 黄勇 分享】</li>
<li><a target="_blank" rel="noopener" href="http://my.oschina.net/huangyong/blog/210438">Shiro 之 Filter（上）：ShiroFilter</a>【由 黄勇 分享】</li>
<li>Shiro 之 Filter（下）</li>
<li><a target="_blank" rel="noopener" href="http://my.oschina.net/snakerflow/blog/219860">Shiro 之 Realm</a>【由 Dead_knight 分享】</li>
<li>Shiro 之 SessionManager</li>
<li><a target="_blank" rel="noopener" href="http://my.oschina.net/snakerflow/blog/219859">Shiro 之 SecurityManager</a>【由 Dead_knight 分享】</li>
<li>Shiro 之 加密与解密</li>
<li>Shiro 之 JSP Tag</li>
<li>Shiro 之 Cache</li>
<li>Shiro 之 与 Spring 集成</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">类加载机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-06 23:44:42" itemprop="dateCreated datePublished" datetime="2021-05-06T23:44:42+08:00">2021-05-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-07 08:37:32" itemprop="dateModified" datetime="2021-05-07T08:37:32+08:00">2021-05-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="双亲委派是什么"><a href="#双亲委派是什么" class="headerlink" title="双亲委派是什么"></a>双亲委派是什么</h3><p>如果一个类加载器收到了类加载的请求，他首先会从自己缓存里查找是否之前加载过这个class，加载过直接返回，没加载过的话他不会自己亲自去加载，他会把这个请求委派给父类加载器去完成，每一层都是如此，类似递归，一直递归到顶层父类。</p>
<p>也就是<code>Bootstrap ClassLoader</code>，只要加载完成就会返回结果，如果顶层父类加载器无法加载此class，则会返回去交给子类加载器去尝试加载，若最底层的子类加载器也没找到，则会抛出<code>ClassNotFoundException</code>。</p>
<p>源码在<code>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</code></p>
<h3 id="为什么需要破坏双亲委派模型"><a href="#为什么需要破坏双亲委派模型" class="headerlink" title="为什么需要破坏双亲委派模型"></a>为什么需要破坏双亲委派模型</h3><blockquote>
<p>Jdbc</p>
</blockquote>
<p>Jdbc为什么要破坏双亲委派模型？</p>
<p>以前的用法是未破坏双亲委派模型的，比如<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code></p>
<p>而在JDBC4.0以后，开始支持使用spi的方式来注册这个Driver，具体做法就是在mysql的jar包中的<code>META-INF/services/java.sql.Driver</code>文件中指明当前使用的Driver是哪个，然后使用的时候就不需要我们手动的去加载驱动了，我们只需要直接获取连接就可以了。<code>Connection con = DriverManager.getConnection(url, username, password );</code></p>
<p>首先，理解一下为什么JDBC需要破坏双亲委派模式，原因是原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL的<code>mysql-connector-*.jar</code>中的Driver类具体实现的。</p>
<p>原生的JDBC中的类是放在<code>rt.jar</code>包的，是由Bootstrap加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而<code>mysql-connector-*.jar</code>中的Driver类是用户自己写的代码，那Bootstrap类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由Application类加载器去进行类加载。</p>
<p>这个时候就引入线程上下文件类加载器(<code>Thread Context ClassLoader</code>)，通过这个东西程序就可以把原本需要由Bootstrap类加载器进行加载的类由Application类加载器去进行加载了。</p>
<blockquote>
<p>Tomcat</p>
</blockquote>
<p>Tomcat为什么要破坏双亲委派模型？</p>
<p>因为一个Tomcat可以部署N个web应用，但是每个web应用都有自己的classloader，互不干扰。比如web1里面有<code>com.test.A.class</code>，web2里面也有<code>com.test.A.class</code>，如果没打破双亲委派模型的话，那么web1加载完后，web2在加载的话会冲突。</p>
<p>因为只有一套classloader，却出现了两个重复的类路径，所以tomcat打破了双亲委派。Tomcat线程级别的，不同web应用是不同的classloader。</p>
<ul>
<li>Java spi 方式，比如jdbc4.0开始就是其中之一。</li>
<li>热部署的场景会破坏，否则实现不了热部署。</li>
</ul>
<h3 id="如何破坏双亲委派模型"><a href="#如何破坏双亲委派模型" class="headerlink" title="如何破坏双亲委派模型"></a>如何破坏双亲委派模型</h3><p>重写<code>loadClass</code>方法，别重写<code>findClass</code>方法，因为<code>loadClass</code>是核心入口，将其重写成自定义逻辑即可破坏双亲委派模型。</p>
<h3 id="如何自定义一个类加载器"><a href="#如何自定义一个类加载器" class="headerlink" title="如何自定义一个类加载器"></a>如何自定义一个类加载器</h3><p>只需要继承<code>java.lang.Classloader</code>类，然后覆盖他的<code>findClass(String name)</code>方法即可，该方法根据参数指定的类名称，返回对应 的Class对象的引用。</p>
<h3 id="热部署原理"><a href="#热部署原理" class="headerlink" title="热部署原理"></a>热部署原理</h3><p>采取破坏双亲委派模型的手段来实现热部署，默认的<code>loadClass()</code>方法先找缓存，你改了class字节码也不会热加载，所以自定义ClassLoader，去掉找缓存那部分，直接就去加载，也就是每次都重新加载。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
