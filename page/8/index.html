<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>BootFei&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="BootFei&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BootFei&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-分布式系统/分布式-链路追踪/java探针" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88/" class="article-date">
  <time datetime="2021-05-13T00:21:05.000Z" itemprop="datePublished">2021-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88/">java探针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="探针类SimpleAgent-java"><a href="#探针类SimpleAgent-java" class="headerlink" title="探针类SimpleAgent.java"></a>探针类SimpleAgent.java</h3><h4 id="方法1：premain"><a href="#方法1：premain" class="headerlink" title="方法1：premain"></a>方法1：premain</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>&#123;</span><br><span class="line">      	...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>premain 方法为固定写法，它有两个方法签名可以选择，JVM 首先会去寻找这个方法来启动探针，它传入了探针的参数，以及 Instrumentation 对象，该对象可以提供对字节码的修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void premain(String agentArgs, Instrumentation inst);</span><br></pre></td></tr></table></figure>

<p>如果没有找到上面的方法，则会寻找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void premain(String agentArgs);</span><br></pre></td></tr></table></figure>

<h4 id="方法2：attach"><a href="#方法2：attach" class="headerlink" title="方法2：attach"></a>方法2：attach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAgent</span></span>&#123;</span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;agentmain&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打包方式"><a href="#打包方式" class="headerlink" title="打包方式"></a>打包方式</h3><p>打包为可用的 java agent 时，需要注意配置参数，上面提供了两种方式，一个是直接在<code>pom.xml</code>中指定配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>com.git.hui.agent.SimpleAgent<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>com.git.hui.agent.SimpleAgent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外一个是在配置文件 <code>META-INF/MANIFEST.MF</code> 中写好(需要注意最后一个空行不可或缺）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: com.git.hui.agent.SimpleAgent</span><br><span class="line">Agent-Class: com.git.hui.agent.SimpleAgent</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="方法1：使用MANIFEST-INFO"><a href="#方法1：使用MANIFEST-INFO" class="headerlink" title="方法1：使用MANIFEST.INFO"></a>方法1：使用MANIFEST.INFO</h4><ul>
<li>在资源目录(Resources)下，新建目录<code>META-INF</code></li>
<li>在<code>META-INF</code>目录下，新建文件<code>MANIFEST.MF</code></li>
</ul>
<p>文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: com.git.hui.agent.SimpleAgent #适用于premain方式</span><br><span class="line">Agent-Class: com.git.hui.agent.SimpleAgent #适用于attach方式</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line"> #空行</span><br></pre></td></tr></table></figure>

<p>请注意，最后的一个空行，不能少，在 idea 中，删除最后一行时，会有错误提醒</p>
<p>然后我们的<code>pom.xml</code>配置，需要作出对应的修改</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">manifestFile</span>&gt;</span></span><br><span class="line">                      src/main/resources/META-INF/MANIFEST.MF</span><br><span class="line">                  <span class="tag">&lt;/<span class="name">manifestFile</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--&lt;manifestEntries&gt;--&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--&lt;Premain-Class&gt;com.git.hui.agent.SimpleAgent&lt;/Premain-Class&gt;--&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--&lt;Agent-Class&gt;com.git.hui.agent.SimpleAgent&lt;/Agent-Class&gt;--&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--&lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt;--&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--&lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt;--&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--&lt;/manifestEntries&gt;--&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">goal</span>&gt;</span>attached<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>mvn assembly:assembly</code>命令打包</p>
<h4 id="方法2：pom-指定配置"><a href="#方法2：pom-指定配置" class="headerlink" title="方法2：pom 指定配置"></a>方法2：pom 指定配置</h4><p>在 pom.xml 文件中，添加如下配置，请注意一下<code>manifestEntries</code>标签内的参数</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>com.git.hui.agent.SimpleAgent<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>com.git.hui.agent.SimpleAgent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>attached<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后通过 <code>mvn assembly:assembly</code> 命令打包，在<code>target</code>目录下，可以看到一个后缀为<code>jar-with-dependencies</code>的 jar 包，就是我们的目标</p>
<h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><p>创建一个web项目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MVCWeb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;web running&quot;</span>);</span><br><span class="line">        	Thread.sleep(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>使用姿势</th>
</tr>
</thead>
<tbody><tr>
<td><code>premain()</code></td>
<td>agent 以 jvm 方式加载时调用，即目标应用在启动时，指定了 agent</td>
<td><code>-javaagent:xxx.jar</code></td>
</tr>
<tr>
<td><code>agentmain()</code></td>
<td>agent 以 attach 方式运行时调用，目标应用程序正常工作后，使用attach应用</td>
<td><code>VirtualMachine.attach(pid)</code>来指定目标进程号 <br/> <code>vm.loadAgent(&quot;...jar&quot;)</code>加载 agent</td>
</tr>
</tbody></table>
<h4 id="方法1：使用jar-agent"><a href="#方法1：使用jar-agent" class="headerlink" title="方法1：使用jar-agent"></a>方法1：使用jar-agent</h4><p>web项目启动时，添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:&#x2F;Users&#x2F;....&#x2F;target&#x2F;java-agent-1.0-SNAPSHOT-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure>



<h4 id="方法2：使用attach方式"><a href="#方法2：使用attach方式" class="headerlink" title="方法2：使用attach方式"></a>方法2：使用attach方式</h4><p>另启动一个attach项目，将agent绑定到web上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, AgentLoadException, AgentInitializationException, AttachNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// attach方法参数为目标应用程序的进程号</span></span><br><span class="line">        VirtualMachine vm = VirtualMachine.attach(<span class="string">&quot;web的进程号&quot;</span>);</span><br><span class="line">        <span class="comment">// 请用你自己的agent绝对地址，替换这个</span></span><br><span class="line">        vm.loadAgent(<span class="string">&quot;/Users/......./target/java-agent-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="使用原生JDK8开发探针统计接口耗时"><a href="#使用原生JDK8开发探针统计接口耗时" class="headerlink" title="使用原生JDK8开发探针统计接口耗时"></a>使用原生JDK8开发探针统计接口耗时</h3><h4 id="java-lang-instrument接口定义"><a href="#java-lang-instrument接口定义" class="headerlink" title="java.lang.instrument接口定义"></a>java.lang.instrument接口定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册一个Transformer，从此之后的类加载都会被Transformer拦截。</span></span><br><span class="line"><span class="comment"> * Transformer可以直接对类的字节码byte[]进行修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对JVM已经加载的类重新触发类加载。使用的就是上面注册的Transformer。</span></span><br><span class="line"><span class="comment"> * retransformation可以修改方法体，但是不能变更方法签名、增加和删除方法/类的成员属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个jar加入到bootstrap classloader的 classpath里</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendToBootstrapClassLoaderSearch</span><span class="params">(JarFile jarfile)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前被JVM加载的所有类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class[] getAllLoadedClasses();</span><br></pre></td></tr></table></figure>

<p>前面两个方法比较重要，addTransformer 方法配置之后，后续的类加载都会被 Transformer 拦截。对于已经加载过的类，可以执行 retransformClasses 来重新触发这个 Transformer 的拦截。类加载的字节码被修改后，除非再次被 retransform，否则不会恢复。</p>
<p>通过上面的描述，可知</p>
<ul>
<li>可以通过<code>Transformer</code>修改类</li>
<li>类加载时，会被触发 Transformer 拦截</li>
</ul>
<h4 id="实现instrument-ClassFileTransformer接口"><a href="#实现instrument-ClassFileTransformer接口" class="headerlink" title="实现instrument.ClassFileTransformer接口"></a>实现instrument.ClassFileTransformer接口</h4><p>在方法的执行前，记录一个时间，执行完之后统计一下时间差，即为耗时</p>
<p>直接修改字节码有点麻烦，因此我们借助神器<code>javaassist</code>来修改字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CostTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">            ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="comment">// 这里我们限制下，只针对目标包下进行耗时统计</span></span><br><span class="line">        <span class="keyword">if</span> (!className.startsWith(<span class="string">&quot;com/git/hui/java/&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CtClass cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">            cl = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(classfileBuffer));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (CtMethod method : cl.getDeclaredMethods()) &#123;</span><br><span class="line">                <span class="comment">// 所有方法，统计耗时；请注意，需要通过`addLocalVariable`来声明局部变量</span></span><br><span class="line">                method.addLocalVariable(<span class="string">&quot;start&quot;</span>, CtClass.longType);</span><br><span class="line">                method.insertBefore(<span class="string">&quot;start = System.currentTimeMillis();&quot;</span>);</span><br><span class="line">                String methodName = method.getLongName();</span><br><span class="line">                method.insertAfter(<span class="string">&quot;System.out.println(\&quot;&quot;</span> + methodName + <span class="string">&quot; cost: \&quot; + (System&quot;</span> +<span class="string">&quot;.currentTimeMillis() - start));&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] transformed = cl.toBytecode();</span><br><span class="line">            <span class="keyword">return</span> transformed;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SimpleAgent类注册instrument"><a href="#SimpleAgent类注册instrument" class="headerlink" title="SimpleAgent类注册instrument"></a>SimpleAgent类注册instrument</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by <span class="doctag">@author</span> yihui in 16:39 20/3/15.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jvm 参数形式启动，运行此方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * manifest需要配置属性Premain-Class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> agentArgs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inst</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;premain&quot;</span>);</span><br><span class="line">        customLogic(inst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态 attach 方式启动，运行此方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * manifest需要配置属性Agent-Class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> agentArgs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inst</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;agentmain&quot;</span>);</span><br><span class="line">        customLogic(inst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计方法耗时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inst</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">customLogic</span><span class="params">(Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> CostTransformer(), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此 agent 完毕，打包和上面的过程一样，</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i: &quot;</span> + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i = print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaseMain main = <span class="keyword">new</span> BaseMain();</span><br><span class="line">        main.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然通过 jvm option 参数指定 agent 的方式，运行上面的代码，会发现抛异常，无法正常运行了</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e67b39eaaf119?w=742&h=292&f=jpeg&s=79442" alt="img"></p>
<p>指出了在 run 方法这里，存在字节码的错误，我们统计耗时的 Agent，主要就是在方法开始前和结束后各自新增了一行代码，我们直接补充在 run 方法中，则相当于下面的代码</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e67b3a018ec29?w=672&h=159&f=jpeg&s=25739" alt="img"></p>
<p>上面的提示很明显的告诉了，最后一行语句永远不可能达到，编译就存在异常了；</p>
<p>很简单，在 jvm 参数中，添加一个<code>-noverify</code> (请注意不同的 jdk 版本，参数可能不一样，我的本地是 jdk8，用这个参数；如果是 jdk7 可以试一下<code>-XX:-UseSplitVerifier</code>)</p>
<p>在 IDEA 开发环境下，如下配置即可</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e67b39ed90844?w=716&h=226&f=jpeg&s=37619" alt="img"></p>
<p>再次运行，正常了</p>
<h4 id="配合spring使用"><a href="#配合spring使用" class="headerlink" title="配合spring使用"></a>配合spring使用</h4><p>通常来说，探针不会引入太重量级的框架，会更多地使用 <code>JDK</code> 原生的接口。然而最近发现，当探针依附在用户应用中时（ <code>Spring</code> 应用），有时难免需要使用反射调用用户接口或 <code>Spring</code> 接口，而反射调用需要类实例，使用 <code>Spring</code> 进行依赖注入的框架中，这个实例必须从 <code>Spring Context</code> 中去取。这就造成了一个问题，如何取到 <code>Spring Context</code> 呢，难道一定要在探针中引入 <code>Sping</code> 框架吗？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88/" data-id="cm6lsyz560014k2dlhq2f8d0h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编程语言/Java/springboot/springboot-starter-04-Dubbo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-04-Dubbo/" class="article-date">
  <time datetime="2021-05-12T04:53:52.000Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-04-Dubbo/">springboot-starter-03-Dubbo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li><p>消费者与提供者工程均需要导入四个依赖 </p>
<ul>
<li>Dubbo 与 Spring Boot 整合依赖</li>
<li>zkClient依赖</li>
<li>slf4j-log4j12依赖</li>
</ul>
</li>
<li><p>自定义 commons 工程依赖 </p>
</li>
<li><p>提供者工程</p>
<ul>
<li>将 Service 接口实现类的@Service 注解更换为阿里的注解，并添加@Component 注解</li>
<li>在启动类上添加@EnableDubboConfiguration 与@EnableTransactionManager 注解</li>
<li>修改配置文件:指定应用名称与注册中心地址 </li>
</ul>
</li>
<li><p>消费者工程</p>
<ul>
<li>将处理器中 Service 的声明上的@Autowired 注解更换为阿里的@Reference 注解 </li>
<li>在启动类上添加@EnableDubboConfiguration 注解</li>
<li>修改配置文件:指定应用名称与注册中心地址</li>
</ul>
</li>
</ul>
<h3 id="定义-commons-工程"><a href="#定义-commons-工程" class="headerlink" title="定义 commons 工程"></a>定义 <strong>commons</strong> 工程</h3><ul>
<li>依赖：无，因为是纯java项目</li>
<li>定义实体类</li>
<li>定义业务接口</li>
</ul>
<h3 id="定义提供者"><a href="#定义提供者" class="headerlink" title="定义提供者"></a>定义提供者</h3><ul>
<li><p>依赖：</p>
<ul>
<li>添加 <strong>dubbo</strong> 与 <strong>spring boot</strong> 整合依赖，需要从alibaba的github中找到依赖</li>
<li>添加 <strong>zkClient</strong> 依赖</li>
<li>dubboCommons依赖</li>
<li>还有其他的mysql, druid,mybatis依赖</li>
</ul>
</li>
<li><p>定义业务接口</p>
<ul>
<li>将 Service 接口实现类的@Service 注解更换为阿里的注解，并添加@Component 注解</li>
</ul>
</li>
<li><p>修改启动类</p>
<ul>
<li>添加@EnableDubboConfiguration 与@EnableTransactionManager 注解</li>
</ul>
</li>
<li><p>修改配置文件</p>
<ul>
<li><pre><code class="yaml">spring:
  # 功能等价于 spring-dubbo 配置文件中的&lt;dubbo:application/&gt; # 该名称是由服务治理平台使用
  application:
      name: 11-provider-springboot # 指定zk注册中心
  dubbo:
      registry: zookeeper://zkOS:2181
  # zk 集群作注册中心
  # registry: zookeeper://zkOS1:2181?backup=zkOS2:2181,zkOS3:2181
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 定义消费者(略)</span><br><span class="line"></span><br><span class="line">- 依赖：</span><br><span class="line"></span><br><span class="line">  - 添加 **dubbo** 与 **spring boot** 整合依赖，需要从alibaba的github中找到依赖</span><br><span class="line">  - 添加 **zkClient** 依赖</span><br><span class="line">  - dubboCommons依赖</span><br><span class="line"></span><br><span class="line">- 修改配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;yaml</span><br><span class="line">    spring:</span><br><span class="line">      # 功能等价于 spring-dubbo 配置文件中的&lt;dubbo:application&#x2F;&gt; # 该名称是由服务治理平台使用</span><br><span class="line">      application:</span><br><span class="line">      	name: 11-consumer-springboot # 指定zk注册中心</span><br><span class="line">      dubbo:</span><br><span class="line">      	registry: zookeeper:&#x2F;&#x2F;zkOS:2181</span><br><span class="line">      # zk 集群作注册中心</span><br><span class="line">      # registry: zookeeper:&#x2F;&#x2F;zkOS1:2181?backup&#x3D;zkOS2:2181,zkOS3:2181</span><br></pre></td></tr></table></figure>




</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-04-Dubbo/" data-id="cm6lsyz5v007zk2dl9dt7h99s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编程语言/Java/springboot/springboot-starter-03-Mybatis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-03-Mybatis/" class="article-date">
  <time datetime="2021-05-12T04:44:56.000Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-03-Mybatis/">springboot-starter-03-Mybatis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="导入三个依赖"><a href="#导入三个依赖" class="headerlink" title="导入三个依赖"></a>导入三个依赖</h3><ul>
<li><p>mybatis 与 Spring Boot 整合依赖，mysql 驱动依赖， Druid 数据源依赖。</p>
</li>
<li><pre><code class="xml">&lt;!--mybatis 与 spring boot 整合依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!--mysql 驱动--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- druid 驱动，数据源 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
  &lt;artifactId&gt;druid&lt;/artifactId&gt;
  &lt;version&gt;1.1.12&lt;/version&gt;
&lt;/dependency&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 定义 Service接口</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">  public class StudentService&#123;</span><br><span class="line">  	@Autowired</span><br><span class="line">  	private IstudentDao dao;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h3 id="定义-Dao-接口"><a href="#定义-Dao-接口" class="headerlink" title="定义 Dao 接口"></a>定义 <strong>Dao</strong> 接口</h3><ul>
<li><p>Com.abc.dao目录</p>
</li>
<li><pre><code class="java">//Dao 接口上要添加@Mapper 注解。
public interface IstudentDao&#123;
    void insertStudent(Student s);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 定义映射文件</span><br><span class="line"></span><br><span class="line">- Com.abc.dao目录， &lt;!--与Dao接口在同一目录--&gt;</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;xml</span><br><span class="line">  &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;   </span><br><span class="line">  &lt;!DOCTYPE mapper   </span><br><span class="line">      PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;   </span><br><span class="line">      &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">  &lt;mapper namespace&#x3D;&quot;com.abc.dao.IstudentDao&quot;&gt;</span><br><span class="line">      &lt;!-- 这里namespace必须是UserMapper接口的路径” --&gt;</span><br><span class="line">      &lt;insert id&#x3D;&quot;insertStudent&quot;&gt;</span><br><span class="line">          insert into student(name,age) values(#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">      &lt;&#x2F;insert&gt;</span><br><span class="line">  &lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>注册资源目录</p>
<ul>
<li><p>在 pom 文件中将 dao 目录注册为资源目录。</p>
</li>
<li><pre><code class="xml">&lt;!-- dao 目录注册为资源目录 --&gt;
&lt;build&gt;
  &lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
      &lt;includes&gt;
        &lt;include&gt;**/*.xml&lt;/include&gt;
      &lt;/includes&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
&lt;/build&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 修改主配置文件</span><br><span class="line"></span><br><span class="line">  - 注册映射文件</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;properties</span><br><span class="line">      mybatis.mapper-location&#x3D;classpath:com&#x2F;abc&#x2F;dao&#x2F;.xml</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>注册实体类别名</p>
<ul>
<li><pre><code class="properties">mybatis.type-aliases-packages=com.abc.beans
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注册数据源</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;properties</span><br><span class="line">    spring.datasource.type&#x3D;com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">    spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;test</span><br><span class="line">    spring.datasource.username&#x3D;root</span><br><span class="line">    spring.datasource.password&#x3D;root</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-03-Mybatis/" data-id="cm6lsyz5v0080k2dl734peo5k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编程语言/Java/springboot/springboot-starter-02-Redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-02-Redis/" class="article-date">
  <time datetime="2021-05-12T04:20:17.000Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-02-Redis/">springboot-starter-02-redis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>高并发下访问 Redis，存在什么问题?存在三个问题: </p>
<ul>
<li>缓存穿透: 为DB查询为null的数据预设一个值</li>
<li>缓存雪崩: 提前规划好缓存到期时间</li>
<li>热点缓存: 属于缓存雪崩的特例，有一个缓存到期了，大量请求访问这个缓存无效，从而大量请求数据库。双重检测锁机制</li>
</ul>
</blockquote>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><ul>
<li><p>小技巧：如redis,mybatis等依赖，<a href="">可以从父spring依赖中（ctrl + c）找到该依赖和版本号</a>，然后添加</p>
</li>
<li><p>在 pom 文件中添加 Spring Boot 与 Redis 整合依赖。</p>
</li>
<li><pre><code class="xml">&lt;!--mybatis 与 spring boot 整合依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 修改主配置文件</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;properties</span><br><span class="line">  #单机redis</span><br><span class="line">  spring.redis.host&#x3D;</span><br><span class="line">  spring.redis.port&#x3D;</span><br><span class="line">  spring.redis.password&#x3D;</span><br><span class="line">  </span><br><span class="line">  #集群redis</span><br><span class="line">  spring.redis.sentinel.master&#x3D;mymaster</span><br><span class="line">  spring.redis.sentinel.nodes&#x3D;sentine1:22076</span><br><span class="line">  </span><br><span class="line">  spring.cache.type&#x3D;redis</span><br><span class="line">  spring.cache.cache-names&#x3D;realTimeCache</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="修改启动类"><a href="#修改启动类" class="headerlink" title="修改启动类"></a>修改启动类</h3><ul>
<li>添加@EnableCaching: 开启缓存</li>
</ul>
<h3 id="修改实体类-Student"><a href="#修改实体类-Student" class="headerlink" title="修改实体类 Student"></a>修改实体类 <strong>Student</strong></h3><ul>
<li>由于要将查询的实体类对象缓存到 Redis，Redis 要求实体类必须序列化。所以需要实体类实现序列化接口Serializable。</li>
</ul>
<h3 id="修改-Service-接口实现类"><a href="#修改-Service-接口实现类" class="headerlink" title="修改 Service 接口实现类"></a>修改 <strong>Service</strong> 接口实现类</h3><p>@CacheEvict(value=””, allEntries=””)  清楚所有缓存。业务场景，插入必须清楚所缓存</p>
<p>@Cacheable(value=””, key=””) 如果没有缓存，那么查数据库，并添加缓存；如果有缓存，查询指定缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value=&quot;realTimeCache&quot;, key=&quot;&#x27;student&#x27;+#id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> student <span class="title">findStudent</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dao.findStudent(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheEvict(value=&quot;realTimeCache&quot;, allEntries=&quot;true&quot;)</span>  </span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student s)</span></span>&#123;</span><br><span class="line">  dao.insertStudent(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决缓存问题"><a href="#解决缓存问题" class="headerlink" title="解决缓存问题"></a>解决缓存问题</h3><h4 id="使用双重检查锁解决热点缓存"><a href="#使用双重检查锁解决热点缓存" class="headerlink" title="使用双重检查锁解决热点缓存"></a><a href="">使用双重检查锁解决热点缓存</a></h4><ul>
<li><pre><code class="java">public Integer getStudentsCount()&#123;
    BoundValueOperations&lt;Object,Object&gt; ops = redisTemplate.boundValuesOps(&quot;count&quot;);
  Object cnt= ops.getValue();//第一重检查
  if(cnt == null)&#123; 
    //1nd请求来到，2nd请求和3rd请求，因为这个锁而阻塞，无法查询数据库
    synchronized(this)&#123;
      cnt= ops.getValue();//第二重检查
      if(cnt==null)&#123; 
        cnt = dao.findStudentsCount();
        opt.set(cnt,10,TimeUnits.Seconds);
      &#125;
    &#125;
  &#125;

  return (Integer) cnt;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### [是否存在线程安全问题呢？]()</span><br><span class="line"></span><br><span class="line">  - 首先，synchronized(this)中的锁必须是单例的, @Component已经保证该锁的对象在Spring容器中是单例了，所以此处没有线程安全</span><br><span class="line">  </span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    private Integer cnt &#x3D; new Integer(1);</span><br><span class="line">    public Integer getStudentsCount()&#123;</span><br><span class="line">      if(cnt &#x3D;&#x3D; null)&#123; </span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">          if(cnt&#x3D;&#x3D;null)&#123; </span><br><span class="line">            &#x2F;&#x2F;以下这个new语句的底层步骤</span><br><span class="line">            &#x2F;&#x2F;1: 申请一个堆空间space</span><br><span class="line">            &#x2F;&#x2F;2: 使用对象初始数据初始化对空间space</span><br><span class="line">            &#x2F;&#x2F;3: cnt应用指向堆空间space</span><br><span class="line">           	cnt &#x3D; new Integer(2);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      return (Integer) cnt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

  - 第一个请求来到，如果2,3的步骤被编译器优化导致3先执行；然后第二个请求来到，if(cnt==null)为真, 那么则返回一个没有经过2步骤的cnt对象
  - 解决方法：[cnt设置为volatile保证编译器不优化(推荐) 或者是 设置该方法为同步(略)]()
</code></pre>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-02-Redis/" data-id="cm6lsyz5v007xk2dl2751f1p4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-pros&amp;cons" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/12/pros&cons/" class="article-date">
  <time datetime="2021-05-11T16:19:51.000Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/12/pros&cons/">服务端性能优化-01-单台4核8G机器支撑5万QPS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Tcpdump"><a href="#Tcpdump" class="headerlink" title="Tcpdump"></a>Tcpdump</h2><h3 id="1-tcpDump介绍"><a href="#1-tcpDump介绍" class="headerlink" title="1. tcpDump介绍"></a>1. tcpDump介绍</h3><h3 id="2-tcpDump工作原理"><a href="#2-tcpDump工作原理" class="headerlink" title="2. tcpDump工作原理"></a>2. tcpDump工作原理</h3><h3 id="3-tcpDump如何使用"><a href="#3-tcpDump如何使用" class="headerlink" title="3. tcpDump如何使用"></a>3. tcpDump如何使用</h3><h4 id="前置操作：开启网卡的混合模式"><a href="#前置操作：开启网卡的混合模式" class="headerlink" title="前置操作：开启网卡的混合模式"></a>前置操作：开启网卡的混合模式</h4><table>
<thead>
<tr>
<th></th>
<th>网卡的默认</th>
<th>网卡的混合模式</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>默认情况下，tcpdump不会抓取本机内部通讯的报文。根据网络协议栈的规定，对于报文，即使是目的地是本机，也需要经过本机的网络协议层，所以本机通讯肯定是通过API进入了内核，并且完成了路由选择。【比如本机的TCP通信，也必须要socket通信的基本要素：src ip port dst ip port】</td>
<td>如果要使用tcpdump抓取其他主机MAC地址的数据包，必须开启网卡混杂模式。<br />所谓混杂模式，用最简单的语言就是让网卡抓取任何经过它的数据包，不管这个数据包是不是发给它或者是它发出的。一般而言，Unix不会让普通用户设置混杂模式，因为这样可以看到别人的信息，比如telnet的用户名和密码，这样会引起一些安全上的问题，所以只有root用户可以开启混杂模式，</td>
</tr>
<tr>
<td>命令</td>
<td></td>
<td>ifconfig en0 promisc<br /> en0是你要打开混杂模式的网卡。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/12/pros&cons/" data-id="cm6lsyz4y0001k2dlf1atfp07" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-系统设计/限流算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/12/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2021-05-11T16:19:51.000Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/12/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/">服务端性能优化-01-单台4核8G机器支撑5万QPS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="令牌桶的效果"><a href="#令牌桶的效果" class="headerlink" title="令牌桶的效果"></a>令牌桶的效果</h2><h3 id="场景1：平滑突发限流"><a href="#场景1：平滑突发限流" class="headerlink" title="场景1：平滑突发限流"></a>场景1：平滑突发限流</h3><p>设置每秒放置的令牌数为5个。返回的RateLimiter对象可以保证1秒内不会给超过5个令牌，并且以固定速率（0.2秒一个）进行放置，达到平滑输出的效果。</p>
<h4 id="获取频率高于令牌产生频率，一次获取一个"><a href="#获取频率高于令牌产生频率，一次获取一个" class="headerlink" title="获取频率高于令牌产生频率，一次获取一个"></a>获取频率高于令牌产生频率，一次获取一个</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSmoothBursty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> RateLimiter r = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire() + <span class="string">&quot;s&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * output: 基本上都是0.2s执行一次，符合一秒发放5个令牌的设定。</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.0s </span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.182014s</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.188464s</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.198072s</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.196048s</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.197538s</span></span><br><span class="line"><span class="comment">     * get 1 tokens: 0.196049s</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="获取频率低于令牌产生频率，一次获取一个"><a href="#获取频率低于令牌产生频率，一次获取一个" class="headerlink" title="获取频率低于令牌产生频率，一次获取一个"></a>获取频率低于令牌产生频率，一次获取一个</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSmoothBursty2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> RateLimiter r = RateLimiter.create(<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line"> System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * output:</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * end</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.499796s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="一次获取5个（滞后效应）"><a href="#一次获取5个（滞后效应）" class="headerlink" title="一次获取5个（滞后效应）"></a>一次获取5个（滞后效应）</h4><p><code>RateLimiter</code>由于会累积令牌，所以可以应对突发流量。在下面代码中，有一个请求会直接请求5个令牌，但是由于此时令牌桶中有累积的令牌，足以快速响应。 <code>RateLimiter</code>在没有足够令牌发放时，采用滞后处理的方式，也就是前一个请求获取令牌所需等待的时间由下一次请求来承受，也就是代替前一个请求进行等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSmoothBursty3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> RateLimiter r = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;get 5 tokens: &quot;</span> + r.acquire(<span class="number">5</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 			<span class="comment">/**</span></span><br><span class="line"><span class="comment">       * output:</span></span><br><span class="line"><span class="comment">       * get 5 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.996766s 滞后效应，需要替前一个请求进行等待</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.194007s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.196267s</span></span><br><span class="line"><span class="comment">       * end</span></span><br><span class="line"><span class="comment">       * get 5 tokens: 0.195756s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.995625s 滞后效应，需要替前一个请求进行等待</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.194603s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.196866s</span></span><br><span class="line"><span class="comment">       */</span></span><br></pre></td></tr></table></figure>

<h3 id="场景2：平滑预热限流"><a href="#场景2：平滑预热限流" class="headerlink" title="场景2：平滑预热限流"></a>场景2：平滑预热限流</h3><p><code>RateLimiter</code>的 <code>SmoothWarmingUp</code>是带有预热期的平滑限流，它启动后会有一段预热期，逐步将分发频率提升到配置的速率。 比如下面代码中的例子，创建一个平均分发令牌速率为2，预热期为3分钟。由于设置了预热时间是3秒，令牌桶一开始并不会0.5秒发一个令牌，而是频率越来越高，在3秒钟之内达到原本设置的频率，以后就以固定的频率输出。这种功能适合系统刚启动需要一点时间来“热身”的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSmoothwarmingUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> RateLimiter r = RateLimiter.create(<span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;get 1 tokens: &quot;</span> + r.acquire(<span class="number">1</span>) + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 			<span class="comment">/**</span></span><br><span class="line"><span class="comment">       * output:</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.0s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 1.329289s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.994375s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.662888s  上边三次获取的时间相加正好为3秒</span></span><br><span class="line"><span class="comment">       * end</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.49764s  正常速率0.5秒一个令牌</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.497828s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.49449s</span></span><br><span class="line"><span class="comment">       * get 1 tokens: 0.497522s</span></span><br><span class="line"><span class="comment">       * end</span></span><br><span class="line"><span class="comment">       */</span></span><br></pre></td></tr></table></figure>



<h2 id="令牌桶的实现"><a href="#令牌桶的实现" class="headerlink" title="令牌桶的实现"></a>令牌桶的实现</h2><h3 id="平滑突发限流"><a href="#平滑突发限流" class="headerlink" title="平滑突发限流"></a>平滑突发限流</h3><p><code>RateLimiter</code>的原理就是每次调用 <code>acquire</code>时用当前时间和 <code>nextFreeTicketMicros</code>进行比较，根据二者的间隔和添加单位令牌的时间间隔 <code>stableIntervalMicros</code>来刷新存储令牌数 <code>storedPermits</code>。然后acquire会进行休眠，直到 <code>nextFreeTicketMicros</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/12/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/" data-id="cm6lsyz500003k2dl1w2cfvpv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络编程/tcp/大量 CLOSE_WAIT 连接原因分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp/%E5%A4%A7%E9%87%8F%20CLOSE_WAIT%20%E8%BF%9E%E6%8E%A5%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2021-05-11T16:19:51.000Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp/%E5%A4%A7%E9%87%8F%20CLOSE_WAIT%20%E8%BF%9E%E6%8E%A5%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/">大量 CLOSE_WAIT 连接原因分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>CLOSE_WAIT是tcp的四次挥手阶段的服务器状态</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/u4aVxRTn2TgUCmDdceT9LVRwWgb9icsy4AsN4tIJ7iaibx2iaSxNa59JZHQRSjqf41ibqDQia01SZ7bPOWo1Dn3qJjRg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p>服务端收到FIN包后，一直没有发送FIN包</p>
<h1 id="Dubbo服务器出现大量-CLOSE-WAIT"><a href="#Dubbo服务器出现大量-CLOSE-WAIT" class="headerlink" title="Dubbo服务器出现大量 CLOSE_WAIT"></a>Dubbo服务器出现大量 CLOSE_WAIT</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&amp;mid=2247486020&amp;idx=1&amp;sn=f7cf41aec28e2e10a46228a64b1c0a5c&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&amp;mid=2247486020&amp;idx=1&amp;sn=f7cf41aec28e2e10a46228a64b1c0a5c&amp;scene=21#wechat_redirect</a></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/298214130">https://www.zhihu.com/question/298214130</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp/%E5%A4%A7%E9%87%8F%20CLOSE_WAIT%20%E8%BF%9E%E6%8E%A5%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/" data-id="cm6lsyz5e003sk2dl2qpygm3t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-常用工具/压测工具/性能测试常见问题及瓶颈判断分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/11/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E7%93%B6%E9%A2%88%E5%88%A4%E6%96%AD%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2021-05-11T11:27:28.000Z" itemprop="datePublished">2021-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/11/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E7%93%B6%E9%A2%88%E5%88%A4%E6%96%AD%E5%88%86%E6%9E%90/">性能测试常见问题及瓶颈判断分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.录制登录脚本后回放，结果失败<br>登录中为了安全，一般会对密码进行加密，查看录制的脚本中密码是否加密，如果是加密信息，有两种解决：一个是让开发修改应用，使用明码；一个是开发修改应用不做密码验证，脚本输入任何密码都通过。</p>
<p>2.增加并发后，TPS基本没有变化，应用和数据库的CPU也都消耗不高<br>可以先选择一个非登录的交易，最好是查询类交易，做1并发、5并发、10并发，试运行5分钟查看平均响应时间和TPS，如果TPS从5到10并发基本没有变化，应用和数据库的CPU也没大的变化，只是平均响应时间翻倍增加，那么基本可以确定是连接的限制问题，需要让开发查看三个连接数的设置：一个是应用允许的连接数；一个是连接池的限制；一个是数据库允许的连接限制。<br>切记：一定跟开发确认关闭日志或者为error级别，否则也会存在TPS很低。</p>
<p>3.数据库瓶颈判断<br>在少量并发，比如10并发左右，应用服务器cpu基本没消耗，但数据库的cpu却消耗非常高，一般是数据库问题，常见的是索引或者大量的order by以及group yu语句，需要开发修改。<br>一般的机器配置cpu为8C，足够支持50以上的并发。</p>
<p>4.应用问题判断<br>通常的软件设计，最后的资源消耗是在数据库，所以如果是在低并发（10user）应用的消耗非常高，但数据库却很低，说明是应用存在问题，需要开发介入查找。</p>
<p>5.压力机是win7的特殊限制<br>如果压力机是win7，那么默认的win7允许的连接是5个，所以需要通过工具修改半连接数的限制。而windonws server则没有这个问题。</p>
<p>6.磁盘瓶颈的判断<br>在linux中，通过iostat命令可以查看磁盘的一些数据，如果Pages Read/sec很低，同时%Disk Time和Average Disk Queue Length的值很高，即磁盘非常繁忙但实际读取的数据却很少，说明磁盘性能低，大量的数据等待磁盘读取，磁盘存在瓶颈。</p>
<p>7.内存的瓶颈判断<br>在linux中，通过top或free命令查看到内存的一些数据，在swap项，如果used使用的很多，而free很少，说明大量数据需要从磁盘读取而不是内存读取，这样初步可以判断是内存不够。</p>
<p>8.内存泄漏判断<br>在linux中，通过top命令查看到内存的一些数据，如果available mem非常少，比如只有几十兆，说明可能有程序没有释放内存。如果这个数值在逐渐的减少，说明是内存泄漏。</p>
<p>9.数据库锁的判断<br>1个用户tps到5个用户tps到10个用户tps基本没有变化，应该是数据库有锁，导致是串行交易，查看脚本是否对单账户操作，或者应用是不是单账户操作。</p>
<p>10.判断应用服务器的连接数<br>可以在应用服务器端运行脚本的时候执行下列命令，查看系统是否有很多的“TIME_WAIT”,如果有近万的等待说明问题出在应用端，当然只是几百个就可以忽略了。<br>命令：ps –ef | grep “TIME_WAIT” |wc –l ;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/11/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E7%93%B6%E9%A2%88%E5%88%A4%E6%96%AD%E5%88%86%E6%9E%90/" data-id="cm6lsyz5b002gk2dl7c7m4b9v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式系统/分布式-事务/一致性/分布式事务-02-一致性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-02-%E4%B8%80%E8%87%B4%E6%80%A7/" class="article-date">
  <time datetime="2021-05-11T04:55:26.000Z" itemprop="datePublished">2021-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-02-%E4%B8%80%E8%87%B4%E6%80%A7/">一致性-02-分布式事务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="分布式事务–数据一致性引擎概览"><a href="#分布式事务–数据一致性引擎概览" class="headerlink" title="分布式事务–数据一致性引擎概览"></a>分布式事务–数据一致性引擎概览</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>一般，广告检索系统都承载着公司很大比重的营收占比。</p>
<p>计费系统是广告系统的偏底层一环，承担着反作弊、计算费用、优惠扣减、费用实际扣除等职责。整个扣费流程涉及到了计费单、营销系统、支付账务系统、预算系统等的上下游数据一致性问题。</p>
<p>并且，由于存在CPT、CPA、CPC等不同类型的计费方式，而广告点击有流量不可回溯等特点（普通支付场景可以让用户重试），计费的数据一致性引擎的合理设计就变得尤为重要了。</p>
<h3 id="一致性保障方案选择"><a href="#一致性保障方案选择" class="headerlink" title="一致性保障方案选择"></a>一致性保障方案选择</h3><p>支付业务一般的可以分为两种</p>
<ul>
<li>一种是有支付牌照的公司，直接和账户和银行打交道<ul>
<li>一般需要非常强硬的保障手段来实现分布式下数据的强一致性。比如TCC的类二阶段提交方式</li>
</ul>
</li>
<li>另一种是调用第三方支付服务，实现支付业务。<ul>
<li>相对来说，一致性要求不是非常苛刻，有不少的解决方案可供选择，比如本地消息表、事务型消息等等</li>
</ul>
</li>
</ul>
<p>当前项目的场景显然属于第二种。那么，应该怎么合理选择实现方式呢：</p>
<h4 id="事务型消息"><a href="#事务型消息" class="headerlink" title="事务型消息"></a>事务型消息</h4><p>优点：实现方案轻量，改造成本小，适合为对实时性不是特别高的场景。</p>
<p>缺点：就是每个系统只能负责自己这一块，流程变得冗长，不利于问题排查。业务耦合程度可能要高一些。</p>
<h4 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h4><p>系统实现真的是非常的重。</p>
<ul>
<li>需要流程中的所有系统，按照既定的规范来实现一套包含了try/commit/cancel三个处理逻辑的调用模板。 </li>
<li>需要流程中的所有系统，按照既定的规范来创建主事务表和分支事务表，来记录事务状态和调用参数及路由。</li>
<li>需要参与者创建事务幂等表，实现拒绝空回滚或拒绝后到达的资源扣减等的防悬挂逻辑。</li>
</ul>
<p>光是让各系统配合实现几个接口，我觉得，如果没有非常大的资金风险压迫，没几个人会配合。</p>
<p>而且，TCC可能更适用于有用户直接参与的资源扣减场景，因为引擎的基本思路是失败时操作回滚，保证上下游一致。</p>
<p>但是，上面也说过了，广告点击流的特点是流量不可回放，用户不可能因为这次计费没成功，就帮我们再点一次。所以，我们的一致性引擎的恢复逻辑，不仅要支持回滚，还要支持重试。不可漏掉每一次点击计费。</p>
<h4 id="saga模式"><a href="#saga模式" class="headerlink" title="saga模式"></a>saga模式</h4><p>最终，我们参考saga模式，选择的是类saga的状态机引擎的补偿模式。</p>
<p>这种方式的优点是，对老系统改造成本友好，即使实现接口也比较方便，通过状态机编排执行节点链，并配置重试回滚方式、实时异步策略。</p>
<p>事务信息存储方式相对灵活，主要看自己公司的各种存储的可靠性和一致性的承诺。</p>
<h3 id="数据一致性引擎-saga模式"><a href="#数据一致性引擎-saga模式" class="headerlink" title="数据一致性引擎: saga模式"></a>数据一致性引擎: saga模式</h3><h4 id="引擎架构图"><a href="#引擎架构图" class="headerlink" title="引擎架构图"></a>引擎架构图</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT531rYZT3GBGOAHYiaBqrVEmcZHSCLhUsnUzqJjRWp0V1Rep93Bpjicqs1bbp5U4KEx1LWibdnYicCBL2bQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h4 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h4><ul>
<li><em>状态机</em> 实现节点执行顺序编排及其他执行特性</li>
<li><em>节点</em> 业务需要实现的逻辑节点，比如计费的cpc扣费逻辑，需要有前置check、price调价、coupon优惠券、pmc扣费等执行节点</li>
<li><em>补偿逻辑</em> 属于节点的一部分实现，每个执行节点需要实现当前节点的补偿逻辑，以供执行异常时进行恢复操作</li>
<li><em>钩子函数</em> 在引擎执行前和执行后，允许业务系统执行自有的特殊操作</li>
<li><em>定时任务</em> 异常数据恢复的触发入口</li>
</ul>
<h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><ul>
<li><em>补偿方式</em> 可配置，有重试/回滚 两种补偿方式可选；重试补偿时，执行顺便和正常顺序一致，回滚补偿时，从最后一个执行节点往前回滚</li>
<li><em>补偿触发时效</em> 可配置，有实时/异步延时 两种触发策略可选，如果有资源悬挂的风险，建议选异步延时触发</li>
<li><em>重试次数及时间衰减</em> 可配置，按业务实际情况定制衰减序列</li>
</ul>
<h4 id="状态机配置实例"><a href="#状态机配置实例" class="headerlink" title="状态机配置实例"></a>状态机配置实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;xxxx_xxxx_xxxx&quot;,</span><br><span class="line">  &quot;comment&quot;: &quot;cpc计费状态机&quot;,</span><br><span class="line">  &quot;firstNodeName&quot;: &quot;check&quot;,</span><br><span class="line">  &quot;nodes&quot;: &#123;</span><br><span class="line">    &quot;check&quot;: &#123;</span><br><span class="line">      &quot;nextNodeName&quot;: &quot;land&quot;,</span><br><span class="line">      &quot;preNodeName&quot;: &quot;&quot;,</span><br><span class="line">      &quot;skipRecover&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;land&quot;: &#123;</span><br><span class="line">      &quot;nextNodeName&quot;: &quot;antiFraud&quot;,</span><br><span class="line">      &quot;preNodeName&quot;: &quot;check&quot;,</span><br><span class="line">      &quot;skipRecover&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;antiFraud&quot;: &#123;</span><br><span class="line">      &quot;nextNodeName&quot;: &quot;realPrice&quot;,</span><br><span class="line">      &quot;preNodeName&quot;: &quot;land&quot;,</span><br><span class="line">      &quot;skipRecover&quot;: false</span><br><span class="line">    &#125;,&quot;...&quot;:&#123;&quot;...&quot;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  #重试次数</span><br><span class="line">  &quot;retryCount&quot;: &quot;4&quot;, </span><br><span class="line">  #重试时间衰减</span><br><span class="line">  &quot;timeDecaySeries&quot;: [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;10&quot;], </span><br><span class="line">  #补偿策略，重试&#x2F;回滚</span><br><span class="line">  &quot;recoverType&quot;: &quot;Retry&quot;,</span><br><span class="line">  #触发时效，实时触发&#x2F;异步触发</span><br><span class="line">  &quot;compensateTimeliness&quot;: &quot;ASYNC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引擎初始化"><a href="#引擎初始化" class="headerlink" title="引擎初始化"></a>引擎初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DTConfig.builder()</span><br><span class="line">    .setAppName(&quot;billing&quot;)&#x2F;&#x2F;配置appName</span><br><span class="line">    .setLogStoreStrategy(StoreStrategyEnum.DEFAULT_STORE)&#x2F;&#x2F;存储策略</span><br><span class="line">    .setRedisConfig(redisConfigPath) &#x2F;&#x2F;设置redis配置</span><br><span class="line">    .setDBTableConfig(mysqlConfigPath) &#x2F;&#x2F;mysql配置</span><br><span class="line">    .setZKConfig(configPath) &#x2F;&#x2F; wConfig 配置 ，切流灰度使用</span><br><span class="line">    .setStateMachinePath(stateMachinePath)&#x2F;&#x2F;状态机配置项地址</span><br><span class="line">    .setNegligibleErrorCode(BillingDTConstants.serious_error_code_str) &#x2F;&#x2F;当前系统关键异常code集合（不可忽略的致命异常，供恢复逻辑使用）</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h4 id="引擎调用"><a href="#引擎调用" class="headerlink" title="引擎调用"></a>引擎调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;本次调用所使用的状态机名称</span><br><span class="line">String stateMachineName&#x3D;&quot;ecpm_state_machine&quot;; &#x2F;&#x2F;当前请求使用到的状态机名称（和状态机配置中的name一致）</span><br><span class="line">&#x2F;&#x2F;获取引擎实例</span><br><span class="line">DTBizEngine dtBizEngine&#x3D;new SagaDTBizEngine();</span><br><span class="line">&#x2F;&#x2F;组装入参执行调用</span><br><span class="line">DTResponse response&#x3D;  dtBizEngine.start(new DTEngineRequest(bizType,bizId,stateMachineName,originContext));</span><br><span class="line">&#x2F;&#x2F;打印结果</span><br><span class="line">System.out.println(response.getData());</span><br></pre></td></tr></table></figure>

<h4 id="异步化（参考dubbo的异步化实现的）"><a href="#异步化（参考dubbo的异步化实现的）" class="headerlink" title="异步化（参考dubbo的异步化实现的）"></a>异步化（参考dubbo的异步化实现的）</h4><p>主线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   &#x2F;&#x2F;创建 DTFurure ,传入 (DTEngineRequest request , int timeout)</span><br><span class="line">   DTFuture mFuture&#x3D;new DTFuture(request, 1000);</span><br><span class="line">   &#x2F;&#x2F;将该future传递下去，也可以用其他方式传递，这里直接放到了request扩展字段做示例</span><br><span class="line">   request.getExtendField().put(&quot;MY_KEY&quot;,mFuture);</span><br><span class="line">   &#x2F;&#x2F;异步线程调用 </span><br><span class="line">   EcpmEventBus.getInstance().post(new EcpmBillingEvent(request));</span><br><span class="line">   &#x2F;&#x2F;有限时间超时等待，get到的结果是业务完成时设置进来的对象，业务系统可以按自己的场景转换</span><br><span class="line">   Object future&#x3D; mFuture.get(1000); &#x2F;&#x2F;单位是毫秒</span><br><span class="line">   &#x2F;&#x2F;do something</span><br><span class="line"></span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>执行线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;do something ...</span><br><span class="line"></span><br><span class="line">DTFurure futrue&#x3D;(DTFurure)request.getExtendField().get(&quot;MY_KEY&quot;);</span><br><span class="line"></span><br><span class="line">DTFuture.received(futrue.getId(),response);</span><br></pre></td></tr></table></figure>





<h2 id="分布式事务2–-数据一致性引擎原理"><a href="#分布式事务2–-数据一致性引擎原理" class="headerlink" title="分布式事务2– 数据一致性引擎原理"></a>分布式事务2– 数据一致性引擎原理</h2><blockquote>
<p>分布式事务解决什么问题</p>
<ul>
<li><em>准备调用下游扣费，或刚调起下游扣费接口，服务宕机了，怎么办？</em></li>
<li><em>调用下游超时，不知道下游是否执行怎么办？</em></li>
<li><em>调用下游时发生网路堵塞，回滚先到扣费操作后到被悬挂怎么办？</em></li>
<li><em>整个事务需要同时满足重试和回滚操作怎么办？</em></li>
<li><em>因为支付系统大面积重试时，优惠券节点也要重试么？</em></li>
<li><em>重试失败怎么办？重试间隔怎么设置？</em></li>
</ul>
</blockquote>
<p>下面就带着这些待解决的场景问题，看看 DT 引擎是个什么东西</p>
<h3 id="DT-引擎是个什么东西"><a href="#DT-引擎是个什么东西" class="headerlink" title="DT 引擎是个什么东西"></a>DT 引擎是个什么东西</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT532jLJNoZH2DKo0XkmGoibsPVkfHP9DkJ8CSICmttBZeQDwYTMnlwH9HACOiaQcvdEeo9hqsBjxn7LYQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">从上图可以看到，DT 的核心组成包括三大部分：</p>
<ul>
<li><em>事务协调器</em>：负责节点编排、结果判断、分支路由等主要功能。</li>
<li><em>业务执行及补偿节点</em> ：负责调用业务系统实现的多个执行节点。</li>
<li><em>异步补偿触发</em>：负责在执行异常时，异步调起恢复任务并触发执行。</li>
</ul>
<p><strong>「总结下，DT 是个以状态机为基础的，补偿式的分布式长事务一致性保障引擎。」</strong></p>
<p>下面将详述每个模块的实现方案和细节。</p>
<h3 id="DT-引擎原理介绍"><a href="#DT-引擎原理介绍" class="headerlink" title="DT 引擎原理介绍"></a>DT 引擎原理介绍</h3><p><strong>「理论基础」</strong>：是从Hector&amp;Kenneth在1987年发表的《Sagas》论文中演化而来：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT532jLJNoZH2DKo0XkmGoibsPV6iafWicVp2q6BkiakhygY9bm6pz9ez7W4ooSehcXORuPehagNfwg3NiaMg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>图中绿色的部分是正向执行逻辑，发起方逐个调用，参与者不分阶段，直接执行并提交本地事务.</p>
<p>当链路中某个参与者执行逻辑发生异常时，则依据实际配置，执行补偿–回滚或重试。</p>
<p><em>适用场景</em>：</p>
<ul>
<li>业务流程长、业务流程多</li>
<li>业务场景除了回滚还有重试等场景。</li>
<li>参与者没法保证提供 TCC 接口。</li>
</ul>
<p>优势：</p>
<ul>
<li>一阶段提交本地事务，无锁，高性能、事件驱动架构；</li>
<li>参与者可异步执行，高吞吐；补偿服务易于实现。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不保证隔离性</li>
</ul>
<h3 id="模块设计详解"><a href="#模块设计详解" class="headerlink" title="模块设计详解"></a>模块设计详解</h3><p>相比Seate里的saga， 原理都是一样的，但是内部实现很多实现方案进行了精炼和一些专属定制化的开发。</p>
<p>比如，saga 中的状态机定义内容非常庞大，几乎所有的内容都出现在了配置文件中，而 DT 精简到了只剩下节点编排，且顺序固定，不支持节点间路由跳转（因为感觉也没必要~）。</p>
<p>诸如此类的定制等等~</p>
<p>其目的，不是为了重复造轮子，是为了有一致性诉求，但是不想对接庞大的解决方案的同学们，提供一种轻量级的处理方案。</p>
<h4 id="事务协调器"><a href="#事务协调器" class="headerlink" title="事务协调器"></a>事务协调器</h4><p>协调器的主要职责，是执行节点的流程编排、事务的开启、节点状态的维护和上报、全局状态的维护和更新、全局事务完结后的后续处理等。<img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT532jLJNoZH2DKo0XkmGoibsPVuhotJZBDuYibcmOwGXNR2H9pHROkpBTjduuKHjicJAVmr0xj8iaSzTq8Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">整个事务协调器类图如图所示：</p>
<ol>
<li><code>DTBizEngine</code>接口定义了引擎的执行入口，具体实现策略都继承自它。</li>
<li><code>SagaDTBizEngine</code> 是saga模式的具体实现类。</li>
<li>通过<code>DTStart</code> 注解实现启动拦截器，执行事务启动初始化操作。</li>
<li>通过<code>DTAction</code> 注解实现业务节点拦截器，执行数据上报和状态维护。</li>
<li>引擎通过<code>config</code>类拿到业务配置的<code>DTactionService</code>实例执行链，执行 <code>action</code>方法以触发业务逻辑。</li>
<li><code>TriggerManager</code>负责调取<em>框架定义+业务自定义</em>的<strong>「钩子函数」</strong>，负责处理各个不同的执行阶段的特殊处理。</li>
<li>整个业务流程，均由事务协调器协调处理。业务系统只需要实现每个节点的 <code>DTactionService.action</code> 接口和 <code>compensate</code> 接口</li>
</ol>
<p><strong>「为了达到进度协调且保证各节点之间的数据一致性，有一些核心的问题需要解决。下面我们详细说明」</strong></p>
<h4 id="状态机的设计和维护"><a href="#状态机的设计和维护" class="headerlink" title="状态机的设计和维护"></a>状态机的设计和维护</h4><p>状态机的配置决定了事务的节点编排和执行流程。既要决定正常的业务执行流程，还要考虑不同场景下的可配置策略。</p>
<h5 id="重试和回滚"><a href="#重试和回滚" class="headerlink" title="重试和回滚"></a>重试和回滚</h5><p>回滚，需要从最后一个节点往前回滚。而重试，则需要从前往后执行，因此，状态机节点需要和二叉树一样，将pre 和next节点维护起来。</p>
<p>目前这种方式，是一种极简方式，适用于业务流程比较固定的场景。如果有节点路由的诉求，那另当别论了。</p>
<h5 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h5><p>业务执行过程中可能会遇到不同类别的异常。</p>
<p>有些异常是可以忽略的，比如某作弊流量查某个关键配置时未查到，可以直接过滤，不进行后续流程。而个别的严重异常是我们不希望忽略的，比如调支付系统失败，超时等等。</p>
<p>而有些节点，包含了上述两种异常，而有些节点，所有异常均不能忽略。</p>
<p>所以，我们在捕获异常方面会支持两种配置方式：<br><strong>「整个节点异常不可忽略」</strong><br><strong>「不可忽略的异常码列表」</strong></p>
<p>如果当前节点配置了所有异常不可忽略，会直接进入补偿流程。如果没有配置该参数，则会在不可忽略的异常码列表中查询匹配。</p>
<h5 id="重试时间衰减"><a href="#重试时间衰减" class="headerlink" title="重试时间衰减"></a>重试时间衰减</h5><p>为了防止下游系统异常恢复不及时和异常请求因特殊情况被防止无限期补偿等场景，我们做了重试时间衰减策略。该时间衰减序列被维护在状态机配置中，比如<br><strong>「1,3,5,10」</strong><br>则，框架在捞取异常数据进行处理时，会计算上次补偿的时间是否满足该时间序列，再进行执行。</p>
<h4 id="主事务和分支事务"><a href="#主事务和分支事务" class="headerlink" title="主事务和分支事务"></a>主事务和分支事务</h4><p><em>我们需要依赖主事务串联整个流程，依赖分支事务在执行异常时感知各参与者的执行结果。</em></p>
<p>一般在TCC模式下，绝大部分情况都以<em>本地数据库事务</em>为依托，会把主事务的创建、参与者的调用包在本地事务内部，这样，使用同一个数据库创建主事务和分支事务表，天然保证和本地业务数据的一致性。这样数据的压力也会有所增加，基本都是在分库分表之后，把压力均摊到分库上完成性能要求。</p>
<p>但是，还有一些情况另外，比如我们目前的业务，为了提高性能，没有启动本地事务，相当于是在裸跑。</p>
<p>那么，一个关键的问题就是数据存储的稳定性和流程阻断方案的完善。</p>
<p><em>一是</em>需要一个高性能的存储来满足数据的强一致性要求，可以允许存储操作失败，但是决不允许接口返回成功，实际上数据丢失的情况发生。<br><em>二是</em>一个完善的流程阻断方案：我们的存储操作一般分为前置操作和后置操作，如主事务插入和分支事务插入都是前置操作，而分支事务状态更新则是后置操作。在前置操作时失败，则流程阻断，返回失败，让调用方重试或框架补偿。</p>
<p><em>最终希望起到的作用是</em>：<br>(1)只要存储中没有，那就是肯定没执行；<br>(2)而如果在存储中查到了记录，框架会认为，曾经有可能执行过，还需要看对应的状态执行对应的补偿。</p>
<h4 id="流程串联"><a href="#流程串联" class="headerlink" title="流程串联"></a>流程串联</h4><p>框架需要确定后置处理器和钩子函数的注册时机和方式，需要把主事务的开启，执行节点状态的更新，全部执行完成后的处理逻辑编织在一起，等等。</p>
<p><em>具体方法</em>：使用拦截器的方式，在事务开启前后、节点执行前后，进行事务信息维护和更新，保证流程和数据相互匹配</p>
<h4 id="服务匹配和调起"><a href="#服务匹配和调起" class="headerlink" title="服务匹配和调起"></a>服务匹配和调起</h4><p>执行到每个节点，都需要获取参与者的对应服务实例。这个地方之前还会面试问过，问我异常恢复的时候怎么做到通过分支事务表里记录的字符串，调起对方的rpc服务。</p>
<p>这块的实现其实也有很多种，之前工作中用到的tcc模式的dtx引擎，是依托spring框架，使用XMap技术将配置在xml中的对应服务解析成对应的 Javabean,并匹配本地注册中心的服务端信息，调起对应服务。</p>
<p>DT中，我们用了一种比较简单的方法，那就是<code>「ServiceLoader」</code>，非常有用的一个获取同一接口下所有实现类服务的方法。</p>
<p>只需三步:</p>
<ul>
<li>创建接口。<br><code>com.cjh.test.Hello</code></li>
<li>创建实现类。<br><code>com.cjh.test.AHelloImpl</code><br><code>com.cjh.test.BHelloImpl</code></li>
<li>指定位置创建接口文件. 在<br><code>resource/META-INF/service</code><br>文件夹下，创建名为<br><strong>「com.cjh.test.Hello」</strong><br>的文件，将<br><code>com.cjh.test.AHelloImpl</code><br><code>com.cjh.test.BHelloImpl</code><br>这两行文本填入</li>
</ul>
<p>ok 完事~ 所以只要框架指定一个包含了 action 和 compesate 的接口，而业务系统的各个节点都实现了该接口，我们就可以方便的调起这些服务~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;示例代码</span><br><span class="line">ServiceLoader&lt;AAA&gt; serviceLoader&#x3D;ServiceLoader.load(AAA.class);</span><br><span class="line"></span><br><span class="line">for (AAA load : serviceLoader) &#123;</span><br><span class="line">  System.out.println(load);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoadInterface loadInterface&#x3D; EnhancedServiceLoader.load(LoadInterface.class,&quot;BLoad&quot;);</span><br><span class="line">loadInterface.execute();</span><br><span class="line"></span><br><span class="line">Method method &#x3D; loadInterface.getClass().getMethod(&quot;execute&quot;);</span><br><span class="line">method.invoke(loadInterface);</span><br><span class="line"></span><br><span class="line">EnhancedServiceLoader.load(LoadInterface.class,&quot;ALoad&quot;).execute();</span><br></pre></td></tr></table></figure>

<h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>框架支持业务系统在流程执行开始前、完成后、成功后、异常后执行对应的自定义处理，以满足业务系统的特殊需求。</p>
<h4 id="异步补偿"><a href="#异步补偿" class="headerlink" title="异步补偿"></a>异步补偿</h4><p>采用分布式调用方法，定时触发未处理数据的捞取操作，并用数据总线的方式，让系统快速执行补偿。为了防止某条数据被多台机器同时捞取，会加分布式锁进行拒绝拦截。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>那么，DT是如何解决开篇提到的那些问题的呢：</p>
<ol>
<li>在调用扣费服务时发生本服务宕机，说明主事务一定是插入成功的，异步补偿会捞取该主事务记录，并捞取对应的分支事务记录，执行异步补偿。</li>
<li>调用下游超时，说明分支事务已经插入成功，我们更新分支事务为状态未知，等待补偿。</li>
<li>用异步补偿的方式，处理一分钟之前的未完成数据，尽可能避免网络阻塞带来的影响<em>拒绝空回滚，扣费请求后置的幂等处理，需要下游保障</em></li>
<li>支付系统大面积超时，我们会根据分支事务记录来判断其他节点是否已经执行成功，如果执行成功，则跳过重试操作，以避免不必要的系统调用，防止因为冗余的重试调用触发某一系统瓶颈导致全链路崩溃。</li>
<li>时间衰减等  略</li>
</ol>
<h2 id="高并发消息队列补充篇：在所依赖存储不授信的场景下实现柔性事务降级"><a href="#高并发消息队列补充篇：在所依赖存储不授信的场景下实现柔性事务降级" class="headerlink" title="高并发消息队列补充篇：在所依赖存储不授信的场景下实现柔性事务降级"></a>高并发消息队列补充篇：在所依赖存储不授信的场景下实现柔性事务降级</h2><h3 id="基础服务支持不到位的坑"><a href="#基础服务支持不到位的坑" class="headerlink" title="基础服务支持不到位的坑"></a>基础服务支持不到位的坑</h3><h4 id="项目背景和整理设计思路"><a href="#项目背景和整理设计思路" class="headerlink" title="项目背景和整理设计思路"></a>项目背景和整理设计思路</h4><p>项目背景其实还是我们的数据一致性保证长事务引擎。</p>
<p>整体架构如下：<img src="https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT530yxTpTWvojyJtiaOx7PibGLmKicicpErWQMicaMx4Qia15njNTb2icCwTibIskpo1zNMfFxLVjJqGDn2GbyA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<ul>
<li>通过状态机来组织和支持多种不同的业务流</li>
<li>通过将外部服务节点化来抽象和规范化参与者的服务</li>
<li>通过节点的异常捕获来感知参与方的执行结果</li>
<li>通过实时或异步的恢复机制，实现柔性事务·</li>
</ul>
<h4 id="不可缺少的强依赖–存储"><a href="#不可缺少的强依赖–存储" class="headerlink" title="不可缺少的强依赖–存储"></a>不可缺少的强依赖–存储</h4><p>想要业务请求保证最终一致，不可能是没有存储参与的一锤子买卖，因为还要考虑本身服务器的抖动，业务上的异步要求等等。所以，存储是一个不可缺少的依赖，如下图所示：<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">存储服务作用在引擎的整个生命周期：</p>
<ul>
<li>在请求进入初期，进行上下文落地(因为广告流量只有一次操作，不像普通支付可以允许用户重试，广告场景下，用户的多次操作需要进行分别计费，并且不太适合利用MQ的ack机制进行重试，因为那需要等流程全部执行完，会影响消息消费速率)</li>
<li>在节点执行结束，进行节点执行状态落地(这样，在遇到需要补偿的情况，可以避免冗余调用，防止不需要重试的系统被其他抖动的系统冲击)</li>
<li>在异步恢复时，获取上下文和节点执行状态集合，以完成事务的最终一致性处理。</li>
</ul>
<h4 id="存储的调研和选择"><a href="#存储的调研和选择" class="headerlink" title="存储的调研和选择"></a>存储的调研和选择</h4><h5 id="业界的选择–数据库"><a href="#业界的选择–数据库" class="headerlink" title="业界的选择–数据库"></a>业界的选择–数据库</h5><p>对于支付类业务，其实，最好的是用数据库。业务层的订单表相当于业务请求上下文，会将请求的所需信息落地(没有上下文落地其实也没关系，返回用户失败即可)。</p>
<p>节点执行状态数据存在和订单表同库的另一个表中，即可支持一个在一个本地事务内保证分布式事务的最终一致性逻辑。</p>
<h5 id="业务特性决定了数据库不合适"><a href="#业务特性决定了数据库不合适" class="headerlink" title="业务特性决定了数据库不合适"></a>业务特性决定了数据库不合适</h5><p>由于种种原因，我们这里不太适合用数据库，一个是广告上下文太大，且绝大多时候没有用，为了少数异常存到订单表的话太浪费；二是目前采用实时库+历史库的方式进行，没有分库，如果增加了中间状态表，目前的并发量，对数据库压力会很大，但目前搞分库又不是那么必要。</p>
<p>所以数据库不太适合。</p>
<h5 id="公司自研存储的选择和使用"><a href="#公司自研存储的选择和使用" class="headerlink" title="公司自研存储的选择和使用"></a>公司自研存储的选择和使用</h5><p>正好，公司自研了一套基于rocksdb的高性能存储，在读写性能和数据结构方面基本可以代替MySQL和Redis。在公司内部被广泛使用。</p>
<p>两个版本，一个是paxos强一致版本，读写性能稍弱，但保证数据强一致；另一个是普通版本，读写性能更高，但不保证强一致，即有可能主从切换会丢数据。</p>
<p>对于带金融属性的业务来说，在理论上的读写性能满足业务要求的情况下，当然是首选强一致的版本了。特别是业务上下文，丢失的结果就是该请求的整个异常恢复流程无法被正常唤起。</p>
<p>然而，理想照进现实，由于该版本之前应对的业务场景较为简单，并发也没有我们这么大，一些底层调优不到位导致服务抖动频繁。</p>
<p>如果是在大厂，就像之前用OB，只要OB有承若数据不丢，那基本不用考虑丢失的问题。如果丢了，我想可能大概率就会把锅抛给存储团队，限时优化之类。</p>
<p>但，我们小厂可都是<em>相亲相爱的一家人</em>，怎么能干这种事。所以选了另一个版本，使用更广泛，更成熟的非强一致版本。而数据丢失的问题由业务自己来想办法。</p>
<h3 id="消息队列的介入"><a href="#消息队列的介入" class="headerlink" title="消息队列的介入"></a>消息队列的介入</h3><h4 id="非强一致存储为啥会丢数据"><a href="#非强一致存储为啥会丢数据" class="headerlink" title="非强一致存储为啥会丢数据"></a>非强一致存储为啥会丢数据</h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">如上图所示，该存储架构采用的是主从模式，数据由主写入，同步到从，当主异常时，进行主从切换，恢复服务。</p>
<p>但是，由于不是强一致协议，写主成功即为成功，当主宕机时，虽然主从切换很快，10秒完成，但还没有来得及同步到从的那部分数据，就会因为因为主从切换而丢失。</p>
<p>怎么办？</p>
<h4 id="消息队列登场"><a href="#消息队列登场" class="headerlink" title="消息队列登场"></a>消息队列登场</h4><p>为了应对存储不授信的情况，我们引入了消息队列来实现存储的丢失补偿。<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">如上图所示，引入延迟消息进入处理流程。</p>
<ul>
<li>当节点执行发生异常时，发送当前业务上下文到消息队列。如果是正常执行的情况则无需发送。</li>
<li>消息的延迟间隔，要大于主从切换的时间，并且需要小于定时任务的触发间隔。比如，主从切换需要10s，那延迟消息的延迟间隔就设置为30s , 接收消息都重新插入上下文到存储。在节点异常一分钟之后，被定时任务捞取，执行处理。</li>
</ul>
<p>用两个时间差来覆盖掉主从切换带来的数据丢失的影响。</p>
<h4 id="更进一步–存储降级"><a href="#更进一步–存储降级" class="headerlink" title="更进一步–存储降级"></a>更进一步–存储降级</h4><p>那么，更极端的情况，如果整个存储服务持续不可用怎么办？</p>
<p><strong>降级：</strong> 自己的命运要把握在自己手中。目的是保证绝大部分服务正常。<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"></p>
<ul>
<li>监控系统。用于收集和汇报操作存储时的异常，并统计错误率和超时率</li>
<li>一旦错误率和超时率达到阈值（比如持续30s，所有服务全部超时）执行关联脚本。</li>
<li>脚本负责触发配置中心的配置切换，由正常模式切换为柔性模式。</li>
<li>柔性模式下，所有涉及存储读写的操作将被忽略，以保障绝大部分请求可以正常执行。</li>
<li>遇到执行异常的节点，将上下文发送至消息队列，消费时不再插入存储，而是改为直接消费。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BA%8B%E5%8A%A1/%E4%B8%80%E8%87%B4%E6%80%A7/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-02-%E4%B8%80%E8%87%B4%E6%80%A7/" data-id="cm6lsyz5j0056k2dlfl4ba1k2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/开源项目/身份认证/shiro分布式-01-subject维护" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%88%86%E5%B8%83%E5%BC%8F-01-subject%E7%BB%B4%E6%8A%A4/" class="article-date">
  <time datetime="2021-05-11T03:52:48.000Z" itemprop="datePublished">2021-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%88%86%E5%B8%83%E5%BC%8F-01-subject%E7%BB%B4%E6%8A%A4/">shiro分布式-01-subject维护</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在技术群有一位提出</p>
<p>   shiro框架下获取主题subject信息都是从SecurityUtils.getSubject()方法中获取，跟踪到最后都是从ThreadLocal变量中获取的值，只能在当前内存中存储，那分布式部署的话，会产生获取到的subject的主体信息不一致的问题？</p>
<p>那么 先看下上述问题的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SecurityUtils</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Subject <span class="title">getSubject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     Subject subject = ThreadContext.getSubject();</span><br><span class="line">     <span class="keyword">if</span> (subject == <span class="literal">null</span>) &#123;</span><br><span class="line">         subject = (<span class="keyword">new</span> Subject.Builder()).buildSubject();</span><br><span class="line">         ThreadContext.bind(subject);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> subject;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看下ThreadContext的方法 getSubject-&gt;get-&gt;getValue-&gt;resources</span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    public <span class="keyword">static</span> Subject getSubject() &#123;</span><br><span class="line">        <span class="keyword">return</span> (Subject) <span class="keyword">get</span>(SUBJECT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">   public <span class="keyword">static</span> <span class="built_in">Object</span> <span class="keyword">get</span>(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">String</span> msg = <span class="string">&quot;get() - in thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            log.trace(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span> value = getValue(key);</span><br><span class="line">        <span class="keyword">if</span> ((value != <span class="keyword">null</span>) &amp;&amp; log.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">String</span> msg = <span class="string">&quot;Retrieved value of type [&quot;</span> + value.getClass().getName() + <span class="string">&quot;] for key [&quot;</span> +</span><br><span class="line">                    key + <span class="string">&quot;] &quot;</span> + <span class="string">&quot;bound to thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            log.trace(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//3 </span></span><br><span class="line">     private <span class="keyword">static</span> <span class="built_in">Object</span> getValue(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, <span class="built_in">Object</span>&gt; perThreadResources = resources.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">return</span> perThreadResources != <span class="keyword">null</span> ? perThreadResources.<span class="keyword">get</span>(key) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">        private <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, <span class="built_in">Object</span>&gt;&gt; resources = <span class="keyword">new</span> InheritableThreadLocalMap&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, <span class="built_in">Object</span>&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>单看这些，可能有的朋友也会认同如此，都是从resources这个线程私有变量拿去。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="谁负责从subject取值"><a href="#谁负责从subject取值" class="headerlink" title="谁负责从subject取值"></a>谁负责从subject取值</h3><p>根据上述代码分析，是每个请求从subject中获取自己的subject信息</p>
<h3 id="谁负责对subject赋值"><a href="#谁负责对subject赋值" class="headerlink" title="谁负责对subject赋值"></a>谁负责对subject赋值</h3><p>但是我是做过基于redis分布搭建shiro项目的，肯定应该不会存在上述现象，还是查源码为先吧。</p>
<h4 id="先看这个ThreadLocal变量究竟是哪个类在给他赋值？"><a href="#先看这个ThreadLocal变量究竟是哪个类在给他赋值？" class="headerlink" title="先看这个ThreadLocal变量究竟是哪个类在给他赋值？"></a>先看这个ThreadLocal变量究竟是哪个类在给他赋值？</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadContext类</span></span><br><span class="line"><span class="comment">//获取的变量key，请注意看，无论怎么取subject，key值永远不变 </span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> String SECURITY_MANAGER_KEY = ThreadContext.<span class="keyword">class</span>.getName() + <span class="string">&quot;_SECURITY_MANAGER_KEY&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> String SUBJECT_KEY = ThreadContext.<span class="keyword">class</span>.getName() + <span class="string">&quot;_SUBJECT_KEY&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到一个引用，置入subject的信息</span></span><br><span class="line">    <span class="keyword">public</span> static void bind(Subject subject) &#123;</span><br><span class="line">        <span class="keyword">if</span> (subject != <span class="literal">null</span>) &#123;</span><br><span class="line">            put(SUBJECT_KEY, subject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>对bind方法进行跟踪</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">--SubjectThreadState</span><span class="selector-class">.bind</span>()</span><br><span class="line"><span class="selector-tag">----SubjectCallable</span><span class="selector-class">.call</span>()</span><br><span class="line"><span class="selector-tag">------DelegatingSubject</span><span class="selector-class">.execute</span>(<span class="selector-tag">Callable</span>&lt;<span class="selector-tag">V</span>&gt; <span class="selector-tag">callable</span>)</span><br><span class="line"><span class="selector-tag">----SubjectRunnable</span><span class="selector-class">.run</span>()</span><br><span class="line"><span class="selector-tag">------DelegatingSubject</span><span class="selector-class">.execute</span>(<span class="selector-tag">Runnable</span> <span class="selector-tag">runnable</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到SubjectThreadState字面意思应该是线程状态的信息，最终都跟踪到DelegatingSubject这个代理类上，其执行线程方法，更新绑定的subject值；</p>
<p>再继续溯源，找到AbstractShiroFilter类的doFilterInternal。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, <span class="keyword">final</span> FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Throwable t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);</span><br><span class="line">            <span class="keyword">final</span> ServletResponse response = prepareServletResponse(request, servletResponse, chain);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Subject subject = createSubject(request, response);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="comment">//在该处调用线程方法更新</span></span><br><span class="line">            subject.execute(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    updateSessionLastAccessTime(request, response);</span><br><span class="line">                    executeChain(request, response, chain);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">            t = ex.getCause();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            t = throwable;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，应该了解到一点，就是每个请求进来的时候，这个主线程会有对应的新线程去更新赋值subject的信息。</p>
<h4 id="每次请求进来时这个subject信息是在这里生成的，那原来已经登录的用户再次来请求的subject已经变了，怎么登录成功呢？还有没登录的时候，这里会怎么处理呢？"><a href="#每次请求进来时这个subject信息是在这里生成的，那原来已经登录的用户再次来请求的subject已经变了，怎么登录成功呢？还有没登录的时候，这里会怎么处理呢？" class="headerlink" title="每次请求进来时这个subject信息是在这里生成的，那原来已经登录的用户再次来请求的subject已经变了，怎么登录成功呢？还有没登录的时候，这里会怎么处理呢？"></a>每次请求进来时这个subject信息是在这里生成的，那原来已经登录的用户再次来请求的subject已经变了，怎么登录成功呢？还有没登录的时候，这里会怎么处理呢？</h4><p>借着这个问题，咱么看一下这个shiro过滤器都干啥了？</p>
<p> 一般web项目都指定 ShiroFilter这个过滤器，在初始化到第一个请求到达之前，首先设置了一些环境参数，获取配置信息，初始化一些变量，包含SecurityManager这个核心（可以看init()，onFilterConfigSet()函数）</p>
<p>第一个请求到达进入doFilterInternal方法内，调用prepareServletRequest，prepareServletResponse，判断为http方式时，封装Shiro格式的输入输出流。</p>
<p>还有就是一旦发生请求，那么会话session就已经存在了</p>
<p>接下来创建新的subject具体过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractShiroFilter</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebSubject <span class="title">createSubject</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebSubject.Builder(getSecurityManager(), request, response).buildWebSubject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跟踪buildWebSubject方法，DefaultSecurityManager类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSecurityManager</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Subject <span class="title">createSubject</span><span class="params">(SubjectContext subjectContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//create a copy so we don&#x27;t modify the argument&#x27;s backing map:</span></span><br><span class="line">        <span class="comment">//英文不好，自行百度吧</span></span><br><span class="line">        SubjectContext context = copy(subjectContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ensure that the context has a SecurityManager instance, and if not, add one:</span></span><br><span class="line">         <span class="comment">//英文不好，自行百度吧</span></span><br><span class="line">        context = ensureSecurityManager(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Resolve an associated Session (usually based on a referenced session ID), and place it in the context before</span></span><br><span class="line">        <span class="comment">//sending to the SubjectFactory.  The SubjectFactory should not need to know how to acquire sessions as the</span></span><br><span class="line">        <span class="comment">//process is often environment specific - better to shield the SF from these details:</span></span><br><span class="line">         <span class="comment">//这里是重点</span></span><br><span class="line">        context = resolveSession(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Similarly, the SubjectFactory should not require any concept of RememberMe - translate that here first</span></span><br><span class="line">        <span class="comment">//if possible before handing off to the SubjectFactory:</span></span><br><span class="line">        context = resolvePrincipals(context);</span><br><span class="line">        <span class="comment">//也是重点</span></span><br><span class="line">        Subject subject = doCreateSubject(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//save this subject for future reference if necessary:</span></span><br><span class="line">        <span class="comment">//(this is needed here in case rememberMe principals were resolved and they need to be stored in the</span></span><br><span class="line">        <span class="comment">//session, so we don&#x27;t constantly rehydrate the rememberMe PrincipalCollection on every operation).</span></span><br><span class="line">        <span class="comment">//Added in 1.2:</span></span><br><span class="line">        </span><br><span class="line">        save(subject);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>重点跟踪resolveSession()方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> SubjectContext resolveSession(SubjectContext context) &#123;</span><br><span class="line">      <span class="comment">//第一次进来肯定没有缓存值，会进入下面的resolveContextSession</span></span><br><span class="line">      <span class="keyword">if</span> (context.resolveSession() != <span class="literal">null</span>) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;Context already contains a session.  Returning.&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> context;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//Context couldn&#x27;t resolve it directly, let&#x27;s see if we can since we have direct access to </span></span><br><span class="line">          <span class="comment">//the session manager:</span></span><br><span class="line">          Session session = resolveContextSession(context);</span><br><span class="line">          <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">              context.setSession(session);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvalidSessionException e) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;Resolved SubjectContext context session is invalid.  Ignoring and creating an anonymous &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;(session-less) Subject instance.&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSecurityManager</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Session <span class="title">resolveContextSession</span><span class="params">(SubjectContext context)</span> <span class="keyword">throws</span> InvalidSessionException </span>&#123;</span><br><span class="line"><span class="comment">//这里判断一下是http请求的话，会获取本身session的id</span></span><br><span class="line">     SessionKey key = getSessionKey(context);</span><br><span class="line">     <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> getSession(key);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//一直跟踪getSession方法到AbstractNativeSessionManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Session <span class="title">getSession</span><span class="params">(SessionKey key)</span> <span class="keyword">throws</span> SessionException </span>&#123;</span><br><span class="line">       Session session = lookupSession(key);</span><br><span class="line">       <span class="keyword">return</span> session != <span class="keyword">null</span> ? createExposedSession(session, key) : <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Session <span class="title">lookupSession</span><span class="params">(SessionKey key)</span> <span class="keyword">throws</span> SessionException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;SessionKey argument cannot be null.&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> doGetSession(key);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面doGetSession调用了了AbstractValidatingSessionManager</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Session <span class="title">doGetSession</span><span class="params">(<span class="keyword">final</span> SessionKey key)</span> <span class="keyword">throws</span> InvalidSessionException </span>&#123;</span><br><span class="line">        enableSessionValidationIfNecessary();</span><br><span class="line"></span><br><span class="line">        log.trace(<span class="string">&quot;Attempting to retrieve session with key &#123;&#125;&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">        Session s = retrieveSession(key);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">            validate(s, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSessionManager.retrieveSession</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Session <span class="title">retrieveSession</span><span class="params">(SessionKey sessionKey)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</span><br><span class="line">        Serializable sessionId = getSessionId(sessionKey);</span><br><span class="line">        <span class="keyword">if</span> (sessionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Unable to resolve session ID from SessionKey [&#123;&#125;].  Returning null to indicate a &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;session could not be found.&quot;</span>, sessionKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Session s = retrieveSessionFromDataSource(sessionId);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//session ID was provided, meaning one is expected to be found, but we couldn&#x27;t find one:</span></span><br><span class="line">            String msg = <span class="string">&quot;Could not find session with ID [&quot;</span> + sessionId + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownSessionException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DefaultSessionManager.retrieveSessionFromDataSource</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Session <span class="title">retrieveSessionFromDataSource</span><span class="params">(Serializable sessionId)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sessionDAO.readSession(sessionId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>一直跟踪到sessionDAO.readSession,这里，从方法字面意思也知道是从缓存或者数据库读取session信息了。就是上面提到的redis缓存，会吧session信息存储。</p>
<p>接下来回头看，在buildWebSubject的方法里面，获取到了缓存的session信息或者是一个全新的session信息，</p>
<p>之后的doCreateSubject方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultWebSubjectFactory</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subject <span class="title">createSubject</span><span class="params">(SubjectContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//SHIRO-646</span></span><br><span class="line">        <span class="comment">//Check if the existing subject is NOT a WebSubject. If it isn&#x27;t, then call super.createSubject instead.</span></span><br><span class="line">        <span class="comment">//Creating a WebSubject from a non-web Subject will cause the ServletRequest and ServletResponse to be null, which wil fail when creating a session.</span></span><br><span class="line">        <span class="keyword">boolean</span> isNotBasedOnWebSubject = context.getSubject() != <span class="keyword">null</span> &amp;&amp; !(context.getSubject() <span class="keyword">instanceof</span> WebSubject);</span><br><span class="line">        <span class="keyword">if</span> (!(context <span class="keyword">instanceof</span> WebSubjectContext) || isNotBasedOnWebSubject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.createSubject(context);</span><br><span class="line">        &#125;</span><br><span class="line">        WebSubjectContext wsc = (WebSubjectContext) context;</span><br><span class="line">        SecurityManager securityManager = wsc.resolveSecurityManager();</span><br><span class="line">        <span class="comment">//取到session信息</span></span><br><span class="line">        Session session = wsc.resolveSession();</span><br><span class="line">        <span class="keyword">boolean</span> sessionEnabled = wsc.isSessionCreationEnabled();</span><br><span class="line">        <span class="comment">//如果缓存没有，获取session中的身份信息</span></span><br><span class="line">        PrincipalCollection principals = wsc.resolvePrincipals();</span><br><span class="line">        <span class="comment">//如果缓存没有，获取session中的认证信息</span></span><br><span class="line">        <span class="keyword">boolean</span> authenticated = wsc.resolveAuthenticated();</span><br><span class="line">        String host = wsc.resolveHost();</span><br><span class="line">        ServletRequest request = wsc.resolveServletRequest();</span><br><span class="line">        ServletResponse response = wsc.resolveServletResponse();</span><br><span class="line">        <span class="comment">//创建新的subject</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebDelegatingSubject(principals, authenticated, host, session, sessionEnabled,</span><br><span class="line">                request, response, securityManager);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建完毕以后，接下来就更新缓存内的subject的状态，直至请求结束</p>
<p>到这里每次请求到达filter基本上流程就完毕了，如果已经登录了，无论是从本身的map缓存还是外部的redis缓存，都应该能拿到session信息，如果没有登录，是拿不到的。也证明了分布式部署时，有了session的分布式缓存，应该就基本搭建成功了吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%88%86%E5%B8%83%E5%BC%8F-01-subject%E7%BB%B4%E6%8A%A4/" data-id="cm6lsyz5y0099k2dlctb591n5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/9/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/">juc</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/oom/">oom</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/oom/">oom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/spring/">spring</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/" rel="tag">JDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/annotation/" rel="tag">annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cluster/" rel="tag">cluster</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jstack/" rel="tag">jstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock/" rel="tag">lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/net/" rel="tag">net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/next/" rel="tag">next</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/" rel="tag">reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-starter/" rel="tag">spring starter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/startup/" rel="tag">startup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transaction/" rel="tag">transaction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtual-machine/" rel="tag">virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vm/" rel="tag">vm</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDK/" style="font-size: 11.11px;">JDK</a> <a href="/tags/annotation/" style="font-size: 10px;">annotation</a> <a href="/tags/cluster/" style="font-size: 10px;">cluster</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/hexo/" style="font-size: 12.22px;">hexo</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/jstack/" style="font-size: 14.44px;">jstack</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/lock/" style="font-size: 10px;">lock</a> <a href="/tags/mysql/" style="font-size: 16.67px;">mysql</a> <a href="/tags/net/" style="font-size: 10px;">net</a> <a href="/tags/next/" style="font-size: 11.11px;">next</a> <a href="/tags/redis/" style="font-size: 15.56px;">redis</a> <a href="/tags/reflect/" style="font-size: 10px;">reflect</a> <a href="/tags/spring-starter/" style="font-size: 10px;">spring starter</a> <a href="/tags/springboot/" style="font-size: 18.89px;">springboot</a> <a href="/tags/startup/" style="font-size: 17.78px;">startup</a> <a href="/tags/transaction/" style="font-size: 11.11px;">transaction</a> <a href="/tags/virtual-machine/" style="font-size: 12.22px;">virtual machine</a> <a href="/tags/vm/" style="font-size: 13.33px;">vm</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%A1%86%E6%9E%B6-04-bean%E5%8C%85-Bean/">spring框架-04-bean包-Bean</a>
          </li>
        
          <li>
            <a href="/2022/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-HashMap/">JDK-util-HashMap</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E5%9C%BA%E6%99%AF/">mysql - 常见事务问题解决方案</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">mysql - 面试问题</a>
          </li>
        
          <li>
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">交换排序-冒泡排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 Fei Qi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>