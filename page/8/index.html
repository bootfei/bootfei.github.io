<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/8/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-01-redis%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-01-redis%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">分布式锁-01-redis实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-20 11:42:40" itemprop="dateCreated datePublished" datetime="2021-05-20T11:42:40+08:00">2021-05-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><h2 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109</span><br><span class="line">	at org.redisson.RedissonLock.unlock(RedissonLock.java:366)</span><br></pre></td></tr></table></figure>

<h2 id="排查原因"><a href="#排查原因" class="headerlink" title="排查原因"></a>排查原因</h2><ul>
<li><p>先检查项目中是否确保了 <strong>redissonClient 的单例</strong>。</p>
<ul>
<li>定位依据：我还没想到，因为用spring都是单例</li>
</ul>
</li>
<li><p>redissonClient 虽然是单例的静态成员变量，但初始化时未加锁，而是简单使用  （本次报错原因）</p>
<ul>
<li><p>定位依据：不需要改代码甚至debug，只需要搜索日志里是否有两行，打印两次版本信息说明肯定初始化了两次 Redisson。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13:58:07.972 [main] INFO org.redisson.Version - Redisson 2.8.2</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static RedissonClient redisson &#x3D; null;</span><br><span class="line">      </span><br><span class="line">public static RedissonClient getRedisson()&#123;</span><br><span class="line">  if(redisson &#x3D;&#x3D; null)&#123;</span><br><span class="line">      RedissonManager.init(); &#x2F;&#x2F;初始化</span><br><span class="line">  &#125;</span><br><span class="line">  return redisson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>加锁解锁没有同一个 lock，而是每次都使用<code>getRedisson().getLock(key)</code> 获取lock1和lock2两个不同的lock对象。导致解锁时从另一个 redissonClient 并没有获取到锁。换言之，报错里的<code>not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109</code> 其实关键问题在于<code>by node id</code> ，而不是线程id。<ul>
<li>定位依据：加锁和解锁时，打印lock对象，对象信息不一致，说明是两个对象。</li>
</ul>
</li>
<li>解锁时，当前线程不是锁的持有者，关键问题在于<code>by current thread</code> ，而不是 node id。<ul>
<li>定位依据：使用lock.isHeldByCurrentThread()判断，如果不是被当前线程持有锁，当前线程释放释放锁肯定报这个异常</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-04-%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-04-%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">shiro应用-04-缓存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-19 19:13:10" itemprop="dateCreated datePublished" datetime="2021-05-19T19:13:10+08:00">2021-05-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在每一次请求需要权限的时候总是会调用授权的方法查询数据库，这样的话性能很低，因此我们可以使用缓存管理器，来达到这种要求，在Shiro中有一个内存缓存管理器，内部就是使用Map实现的，但是这种缓存并不能实现跨JVM（分布式），因此我们可以使用Redis自定义一个缓存管理器，步骤如下：</p>
<h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><h3 id="实现RedisCache，用于实现对授权信息的缓存"><a href="#实现RedisCache，用于实现对授权信息的缓存" class="headerlink" title="实现RedisCache，用于实现对授权信息的缓存"></a>实现RedisCache，用于实现对授权信息的缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis的Cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储在redis中的hash中的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String COMMON_NAME=<span class="string">&quot;shiro-demo&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">RedisCache</span><span class="params">(RedisTemplate redisTemplate, String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">         <span class="keyword">this</span>.name=COMMON_NAME+<span class="string">&quot;:&quot;</span>+name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定的key的缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CacheException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">     		<span class="keyword">return</span> (V) redisTemplate.opsForHash().get(name,k);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CacheException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">         redisTemplate.opsForHash().put(name, k, v);</span><br><span class="line">         <span class="comment">//设置过期时间</span></span><br><span class="line">         <span class="keyword">return</span> v;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定key的缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 默认是principle对象，在AuthorizingRealm中设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">         V v = <span class="keyword">this</span>.get(k);</span><br><span class="line">         redisTemplate.opsForHash().delete(name, k);</span><br><span class="line">         <span class="keyword">return</span> v;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除所有的缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">     		redisTemplate.delete(name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     		<span class="keyword">return</span> redisTemplate.opsForHash().size(name).intValue();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     		<span class="keyword">return</span> redisTemplate.opsForHash().keys(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     		<span class="keyword">return</span> redisTemplate.opsForHash().values(name);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现RedisManager"><a href="#实现RedisManager" class="headerlink" title="实现RedisManager"></a>实现RedisManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis的CacheManager</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> &lt;K, V&gt; <span class="function">Cache&lt;K, V&gt; <span class="title">getCache</span><span class="params">(String s)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line">     		<span class="keyword">return</span> <span class="keyword">new</span> RedisCache&lt;K,V&gt;(redisTemplate, s);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在配置类中配置上缓存管理器，需要设置到SecurityManager中才能生效"><a href="#在配置类中配置上缓存管理器，需要设置到SecurityManager中才能生效" class="headerlink" title="在配置类中配置上缓存管理器，需要设置到SecurityManager中才能生效"></a>在配置类中配置上缓存管理器，需要设置到SecurityManager中才能生效</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置缓存管理器，使用自定义的Redis缓存管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="keyword">new</span> RedisCacheManager();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置安全管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">     DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(userRealm());</span><br><span class="line">     <span class="comment">//设置缓存管理器</span></span><br><span class="line">     securityManager.setCacheManager(cacheManager());</span><br><span class="line">     <span class="keyword">return</span> securityManager;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a><strong>清除缓存</strong></h2><ul>
<li>在CachingRelam中有一个清除缓存的方法<code>org.apache.shiro.realm.CachingRealm#clearCache</code>，在我们自定义的Realm中覆盖该方法即可，这样就能在<strong>退出或者在业务逻辑中用户的权限改变</strong>的时候能够清除缓存的数据，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除CacheManager中的缓存，可以在用户权限改变的时候调用，这样再次需要权限的时候就会重新查询数据库不走缓存了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Subject subject = SecurityUtils.getSubject();</span><br><span class="line">    <span class="comment">//调用父类的清除缓存的方法</span></span><br><span class="line">    <span class="keyword">super</span>.clearCache(subject.getPrincipals());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>除了重写或者覆盖CachingRelam中的方法，根据源码可以知道，真正起作用的方法是<code>AuthorizingRealm</code>中的方法<code>clearCachedAuthorizationInfo</code>，因此我们也可以重写或者覆盖这个方法，这里不再演示。</strong></li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h2><ul>
<li>在Shiro中一旦有地方调用<code>Subject.hasRole</code>等校验权限的地方，那么就会检测授权信息，在<code>org.apache.shiro.realm.AuthorizingRealm#getAuthorizationInfo</code>的方法中会先缓存中查询是否存在，否则调用授权的方法从数据库中查询，查询之后放入缓存中，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">getAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (principals == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       AuthorizationInfo info = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">           log.trace(<span class="string">&quot;Retrieving AuthorizationInfo for principals [&quot;</span> + principals + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">//获取可用的缓存管理器</span></span><br><span class="line">       Cache&lt;Object, AuthorizationInfo&gt; cache = getAvailableAuthorizationCache();</span><br><span class="line">       <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">               log.trace(<span class="string">&quot;Attempting to retrieve the AuthorizationInfo from cache.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//获取缓存的key，这里获取的就是principal主体信息</span></span><br><span class="line">           Object key = getAuthorizationCacheKey(principals);</span><br><span class="line">           <span class="comment">//从缓存中获取数据</span></span><br><span class="line">           info = cache.get(key);</span><br><span class="line">           <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   log.trace(<span class="string">&quot;No AuthorizationInfo found in cache for principals [&quot;</span> + principals + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   log.trace(<span class="string">&quot;AuthorizationInfo found in cache for principals [&quot;</span> + principals + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果缓存中没有查到</span></span><br><span class="line">       <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//调用重写的授权方法，从数据库中查询</span></span><br><span class="line">           info = doGetAuthorizationInfo(principals);</span><br><span class="line">       <span class="comment">//如果查询到了，添加到缓存中</span></span><br><span class="line">           <span class="keyword">if</span> (info != <span class="keyword">null</span> &amp;&amp; cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                   log.trace(<span class="string">&quot;Caching authorization info for principals: [&quot;</span> + principals + <span class="string">&quot;].&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//获取缓存的key</span></span><br><span class="line">               Object key = getAuthorizationCacheKey(principals);</span><br><span class="line">               <span class="comment">//放入缓存</span></span><br><span class="line">               cache.put(key, info);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> info;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-03-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E5%BA%94%E7%94%A8-03-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">shiro应用-03-会话管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-19 17:16:08" itemprop="dateCreated datePublished" datetime="2021-05-19T17:16:08+08:00">2021-05-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。</p>
<p>Shiro在开启Web功能的时候默认的会话管理器是DefaultWebSessionManager，这种管理器是针对cookie进行存储的，将sessionId存储在cookie中，但是现在的主流方向是前后端分离，我们不能再依赖Cookie，因此我们必须自定义的会话管理器，实现跨JVM，前后端分离。</p>
<h2 id="自定义SessionMananger"><a href="#自定义SessionMananger" class="headerlink" title="自定义SessionMananger"></a><strong>自定义SessionMananger</strong></h2><ul>
<li>在原有的DefaultWebSessionManager进行扩展，否则从头实现将会要写大量代码。默认的Web的会话管理器是从cookie中获取SessionId，我们只需要重写其中的方法即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的会话管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionManager</span> <span class="keyword">extends</span> <span class="title">DefaultWebSessionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前后端分离不存在cookie，因此需要重写getSessionId的逻辑，从请求参数中获取</span></span><br><span class="line"><span class="comment">     * 此处的逻辑：在登录成功之后会将sessionId作为一个token返回，下次请求的时候直接带着token即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">getSessionId</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取上传的token,这里的token就是sessionId</span></span><br><span class="line">        <span class="keyword">return</span> request.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写该方法，在SessionManager中只要涉及到Session的操作都会获取Session，获取Session主要是从缓存中获取，父类的该方法执行逻辑如下：</span></span><br><span class="line"><span class="comment">     *  1、先从RedisCache中获取，调用get方法</span></span><br><span class="line"><span class="comment">     *  2、如果RedisCache中不存在，在从SessionDao中获取，调用get方法</span></span><br><span class="line"><span class="comment">     *  优化：我们只需要从SessionDao中获取即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionKey Session的Key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Session <span class="title">retrieveSession</span><span class="params">(SessionKey sessionKey)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</span><br><span class="line">        <span class="comment">//获取SessionId</span></span><br><span class="line">        Serializable sessionId = getSessionId(sessionKey);</span><br><span class="line">        <span class="keyword">if</span> (sessionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Unable to resolve session ID from SessionKey [&#123;&#125;].  Returning null to indicate a &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;session could not be found.&quot;</span>, sessionKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接调用SessionDao中的get方法获取</span></span><br><span class="line">        Session session = ((RedisSessionDao) sessionDAO).doReadSession(sessionId);</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//session ID was provided, meaning one is expected to be found, but we couldn&#x27;t find one:</span></span><br><span class="line">            String msg = <span class="string">&quot;Could not find session with ID [&quot;</span> + sessionId + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownSessionException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法是作用是当访问指定的uri的时候会更新Session中的执行时间，用来动态的延长失效时间。</span></span><br><span class="line"><span class="comment">     * 在父类的实现方法会直接调用SessionDao中的更新方法更新缓存中的Session</span></span><br><span class="line"><span class="comment">     * 此处并没有其他的逻辑，后续可以补充</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">touch</span><span class="params">(SessionKey key)</span> <span class="keyword">throws</span> InvalidSessionException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.touch(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="自定义SessionDao"><a href="#自定义SessionDao" class="headerlink" title="自定义SessionDao"></a><strong>自定义SessionDao</strong></h2><ul>
<li>SessionDao的作用是Session持久化的手段，默认的SessionDao是缓存在内存中的，此处使用Redis作为缓存的工具，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义RedisSessionDao，继承CachingSessionDAO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionDao</span> <span class="keyword">extends</span> <span class="title">CachingSessionDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doUpdate方法&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(session.getId(), session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doDelete方法&quot;</span>);</span><br><span class="line">        redisTemplate.delete(session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个Session，添加到缓存中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session Session信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创建的SessionId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">doCreate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doCreate方法&quot;</span>);</span><br><span class="line">        Serializable sessionId = generateSessionId(session);</span><br><span class="line">        assignSessionId(session, sessionId);</span><br><span class="line">        redisTemplate.opsForValue().set(session.getId(), session);</span><br><span class="line">        <span class="keyword">return</span> sessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Session <span class="title">doReadSession</span><span class="params">(Serializable sessionId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doReadSession方法&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> (Session) redisTemplate.opsForValue().get(sessionId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义SessionId生成策略"><a href="#自定义SessionId生成策略" class="headerlink" title="自定义SessionId生成策略"></a><strong>自定义SessionId生成策略</strong></h2><ul>
<li>默认的Shiro的生成策略是JavaUuidSessionIdGenerator，此处也可以自定义自己的生成策略，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的SessionId的生成策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionIdGenerator</span> <span class="keyword">implements</span> <span class="title">SessionIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Serializable <span class="title">generateId</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义Session监听器"><a href="#自定义Session监听器" class="headerlink" title="自定义Session监听器"></a><strong>自定义Session监听器</strong></h2><ul>
<li>Session监听器能够监听Session的生命周期，包括开始、过期、失效（停止），如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Session监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionListener</span> <span class="keyword">implements</span> <span class="title">SessionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Session无效【停止了，stopTime！=null】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;session失效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExpiration</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;超时&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="完成上述配置"><a href="#完成上述配置" class="headerlink" title="完成上述配置"></a><strong>完成上述配置</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置SessionDao，使用自定义的Redis缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionDAO <span class="title">sessionDAO</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RedisSessionDao sessionDao = <span class="keyword">new</span> RedisSessionDao();</span><br><span class="line">        <span class="comment">//设置自定义的Id生成策略</span></span><br><span class="line">        sessionDao.setSessionIdGenerator(<span class="keyword">new</span> RedisSessionIdGenerator());</span><br><span class="line">        <span class="keyword">return</span> sessionDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置会话监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionListener <span class="title">sessionListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisSessionListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置会话管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionManager <span class="title">sessionManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultWebSessionManager sessionManager = <span class="keyword">new</span> RedisSessionManager();</span><br><span class="line">        <span class="comment">//设置session的过期时间</span></span><br><span class="line">        sessionManager.setGlobalSessionTimeout(<span class="number">60000</span>);</span><br><span class="line">        <span class="comment">//设置SessionDao</span></span><br><span class="line">        sessionManager.setSessionDAO(sessionDAO());</span><br><span class="line">        <span class="comment">//设置SessionListener</span></span><br><span class="line">        sessionManager.setSessionListeners(Lists.newArrayList(sessionListener()));</span><br><span class="line">        <span class="keyword">return</span> sessionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置安全管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(userRealm());</span><br><span class="line">        <span class="comment">//设置缓存管理器</span></span><br><span class="line">        securityManager.setCacheManager(cacheManager());</span><br><span class="line">        <span class="comment">//设置会话管理器</span></span><br><span class="line">        securityManager.setSessionManager(sessionManager());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a><strong>优化</strong></h2><ul>
<li>在源码中可以看到<code>AbstractSessionDAO</code>中的增删改查方法的执行逻辑使用的双层缓存的，还设计到查询CacheManager中的缓存，但是我们的SessionDao既然是实现了Redis的缓存，那么是没必要查询两次的，因此需要重写其中的方法，此时我们自己需要写一个抽象类覆盖其中的增删改查方法即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RedisSessionDao的抽象类，重写其中的增删改查方法，原因如下：</span></span><br><span class="line"><span class="comment"> *  1、AbstractSessionDAO中的默认方法是写查询CacheManager中的缓存，既然SessionDao实现了Redis的缓存</span></span><br><span class="line"><span class="comment"> *      那么就不需要重复查询两次，因此重写了方法，直接使用RedisSessionDao查询即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRedisSessionDao</span> <span class="keyword">extends</span> <span class="title">AbstractSessionDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写creat方法，直接执行sessionDao的方法，不再执行cacheManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Serializable <span class="title">create</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        Serializable sessionId = doCreate(session);</span><br><span class="line">        <span class="keyword">if</span> (sessionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;sessionId returned from doCreate implementation is null.  Please verify the implementation.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写删除操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        doDelete(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写update方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnknownSessionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Session session)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</span><br><span class="line">        doUpdate(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写查找方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnknownSessionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Session <span class="title">readSession</span><span class="params">(Serializable sessionId)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</span><br><span class="line">        Session s = doReadSession(sessionId);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownSessionException(<span class="string">&quot;There is no session with id [&quot;</span> + sessionId + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(Session session)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">(Session session)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>此时的上面的RedisSessionDao直接继承我们自定义的抽象类即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义RedisSessionDao，继承AbstractRedisSessionDao，达到只查一层缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionDao</span> <span class="keyword">extends</span> <span class="title">AbstractRedisSessionDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String HASH_NAME=<span class="string">&quot;shiro_user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doUpdate方法&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().put(HASH_NAME, session.getId(), session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doDelete方法&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().delete(HASH_NAME, session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个Session，添加到缓存中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session Session信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创建的SessionId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">doCreate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doCreate方法&quot;</span>);</span><br><span class="line">        Serializable sessionId = generateSessionId(session);</span><br><span class="line">        assignSessionId(session, sessionId);</span><br><span class="line">        redisTemplate.opsForHash().put(HASH_NAME, session.getId(),session);</span><br><span class="line">        <span class="keyword">return</span> sessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Session <span class="title">doReadSession</span><span class="params">(Serializable sessionId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行redisdao的doReadSession方法&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> (Session) redisTemplate.opsForHash().get(HASH_NAME,sessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有的Session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Session&gt; <span class="title">getActiveSessions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List values = redisTemplate.opsForHash().values(HASH_NAME);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(values))&#123;</span><br><span class="line">            <span class="keyword">return</span> values;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h2><ul>
<li><p>Shiro默认是在当前用户访问页面的时候检查Session是否停止或者过期，如果过期和停止了会调用的SessionDao中的相关方法删除缓存，但是如果这是在用户名操作的情况下，如果用户一直未操作，那么Session已经失效了，但是缓存中并没有删除，这样一来将会有大量无效的Session堆积，因此我们必须定时清理失效的Session。</p>
</li>
<li><p>清理会话，有如下两种方法：</p>
</li>
<li><ul>
<li>自己写一个定时器，每隔半小时或者几分钟清除清除缓存</li>
<li>自定义SessionValidationScheduler</li>
<li>使用已经实现的ExecutorServiceSessionValidationScheduler</li>
</ul>
</li>
</ul>
<ul>
<li>在Shiro中默认会开启ExecutorServiceSessionValidationScheduler，执行时间是一个小时，但是如果想要使用定时器定时清除的话，那么需要关闭默认的清除器，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//禁用Session清除器，使用定时器清除</span></span><br><span class="line">sessionManager.setSessionValidationSchedulerEnabled(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>







<h3 id="如何的Session是失效的"><a href="#如何的Session是失效的" class="headerlink" title="如何的Session是失效的"></a><strong>如何的Session是失效的</strong></h3><ul>
<li><p>Session是如何保活的？</p>
</li>
<li><ul>
<li><p>在<code>org.apache.shiro.web.servlet.AbstractShiroFilter#doFilterInternal</code>中的一个<code>updateSessionLastAccessTime(request, response);</code>方法用来更新Session的最后执行时间为当前时间，最终调用的就是<code>org.apache.shiro.session.mgt.SimpleSession#touch</code>。</p>
</li>
<li><p>在每次请求验证Session的时候实际调用的是<code>org.apache.shiro.session.mgt.AbstractValidatingSessionManager#doValidate</code>方法，在其中真正调用的是<code>org.apache.shiro.session.mgt.SimpleSession#validate</code>来验证是否过期或者停止</p>
</li>
<li><ul>
<li>核心逻辑就是验证当前的时间和最后执行时间的差值是否在设置的过期时间的范围内</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="何时是失效的"><a href="#何时是失效的" class="headerlink" title="何时是失效的"></a><strong>何时是失效的</strong></h3><ul>
<li><p>Session失效目前通过读源码总结出如下三点：</p>
</li>
<li><ul>
<li><p>isValid判断，这个会在访问请求的时候shiro会自动验证，并且设置进去</p>
</li>
<li><p>用户长期不请求，此时的isValid并不能验证出来，此时需要比较最后执行的时间和开始时间比较</p>
</li>
<li><p>没有登录就访问的也会在redis中生成一个Session，但是此时的Session中是没有两个属性的，以下的两个属性只有在认证成功之后才会设置查到Session中</p>
</li>
<li><ul>
<li>org.apache.shiro.subject.support.DefaultSubjectContext#PRINCIPALS_SESSION_KEY</li>
<li>org.apache.shiro.subject.support.DefaultSubjectContext#AUTHENTICATED_SESSION_KEY</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>通过上面的分析，此时就能写出从缓存中删除失效Session的代码，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * session过期有三种可能，如下：</span></span><br><span class="line"><span class="comment">     *  1、isValid判断，这个会在访问请求的时候shiro会自动验证，并且设置进去</span></span><br><span class="line"><span class="comment">     *  2、用户长期不请求，此时的isValid并不能验证出来，此时需要比较最后执行的时间和开始时间</span></span><br><span class="line"><span class="comment">     *  3、没有登录就访问的也会在redis中生成一个Session，但是此时的Session中是没有两个属性的</span></span><br><span class="line"><span class="comment">     *      1、org.apache.shiro.subject.support.DefaultSubjectContext#PRINCIPALS_SESSION_KEY</span></span><br><span class="line"><span class="comment">     *      2、org.apache.shiro.subject.support.DefaultSubjectContext#AUTHENTICATED_SESSION_KEY</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearExpireSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取所有的Session</span></span><br><span class="line">        Collection&lt;Session&gt; sessions = redisSessionDao.getActiveSessions();</span><br><span class="line">        sessions.forEach(s-&gt;&#123;</span><br><span class="line">            SimpleSession session= (SimpleSession) s;</span><br><span class="line">            <span class="comment">//第一种可能</span></span><br><span class="line">            Boolean status1=!session.isValid();</span><br><span class="line">            <span class="comment">//第二种可能用开始时间和过期时间比较</span></span><br><span class="line">            Boolean status2=session.getLastAccessTime().getTime()+session.getTimeout()&lt;<span class="keyword">new</span> Date().getTime();</span><br><span class="line">            <span class="comment">//第三种可能</span></span><br><span class="line">            Boolean status3= Objects.isNull(session.getAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY))&amp;&amp;Objects.isNull(session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY));</span><br><span class="line">            <span class="keyword">if</span> (status1||status2||status3)&#123;</span><br><span class="line">                <span class="comment">//清楚session</span></span><br><span class="line">                redisSessionDao.delete(session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/19/database/Mybatis/Mybatis-PageHelper%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/19/database/Mybatis/Mybatis-PageHelper%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Mybatis-PageHelper插件实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-19 15:30:42 / Modified: 17:10:39" itemprop="dateCreated datePublished" datetime="2021-05-19T15:30:42+08:00">2021-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%81%A5%E5%A3%AE%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%81%A5%E5%A3%AE%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">健壮后端服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-17 19:37:33" itemprop="dateCreated datePublished" datetime="2021-05-17T19:37:33+08:00">2021-05-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如何避免故障？一句话概括 : 怀疑第三方，防备使用方，做好自己。</p>
<h2 id="怀疑第三方"><a href="#怀疑第三方" class="headerlink" title="怀疑第三方"></a>怀疑第三方</h2><p>坚持一条信念：“所有第三方服务都不可靠”，不管第三方什么天花乱坠的承诺。</p>
<h3 id="接口备份-数据备份，制定好业务降级方案"><a href="#接口备份-数据备份，制定好业务降级方案" class="headerlink" title="接口备份+ 数据备份，制定好业务降级方案"></a>接口备份+ 数据备份，制定好业务降级方案</h3><p>第三方提供了两种方式：1）一种是消息通知服务，只发送变更后的数据；2）一种是 HTTP 服务，需要我们自己主动调用获取数据。我们一开始选择消息同步的方式，因为实时性更高，但是之后就遭遇到消息迟迟发送不过来的问题，而且也没什么异常，等我们发现一天时间已过去，问题已然升级为故障。合理的方式应该两个同步方案都使用，消息方式用于实时更新，HTTP 主动同步方式定时触发（比如1小时）用于兜底，即使消息出了问题，通过主动同步也能保证一小时一更新。</p>
<p>有些时候第三方服务表面看起来正常，但是返回的数据是被污染的。这时需要每隔一段时间，对数据进行备份，方便在数据被污染时做回滚</p>
<h3 id="设置超时时间，保障快速失败"><a href="#设置超时时间，保障快速失败" class="headerlink" title="设置超时时间，保障快速失败"></a>设置超时时间，保障快速失败</h3><p>某服务调用的一个第三方接口正常响应时间是 50 ms，某天该第三方接口出现问题，大约有 15% 的请求响应时间超过 2s，没过多久服务 load 飙高到 10 以上，响应时间也非常缓慢，即第三方服务将我们服务拖垮了。为什么会被拖垮？没设置超时！我们采用的是同步调用方式，使用了一个线程池，该线程池里最大线程数设置了 50，如果所有线程都在忙，多余的大量请求就堆在队列里中。</p>
<p>正确的做法是和第三方商量确定个较短的超时时间比如 200 ms，这样即使他们服务出现问题也不会对我们服务产生很大影响。</p>
<h3 id="慎重选择重试机制"><a href="#慎重选择重试机制" class="headerlink" title="慎重选择重试机制"></a>慎重选择重试机制</h3><p>需要结合自己的业务以及异常来仔细斟酌是否使用重试机制。</p>
<h2 id="防备使用方"><a href="#防备使用方" class="headerlink" title="防备使用方"></a>防备使用方</h2><p>这里又要坚持一条信念：“所有的使用方都不靠谱”，</p>
<h3 id="设计一个好的-API（RPC、Restful）避免误用"><a href="#设计一个好的-API（RPC、Restful）避免误用" class="headerlink" title="设计一个好的 API（RPC、Restful）避免误用"></a>设计一个好的 API（RPC、Restful）避免误用</h3><p>过去两年间看过不少故障，直接或间接原因来自于糟糕的接口。如果你的接口让很多人误用，那要好好反思自己的接口设计了，接口设计虽然看着简单，但是学问很深，建议大家好好看看 Joshua Bloch 的演讲《How to Design a Good API &amp; Why it Matters（如何设计一个好的 API 及为什么这很重要）》以及《Java API 设计清单》。</p>
<h3 id="流量控制和限制"><a href="#流量控制和限制" class="headerlink" title="流量控制和限制"></a>流量控制和限制</h3><p>生活给了我们答案：比如老式电闸都安装了保险丝，一旦有人使用超大功率的设备，保险丝就会烧断以保护各个电器不被强电流给烧坏。同理我们的接口也需要安装上“保险丝”，以防止非预期的请求对系统压力过大而引起的系统瘫痪，当流量过大时，可以采取拒绝或者引流等机制</p>
<h2 id="做好自己"><a href="#做好自己" class="headerlink" title="做好自己"></a>做好自己</h2><p>做好自己是个非常大的话题，从需求分析、架构设计 、代码编写、测试、code review、上线、线上服务运维等阶段都可以重点展开介绍，这次简单分享下架构设计、代码编写上的几条经验原则。</p>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>略<!--我一直坚持的原则--></p>
<h3 id="控制资源的使用"><a href="#控制资源的使用" class="headerlink" title="控制资源的使用"></a>控制资源的使用</h3><p>写代码脑子一定要绷紧一根弦，认知到我们所在的机器资源是有限的。机器资源有哪些？CPU、内存、网络、磁盘等，如果不做好保护控制工作，一旦某一资源满负荷，很容易导致出现线上问题。</p>
<p><strong>CPU 资源怎么限制</strong></p>
<ul>
<li>计算算法优化。</li>
<li>锁。对于很多服务而言，没有那么多耗费计算资源的算法，但 CPU 使用率也很高，这个时候需要看看锁的使用情况，我的建议是如无必要，尽量不用显式使用锁。</li>
<li>习惯问题。比如写循环的时候，千万要检查看看是否能正确退出，有些时候一不小心，在某些条件下就成为死循环</li>
<li>尽量使用线程池。通过线程池来限制线程的数目，避免线程过多造成的线程上下文切换的开销。</li>
<li>JVM 参数调优。</li>
</ul>
<p><strong>内存资源怎么限制</strong></p>
<ul>
<li>JVM 参数设置。有一篇朋友写的好文可以参考《Linux 与 JVM 的内存关系分析》。</li>
<li>初始化 Java 集合类大小。使用 Java 集合类的时候尽量初始化大小，在长连接服务等耗费内存资源的服务中这种优化非常重要。</li>
<li>使用内存池/对象池</li>
<li>使用线程池的时候一定要设置队列的最大长度。之前看过好多起故障都是由于队列最大长度没有限制最后导致内存溢出。</li>
<li>如果数据较大避免使用本地缓存。如果数据量较大，可以考虑放置到分布式缓存如 Redis、Tair 等，不然 gc 都可能把自己服务卡死。</li>
<li>对缓存数据进行压缩。比如之前做推荐相关服务时，需要保存用户偏好数据，如果直接保存可能有 12G，后来采用短文本压缩算法直接压缩到 6G，不过这时一定要考虑好压缩解压缩算法的 cpu 使用率、效率与压缩率的平衡，一些压缩率很高但是性能很差的算法，也不适合线上实时调用。有些时候直接使用 probuf 来序列化之后保存，这样也能节省内存空间。</li>
</ul>
<p><strong>网络资源怎么限制</strong></p>
<ul>
<li>减少调用的次数。经常看到有同学在循环里用 redis/tair 的 get，如果意识到这里面的网络开销的话就应该使用批量处理；又如在推荐服务中经常遇到要去多个地方去取数据，一般采用多线程并行去取数据，这个时候不仅耗费cpu资源，也耗费网络资源，一种在实际中常常采用的方法就是先将很多数据离线存储到一块 ，这时候线上服务只要一个请求就能将所有数据获取。</li>
<li>减少传输的数据量。一种方法是压缩后传输，还有一种就是按需传输，比如经常遇到的 getData(int id)，如果我们返回该 id 对应的 Data 所有信息，一来人家不需要，二来数据量传输太大，这个时候可以改为 getData(int id, Listfields)，使用方传输相应的字段过来，服务端只返回使用方需要的字段即可。</li>
</ul>
<p><strong>磁盘资源怎么限制</strong></p>
<p>打日志要控制量，并定期清理。</p>
<h3 id="避免单点"><a href="#避免单点" class="headerlink" title="避免单点"></a>避免单点</h3><p>从大层次上讲服务可以多机房部署、异地多活；从自己设计角度上讲，服务应该能做到水平扩展。</p>
<ul>
<li>对于很多无状态的服务，通过 nginx、zookeeper 能轻松实现水平扩展；</li>
<li>对一些 job 类型的服务，怎么避免单点呢，毕竟只能在一个节点上运行，可以参考《Quartz应用与集群原理分析》一文；对数据服务来说，怎么避免单点呢？简而言之、可以通过分片、分层等方式来实现</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%B5%84%E6%BA%90%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%B5%84%E6%BA%90%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/%E8%B5%84%E6%BA%90%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" class="post-title-link" itemprop="url">数据库连接池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-13 09:17:35" itemprop="dateCreated datePublished" datetime="2021-05-13T09:17:35+08:00">2021-05-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-07 13:00:50" itemprop="dateModified" datetime="2021-11-07T13:00:50+08:00">2021-11-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="每次请求建立连接"><a href="#每次请求建立连接" class="headerlink" title="每次请求建立连接"></a>每次请求建立连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">FindAllUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//1、装载sqlserver驱动对象</span></span><br><span class="line">  DriverManager.registerDriver(<span class="keyword">new</span> SQLServerDriver());             </span><br><span class="line">  <span class="comment">//2、通过JDBC建立数据库连接</span></span><br><span class="line">  Connection con =DriverManager.getConnection(<span class="string">&quot;jdbc:sqlserver://192.168.2.6:1433;DatabaseName=customer&quot;</span>, <span class="string">&quot;sa&quot;</span>, <span class="string">&quot;123&quot;</span>);            </span><br><span class="line">  <span class="comment">//3、创建状态</span></span><br><span class="line">  Statement state =con.createStatement();           </span><br><span class="line">  <span class="comment">//4、查询数据库并返回结果</span></span><br><span class="line">  ResultSet result =state.executeQuery(<span class="string">&quot;select * from users&quot;</span>);           </span><br><span class="line">  <span class="comment">//5、输出查询结果</span></span><br><span class="line">  <span class="keyword">while</span>(result.next())&#123;</span><br><span class="line">    System.out.println(result.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">  &#125;            </span><br><span class="line">  <span class="comment">//6、断开数据库连接</span></span><br><span class="line">  result.close();</span><br><span class="line">  state.close();</span><br><span class="line">  con.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>每一次web请求都要建立一次数据库连接。每次都得花费0.05s～1s的时间，而且系统还要分配内存资源</li>
<li>对于每一次数据库连接，使用完后都得断开。否则如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏</li>
<li>不能控制被创建的连接对象数，连接过多可能导致内存泄漏</li>
</ul>
<h3 id="每次请求访问连接池"><a href="#每次请求访问连接池" class="headerlink" title="每次请求访问连接池"></a>每次请求访问连接池</h3><p>改进：</p>
<ul>
<li>预先在缓冲池中放入一定数量的连接。</li>
<li>查询完数据库后，不关闭连接，而是暂时存放起来，当别人使用时，把这个连接给他们使用。</li>
</ul>
<p>优点：</p>
<ul>
<li>避免了一次建立数据库连接和断开的操作时间消耗</li>
<li>通过设定连接池最大连接数来防止系统无限地与数据库连接。</li>
<li>通过连接池的管理机制监视数据库的连接的数量﹑使用情况，为系统开发﹑测试及性能调整提供依据。</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="DataSource作用"><a href="#DataSource作用" class="headerlink" title="DataSource作用"></a>DataSource作用</h3><p>DataSource是javax.sql包中的类，是Java原生rt.jar包中的类。<!--就是Bootstrap Class Loader加载的jar包--></p>
<p>javax.sql.DataSource定义的是抽象方法，通过Java JNDI的方式将具体实现开放给各个厂商、个人自己实现。</p>
<p>在Spring框架中，通过DataSource + 配置的方式，来定义具体的数据库源。并向Spring框架提供数据源的Connection服务。</p>
<blockquote>
<p>在Spring中若想实现多数据源，那么就需要在DataSource下手</p>
</blockquote>
<h3 id="Connection作用"><a href="#Connection作用" class="headerlink" title="Connection作用"></a>Connection作用</h3><ul>
<li>connection可以当成是服务器和数据库的一个会话</li>
<li>statemant用来在会话的上下文中执行sql以及返回结果。一个connection可以包含多个statement</li>
<li>在两者中间存在事务的概念。在java语言中，connection类本身提供了对事务的ACID特性的支持，可以通过设置connection的autocommit属性为false 然后显式的调用commit或rollback方法来实现。但要高效的进行connection复用，就必须提供相应的事务支持机制。<a href="">可采用每一个事务独占一个连接来实现</a>，这种方法可以大大降低事务管理的复杂性。</li>
</ul>
<!--这句话不严谨，其实一个Connection只能被一个线程独享，即只有当某一线程完成了本次数据操作，将连接放回到连接池之后，其他线程才能够再次获取该Connection并使用-->

<blockquote>
<p>一个连接对应一个事务，多个连接的事务是不一样的</p>
</blockquote>
<h4 id="连接池代码"><a href="#连接池代码" class="headerlink" title="连接池代码"></a>连接池代码</h4><ul>
<li>编写class 实现DataSource 接口</li>
<li>在class构造器一次性创建10个连接，将连接保存LinkedList中</li>
<li>实现getConnection 从 LinkedList中返回一个连接 <!--注意：这里原作者写的有问题，实际上这个连接是被某个线程独享的--></li>
<li>提供将连接放回连接池中方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">  <span class="comment">//链表 --- 实现栈结构</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Connection&gt; dataSources = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化连接数量</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一次性创建10个连接</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//1、装载sqlserver驱动对象</span></span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> SQLServerDriver());</span><br><span class="line">        <span class="comment">//2、通过JDBC建立数据库连接</span></span><br><span class="line">        Connection con =DriverManager.getConnection(</span><br><span class="line">          <span class="string">&quot;jdbc:sqlserver://192.168.2.6:1433;DatabaseName=customer&quot;</span>, <span class="string">&quot;sa&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//3、将连接加入连接池中</span></span><br><span class="line">        dataSources.add(con);  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="keyword">synchronized</span> <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dataSources.removeFirst(); <span class="comment">// 删除第一个连接返回</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将连接放回连接池</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">    dataSources.add(conn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询所有用户</span></span><br><span class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">FindAllUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、使用连接池建立数据库连接</span></span><br><span class="line">    MyDataSource dataSource = <span class="keyword">new</span> MyDataSource();</span><br><span class="line">    Connection conn =dataSource.getConnection();        </span><br><span class="line">    <span class="comment">//2、创建状态</span></span><br><span class="line">    Statement state =con.createStatement();           </span><br><span class="line">    <span class="comment">//3、查询数据库并返回结果</span></span><br><span class="line">    ResultSet result =state.executeQuery(<span class="string">&quot;select * from users&quot;</span>);           </span><br><span class="line">    <span class="comment">//4、输出查询结果</span></span><br><span class="line">    <span class="keyword">while</span>(result.next())&#123;</span><br><span class="line">      System.out.println(result.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    &#125;            </span><br><span class="line">    <span class="comment">//5、断开数据库连接</span></span><br><span class="line">    result.close();</span><br><span class="line">    state.close();</span><br><span class="line">    <span class="comment">//6、归还数据库连接给连接池</span></span><br><span class="line">    dataSource.releaseConnection(conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="ThreadLocal作用"><a href="#ThreadLocal作用" class="headerlink" title="ThreadLocal作用"></a>ThreadLocal作用</h3><h4 id="ThreadLocal能存共享变量么？"><a href="#ThreadLocal能存共享变量么？" class="headerlink" title="ThreadLocal能存共享变量么？"></a><strong>ThreadLocal能存共享变量么？</strong></h4><p>存肯定能存，但不建议，因为将Connection set进ThreadLocalMap，也其实是保存一个内存对象的地址引用而已，真正使用的时候，还是唯一的那个对象在起作用。</p>
<p><a href=""><em>ThreadLocal最常用的功能，是为了避免层层传递而提供了对象保存和获取方法，把同一个数据库连接“分享”给同一个线程的不同调用方法。</em></a></p>
<h4 id="ThreadLocal完成数据库连接隔离的功能，需要怎么做"><a href="#ThreadLocal完成数据库连接隔离的功能，需要怎么做" class="headerlink" title="ThreadLocal完成数据库连接隔离的功能，需要怎么做?"></a>ThreadLocal完成数据库连接隔离的功能，需要怎么做?</h4><p>如果非要用ThreadLocal实现这个连接隔离的功能，那么，只能是为每个线程创建新的连接，然后保存在Threadlocal中，这样，每个线程在自己的生命周期范围内只会使用这个连接，即可实现线程隔离。</p>
<h4 id="druid、zdal中，threadlocal的作用体现在哪里呢？"><a href="#druid、zdal中，threadlocal的作用体现在哪里呢？" class="headerlink" title="druid、zdal中，threadlocal的作用体现在哪里呢？"></a>druid、zdal中，threadlocal的作用体现在哪里呢？</h4><p>druid、zdal等优秀的中间件，可不止是数据库连接池这一个作用，<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&mid=2650001189&idx=1&sn=87606749ae2be031a9171d272fd73819&scene=21#wechat_redirect">阿里数据库中间件zdal源码解析</a> 文中也有提及。</p>
<p>就以zdal为例，因为阿里的数据库规模基本都非常大，但又有一套完备的数据库库表拆分规范，因此，分库键、分表键、主键、虚拟表名等在设计和存储时需要遵循规范，而zdal中的解析操作，也需要与之相匹配。这个解析工作是相对复杂且繁重的，然而，针对同一用户的操作，通常库表的路由是相对固定的，因此，当我们解析过一次sql，通过各个字段和配置规则，计算出了库表路由</p>
<p>===&gt; (划重点) 那么，<a href="">可以直接put进线程上下文，供本次请求的后续数据库操作使用</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parse</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    SimpleCondition simpleCondition = <span class="keyword">new</span> SimpleCondition();</span><br><span class="line">    simpleCondition.setVirtualTableName(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    simpleCondition.put(<span class="string">&quot;age&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    ThreadLocalMap.put(ThreadLocalString.ROUTE_CONDITION, simpleCondition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 后续操作()&#123;</span><br><span class="line">   RouteCondition rc = (RouteCondition) ThreadLocalMap.get(ThreadLocalString.ROUTE_CONDITION);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//不走解析SQL，由ThreadLocal传入的指定对象（RouteCondition），决定库表目的地</span></span><br><span class="line">       metaData = sqlDispatcher.getDBAndTables(rc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 通过解析SQL来分库分表</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          metaData = sqlDispatcher.getDBAndTables(originalSql, parameters);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ZdalCheckedExcption e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个也正好是对前面ThreadLocal正确使用方法的补充</p>
<h2 id="开源数据库连接池的原理"><a href="#开源数据库连接池的原理" class="headerlink" title="开源数据库连接池的原理"></a>开源数据库连接池的原理</h2><p><strong>zdal的连接池管理源码一览：</strong></p>
<ul>
<li>druid维护一个数组来存放连接</li>
<li>同时维护了多个变量来检测连接池的状态，其中poolingCount用来表示池中连接的数量</li>
<li>当有线程来获取连接时，需要先加锁，对数量进行减一操作。</li>
<li>当获取连接时发现数量为0 ，则返回为空</li>
<li>当连接关闭时，会将连接资源放回数组，并对数量做加一操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">InternalManagedConnectionPool</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">     <span class="comment">//构造函数中，初始化了连接池大小和信号量大小</span></span><br><span class="line">     connectionListeners = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.maxSize);</span><br><span class="line">      permits = <span class="keyword">new</span> InternalSemaphore(<span class="keyword">this</span>.maxSize);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取连接</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ConnectionListener <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//信号量尝试获取许可</span></span><br><span class="line">   <span class="keyword">if</span> (permits.tryAcquire(poolParams.blockingTimeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">         ConnectionListener cl = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">         <span class="comment">//加锁资源池</span></span><br><span class="line">         <span class="keyword">synchronized</span> (connectionListeners) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (connectionListeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//获取list的最后一个</span></span><br><span class="line">                cl = (ConnectionListener) connectionListeners.remove(connectionListeners.size() - <span class="number">1</span>);</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">//最大连接数 减去 正在工作的信号量 </span></span><br><span class="line">                <span class="keyword">int</span> size = (maxSize - permits.availablePermits());</span><br><span class="line">                <span class="keyword">if</span> (size &gt; maxUsedConnections)&#123;</span><br><span class="line">                     maxUsedConnections = size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> cl;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">while</span>(connectionListeners.size() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//OK, 在连接池中找不到正在工作的连接了. 那就创建个新的</span></span><br><span class="line">      createNewConnection()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.maxSize == <span class="keyword">this</span>.maxUsedConnections) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ResourceException(</span><br><span class="line">         <span class="string">&quot;数据源最大连接数已满，并且在超时时间范围内没有新的连接释放,poolName = &quot;</span></span><br><span class="line">         + poolName</span><br><span class="line">         + <span class="string">&quot; blocking timeout=&quot;</span></span><br><span class="line">         + poolParams.blockingTimeout +</span><br><span class="line">         <span class="string">&quot;(ms)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>volatile 标识的maxUsedConnections用来完成线程间数据可见</li>
<li>隶属于AQS系列的Semaphone，用来控制共享资源并发访问量。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>假设同一时间多个线程从数据库连接池获取连接，那肯定拿的是不同的连接，当前线程和别的线程拿的连接不一样，那当前线程在crud的时候，和其他线程不在一个事务之内。</li>
<li><del>假设不同时间的多个线程要从数据库连接池后获取连接，那这个时候就可能拿到的是同一个连接了，那多个线程线程拿到的是同一个连接，也就是说在多个线程在同一个事务之内。</del>“<del>为了避免不同时间的多个线程可能是同一个连接，那么引入了threadlocal后，每个线程之间都会创建独立的连接副本，将collection各自copy一份，这样就互相不干扰了。</del>“ <strong>这句话是错误的</strong>，<a href="">因为threadLocal只保留同一个connection内存对象的不同引用，线程操作的对象其实还是同一个</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/java%E6%8E%A2%E9%92%88/" class="post-title-link" itemprop="url">java探针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-13 08:21:05" itemprop="dateCreated datePublished" datetime="2021-05-13T08:21:05+08:00">2021-05-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-02 13:52:45" itemprop="dateModified" datetime="2021-09-02T13:52:45+08:00">2021-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="探针类SimpleAgent-java"><a href="#探针类SimpleAgent-java" class="headerlink" title="探针类SimpleAgent.java"></a>探针类SimpleAgent.java</h3><h4 id="方法1：premain"><a href="#方法1：premain" class="headerlink" title="方法1：premain"></a>方法1：premain</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>&#123;</span><br><span class="line">      	...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>premain 方法为固定写法，它有两个方法签名可以选择，JVM 首先会去寻找这个方法来启动探针，它传入了探针的参数，以及 Instrumentation 对象，该对象可以提供对字节码的修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void premain(String agentArgs, Instrumentation inst);</span><br></pre></td></tr></table></figure>

<p>如果没有找到上面的方法，则会寻找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void premain(String agentArgs);</span><br></pre></td></tr></table></figure>

<h4 id="方法2：attach"><a href="#方法2：attach" class="headerlink" title="方法2：attach"></a>方法2：attach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAgent</span></span>&#123;</span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;agentmain&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打包方式"><a href="#打包方式" class="headerlink" title="打包方式"></a>打包方式</h3><p>打包为可用的 java agent 时，需要注意配置参数，上面提供了两种方式，一个是直接在<code>pom.xml</code>中指定配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>com.git.hui.agent.SimpleAgent<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>com.git.hui.agent.SimpleAgent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外一个是在配置文件 <code>META-INF/MANIFEST.MF</code> 中写好(需要注意最后一个空行不可或缺）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: com.git.hui.agent.SimpleAgent</span><br><span class="line">Agent-Class: com.git.hui.agent.SimpleAgent</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="方法1：使用MANIFEST-INFO"><a href="#方法1：使用MANIFEST-INFO" class="headerlink" title="方法1：使用MANIFEST.INFO"></a>方法1：使用MANIFEST.INFO</h4><ul>
<li>在资源目录(Resources)下，新建目录<code>META-INF</code></li>
<li>在<code>META-INF</code>目录下，新建文件<code>MANIFEST.MF</code></li>
</ul>
<p>文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: com.git.hui.agent.SimpleAgent #适用于premain方式</span><br><span class="line">Agent-Class: com.git.hui.agent.SimpleAgent #适用于attach方式</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line"> #空行</span><br></pre></td></tr></table></figure>

<p>请注意，最后的一个空行，不能少，在 idea 中，删除最后一行时，会有错误提醒</p>
<p>然后我们的<code>pom.xml</code>配置，需要作出对应的修改</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">manifestFile</span>&gt;</span></span><br><span class="line">                      src/main/resources/META-INF/MANIFEST.MF</span><br><span class="line">                  <span class="tag">&lt;/<span class="name">manifestFile</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--&lt;manifestEntries&gt;--&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--&lt;Premain-Class&gt;com.git.hui.agent.SimpleAgent&lt;/Premain-Class&gt;--&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--&lt;Agent-Class&gt;com.git.hui.agent.SimpleAgent&lt;/Agent-Class&gt;--&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--&lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt;--&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--&lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt;--&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--&lt;/manifestEntries&gt;--&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">goal</span>&gt;</span>attached<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>mvn assembly:assembly</code>命令打包</p>
<h4 id="方法2：pom-指定配置"><a href="#方法2：pom-指定配置" class="headerlink" title="方法2：pom 指定配置"></a>方法2：pom 指定配置</h4><p>在 pom.xml 文件中，添加如下配置，请注意一下<code>manifestEntries</code>标签内的参数</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>com.git.hui.agent.SimpleAgent<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>com.git.hui.agent.SimpleAgent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>attached<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后通过 <code>mvn assembly:assembly</code> 命令打包，在<code>target</code>目录下，可以看到一个后缀为<code>jar-with-dependencies</code>的 jar 包，就是我们的目标</p>
<h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><p>创建一个web项目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MVCWeb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;web running&quot;</span>);</span><br><span class="line">        	Thread.sleep(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>使用姿势</th>
</tr>
</thead>
<tbody><tr>
<td><code>premain()</code></td>
<td>agent 以 jvm 方式加载时调用，即目标应用在启动时，指定了 agent</td>
<td><code>-javaagent:xxx.jar</code></td>
</tr>
<tr>
<td><code>agentmain()</code></td>
<td>agent 以 attach 方式运行时调用，目标应用程序正常工作后，使用attach应用</td>
<td><code>VirtualMachine.attach(pid)</code>来指定目标进程号 <br/> <code>vm.loadAgent(&quot;...jar&quot;)</code>加载 agent</td>
</tr>
</tbody></table>
<h4 id="方法1：使用jar-agent"><a href="#方法1：使用jar-agent" class="headerlink" title="方法1：使用jar-agent"></a>方法1：使用jar-agent</h4><p>web项目启动时，添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:&#x2F;Users&#x2F;....&#x2F;target&#x2F;java-agent-1.0-SNAPSHOT-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure>



<h4 id="方法2：使用attach方式"><a href="#方法2：使用attach方式" class="headerlink" title="方法2：使用attach方式"></a>方法2：使用attach方式</h4><p>另启动一个attach项目，将agent绑定到web上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, AgentLoadException, AgentInitializationException, AttachNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// attach方法参数为目标应用程序的进程号</span></span><br><span class="line">        VirtualMachine vm = VirtualMachine.attach(<span class="string">&quot;web的进程号&quot;</span>);</span><br><span class="line">        <span class="comment">// 请用你自己的agent绝对地址，替换这个</span></span><br><span class="line">        vm.loadAgent(<span class="string">&quot;/Users/......./target/java-agent-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="使用原生JDK8开发探针统计接口耗时"><a href="#使用原生JDK8开发探针统计接口耗时" class="headerlink" title="使用原生JDK8开发探针统计接口耗时"></a>使用原生JDK8开发探针统计接口耗时</h3><h4 id="java-lang-instrument接口定义"><a href="#java-lang-instrument接口定义" class="headerlink" title="java.lang.instrument接口定义"></a>java.lang.instrument接口定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册一个Transformer，从此之后的类加载都会被Transformer拦截。</span></span><br><span class="line"><span class="comment"> * Transformer可以直接对类的字节码byte[]进行修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对JVM已经加载的类重新触发类加载。使用的就是上面注册的Transformer。</span></span><br><span class="line"><span class="comment"> * retransformation可以修改方法体，但是不能变更方法签名、增加和删除方法/类的成员属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个jar加入到bootstrap classloader的 classpath里</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendToBootstrapClassLoaderSearch</span><span class="params">(JarFile jarfile)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前被JVM加载的所有类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class[] getAllLoadedClasses();</span><br></pre></td></tr></table></figure>

<p>前面两个方法比较重要，addTransformer 方法配置之后，后续的类加载都会被 Transformer 拦截。对于已经加载过的类，可以执行 retransformClasses 来重新触发这个 Transformer 的拦截。类加载的字节码被修改后，除非再次被 retransform，否则不会恢复。</p>
<p>通过上面的描述，可知</p>
<ul>
<li>可以通过<code>Transformer</code>修改类</li>
<li>类加载时，会被触发 Transformer 拦截</li>
</ul>
<h4 id="实现instrument-ClassFileTransformer接口"><a href="#实现instrument-ClassFileTransformer接口" class="headerlink" title="实现instrument.ClassFileTransformer接口"></a>实现instrument.ClassFileTransformer接口</h4><p>在方法的执行前，记录一个时间，执行完之后统计一下时间差，即为耗时</p>
<p>直接修改字节码有点麻烦，因此我们借助神器<code>javaassist</code>来修改字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CostTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">            ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="comment">// 这里我们限制下，只针对目标包下进行耗时统计</span></span><br><span class="line">        <span class="keyword">if</span> (!className.startsWith(<span class="string">&quot;com/git/hui/java/&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CtClass cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">            cl = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(classfileBuffer));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (CtMethod method : cl.getDeclaredMethods()) &#123;</span><br><span class="line">                <span class="comment">// 所有方法，统计耗时；请注意，需要通过`addLocalVariable`来声明局部变量</span></span><br><span class="line">                method.addLocalVariable(<span class="string">&quot;start&quot;</span>, CtClass.longType);</span><br><span class="line">                method.insertBefore(<span class="string">&quot;start = System.currentTimeMillis();&quot;</span>);</span><br><span class="line">                String methodName = method.getLongName();</span><br><span class="line">                method.insertAfter(<span class="string">&quot;System.out.println(\&quot;&quot;</span> + methodName + <span class="string">&quot; cost: \&quot; + (System&quot;</span> +<span class="string">&quot;.currentTimeMillis() - start));&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] transformed = cl.toBytecode();</span><br><span class="line">            <span class="keyword">return</span> transformed;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SimpleAgent类注册instrument"><a href="#SimpleAgent类注册instrument" class="headerlink" title="SimpleAgent类注册instrument"></a>SimpleAgent类注册instrument</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by <span class="doctag">@author</span> yihui in 16:39 20/3/15.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jvm 参数形式启动，运行此方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * manifest需要配置属性Premain-Class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> agentArgs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inst</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;premain&quot;</span>);</span><br><span class="line">        customLogic(inst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态 attach 方式启动，运行此方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * manifest需要配置属性Agent-Class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> agentArgs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inst</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;agentmain&quot;</span>);</span><br><span class="line">        customLogic(inst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计方法耗时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inst</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">customLogic</span><span class="params">(Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> CostTransformer(), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此 agent 完毕，打包和上面的过程一样，</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i: &quot;</span> + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i = print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaseMain main = <span class="keyword">new</span> BaseMain();</span><br><span class="line">        main.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然通过 jvm option 参数指定 agent 的方式，运行上面的代码，会发现抛异常，无法正常运行了</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e67b39eaaf119?w=742&h=292&f=jpeg&s=79442" alt="img"></p>
<p>指出了在 run 方法这里，存在字节码的错误，我们统计耗时的 Agent，主要就是在方法开始前和结束后各自新增了一行代码，我们直接补充在 run 方法中，则相当于下面的代码</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e67b3a018ec29?w=672&h=159&f=jpeg&s=25739" alt="img"></p>
<p>上面的提示很明显的告诉了，最后一行语句永远不可能达到，编译就存在异常了；</p>
<p>很简单，在 jvm 参数中，添加一个<code>-noverify</code> (请注意不同的 jdk 版本，参数可能不一样，我的本地是 jdk8，用这个参数；如果是 jdk7 可以试一下<code>-XX:-UseSplitVerifier</code>)</p>
<p>在 IDEA 开发环境下，如下配置即可</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e67b39ed90844?w=716&h=226&f=jpeg&s=37619" alt="img"></p>
<p>再次运行，正常了</p>
<h4 id="配合spring使用"><a href="#配合spring使用" class="headerlink" title="配合spring使用"></a>配合spring使用</h4><p>通常来说，探针不会引入太重量级的框架，会更多地使用 <code>JDK</code> 原生的接口。然而最近发现，当探针依附在用户应用中时（ <code>Spring</code> 应用），有时难免需要使用反射调用用户接口或 <code>Spring</code> 接口，而反射调用需要类实例，使用 <code>Spring</code> 进行依赖注入的框架中，这个实例必须从 <code>Spring Context</code> 中去取。这就造成了一个问题，如何取到 <code>Spring Context</code> 呢，难道一定要在探针中引入 <code>Sping</code> 框架吗？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-04-Dubbo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-04-Dubbo/" class="post-title-link" itemprop="url">springboot-starter-03-Dubbo</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-12 12:53:52 / Modified: 12:54:18" itemprop="dateCreated datePublished" datetime="2021-05-12T12:53:52+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li><p>消费者与提供者工程均需要导入四个依赖 </p>
<ul>
<li>Dubbo 与 Spring Boot 整合依赖</li>
<li>zkClient依赖</li>
<li>slf4j-log4j12依赖</li>
</ul>
</li>
<li><p>自定义 commons 工程依赖 </p>
</li>
<li><p>提供者工程</p>
<ul>
<li>将 Service 接口实现类的@Service 注解更换为阿里的注解，并添加@Component 注解</li>
<li>在启动类上添加@EnableDubboConfiguration 与@EnableTransactionManager 注解</li>
<li>修改配置文件:指定应用名称与注册中心地址 </li>
</ul>
</li>
<li><p>消费者工程</p>
<ul>
<li>将处理器中 Service 的声明上的@Autowired 注解更换为阿里的@Reference 注解 </li>
<li>在启动类上添加@EnableDubboConfiguration 注解</li>
<li>修改配置文件:指定应用名称与注册中心地址</li>
</ul>
</li>
</ul>
<h3 id="定义-commons-工程"><a href="#定义-commons-工程" class="headerlink" title="定义 commons 工程"></a>定义 <strong>commons</strong> 工程</h3><ul>
<li>依赖：无，因为是纯java项目</li>
<li>定义实体类</li>
<li>定义业务接口</li>
</ul>
<h3 id="定义提供者"><a href="#定义提供者" class="headerlink" title="定义提供者"></a>定义提供者</h3><ul>
<li><p>依赖：</p>
<ul>
<li>添加 <strong>dubbo</strong> 与 <strong>spring boot</strong> 整合依赖，需要从alibaba的github中找到依赖</li>
<li>添加 <strong>zkClient</strong> 依赖</li>
<li>dubboCommons依赖</li>
<li>还有其他的mysql, druid,mybatis依赖</li>
</ul>
</li>
<li><p>定义业务接口</p>
<ul>
<li>将 Service 接口实现类的@Service 注解更换为阿里的注解，并添加@Component 注解</li>
</ul>
</li>
<li><p>修改启动类</p>
<ul>
<li>添加@EnableDubboConfiguration 与@EnableTransactionManager 注解</li>
</ul>
</li>
<li><p>修改配置文件</p>
<ul>
<li><pre><code class="yaml">spring:
  # 功能等价于 spring-dubbo 配置文件中的&lt;dubbo:application/&gt; # 该名称是由服务治理平台使用
  application:
      name: 11-provider-springboot # 指定zk注册中心
  dubbo:
      registry: zookeeper://zkOS:2181
  # zk 集群作注册中心
  # registry: zookeeper://zkOS1:2181?backup=zkOS2:2181,zkOS3:2181
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 定义消费者(略)</span><br><span class="line"></span><br><span class="line">- 依赖：</span><br><span class="line"></span><br><span class="line">  - 添加 **dubbo** 与 **spring boot** 整合依赖，需要从alibaba的github中找到依赖</span><br><span class="line">  - 添加 **zkClient** 依赖</span><br><span class="line">  - dubboCommons依赖</span><br><span class="line"></span><br><span class="line">- 修改配置文件</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;yaml</span><br><span class="line">    spring:</span><br><span class="line">      # 功能等价于 spring-dubbo 配置文件中的&lt;dubbo:application&#x2F;&gt; # 该名称是由服务治理平台使用</span><br><span class="line">      application:</span><br><span class="line">      	name: 11-consumer-springboot # 指定zk注册中心</span><br><span class="line">      dubbo:</span><br><span class="line">      	registry: zookeeper:&#x2F;&#x2F;zkOS:2181</span><br><span class="line">      # zk 集群作注册中心</span><br><span class="line">      # registry: zookeeper:&#x2F;&#x2F;zkOS1:2181?backup&#x3D;zkOS2:2181,zkOS3:2181</span><br></pre></td></tr></table></figure>




</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-03-Mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-03-Mybatis/" class="post-title-link" itemprop="url">springboot-starter-03-Mybatis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-12 12:44:56 / Modified: 12:50:17" itemprop="dateCreated datePublished" datetime="2021-05-12T12:44:56+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="导入三个依赖"><a href="#导入三个依赖" class="headerlink" title="导入三个依赖"></a>导入三个依赖</h3><ul>
<li><p>mybatis 与 Spring Boot 整合依赖，mysql 驱动依赖， Druid 数据源依赖。</p>
</li>
<li><pre><code class="xml">&lt;!--mybatis 与 spring boot 整合依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!--mysql 驱动--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- druid 驱动，数据源 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
  &lt;artifactId&gt;druid&lt;/artifactId&gt;
  &lt;version&gt;1.1.12&lt;/version&gt;
&lt;/dependency&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 定义 Service接口</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">  public class StudentService&#123;</span><br><span class="line">  	@Autowired</span><br><span class="line">  	private IstudentDao dao;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h3 id="定义-Dao-接口"><a href="#定义-Dao-接口" class="headerlink" title="定义 Dao 接口"></a>定义 <strong>Dao</strong> 接口</h3><ul>
<li><p>Com.abc.dao目录</p>
</li>
<li><pre><code class="java">//Dao 接口上要添加@Mapper 注解。
public interface IstudentDao&#123;
    void insertStudent(Student s);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 定义映射文件</span><br><span class="line"></span><br><span class="line">- Com.abc.dao目录， &lt;!--与Dao接口在同一目录--&gt;</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;xml</span><br><span class="line">  &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;   </span><br><span class="line">  &lt;!DOCTYPE mapper   </span><br><span class="line">      PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;   </span><br><span class="line">      &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">  &lt;mapper namespace&#x3D;&quot;com.abc.dao.IstudentDao&quot;&gt;</span><br><span class="line">      &lt;!-- 这里namespace必须是UserMapper接口的路径” --&gt;</span><br><span class="line">      &lt;insert id&#x3D;&quot;insertStudent&quot;&gt;</span><br><span class="line">          insert into student(name,age) values(#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">      &lt;&#x2F;insert&gt;</span><br><span class="line">  &lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>注册资源目录</p>
<ul>
<li><p>在 pom 文件中将 dao 目录注册为资源目录。</p>
</li>
<li><pre><code class="xml">&lt;!-- dao 目录注册为资源目录 --&gt;
&lt;build&gt;
  &lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
      &lt;includes&gt;
        &lt;include&gt;**/*.xml&lt;/include&gt;
      &lt;/includes&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
&lt;/build&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 修改主配置文件</span><br><span class="line"></span><br><span class="line">  - 注册映射文件</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;properties</span><br><span class="line">      mybatis.mapper-location&#x3D;classpath:com&#x2F;abc&#x2F;dao&#x2F;.xml</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>注册实体类别名</p>
<ul>
<li><pre><code class="properties">mybatis.type-aliases-packages=com.abc.beans
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注册数据源</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;properties</span><br><span class="line">    spring.datasource.type&#x3D;com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">    spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;test</span><br><span class="line">    spring.datasource.username&#x3D;root</span><br><span class="line">    spring.datasource.password&#x3D;root</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-02-Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-starter-02-Redis/" class="post-title-link" itemprop="url">springboot-starter-02-redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-12 12:20:17" itemprop="dateCreated datePublished" datetime="2021-05-12T12:20:17+08:00">2021-05-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-21 10:46:32" itemprop="dateModified" datetime="2023-03-21T10:46:32+08:00">2023-03-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>高并发下访问 Redis，存在什么问题?存在三个问题: </p>
<ul>
<li>缓存穿透: 为DB查询为null的数据预设一个值</li>
<li>缓存雪崩: 提前规划好缓存到期时间</li>
<li>热点缓存: 属于缓存雪崩的特例，有一个缓存到期了，大量请求访问这个缓存无效，从而大量请求数据库。双重检测锁机制</li>
</ul>
</blockquote>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><ul>
<li><p>小技巧：如redis,mybatis等依赖，<a href="">可以从父spring依赖中（ctrl + c）找到该依赖和版本号</a>，然后添加</p>
</li>
<li><p>在 pom 文件中添加 Spring Boot 与 Redis 整合依赖。</p>
</li>
<li><pre><code class="xml">&lt;!--mybatis 与 spring boot 整合依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 修改主配置文件</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;properties</span><br><span class="line">  #单机redis</span><br><span class="line">  spring.redis.host&#x3D;</span><br><span class="line">  spring.redis.port&#x3D;</span><br><span class="line">  spring.redis.password&#x3D;</span><br><span class="line">  </span><br><span class="line">  #集群redis</span><br><span class="line">  spring.redis.sentinel.master&#x3D;mymaster</span><br><span class="line">  spring.redis.sentinel.nodes&#x3D;sentine1:22076</span><br><span class="line">  </span><br><span class="line">  spring.cache.type&#x3D;redis</span><br><span class="line">  spring.cache.cache-names&#x3D;realTimeCache</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="修改启动类"><a href="#修改启动类" class="headerlink" title="修改启动类"></a>修改启动类</h3><ul>
<li>添加@EnableCaching: 开启缓存</li>
</ul>
<h3 id="修改实体类-Student"><a href="#修改实体类-Student" class="headerlink" title="修改实体类 Student"></a>修改实体类 <strong>Student</strong></h3><ul>
<li>由于要将查询的实体类对象缓存到 Redis，Redis 要求实体类必须序列化。所以需要实体类实现序列化接口Serializable。</li>
</ul>
<h3 id="修改-Service-接口实现类"><a href="#修改-Service-接口实现类" class="headerlink" title="修改 Service 接口实现类"></a>修改 <strong>Service</strong> 接口实现类</h3><p>@CacheEvict(value=””, allEntries=””)  清楚所有缓存。业务场景，插入必须清楚所缓存</p>
<p>@Cacheable(value=””, key=””) 如果没有缓存，那么查数据库，并添加缓存；如果有缓存，查询指定缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value=&quot;realTimeCache&quot;, key=&quot;&#x27;student&#x27;+#id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> student <span class="title">findStudent</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dao.findStudent(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheEvict(value=&quot;realTimeCache&quot;, allEntries=&quot;true&quot;)</span>  </span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student s)</span></span>&#123;</span><br><span class="line">  dao.insertStudent(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决缓存问题"><a href="#解决缓存问题" class="headerlink" title="解决缓存问题"></a>解决缓存问题</h3><h4 id="使用双重检查锁解决热点缓存"><a href="#使用双重检查锁解决热点缓存" class="headerlink" title="使用双重检查锁解决热点缓存"></a><a href="">使用双重检查锁解决热点缓存</a></h4><ul>
<li><pre><code class="java">public Integer getStudentsCount()&#123;
    BoundValueOperations&lt;Object,Object&gt; ops = redisTemplate.boundValuesOps(&quot;count&quot;);
  Object cnt= ops.getValue();//第一重检查
  if(cnt == null)&#123; 
    //1nd请求来到，2nd请求和3rd请求，因为这个锁而阻塞，无法查询数据库
    synchronized(this)&#123;
      cnt= ops.getValue();//第二重检查
      if(cnt==null)&#123; 
        cnt = dao.findStudentsCount();
        opt.set(cnt,10,TimeUnits.Seconds);
      &#125;
    &#125;
  &#125;

  return (Integer) cnt;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### [是否存在线程安全问题呢？]()</span><br><span class="line"></span><br><span class="line">  - 首先，synchronized(this)中的锁必须是单例的, @Component已经保证该锁的对象在Spring容器中是单例了，所以此处没有线程安全</span><br><span class="line">  </span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    private Integer cnt &#x3D; new Integer(1);</span><br><span class="line">    public Integer getStudentsCount()&#123;</span><br><span class="line">      if(cnt &#x3D;&#x3D; null)&#123; </span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">          if(cnt&#x3D;&#x3D;null)&#123; </span><br><span class="line">            &#x2F;&#x2F;以下这个new语句的底层步骤</span><br><span class="line">            &#x2F;&#x2F;1: 申请一个堆空间space</span><br><span class="line">            &#x2F;&#x2F;2: 使用对象初始数据初始化对空间space</span><br><span class="line">            &#x2F;&#x2F;3: cnt应用指向堆空间space</span><br><span class="line">           	cnt &#x3D; new Integer(2);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      return (Integer) cnt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

  - 第一个请求来到，如果2,3的步骤被编译器优化导致3先执行；然后第二个请求来到，if(cnt==null)为真, 那么则返回一个没有经过2步骤的cnt对象
  - 解决方法：[cnt设置为volatile保证编译器不优化(推荐) 或者是 设置该方法为同步(略)]()
</code></pre>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
