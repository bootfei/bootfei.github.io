<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="learn more, forget more; practice more, get more.">
<meta property="og:type" content="website">
<meta property="og:title" content="BootFei&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="learn more, forget more; practice more, get more.">
<meta property="og:locale">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en,cn'
  };
</script>

  <title>BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">209</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%A1%86%E6%9E%B6-04-bean%E5%8C%85-Bean/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%A1%86%E6%9E%B6-04-bean%E5%8C%85-Bean/" class="post-title-link" itemprop="url">spring框架-04-bean包-Bean</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-17 19:52:16" itemprop="dateCreated datePublished" datetime="2022-10-17T19:52:16+08:00">2022-10-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-12-10 18:54:08" itemprop="dateModified" datetime="2022-12-10T18:54:08+08:00">2022-12-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="spring框架-04-bean包-Bean"><a href="#spring框架-04-bean包-Bean" class="headerlink" title="spring框架-04-bean包-Bean"></a>spring框架-04-bean包-Bean</h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lvJAyXpj95WKrwovJQwiay1XP0WEEEPn0uuicicWbPcVo9picKjaErjr3psdE0jMY9Fqs8xoUA28rVmA/640" alt="图片"></p>
<h3 id="BeanDefinition（元信息的内存形式）"><a href="#BeanDefinition（元信息的内存形式）" class="headerlink" title="BeanDefinition（元信息的内存形式）"></a>BeanDefinition（元信息的内存形式）</h3><p>我们只是需要知道配置元信息被加载到内存之后是以BeanDefinition的形存在的即可。</p>
<h3 id="BeanDefinitionReader（元信息的读取）"><a href="#BeanDefinitionReader（元信息的读取）" class="headerlink" title="BeanDefinitionReader（元信息的读取）"></a>BeanDefinitionReader（元信息的读取）</h3><img src="https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhqR6Jg1H8Gw5ryNDWeh5b2FtAJ3fVegLzicgADJvM2ibYFJKkuoS0ehty9TI437OtBRCE5u0Mo4VOfw/640" alt="图片" style="zoom:66%;" />

<p>Spring中xml配置文件中一个个的Bean定义，但是Spring是要靠BeanDefinationReader了。</p>
<ul>
<li><p>读取xml配置元信息，那么可以使用XmlBeanDefinationReader。</p>
</li>
<li><p>读取properties配置文件，那么可以使用PropertiesBeanDefinitionReader加载。</p>
</li>
<li><p>读取注解配置元信息，那么可以使用 AnnotatedBeanDefinitionReader加载。</p>
</li>
<li><p>读取自定义的配置信息，那么可以自定义BeanDefinationReader来控制配置元信息的加载</p>
</li>
</ul>
<p>总的来说，BeanDefinationReader的作用就是加载配置元信息，并将其转化为内存形式的BeanDefination，存在某一个地方</p>
<h3 id="BeanDefinationRegistry（元信息内存形式的内存位置）"><a href="#BeanDefinationRegistry（元信息内存形式的内存位置）" class="headerlink" title="BeanDefinationRegistry（元信息内存形式的内存位置）"></a>BeanDefinationRegistry（元信息内存形式的内存位置）</h3><p>Spring通过BeanDefinationReader将配置元信息加载到内存生成相应的BeanDefination之后，就将其注册到BeanDefinationRegistry中，BeanDefinationRegistry就是一个存放BeanDefination的Map，通过特定的Bean定义的id，映射到相应的BeanDefination。</p>
<h3 id="BeanFactoryPostProcessor-解析BeanDef中的占位符"><a href="#BeanFactoryPostProcessor-解析BeanDef中的占位符" class="headerlink" title="BeanFactoryPostProcessor(解析BeanDef中的占位符)"></a>BeanFactoryPostProcessor(解析BeanDef中的占位符)</h3><p>BeanFactoryPostProcessor是容器启动阶段Spring提供的一个扩展点，主要负责对注册到BeanDefinationRegistry中的一个个的BeanDefination进行一定程度上的修改与替换。</p>
<p>例如我们的配置元信息中有些可能会修改的配置信息散落到各处，不够灵活，修改相应配置的时候比较麻烦，这时我们可以使用占位符的方式来配置。例如配置Jdbc的DataSource连接的时候可以这样配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot;  </span><br><span class="line">    class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot;  </span><br><span class="line">    destroy-method&#x3D;&quot;close&quot;&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;maxIdle&quot; value&#x3D;&quot;$&#123;jdbc.maxIdle&#125;&quot;&gt;&lt;&#x2F;property&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;maxActive&quot; value&#x3D;&quot;$&#123;jdbc.maxActive&#125;&quot;&gt;&lt;&#x2F;property&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;maxWait&quot; value&#x3D;&quot;$&#123;jdbc.maxWait&#125;&quot;&gt;&lt;&#x2F;property&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;minIdle&quot; value&#x3D;&quot;$&#123;jdbc.minIdle&#125;&quot;&gt;&lt;&#x2F;property&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;property name&#x3D;&quot;driverClassName&quot;  </span><br><span class="line">        value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot;&gt;  </span><br><span class="line">    &lt;&#x2F;property&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;&#x2F;property&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;&#x2F;property&gt;  </span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;&#x2F;property&gt;  </span><br><span class="line">&lt;&#x2F;bean&gt; </span><br></pre></td></tr></table></figure>

<p>BeanFactoryPostProcessor就会对注册到BeanDefinationRegistry中的BeanDefination做最后的修改，替换<code>$</code>占位符为配置文件中的真实的数据。</p>
<p>至此，整个容器启动阶段就算完成了，容器的启动阶段的最终产物就是注册到BeanDefinationRegistry中的一个个BeanDefination了，这就是Spring为Bean实例化所做的预热的工作。<img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBzOtg5OQ6icxfKTvViaePJOczt8icmDz64YEmm1NjOzOkpl7C4dU8Arrc4xFFniayWje5TkK8AydcAtg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:67%;" /></p>
<h1 id="Bean实例化阶段源码解析"><a href="#Bean实例化阶段源码解析" class="headerlink" title="Bean实例化阶段源码解析"></a>Bean实例化阶段源码解析</h1><p>Bean的创建过程</p>
<ol>
<li>验证，Merge BeanDefinition(<code>@Lookup</code>等)，判断是否是抽象类、单例、懒加载、FactoryBean等等</li>
<li>推断构造方法</li>
<li>new对象(反射),放到Spring容器中</li>
<li>缓存注解信息，并合并BeanDefination对象</li>
<li>提前暴露自己(bean的半成品)</li>
<li>判定是否需要属性注入</li>
<li>完成属性注入</li>
<li>调用生命周期回调方法<code>Aware</code>等</li>
<li>完成代理AOP</li>
<li>put容器</li>
<li>销毁对象</li>
</ol>
<h2 id="context包高级容器入口：AbstractApplicationContext-refresh"><a href="#context包高级容器入口：AbstractApplicationContext-refresh" class="headerlink" title="context包高级容器入口：AbstractApplicationContext.refresh()"></a>context包高级容器入口：AbstractApplicationContext.refresh()</h2><p>-&gt;finishBeanFactoryInitialization(beanFactory)</p>
<h2 id="bean包基础容器入口："><a href="#bean包基础容器入口：" class="headerlink" title="bean包基础容器入口："></a>bean包基础容器入口：</h2><p>BeanDefinition的解析入口：</p>
<h5 id="AbstractBeanFactory-preInstantiateSingletons"><a href="#AbstractBeanFactory-preInstantiateSingletons" class="headerlink" title="AbstractBeanFactory.preInstantiateSingletons()"></a>AbstractBeanFactory.preInstantiateSingletons()</h5><p>-&gt; // Instantiate all remaining (non-lazy-init) singletons.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure>

<h5 id="AbstractBeanFactory-getBean-beanName"><a href="#AbstractBeanFactory-getBean-beanName" class="headerlink" title="AbstractBeanFactory#getBean(beanName)"></a>AbstractBeanFactory#getBean(beanName)</h5><p>-&gt; // Trigger initialization of all non-lazy singleton beans…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.doGetBean(name, (Class)<span class="keyword">null</span>, (Object[])<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AbstractBeanFactory-doGetBean-beanName-》从BeanDefinition获取Bean的元数据"><a href="#AbstractBeanFactory-doGetBean-beanName-》从BeanDefinition获取Bean的元数据" class="headerlink" title="AbstractBeanFactory#doGetBean(beanName)=》从BeanDefinition获取Bean的元数据"></a>AbstractBeanFactory#doGetBean(beanName)=》从BeanDefinition获取Bean的元数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//TODO 验证Bean的名字是否非法</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line">	<span class="comment">// 从单例缓存中检查是否存在单例bean，第一次必定返回null</span></span><br><span class="line">	Object sharedInstance = getSingleton(beanName);</span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前bean正在被创建则抛出异常，prototype bean</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//TODO 解析合并后的BeanDefinition对象 待研究</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">            <span class="comment">// 确保当前Bean所依赖的Bean的初始化, @DependsOn</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="comment">// 省略</span></span><br><span class="line">                    <span class="comment">// 实例化该例DependsOn的类</span></span><br><span class="line">                    getBean(dep);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断类是否是单例，prototype bean Spring是不会实例化的</span></span><br><span class="line">			<span class="comment">// SpringBoot和Spring MVC中@Controller、@Service、@Component、@Repository默认都是单例</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 创建bean的过程,对象的创建以及代理</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Bean创建失败，清除Bean创建标识</span></span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AbstractBeanFactory-doCreateBean-beanName"><a href="#AbstractBeanFactory-doCreateBean-beanName" class="headerlink" title="AbstractBeanFactory#doCreateBean(beanName)"></a>AbstractBeanFactory#doCreateBean(beanName)</h2><h5 id="AbstractBeanFactory-createBeanInstance：实例化"><a href="#AbstractBeanFactory-createBeanInstance：实例化" class="headerlink" title="AbstractBeanFactory#createBeanInstance：实例化"></a>AbstractBeanFactory#createBeanInstance：实例化</h5><p>其实也就是 调用对象的构造方法实例化对象  —-&gt; new ServiceA()</p>
<h5 id="AbstractBeanFactory-populateBean：填充属性"><a href="#AbstractBeanFactory-populateBean：填充属性" class="headerlink" title="AbstractBeanFactory#populateBean：填充属性"></a>AbstractBeanFactory#populateBean：填充属性</h5><p>这一步主要是多bean的依赖属性进行填充</p>
<h5 id="AbstractBeanFactory-initializeBean：调用初始化方法"><a href="#AbstractBeanFactory-initializeBean：调用初始化方法" class="headerlink" title="AbstractBeanFactory#initializeBean：调用初始化方法"></a>AbstractBeanFactory#initializeBean：调用初始化方法</h5><p>调用spring xml中的init() 方法。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-HashMap/" class="post-title-link" itemprop="url">JDK-util-HashMap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-19 09:07:43" itemprop="dateCreated datePublished" datetime="2022-04-19T09:07:43+08:00">2022-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-03-09 16:55:17" itemprop="dateModified" datetime="2023-03-09T16:55:17+08:00">2023-03-09</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdibMJVazadOLIHm8dB5Us2Nq4WlibbqZL4NMBNIMsRP3NibcOYT3uU7wNrw/640" alt="Image"></p>
<p>这张图囊括了HashMap中最基础的几个点：</p>
<ol>
<li><code>Java</code>中<code>HashMap</code>的实现的基础数据结构是数组，每一对<code>key</code>-&gt;<code>value</code>的键值对组成<code>Entity</code>类以双向链表的形式存放到这个数组中</li>
<li>元素在数组中的位置由<code>key.hashCode()</code>的值决定，如果两个<code>key</code>的哈希值相等，即发生了哈希碰撞，则这两个<code>key</code>对应的<code>Entity</code>将以链表的形式存放在数组中</li>
<li>调用<code>HashMap.get()</code>的时候会首先计算<code>key</code>的值，继而在数组中找到<code>key</code>对应的位置，然后遍历该位置上的链表找相应的值。</li>
</ol>
<p>当然这张图中没有体现出来的有两点：</p>
<ol>
<li>为了提升整个<code>HashMap</code>的读取效率，当<code>HashMap</code>中存储的元素大小等于桶数组大小乘以负载因子的时候整个<code>HashMap</code>就要扩容，以减小哈希碰撞，具体细节我们在后文中讲代码会说到</li>
<li>在<code>Java 8</code>中如果<strong>桶数组</strong>的同一个位置上的链表数量超过一个定值，则整个链表有一定概率会转为一棵红黑树。</li>
</ol>
<p>整体来看，整个<code>HashMap</code>中最重要的点有四个：<strong>初始化</strong>，<strong>数据寻址-<code>hash</code>方法</strong>，<strong>数据存储-<code>put</code>方法</strong>,<strong>扩容-<code>resize</code>方法</strong>，只要理解了这四个点的原理和调用时机，也就理解了整个<code>HashMap</code>的设计。</p>
<p>如果对其中的某几个问题还有疑惑</p>
<ol>
<li><code>HashMap</code>内部的<code>bucket</code>数组长度为什么一直都是2的整数次幂</li>
<li><code>HashMap</code>默认的<code>bucket</code>数组是多大</li>
<li><code>HashMap</code>什么时候开辟<code>bucket</code>数组占用内存</li>
<li><code>HashMap</code>何时扩容？</li>
<li>桶中的元素链表何时转换为红黑树，什么时候转回链表，为什么要这么设计？</li>
<li><code>Java 8</code>中为什么要引进红黑树，是为了解决什么场景的问题？</li>
<li><code>HashMap</code>如何处理<code>key</code>为<code>null</code>的键值对？</li>
</ol>
<h2 id="new-HashMap"><a href="#new-HashMap" class="headerlink" title="new HashMap()"></a><code>new HashMap()</code></h2><p>在<code>JDK 8</code>中，在调用<code>new HashMap()</code>的时候并没有分配数组堆内存，只是做了一些参数校验，初始化了一些常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tableSizeFor</code>的作用是找到大于<code>cap</code>的最小的2的整数幂，我们假设n(注意是n，不是cap哈)对应的二进制为000001xxxxxx，其中x代表的二进制位是0是1我们不关心 <!--我个人看法，使用位运算时，一定要注意最高位，最高位是符号位，不能移动，所以32bit的int，只能用到倒数第2的高位bit，所以HashMap的最大容量是2^30 --></p>
<p><code>n |= n &gt;&gt;&gt; 1;</code>执行后<code>n</code>的值为：</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdibnWhteLvazicGAkd7go3CeiabRjYN0ib1Wb5h1B8TuPOHBT1cr1K0GCaSA/640" style="zoom:33%;" />

<p>可以看到此时<code>n</code>的二进制最高两位已经变成了1（1和0或1异或都是1），再接着执行第二行代码：</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdibibEwy9YFEA0Gy21LJYNColicAxpW11teDQpRZvE0HqcTC1QYJ6Z7fWBQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:33%;" />

<p>可见<code>n</code>的二进制最高四位已经变成了1，等到执行完代码<code>n |= n &gt;&gt;&gt; 16;</code>之后，<code>n</code>的二进制最低位全都变成了1，<!--就是为了创建最低位都是1的整数--> 也就是<code>n = 2^x - 1</code>其中x和n的值有关，如果没有超过<code>MAXIMUM_CAPACITY</code>，最后会返回一个2的正整数次幂，因此<code>tableSizeFor()</code>的作用就是保证返回一个比入参大的最小的2的正整数次幂。<!--说白了，就是把bit是1的最高位以后的低位，全部置为1，这就是“最小的2的正整数次幂”--></p>
<p>在<code>JDK 7</code>中初始化的代码大体一致，在<code>HashMap</code>第一次<code>put</code>的时候会调用<code>inflateTable</code>计算桶数组的长度，但其算法并没有变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一次put时，初始化table</span><br><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">    &#x2F;&#x2F; Find an power of 2 &gt;&#x3D; toSize</span><br><span class="line">    int capacity &#x3D; roundUpToPowerOf2(toSize);</span><br><span class="line">    threshold &#x3D; (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    table &#x3D; new Entry(capacity);</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们也回答了开头提出来的问题：</p>
<p><code>HashMap</code>什么时候开辟<code>bucket</code>数组占用内存？答案是在<code>HashMap</code>第一次<code>put</code>的时候，无论<code>Java 8</code>还是<code>Java 7</code>都是这样实现的 <!--计算机领域，只有对象真正被使用的时候，才被初始化。类似“延迟加载”-->。这里我们可以看到两个版本的实现中，桶数组的大小都是2的正整数幂，至于为什么这么设计，看完后文你就明白了。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a><code>hash</code></h2><p>在<code>HashMap</code>这个特殊的数据结构中，<code>hash</code>函数承担着寻址定址的作用，其性能对整个<code>HashMap</code>的性能影响巨大，那什么才是一个好的<code>hash</code>函数呢？</p>
<ul>
<li>计算出来的哈希值足够散列，能够有效减少哈希碰撞</li>
<li>本身能够快速计算得出，因为<code>HashMap</code>每次调用<code>get</code>和<code>put</code>的时候都会调用<code>hash</code>方法</li>
</ul>
<p>下面是<code>Java 8</code>中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里比较重要的是<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，这个位运算其实是将<code>key.hashCode()</code>计算出来的<code>hash</code>值的高16位与低16位继续异或，为什么要这么做呢？</p>
<p>我们知道<code>hash</code>函数的作用是用来确定<code>key</code>在桶数组中的位置的，在<code>JDK</code>中为了更好的性能，通常会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D;(table.length - 1) &amp; key.hash();</span><br></pre></td></tr></table></figure>

<p>回忆前文中的内容，<code>table.length</code>是一个2的正整数次幂，类似于<code>000100000</code>，这样的值减一就成了<code>000011111</code>，通过位运算可以高效寻址，这也回答了前文中提到的一个问题，<code>HashMap</code>内部的<code>bucket</code>数组长度为什么一直都是2的整数次幂？好处之一就是可以通过构造位运算快速寻址定址。</p>
<p>回到本小节的议题，既然计算出来的哈希值都要与<code>table.length - 1</code>做与运算，那就意味着计算出来的<code>hash</code>值只有低位有效，这样会加大碰撞几率，因此让高16位与低16位做异或，让低位保留部分高位信息，减少哈希碰撞。</p>
<p>我们再看<code>Java 7</code>中对hash的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by </span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded </span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor). </span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Java 7</code>中为了避免<code>hash</code>值的高位信息丢失，做了更加复杂的异或运算，但是基本出发点都是一样的，都是让哈希值的低位保留部分高位信息，减少哈希碰撞。</p>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a><code>put</code></h2><h3 id="Jdk8"><a href="#Jdk8" class="headerlink" title="Jdk8:"></a>Jdk8:</h3><p>在<code>Java 8</code>中<code>put</code>这个方法的思路分为以下几步：</p>
<ol>
<li>调用<code>key</code>的<code>hashCode</code>方法计算哈希值，并据此计算出数组下标index</li>
<li>如果发现当前的桶数组为<code>null</code>，则调用<code>resize()</code>方法进行初始化</li>
<li>如果没有发生哈希碰撞，则直接放到对应的桶中</li>
<li>如果发生哈希碰撞，且节点已经存在，就替换掉相应的<code>value</code></li>
<li>如果发生哈希碰撞，且桶中存放的是树状结构，则挂载到树上</li>
<li>如果碰撞后为链表，添加到链表尾，如果链表长度超过<code>TREEIFY_THRESHOLD</code>默认是8，则将链表转换为树结构</li>
<li>数据<code>put</code>完成后，如果<code>HashMap</code>的总数超过<code>threshold</code>就要<code>resize</code></li>
</ol>
<p>具体代码以及注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用上文我们已经分析过的hash方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 第一次put时，会调用resize进行桶数组初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据数组长度和哈希值相与来寻址，原理上文也分析过</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果没有哈希碰撞，直接放到桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//【关键点1】 哈希碰撞，且节点已存在，直接替换</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 【关键点2】哈希碰撞，树结构</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 【关键点3】哈希碰撞，链表结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表过长，转换为树结构</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 【关键点4】：如果节点已存在，则跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 否则，指向下一个节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 对应着上文中【关键点4】：节点已存在，跳出循环的分支</span></span><br><span class="line">            <span class="comment">// 直接替换</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 如果超过阈值，还需要扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jdk7"><a href="#jdk7" class="headerlink" title="jdk7:"></a>jdk7:</h3><p><code>Java 7</code>中的<code>put</code>方法就简单不少</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，调用 putForNullKey 方法进行处理  </span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key</span><br><span class="line">                || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; e = table[bucketIndex];     <span class="comment">// ①  </span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K, V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);    <span class="comment">// ②  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个小细节，<code>HashMap</code>允许<code>put</code>key为<code>null</code>的键值对，但是这样的键值对都放到了桶数组的第0个桶中。</p>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a><code>resize()</code></h2><h3 id="jdk8"><a href="#jdk8" class="headerlink" title="jdk8:"></a>jdk8:</h3><p><code>resize</code>是整个<code>HashMap</code>中最复杂的一个模块，如果在<code>put</code>数据之后超过了<code>threshold</code>的值，则需要扩容，扩容意味着桶数组大小变化，我们在前文中分析过，<code>HashMap</code>寻址是通过<code>index =(table.length - 1) &amp; key.hash();</code>来计算的，现在<code>table.length</code>发生了变化，势必会导致部分<code>key</code>的位置也发生了变化，<code>HashMap</code>是如何设计的呢？</p>
<p>这里就涉及到桶数组长度为2的正整数幂的第二个优势了：当桶数组长度为2的正整数幂时，如果桶发生扩容（长度翻倍），则桶中的元素大概只有一半需要切换到新的桶中，另一半留在原先的桶中就可以，并且这个概率可以看做是均等的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdAib0uwiarfrxiaEt9lmHOAhYdiblzYia6ic0unz6yDBBUz9zaYTfnYCdtazFW4ibtEf8bs5F6K2zdNPK7n9w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>通过这个分析可以看到如果在即将扩容的那个位上<code>key.hash()</code>的二进制值为0，则扩容后在桶中的地址不变，否则，扩容后的最高位变为了1，新的地址也可以快速计算出来<code>newIndex = oldCap + oldIndex;</code> <!--对以前的地址完美兼容，这就是size是2的次幂的优势--></p>
<p>下面是<code>Java 8</code>中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果oldCap &gt; 0则对应的是扩容而不是初始化</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有超过最大值，就扩大为原先的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 如果oldCap为0， 但是oldThr不为0，则代表的是table还未进行过初始化</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果到这里newThr还未计算，比如初始化时，则根据容量计算出新的阈值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">// 遍历之前的桶数组，对其值重新散列</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 如果原先的桶中只有一个元素，则直接放置到新的桶中</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 如果原先的桶中是链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// hiHead和hiTail代表元素在新的桶中和旧的桶中的位置不一致</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// loHead和loTail代表元素在新的桶中和旧的桶中的位置一致</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 新的桶中的位置 = 旧的桶中的位置 + oldCap， 详细分析见前文</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jdk7-1"><a href="#jdk7-1" class="headerlink" title="jdk7:"></a>jdk7:</h3><p><code>Java 7</code>中的<code>resize</code>方法相对简单许多：</p>
<ol>
<li>基本的校验之后<code>new</code>一个新的桶数组，大小为指定入参</li>
<li>桶内的元素根据新的桶数组长度确定新的位置，放置到新的桶数组中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable &#x3D; table;</span><br><span class="line">    int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable &#x3D; new Entry[newCapacity];</span><br><span class="line">    boolean oldAltHashing &#x3D; useAltHashing;</span><br><span class="line">    useAltHashing |&#x3D; sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (newCapacity &gt;&#x3D; Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    boolean rehash &#x3D; oldAltHashing ^ useAltHashing;</span><br><span class="line">    transfer(newTable, rehash);</span><br><span class="line">    table &#x3D; newTable;</span><br><span class="line">    threshold &#x3D; (int) Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity &#x3D; newTable.length;</span><br><span class="line">    for (Entry&lt;K, V&gt; e : table) &#123;</span><br><span class="line">        &#x2F;&#x2F;链表跟table[i]断裂遍历，头部往后遍历插入到newTable中</span><br><span class="line">        while (null !&#x3D; e) &#123;</span><br><span class="line">            Entry&lt;K, V&gt; next &#x3D; e.next;</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next &#x3D; newTable[i];</span><br><span class="line">            newTable[i] &#x3D; e;</span><br><span class="line">            e &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在看完了<code>HashMap</code>在<code>Java 8</code>和<code>Java 7</code>的实现之后我们回答一下前文中提出来的那几个问题：</p>
<ol>
<li><p><code>HashMap</code>内部的<code>bucket</code>数组长度为什么一直都是2的整数次幂</p>
<p>答：这样做有两个好处，第一，可以通过<code>(table.length - 1) &amp; key.hash()</code>这样的位运算快速寻址，第二，在<code>HashMap</code>扩容的时候可以保证同一个桶中的元素均匀的散列到新的桶中，具体一点就是同一个桶中的元素在扩容后一般留在原先的桶中，一般放到了新的桶中。</p>
</li>
<li><p><code>HashMap</code>默认的<code>bucket</code>数组是多大</p>
<p>答：默认是16，即时指定的大小不是2的整数次幂，<code>HashMap</code>也会找到一个最近的2的整数次幂来初始化桶数组。<!--长度不超过2^30--></p>
</li>
<li><p><code>HashMap</code>什么时候开辟<code>bucket</code>数组占用内存</p>
<p>答：在第一次<code>put</code>的时候调用<code>resize</code>方法</p>
</li>
<li><p><code>HashMap</code>何时扩容？</p>
<p>答：当<code>HashMap</code>中的元素熟练超过阈值时，阈值计算方式是<code>capacity * loadFactor</code>，在<code>HashMap</code>中<code>loadFactor</code>是0.75</p>
</li>
<li><p>桶中的元素链表何时转换为红黑树，什么时候转回链表，为什么要这么设计？</p>
<p>答：当同一个桶中的元素数量大于等于8的时候元素中的链表转换为红黑树，反之，当桶中的元素数量小于等于6的时候又会转为链表，这样做的原因是避免红黑树和链表之间频繁转换，引起性能损耗</p>
</li>
<li><p><code>Java 8</code>中为什么要引进红黑树，是为了解决什么场景的问题？</p>
<p>答：引入红黑树是为了避免<code>hash</code>性能急剧下降，引起<code>HashMap</code>的读写性能急剧下降的场景，正常情况下，一般是不会用到红黑树的，在一些极端场景下，假如客户端实现了一个性能拙劣的<code>hashCode</code>方法，可以保证<code>HashMap</code>的读写复杂度不会低于O(lgN)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>HashMap</code>如何处理<code>key</code>为<code>null</code>的键值对？</p>
<p>答：放置在桶数组中下标为0的桶中</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/08/database/mysql/mysql-%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/database/mysql/mysql-%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">mysql - 常见事务问题解决方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-08 15:59:03" itemprop="dateCreated datePublished" datetime="2022-03-08T15:59:03+08:00">2022-03-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-05-26 17:19:41" itemprop="dateModified" datetime="2022-05-26T17:19:41+08:00">2022-05-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-数据库如何保证先查询，后插入-更新-原子性？"><a href="#1-数据库如何保证先查询，后插入-更新-原子性？" class="headerlink" title="1 数据库如何保证先查询，后插入/更新 原子性？"></a>1 数据库如何保证先查询，后插入/更新 原子性？</h2><p>ref: <a target="_blank" rel="noopener" href="https://blog.51cto.com/u_7592962/2543362">https://blog.51cto.com/u_7592962/2543362</a></p>
<p>当操作积分用户表时，如果accountId在表中没有数据，那新增一条数据用户积分。如果accountId在表中有数据，更新用户积分。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/08/database/mysql/mysql-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/database/mysql/mysql-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">mysql - 面试问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-08 15:59:03" itemprop="dateCreated datePublished" datetime="2022-03-08T15:59:03+08:00">2022-03-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-05-26 18:10:24" itemprop="dateModified" datetime="2022-05-26T18:10:24+08:00">2022-05-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p>MySQL 脏页刷新到磁盘机制？</p>
<ul>
<li><p>脏页定义：数据存储的最小单元就是数据页，当内存的数据页与磁盘的数据页不一致时，该数据页就是脏页。</p>
</li>
<li><p>脏页生成的时机：由于Write Ahead Log策略，每次事务提交时，innodb先写磁盘，再写内存</p>
</li>
<li><p>脏页落盘（刷新）的时机：</p>
<ul>
<li>MySQL中，刷新的规则叫checkpoint机制，共2种</li>
<li>sharp checkpoint：在数据库关闭时，刷新所有的脏页到磁盘。</li>
<li>fuzzy checkpoint：刷新一部分脏页到磁盘中。<ul>
<li>定时刷新</li>
<li>Flush LRUlist checkpoint ：当LRU中列表中空闲页不足时，强制LRU删除一些末尾的页，如果存在脏页，那么需要checkpoint刷新</li>
<li>async/sync checkpoint ：指重做日志文件不可用时，需要强制将脏页列表中的一些页刷新回磁盘。这可以保证重做日志文件可循环使用</li>
<li>dirty too much checkpoint：关注系统中的整体脏页比例，如果达到一定比例，强制刷新</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>MySQL innodb 引擎的索引结构，B+树一般都多高？ 层高怎么计算？</p>
<ul>
<li><p>不超过3层，因为磁盘的IO查询超过3次会影响性能</p>
</li>
<li><p>影响层高的因素（假设一行数据大小为1kb，非叶子节点的指针是14byte）</p>
<ul>
<li><p>mysql的存储基本单位为数据页，大小=16kb</p>
</li>
<li><p>因为B+树的非叶子节点存储指针，叶子节点存储数据，所以层高与数据行数的关系：<br>*<em>数据量=（非叶子节点的存储指针数量）^ (层高-1) * 一个数据页存储的行数*</em></p>
<ul>
<li>1层的数据行数最大为: (16kb/1kb)^(1-1) = 16条数据</li>
<li>2层的数据行数最大为: (16kb/14byte)^(2-1) * (16kb/1kb) = 18k 条数据</li>
<li>3层的数据行数最大为: (16kb/14byte)^(3-1) * (16kb/1kb) = 20.89w条数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>sql join 驱动表如何选择？</p>
<ul>
<li><p>mysql中的join，底层实现都是用的nested loop</p>
</li>
<li><p>小表驱动大表</p>
<ul>
<li>当使用left join时，左表是驱动表，右表是被驱动表</li>
<li>当使用right join时，右表是驱动表，左表是被驱动表</li>
<li>当使用inner join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>mysql 查询语句执行流程？</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关</li>
<li><strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</li>
</ul>
</li>
</ol>
<ol start="5">
<li>造成慢sql 常见原因有哪些？<ul>
<li>查询条件没有索引，或者索引失效</li>
<li>操作等待锁资源，比如update，select for update</li>
<li>单表数据量过大</li>
</ul>
</li>
</ol>
<ol start="6">
<li>如何分析慢查询，慢查询的分析步骤？ explain 返回的列的含义？<ul>
<li>使用慢查询定位执行慢的SQL：<ul>
<li>慢日志存储路径：show variables like ‘%query%’;</li>
</ul>
</li>
<li>explain 返回的列的含义<ul>
<li>id:SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>
<li>select_type: SELECT 查询的类型.</li>
<li>table: 查询的是哪个表</li>
<li>partitions: 匹配的分区</li>
<li>type: join 类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引. ref: 哪个字段或常数与 key 一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">交换排序-冒泡排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-20 20:40:04 / Modified: 20:40:46" itemprop="dateCreated datePublished" datetime="2021-11-20T20:40:04+08:00">2021-11-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/Users/qifei/Documents/blog/source/_posts/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="冒泡排序动图"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">insert-sorting</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-20 16:14:02 / Modified: 21:01:08" itemprop="dateCreated datePublished" datetime="2021-11-20T16:14:02+08:00">2021-11-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-quick-sorting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-quick-sorting/" class="post-title-link" itemprop="url">quick sorting</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-20 16:13:39 / Modified: 20:38:38" itemprop="dateCreated datePublished" datetime="2021-11-20T16:13:39+08:00">2021-11-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell%E5%B7%A5%E5%85%B7-01-%E5%A4%A7%E7%A5%9E%E7%9A%84%E5%BC%80%E6%BA%90%E7%81%AB%E7%84%B0%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell%E5%B7%A5%E5%85%B7-01-%E5%A4%A7%E7%A5%9E%E7%9A%84%E5%BC%80%E6%BA%90%E7%81%AB%E7%84%B0%E5%9B%BE/" class="post-title-link" itemprop="url">shell工具-01-大神的开源火焰图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-08 18:39:39 / Modified: 18:40:36" itemprop="dateCreated datePublished" datetime="2021-09-08T18:39:39+08:00">2021-09-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p> <em>来源：<a target="_blank" rel="noopener" href="https://zhenbianshu.github.io/">https://zhenbianshu.github.io</a></em></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>火焰图</code>，之前组内大神分享过它的使用办法，但我之后很久都没有用过，以至于对它没有什么深刻印象，最近排查我们 Java 应用负载问题时试用了一下，这才对它的用途有了点心得。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>在排查性能问题时，我们通常会把线程栈 dump 出来，然后使用 <code>grep --no-group-separator -A 1 java.lang.Thread.State jstack.log | awk &#39;NR%2==0&#39; | sort | uniq -c | sort -nr</code> 类似的 shell 语句，查看大多数线程栈都在干什么。而由线程栈的出现频率，来推断 JVM 内耗时最多的调用。</p>
<p>至于其原理，设想广场上有一个大屏幕在不停地播放各种广告。如果我们随机对大屏幕拍照，次数多了，统计照片中各个广告出现的频率，基本可以得出每个广告的播放时长占比了。</p>
<p>而我们应用的资源就像大屏幕，每次调用就像是播放一次广告，统计 dump 出的线程栈出现比例，也就基本能看出线程栈的耗时占比，虽然有误差，但是多次统计下应该差不了多少。这也就是为什么有些家长每次进孩子房间都发现孩子在看系统桌面后以为孩子平时喜欢对着桌面发呆的原因。:)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2444  at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1200)</span><br><span class="line">1587  at sun.misc.Unsafe.park(Native Method)</span><br><span class="line"> 795  at java.security.Provider.getService(Provider.java:1035)</span><br><span class="line"> 293  at java.lang.Object.wait(Native Method)</span><br><span class="line"> 292  at java.lang.Thread.sleep(Native Method)</span><br><span class="line">  73  at org.apache.logging.log4j.core.layout.TextEncoderHelper.copyDataToDestination(TextEncoderHelper.java:61)</span><br><span class="line">  71  at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">  70  at java.lang.Class.forName0(Native Method)</span><br><span class="line">  54  at org.apache.logging.log4j.core.appender.rolling.RollingFileManager.checkRollover(RollingFileManager.java:217)</span><br></pre></td></tr></table></figure>

<p>但是这样有些问题，首先写 shell 挺费事的，另外如果我想查看自栈顶第二个栈的最多调用，即使修改了 shell 命令，结果也不直观。</p>
<p>产生这个问题的主要原因是，我们的线程栈是有调用关系的，即我们需要考虑线程栈的 <code>调用链</code> 和 <code>出现频率</code> 两个维度，而单一的文本表现这两种维度比较困难，所以，著名性能分析大师 brendan gregg 就提出了火焰图。</p>
<h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>火焰图，因其形似火焰而得名，其开源代码地址：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a></p>
</blockquote>
<p>它是一种 svg 可交互式图形，我们通过点击和鼠标指向可以展示出更多的信息。下图就是一个典型的火焰图，从结构上，它是由多个大小和颜色各异的方块构成，每个方块上都有字符，它们底部连接在一块，组成火焰的基底，顶部分出许多”小火苗”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvauyA1tcQgR1fHrxzrSgcAWjq0icLIXIcCIF7hibbGlaXGxFsjibxANw4evL9xNL6nan7iaaeFIJtABg3w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>当我们点击方块时，图片会从我们点击的方块为基底向上展开，而我们鼠标指向方块时，会展示出方块的详细说明。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>介绍火焰图的分析前，我们要首先说明它的特性：</p>
<ul>
<li>由底部到顶部可以追溯一个唯一的调用链，下面的方块是上面方块的父调用。</li>
<li>同一父调用的方块从左到右以字母序排列。</li>
<li>方块上的字符表示一个调用名称，括号内是火焰图指向的调用在火焰图中出现的次数和这个方块占最底层方块的宽度百分比。</li>
<li>方块的颜色没有实际意义，相邻方块的颜色差只为了便于查看。</li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>那么，给我们一张火焰图，我们怎么能看出系统哪里有问题呢？</p>
<p>由上文中的火焰图特性特性，查看火焰图时，我们最主要的关注点要放在方块的宽度上，因为宽度代表了调用栈在全局出现的次数，次数代表着出现频率，而频率也就可以说明耗时。</p>
<p>但是观察火焰图底部或中部方块的宽度占比意义不大，如上面的火焰图，中部的 <code>do_redirections</code> 函数宽度是 24.87%，也就是说它耗用了整个应用近四分之一的时间，但是真正消耗时间的并不是 do_redirections 函数，而是 do_redirections 内部又调用的其他函数，而它的子调用分为了很多个，每个调用的耗时并没有异常。</p>
<p>我们更应该关注的是火焰图顶部的一些 “平顶山”，顶部说明它没有子调用，方块宽说明它耗时长，长时间 hang 住，或者被非常频率地调用，这种方块指向的调用才是性能问题的罪魁祸首。</p>
<p>找到了异常调用，直接优化它，或者再根据火焰图的调用链层层向下，找到我们的业务代码进行优化，也就大功告成。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>每种工具都有其适合的应用场景，火焰图则适合用在：</p>
<ul>
<li>代码循环分析：如果代码中有很大的循环或死循环代码，那么从火焰图的顶部或接近项部的地方会有很明显的”平顶”，表示代码频繁地在某个线程栈上下切换。但需要注意的是，如果循环的总耗时不长，在火焰图上不会很明显。</li>
<li>IO 瓶颈/锁分析：在我们的应用代码中，我们的调用普遍都是同步的，也就是说在进行网络调用、文件 I/O 操作或未成功获得锁时，线程会停留在某个调用上等待 I/O 响应或锁，如果这个等待非常耗时，会导致线程在某个调用上一直 hang 住，这在火焰图上表现得会非常清晰。与此相对的是，我们应用线程构成的火焰图无法准确地表达 CPU 的消耗，因为应用线程内没有系统的调用栈，在应用线程栈 hang 住时，CPU 可能去做其他事了，导致我们看到耗时很长，而 CPU 却很闲。</li>
<li>火焰图倒置分析全局代码：火焰图倒置有时也会很实用，如果我们的代码 N 个不同的分支都调用某一方法，倒置后，所有栈顶相同的调用被合并在一块，我们就能看出这个方法的总耗时，也就很容易评估出优化这个方法的收益。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>既然火焰图这么强大，那么我们该怎么实现呢？</p>
<h4 id="生成工具"><a href="#生成工具" class="headerlink" title="生成工具"></a>生成工具</h4><p>brendan gregg 大神已经把生成火焰图的方法用 perl 实现了，开源代码就在上文的 Github 仓库中，根目录下的 <code>flamegraph.pl</code> 文件就是可执行的 perl 文件了。</p>
<p>这个命令还可以传入各种参数，支持我们修改火焰图的颜色、大小等 。</p>
<p>但 flamegraph.pl 只能处理特定格式的文件，像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a;b;c 12</span><br><span class="line">a;d 3</span><br><span class="line">b;c 3</span><br><span class="line">z;d 5</span><br><span class="line">a;c;e 3</span><br></pre></td></tr></table></figure>

<p>前面是调用链，每个调用之间用 <code>;</code> 隔开，每行后面的数字是调用栈出现的次数。</p>
<p>如上面的数据，用 flamegraph.pl 生成的火焰图如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8Jeic82Or04l8qwqLuAsZNZVtNKRsloJlTsDdd4ialwYzZTGiaAFAhl35iawbMibbwRdCClX2n6zW62gvXgA5uRKYlA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>至于我们的 jstack 信息如何被处理成上面的格式，大神则为常见的 dump 格式都提供了工具，像 <code>stackcollapse-perf.pl</code>可以处理 <code>perf</code> 命令的输出，<code>stackcollapse-jstack.pl</code> 处理 <code>jstack</code> 输出，<code>stackcollapse-gdb.pl</code> 处理 gdb 输出的栈等。</p>
<p>也可以用 shell 简单地实现一下 jstack 的处理方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v -P &#39;.+prio&#x3D;d+ os_prio&#x3D;d+&#39; | grep -v -E &#39;locked &lt;&#39; | awk &#39;&#123;if ($0&#x3D;&#x3D;&quot;&quot;)&#123;print $0&#125;else&#123;printf&quot;%s;&quot;,$0&#125;&#125;&#39; | sort | uniq -c | awk &#39;&#123;a&#x3D;$1;$1&#x3D;&quot;&quot;;print $0,a&#125;&#39;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell-01-%E7%BB%9F%E8%AE%A1stack%E4%BF%A1%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell-01-%E7%BB%9F%E8%AE%A1stack%E4%BF%A1%E6%81%AF/" class="post-title-link" itemprop="url">shell-01-统计stack信息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-08 18:39:15" itemprop="dateCreated datePublished" datetime="2021-09-08T18:39:15+08:00">2021-09-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-24 08:50:05" itemprop="dateModified" datetime="2021-11-24T08:50:05+08:00">2021-11-24</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell-03-grep%E5%88%86%E6%9E%90%E7%BB%9F%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/shell-03-grep%E5%88%86%E6%9E%90%E7%BB%9F%E8%AE%A1/" class="post-title-link" itemprop="url">shell-01-统计stack信息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-08 18:39:15" itemprop="dateCreated datePublished" datetime="2021-09-08T18:39:15+08:00">2021-09-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-08 17:37:37" itemprop="dateModified" datetime="2021-11-08T17:37:37+08:00">2021-11-08</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
