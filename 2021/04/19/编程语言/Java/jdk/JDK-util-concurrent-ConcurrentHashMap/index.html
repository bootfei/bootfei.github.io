<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JDK-JUC-ConcurrentHashMap | BootFei&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Jdk 7 ConcurrentHashMap如何在高并发下提高系统吞吐是所有后端开发者追求的目标，Java并发的开创者Doug Lea在Java 7 ConcurrentHashMap的设计中给出了一些参考答案，自旋锁、CAS的使用、延迟写内存、volatile语义退化等不常见的技巧   对于Java 7来说  ConcurrentHashMap是一个线程安全的Map实现，其读取不需要加锁，通过">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK-JUC-ConcurrentHashMap">
<meta property="og:url" content="http://example.com/2021/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-concurrent-ConcurrentHashMap/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="Jdk 7 ConcurrentHashMap如何在高并发下提高系统吞吐是所有后端开发者追求的目标，Java并发的开创者Doug Lea在Java 7 ConcurrentHashMap的设计中给出了一些参考答案，自旋锁、CAS的使用、延迟写内存、volatile语义退化等不常见的技巧   对于Java 7来说  ConcurrentHashMap是一个线程安全的Map实现，其读取不需要加锁，通过">
<meta property="og:locale">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/R7PtjL3tdAicMdbQfrvwSkfich8cYHngc1rpQ50iaXsQib1VWGqQLr22AgdZcyW71A5P2FpBd9nia1ahOJAXAXSVOOA/640">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdA8G9gcTVIgP3JZWCv0UibUvicIeiaDmgzDGzAh50zu8uibcTzY7acGCJI84Y9J86iaJ0aPK0mD9ASTdR6Q/640">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="article:published_time" content="2021-04-19T01:07:43.000Z">
<meta property="article:modified_time" content="2023-02-10T04:06:43.950Z">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/R7PtjL3tdAicMdbQfrvwSkfich8cYHngc1rpQ50iaXsQib1VWGqQLr22AgdZcyW71A5P2FpBd9nia1ahOJAXAXSVOOA/640">
  
    <link rel="alternate" href="/atom.xml" title="BootFei&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BootFei&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-编程语言/Java/jdk/JDK-util-concurrent-ConcurrentHashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-concurrent-ConcurrentHashMap/" class="article-date">
  <time datetime="2021-04-19T01:07:43.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JDK-JUC-ConcurrentHashMap
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Jdk-7-ConcurrentHashMap"><a href="#Jdk-7-ConcurrentHashMap" class="headerlink" title="Jdk 7 ConcurrentHashMap"></a>Jdk 7 ConcurrentHashMap</h1><p>如何在高并发下提高系统吞吐是所有后端开发者追求的目标，Java并发的开创者Doug Lea在Java 7 ConcurrentHashMap的设计中给出了一些参考答案，<strong>自旋锁、CAS的使用、延迟写内存、volatile语义</strong>退化等不常见的技巧</p>
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/R7PtjL3tdAicMdbQfrvwSkfich8cYHngc1rpQ50iaXsQib1VWGqQLr22AgdZcyW71A5P2FpBd9nia1ahOJAXAXSVOOA/640" alt="Image" style="zoom:50%;" />

<p>对于<code>Java 7</code>来说</p>
<ol>
<li><code>ConcurrentHashMap</code>是一个线程安全的<code>Map</code>实现，其读取不需要加锁，通过引入<code>Segment</code>，可以做到写入的时候加锁力度足够小</li>
<li>由于引入了<code>Segment</code>，<code>ConcurrentHashMap</code>在读取和写入的时候需要需要做两次哈希，但这两次哈希换来的是更细力粒度的锁，也就意味着可以支持更高的并发</li>
<li>每个桶数组中的<code>key-value</code>对仍然以链表的形式存放在桶中，这一点和<code>HashMap</code>是一致的。</li>
</ol>
<p>细节问题：</p>
<ol>
<li><code>ConcurrentHashMap</code>的哪些操作需要加锁？</li>
<li><code>ConcurrentHashMap</code>的无锁读是如何实现的？</li>
<li>在多线程的场景下调用<code>size（）</code>方法获取<code>ConcurrentHashMap</code>的大小有什么挑战？<code>ConcurrentHashMap</code>是怎么解决的？</li>
<li>在有<code>Segment</code>存在的前提下，应该如何扩容的？</li>
</ol>
<p><code>HashMap</code>中最重要的点有四个：<strong>初始化</strong>，<strong>数据寻址-<code>hash</code>方法</strong>，<strong>数据存储-<code>put</code>方法</strong>,<strong>扩容-<code>resize</code>方法</strong>，对于<code>ConcurrentHashMap</code>来说，这四个操作依然是最重要的，但由于其引入了更复杂的数据结构，因此在调用<code>size()</code>查看整个<code>ConcurrentHashMap</code>的数量大小的时候也有不小的挑战</p>
<h2 id="new-ConcurrentHashMap"><a href="#new-ConcurrentHashMap" class="headerlink" title="new ConcurrentHashMap()"></a><code>new ConcurrentHashMap()</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 保证ssize是大于concurrencyLevel的最小的2的整数次幂</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻址需要两次哈希，哈希的高位用于确定segment，低位用户确定桶数组中的元素</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化方法中做了三件重要的事：</p>
<ol>
<li>确定了<code>segments</code>的数组的大小<code>ssize</code>，<code>ssize</code>根据入参<code>concurrencyLevel</code>确定，取大于<code>concurrencyLevel</code>的最小的2的整数次幂</li>
<li>确定哈希寻址时的偏移量，这个偏移量在确定元素在<code>segment</code>数组中的位置时会用到</li>
<li>初始化<code>segment</code>数组中的第一个元素，元素类型为<code>HashEntry</code>的数组，这个数组的长度为<code>initialCapacity / ssize</code>，即初始化大小除以<code>segment</code>数组的大小，<code>segment</code>数组中的其他元素在后续<code>put</code>操作时参考第一个已初始化的实例初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; </span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next; </span><br><span class="line"> </span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(HashEntry&lt;K,V&gt; n)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>HashEntry</code>和<code>HashMap</code>中的<code>HashEntry</code>作用是一样的，它是<code>ConcurrentHashMap</code>的数据项，这里要注意两个细节：</p>
<h3 id="细节一："><a href="#细节一：" class="headerlink" title="细节一："></a><strong>细节一：</strong></h3><p><code>HashEntry</code>的成员变量<code>value</code>和<code>next</code>是被关键字<code>volatile</code>修饰的，也就是说所有线程都可以及时检查到其他线程对这两个变量的改变，因而可以在不加锁的情况下读取到这两个引用的最新值</p>
<h3 id="细节二："><a href="#细节二：" class="headerlink" title="细节二："></a><strong>细节二：</strong></h3><p><code>HashEntry</code>的<code>setNext</code>方法中调用了<code>UNSAFE.putOrderedObject</code>，这个接口是属于<code>sun</code>安全库中的<code>api</code>，并不是<code>J2SE</code>的一部分，它的作用和<code>volatile</code>恰恰相反，调用这个<code>api</code>设值是使得<code>volatile</code>修饰的变量延迟写入主存，那到底是什么时候写入主存呢？</p>
<blockquote>
<p>JMM中有一条规定：</p>
<p>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p>
</blockquote>
<p>后文在讲<code>put</code>方法的时候我们再详细看<code>setNext</code>的用法</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>由于引入了<code>segment</code>，因此不管是调用<code>get</code>方法读还是调用<code>put</code>方法写，都需要做两次哈希，还记得在上文我们讲初始化的时候系统做了一件重要的事：</p>
<ul>
<li>确定哈希寻址时的偏移量，这个偏移量在确定元素在<code>segment</code>数组中的位置时会用到</li>
</ul>
<p>没错就是这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.segmentShift &#x3D; 32 - sshift;</span><br></pre></td></tr></table></figure>

<p>这里用32去减是因为<code>int</code>型的长度是32，有了<code>segmentShift</code>，<code>ConcurrentHashMap</code>是如何做第一次哈希的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 变量j代表着数据项处于segment数组中的第j项</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 如果segment[j]为null,则下面的这个方法负责初始化之</span></span><br><span class="line">    s = ensureSegment(j); </span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以<code>put</code>方法为例，变量<code>j</code>代表着数据项处于<code>segment</code>数组中的第<code>j</code>项。如下图所示假如<code>segment</code>数组的大小为2的n次方，则<code>hash &gt;&gt;&gt; segmentShift</code>正好取了key的哈希值的高n位，再与掩码<code>segmentMask</code>相与相当与仍然用key的哈希的高位来确定数据项在<code>segment</code>数组中的位置。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image"><code>hash</code>方法与非线程安全的<code>HashMap</code>相似，这里不再细说。</p>
<h3 id="细节三："><a href="#细节三：" class="headerlink" title="细节三："></a><strong>细节三：</strong></h3><p>在延迟初始化<code>Segment</code>数组时，作者采用了<code>CAS</code>避免了加锁，而且<code>CAS</code>可以保证最终的初始化只能被一个线程完成。在最终决定调用<code>CAS</code>进行初始化前又做了两次检查，第一次检查可以避免重复初始化<code>tab</code>数组，而第二次检查则可以避免重复初始化<code>Segment</code>对象，每一行代码作者都有详细的考虑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset 实际的字节偏移量</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123; <span class="comment">// recheck 再检查一次是否已经被初始化</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s)) <span class="comment">// 使用 CAS 确保只被初始化一次</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a><code>put</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//细节4</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value); </span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k; <span class="comment">// 如果找到key相同的数据项，则直接替换</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// node不为空说明已经在自旋等待时初始化了，注意调用的是setNext，不是直接操作next</span></span><br><span class="line">                    node.setNext(first); </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 否则，在这里新建一个HashEntry</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>; <span class="comment">// 先加1</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 将新节点写入，注意这里调用的方法有门道</span></span><br><span class="line">                    setEntryAt(tab, index, node); </span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在整个<code>ConcurrentHashMap</code>的设计中非常出彩</p>
<h3 id="细节四："><a href="#细节四：" class="headerlink" title="细节四："></a><strong>细节四：</strong></h3><p>CPU的调度是公平的，好不容易轮到的时间片如果因为获取不到锁就将本线程挂起无疑会降低本线程的效率，更何况挂起之后还要重新调度，切换上下文，又是一笔不小的开销。如果可以遇见其他线程占有锁的时间不会很长，采用自旋将会是一个比较好的选择，在这里面也有一个权衡，如果别的线程占有锁的时间过长，反而是挂起阻塞等待性能好一点，我们来看下<code>ConcurrentHashMap</code>的做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123; <span class="comment">// 自旋等待</span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123; <span class="comment">// 这个桶中还没有写入k-v项</span></span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node 直接创建一个新的节点</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// key值相等，直接跳出去尝试获取锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 遍历链表</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待超过一定次数之后只能挂起线程，阻塞等待了</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123; </span><br><span class="line">            <span class="comment">// 如果头节点改变了，则重置次数，继续自旋等待</span></span><br><span class="line">            e = first = f; </span><br><span class="line">            retries = -<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConcurrentHashMap</code>的策略是tryLock()自旋,  (最多<code>MAX_SCAN_RETRIES</code>次); 如果还没有获取到锁则调用<code>lock</code>挂起阻塞等待，当然如果其他线程采用头插法改变了链表的头结点，则重置自旋等待次数。</p>
<h3 id="细节五："><a href="#细节五：" class="headerlink" title="细节五："></a><strong>细节五：</strong></h3><p>要知道，如果要从编码的角度提升系统的并发度，一个黄金法则就是减少并发临界区的大小。在<code>scanAndLockForPut</code>这个方法的设计上，有个小细节让我眼前一亮，就是在自旋的过程中初始化了一个<code>HashEntry</code>，这样做的好处就是线程在拿到锁之后不用初始化<code>HashEntry</code>了，占有锁的时间相应减小，进而提升性能。</p>
<h3 id="细节六："><a href="#细节六：" class="headerlink" title="细节六："></a><strong>细节六：</strong></h3><p>在<code>put</code>方法的开头，有这么一行不起眼的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashEntry&lt;K,V&gt;[] tab = table;</span><br></pre></td></tr></table></figure>

<p>看起来好像就是简单的临时变量赋值，其实大有来头，我们看一下<code>table</code>的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p><code>table</code>变量被关键字<code>volatile</code>修饰，<code>CPU</code>在处理<code>volatile</code>修饰的变量的时候会有下面的行为：</p>
<blockquote>
<p><strong>嗅探</strong></p>
<p>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里</p>
</blockquote>
<p>因此直接读取这类变量的读取和写入比普通变量的性能消耗更大，因此在<code>put</code>方法的开头将<code>table</code>变量赋值给一个普通的本地变量目的是为了消除<code>volatile</code>带来的性能损耗。这里就有另外一个问题：那这样做会不会导致<code>table</code>的语义改变，让别的线程读取不到最新的值呢？</p>
<h3 id="细节七："><a href="#细节七：" class="headerlink" title="细节七："></a><strong>细节七：</strong></h3><p>注意<code>put</code>方法中的这个方法：<code>entryAt()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">HashEntry&lt;K,V&gt; <span class="title">entryAt</span><span class="params">(HashEntry&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tab == <span class="keyword">null</span>) ? <span class="keyword">null</span> : (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的底层会调用<code>UNSAFE.getObjectVolatile</code>，这个方法的目的就是对于普通变量读取也能像<code>volatile</code>修饰的变量那样读取到最新的值，在前文中我们分析过，由于变量<code>tab</code>现在是一个普通的临时变量，如果直接调用<code>tab[i]</code>不一定能拿到最新的首节点的。细心的读者读到这里可能会想：为啥不刚开始就操作<code>volatile</code>变量呢?</p>
<h3 id="细节八："><a href="#细节八：" class="headerlink" title="细节八："></a><strong>细节八：</strong></h3><p>在<code>put</code>方法的实现中，如果链表中没有<code>key</code>值相等的数据项，则会把新的数据项插入到链表头写入到数组中，其中调用的方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; void setEntryAt(HashEntry&lt;K,V&gt;[] tab, int i, HashEntry&lt;K,V&gt; e) &#123;</span><br><span class="line">    UNSAFE.putOrderedObject(tab, ((long)i &lt;&lt; TSHIFT) + TBASE, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>putOrderedObject</code>这个接口写入的数据不会马上被其他线程获取到，而是在<code>put</code>方法最后调用<code>unclock</code>后才会对其他线程可见，参见前文中对JMM的描述：</p>
<blockquote>
<p>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p>
</blockquote>
<p>这样的好处有两个，第一是性能，因为在持有锁的临界区不需要有同步主存的操作，因此持有锁的时间更短。第二是保证了数据的一致性，在<code>put</code>操作的<code>finally</code>语句执行完之前，<code>put</code>新增的数据是不对其他线程展示的，这是<code>ConcurrentHashMap</code>实现无锁读的关键原因。</p>
<p>我们在这里稍微总结一下<code>put</code>方法里面最重要的三个细节，首先将<code>volatile</code>变量转为普通变量提升性能，因为在<code>put</code>中需要读取到最新的数据，因此接下来调用<code>UNSAFE.getObjectVolatile</code>获取到最新的头结点，但是通过调用<code>UNSAFE.putOrderedObject</code>让变量写入主存的时间延迟到<code>put</code>方法的结尾，一来缩小临界区提升性能，而来也能保证其他线程读取到的是完整数据。</p>
<h3 id="细节九："><a href="#细节九：" class="headerlink" title="细节九："></a><strong>细节九：</strong></h3><p>如果<code>put</code>真的需要往链表头插入数据项，那也得注意了，<code>ConcurrentHashMap</code>相应的语句是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.setNext(first);</span><br></pre></td></tr></table></figure>

<p>我们看下<code>setNext</code>的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void setNext(HashEntry&lt;K,V&gt; n) &#123;</span><br><span class="line">    UNSAFE.putOrderedObject(this, nextOffset, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>next</code>变量是用<code>volatile</code>关键字修饰的，这里调用<code>UNSAFE.putOrderedObject</code>相当于是改变了<code>volatile</code>的语义，这里面的考量有两个，第一个仍然是性能，这样的实现性能明显更高，这一点前文已经详细的分析过，第二点是考虑了语义的一致性，对于<code>put</code>方法来说因为其调用的是<code>UNSAFE.getObjectVolatile</code>，仍然能获取到最新的数据，对于<code>get</code>方法，在<code>put</code>方法未结束之前，是不希望不完整的数据被其他线程通过<code>get</code>方法读取的，这也是合理的。</p>
<h2 id="resize扩容"><a href="#resize扩容" class="headerlink" title="resize扩容"></a><code>resize</code>扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>) <span class="comment">//  Single node on list 只有一个节点，简单处理</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 保证下文中newTable[k]不会为null</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                        last != <span class="keyword">null</span>;</span><br><span class="line">                        last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes 对标记之前的不能重用的节点进行复制，再重新添加到新数组对应的hash桶中去</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node 部分的put功能，把新节点添加到链表的最前面</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分析过，在整个桶数组长度为2的正整数幂的情况下，扩容前同一个桶中的元素在扩容后只会分布在两个桶中，其中一个桶的下标保持不变，我们称之为旧桶，另一个桶的下标为旧桶下标加上旧的容量，我们称之为新桶，其实第一个for循环的目的就是在一个链表中找到最后一个应该移到新桶的数据项，直接移到新桶中，这样做是为了保证后面调用<code>HashEntry&lt;K,V&gt; n = newTable[k];</code>的时候不会读取到<code>null</code>。第二个<code>for</code>就比较简单了，将所有的数据项移到新的桶数组中，当所有的操作完成之后才将<code>newTable</code>赋值给<code>table</code>。</p>
<p><code>rehash</code>方法中是没有加锁的，并不是说调用这个方法不需要加锁，作者是在外层加了锁，这一点需要注意。</p>
<h2 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h2><p>之前在分析<code>HashMap</code>方法的时候我们并没有去讲<code>size</code>方法，因为在单线程环境下这个方法可以使用一个全局的变量解决，同样的方案当然也可以在多线程场景下使用，不过要在多线程环境下读取全局变量又会陷入到无尽的“锁”中，这是我们不愿意看到的，那<code>ConcurrentHashMap</code>是如何解决这个问题的呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面介绍<code>put</code>方法时我们选择忽略了一个小小的成员变量<code>modCount</code>，这个变量在这里大显身手，它的主要作用就是记录整个<code>Segment</code>中写入操作的次数，因为写入操作是会影响整个<code>ConcurrentHashMap</code>的大小的。</p>
<p>因为在读取<code>ConcurrentHashMap</code>大小的时候需要保证读到的是最新的值，因此其调用了<code>UNSAFE.getObjectVolatile</code>这个方法，虽然这个方法的性能比普通变量要差，但是比起全局加锁，可好多了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; Segment&lt;K,V&gt; segmentAt(Segment&lt;K,V&gt;[] ss, int j) &#123;</span><br><span class="line">    long u &#x3D; (j &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; 计算实际的字节偏移量</span><br><span class="line">    return ss &#x3D;&#x3D; null ? null : (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(ss, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="细节十："><a href="#细节十：" class="headerlink" title="细节十："></a><strong>细节十：</strong></h3><p>在<code>size</code>方法的设计上，<code>ConcurrentHashMap</code>先尝试无锁的方法，如果两次遍历所有<code>segment</code>数组的时候整个<code>ConcurrentHashMap</code>没有发生写入操作，则直接返回每个<code>segment</code>数组的<code>size()</code>之和，否则重新遍历，如果写入操作频繁，则不得已加锁处理，这里的加锁相当于是一个全局的锁，因为对<code>segment</code>数组的每一个元素都加了锁。那如何判断整个<code>ConcurrentHashMap</code>的写入是否频繁呢？就看无锁重试的次数，当无锁重试的次数超过阈值的话就全局加锁处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在看完<code>ConcurrentHashMap</code>中的这些细节之后我们尝试回答一下文章开头提出来的问题：</p>
<ol>
<li><p><code>ConcurrentHashMap</code>的哪些操作需要加锁？</p>
<p>答：只有写入操作才需要加锁，读取操作不需要加锁</p>
</li>
<li><p><code>ConcurrentHashMap</code>的无锁读是如何实现的？</p>
<p>答：首先<code>HashEntry</code>中的<code>value</code>和<code>next</code>都是有<code>volatile</code>修饰的，其次在写入操作的时候通过调用<code>UNSAFE</code>库延迟同步了主存，保证了数据的一致性</p>
</li>
<li><p>在多线程的场景下调用<code>size（）</code>方法获取<code>ConcurrentHashMap</code>的大小有什么挑战？<code>ConcurrentHashMap</code>是怎么解决的？</p>
<p>答：<code>size()</code>具有全局的语义，如何能保证在不加全局锁的情况下读取到全局状态的值是一个很大的挑战，<code>ConcurrentHashMap</code>通过查看<strong>两次无锁读</strong>中间是否发生了写入操作来决定读取到的<code>size()</code>是否可信，如果写入操作频繁，则再退化为<strong>全局加锁读取</strong>。</p>
</li>
<li><p>在有<code>Segment</code>存在的前提下，是如何扩容的？</p>
<p>答：<code>segment</code>数组的大小在一开始初始化的时候就已经决定了，扩容主要扩的是<code>HashEntry</code>数组，基本的思路与<code>HashTable</code>一致，但这是一个线程不安全方法，调用之前需要加锁。</p>
</li>
</ol>
<h1 id="Java-8-ConcurrentHashMap"><a href="#Java-8-ConcurrentHashMap" class="headerlink" title="Java 8 ConcurrentHashMap"></a>Java 8 ConcurrentHashMap</h1><p>在<code>Java 7</code>的源码中，作者对悲观锁的使用非常谨慎，大多都转换为自旋锁加<code>volatile</code>获得相同的语义，即使最后迫不得已要用，作者也会通过各种技巧减少锁的临界区。在上一篇文章中我们也有讲到，自旋锁在临界区比较小的时候是一个较优的选择是因为它避免了线程由于阻塞而切换上下文，但本质上它也是个锁，在自旋等待期间只有一个线程能进入临界区，其他线程只会自旋消耗<code>CPU</code>的时间片。<code>Java 8</code>中<code>ConcurrentHashMap</code>的实现通过一些巧妙的设计和技巧，避开了自旋锁的局限，提供了更高的并发性能。如果说<code>Java 7</code>版本的源码是在教我们如何将悲观锁转换为自旋锁，那么在<code>Java 8</code>中我们甚至可以看到如何将自旋锁转换为无锁的方法和技巧。</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/R7PtjL3tdA8G9gcTVIgP3JZWCv0UibUvicIeiaDmgzDGzAh50zu8uibcTzY7acGCJI84Y9J86iaJ0aPK0mD9ASTdR6Q/640" alt="Image" style="zoom:50%;" />

<p>在开始本文之前，大家首先在心里还是要有这样的一张图，如果有同学对<code>HashMap</code>比较熟悉，那这张图也应该不会陌生。事实上在整体的数据结构的设计上<code>Java 8</code>的<code>ConcurrentHashMap</code>和<code>HashMap</code>基本上是一致的。</p>
<p><code>Java 7</code>中<code>ConcurrentHashMap</code>为了提升性能使用了很多的编程技巧，但是引入<code>Segment</code>的设计还是有很大的改进空间的，<code>Java 7</code>中<code>ConcurrrentHashMap</code>的设计有下面这几个可以改进的点：</p>
<ol>
<li><code>Segment</code>在扩容的时候非扩容线程对本<code>Segment</code>的写操作时都要挂起等待的</li>
<li>对<code>ConcurrentHashMap</code>的读操作需要做两次哈希寻址，在读多写少的情况下其实是有额外的性能损失的</li>
<li>尽管<code>size()</code>方法的实现中先尝试无锁读，但是如果在这个过程中有别的线程做写入操作，那调用<code>size()</code>的这个线程就会给整个<code>ConcurrentHashMap</code>加锁，这是整个<code>ConcurrrentHashMap</code>唯一一个全局锁，这点对底层的组件来说还是有性能隐患的</li>
<li>极端情况下（比如客户端实现了一个性能很差的哈希函数）<code>get()</code>方法的复杂度会退化到<code>O(n)</code>。</li>
</ol>
<p>针对1和2，在<code>Java 8</code>的设计是废弃了<code>Segment</code>的使用，将悲观锁的粒度降低至桶维度，因此调用<code>get</code>的时候也不需要再做两次哈希了。<code>size()</code>的设计是<code>Java 8</code>版本中最大的亮点，我们在后面的文章中会详细说明。至于红黑树，这篇文章仍然不做过多阐述。</p>
<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a><code>ForwardingNode</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="comment">// MOVED = -1，ForwardingNode的哈希值为-1</span></span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了普通的<code>Node</code>和<code>TreeNode</code>之外，<code>ConcurrentHashMap</code>还引入了一个新的数据类型<code>ForwardingNode</code>，我们这里只展示他的构造方法，<code>ForwardingNode</code>的作用有两个：</p>
<ul>
<li>在动态扩容的过程中标志某个桶已经被复制到了新的桶数组中</li>
<li>如果在动态扩容的时候有<code>get</code>方法的调用，则<code>ForwardingNode</code>将会把请求转发到新的桶数组中，以避免阻塞<code>get</code>方法的调用，<code>ForwardingNode</code>在构造的时候会将扩容后的桶数组<code>nextTable</code>保存下来。</li>
</ul>
<h3 id="UNSAFE-compareAndSwap"><a href="#UNSAFE-compareAndSwap" class="headerlink" title="UNSAFE.compareAndSwap"></a><code>UNSAFE.compareAndSwap</code></h3><p>这是在<code>Java 8</code>版本的<code>ConcurrentHashMap</code>实现<code>CAS</code>的工具，以<code>int</code>类型为例其方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Atomically update Java variable to &lt;tt&gt;x&lt;&#x2F;tt&gt; if it is currently</span><br><span class="line">* holding &lt;tt&gt;expected&lt;&#x2F;tt&gt;.</span><br><span class="line">* @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if successful</span><br><span class="line">*&#x2F;</span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                              int expected,</span><br><span class="line">                                              int x);</span><br></pre></td></tr></table></figure>

<p>相应的语义为：</p>
<blockquote>
<p>如果对象<code>o</code>起始地址偏移量为<code>offset</code>的值等于<code>expected</code>，则将该值设为<code>x</code>，并返回<code>true</code>表明更新成功，否则返回<code>false</code>，表明<code>CAS</code>失败</p>
</blockquote>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>) <span class="comment">// 检查参数</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)</span><br><span class="line">        initialCapacity = concurrencyLevel;</span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size); <span class="comment">// tableSizeFor，求不小于size的 2^n的算法，jdk1.8的HashMap中说过</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使是最复杂的一个初始化方法代码也是比较简单的，这里我们只需要注意两个点：</p>
<ul>
<li><code>concurrencyLevel</code>在<code>Java 7</code>中是<code>Segment</code>数组的长度，由于在<code>Java 8</code>中已经废弃了<code>Segment</code>，因此<code>concurrencyLevel</code>只是一个保留字段，无实际意义</li>
<li><code>sizeCtl</code>这个值第一次出现，这个值如果等于-1则表明系统正在初始化，如果是其他负数则表明系统正在扩容，在扩容时<code>sizeCtl</code>二进制的低十六位等于扩容的线程数加一，高十六位（除符号位之外）包含桶数组的大小信息</li>
</ul>
<h2 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a><code>put</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>put</code>方法将调用转发到<code>putVal</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 【A】延迟初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 【B】当前桶是空的，直接更新</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【C】如果当前的桶的第一个元素是一个ForwardingNode节点，则该线程尝试加入扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 【D】否则遍历桶内的链表或树，并插入</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 暂时折叠起来，后面详细看</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【F】流程走到此处，说明已经put成功，map的记录总数加一</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="桶数组的初始化"><a href="#桶数组的初始化" class="headerlink" title="桶数组的初始化"></a>桶数组的初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 说明已经有线程在初始化了，本线程开始自旋</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// CAS保证只有一个线程能走到这个分支</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// sc = n - n/4 = 0.75n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 恢复sizeCtl &gt; 0相当于释放锁</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化桶数组的过程中，系统如何保证不会出现并发问题呢，关键点在于自旋锁的使用，当有多个线程都执行<code>initTable</code>方法的时候，<code>CAS</code>可以保证只有一个线程能够进入到真正的初始化分支，其他线程都是自旋等待。这段代码中我们关注三点即可：</p>
<ul>
<li>依照前文所述，当有线程开始初始化桶数组时，会通过<code>CAS</code>将<code>sizeCtl</code>置为-1，其他线程以此为标志开始自旋等待</li>
<li>当桶数组初始化结束后将<code>sizeCtl</code>的值恢复为正数，其值等于0.75倍的桶数组长度，这个值的含义和之前<code>HashMap</code>中的<code>THRESHOLD</code>一致，是系统触发扩容的临界点</li>
<li>在<code>finally</code>语句中对<code>sizeCtl</code>的操作并没有使用<code>CAS</code>是因为<code>CAS</code>保证只有一个线程能够执行到这个地方</li>
</ul>
<h3 id="添加桶数组第一个元素"><a href="#添加桶数组第一个元素" class="headerlink" title="添加桶数组第一个元素"></a>添加桶数组第一个元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>put</code>方法的第二个分支会用<code>tabAt</code>判断当前桶是否是空的，如果是则会通过<code>CAS</code>写入，<code>tabAt</code>通过<code>UNSAFE</code>接口会拿到桶中的最新元素，<code>casTabAt</code>通过<code>CAS</code>保证不会有并发问题，如果<code>CAS</code>失败，则通过循环再进入其他分支</p>
<h3 id="判断是否需要新增线程扩容"><a href="#判断是否需要新增线程扩容" class="headerlink" title="判断是否需要新增线程扩容"></a>判断是否需要新增线程扩容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">    if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123;</span><br><span class="line">        int rs &#x3D; resizeStamp(tab.length);</span><br><span class="line">        while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;</span><br><span class="line">                (sc &#x3D; sizeCtl) &lt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; RESIZE_STAMP_SHIFT &#x3D; 16</span><br><span class="line">            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0)</span><br><span class="line">                break;</span><br><span class="line">            &#x2F;&#x2F; 这里将sizeCtl的值自增1，表明参与扩容的线程数量+1</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个地方我们就要详细说下<code>sizeCtl</code>这个标志位了，临时变量<code>rs</code>由<code>resizeStamp</code>这个方法返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int resizeStamp(int n) &#123;</span><br><span class="line">    &#x2F;&#x2F; RESIZE_STAMP_BITS &#x3D; 16</span><br><span class="line">    return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为入参<code>n</code>是一个<code>int</code>类型的值，所有<code>Integer.numberOfLeadingZeros(n)</code>的返回值介于0到32之间，如果转换成二进制</p>
<ul>
<li><code>Integer.numberOfLeadingZeros(n)</code>的最大值是：00000000 00000000 00000000 00100000</li>
<li><code>Integer.numberOfLeadingZeros(n)</code>的最小值是：00000000 00000000 00000000 00000000</li>
</ul>
<p>因此<code>resizeStampd</code>的返回值也就介于<code>00000000 00000000 10000000 00000000</code>到<code>00000000 00000000 10000000 00100000</code>之间，从这个返回值的范围可以看出来<code>resizeStamp</code>的返回值高16位全都是0，是不包含任何信息的。因此在<code>ConcurrrentHashMap</code>中，会把<code>resizeStamp</code>的返回值左移16位拼到<code>sizeCtl</code>中，这就是为什么<code>sizeCtl</code>的高16位包含整个<code>Map</code>大小的原理。有了这个分析，这段代码中比较长的<code>if</code>判断也就能看懂了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">    sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0)</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</code>保证所有线程要基于同一个旧的桶数组扩容</li>
<li><code>transferIndex &lt;= 0</code>已经有线程完成扩容任务了</li>
</ul>
<p>至于<code>sc == rs + 1 || sc == rs + MAX_RESIZERS</code>这两个判断条件如果是细心的同学一定会觉得难以理解，这个地方确实是JDK的一个<code>BUG</code>，这个<code>BUG</code>已经在<code>JDK 12</code>中修复，详细情况可以参考一下Oracle的官网：<a target="_blank" rel="noopener" href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427%EF%BC%8C%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E5%BA%94%E8%AF%A5%E5%86%99%E6%88%90%E8%BF%99%E6%A0%B7%EF%BC%9A%60sc">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427，这两个判断条件应该写成这样：`sc</a> == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1 || sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS<code>,因为直接比较</code>rs<code>和</code>sc`是没有意义的，必须要有移位操作。它表达的含义是</p>
<ul>
<li><code>sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1</code>当前扩容的线程数为0，即已经扩容完成了，就不需要再新增线程扩容</li>
<li><code>sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS</code>参与扩容的线程数已经到了最大，就不需要再新增线程扩容</li>
</ul>
<p>真正扩容的逻辑在<code>transfer</code>方法中，我们后面会详细看，不过有个小细节可以提前注意，如果<code>nextTable</code>已经初始化了，<code>transfer</code>会返回<code>nextTable</code>的的引用，后续可以直接操作新的桶数组。</p>
<h3 id="插入新值"><a href="#插入新值" class="headerlink" title="插入新值"></a>插入新值</h3><p>如果桶数组已经初始化好了，该扩容的也扩容了，并且根据哈希定位到的桶中已经有元素了，那流程就跟普通的<code>HashMap</code>一样了，唯一一点不同的就是，这时候要给当前的桶加锁，且看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; spread(key.hashCode());</span><br><span class="line">    int binCount &#x3D; 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)&#x2F;&#x2F; 折叠</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 折叠&#125;</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)&#x2F;&#x2F; 折叠</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal &#x3D; null;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                &#x2F;&#x2F; 要注意这里这个不起眼的判断条件</span><br><span class="line">                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                    if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; fh&gt;&#x3D;0的节点是链表，否则是树节点或者ForwardingNode</span><br><span class="line">                        binCount &#x3D; 1;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                    (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal &#x3D; e.val; &#x2F;&#x2F; 如果链表中有值了，直接更新</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val &#x3D; value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                &#x2F;&#x2F; 如果流程走到这里，则说明链表中还没值，直接连接到链表尾部</span><br><span class="line">                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 红黑树的操作先略过</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; put成功，map的元素个数+1</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中要特备注意一个不起眼的判断条件（上下文在源码上已经标注出来了）：<code>tabAt(tab, i) == f</code>，这个判断的目的是为了处理调用<code>put</code>方法的线程和扩容线程的竞争。因为<code>synchronized</code>是阻塞锁，如果调用<code>put</code>方法的线程恰好和扩容线程同时操作同一个桶，且调用<code>put</code>方法的线程竞争锁失败，等到该线程重新获取到锁的时候，当前桶中的元素就会变成一个<code>ForwardingNode</code>，那就会出现<code>tabAt(tab, i) != f</code>的情况。</p>
<h2 id="多线程动态扩容"><a href="#多线程动态扩容" class="headerlink" title="多线程动态扩容"></a>多线程动态扩容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n &#x3D; tab.length, stride;</span><br><span class="line">    if ((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride &#x3D; MIN_TRANSFER_STRIDE; &#x2F;&#x2F; subdivide range</span><br><span class="line">    if (nextTab &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F; 初始化新的桶数组</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab &#x3D; nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      &#x2F;&#x2F; try to cope with OOME</span><br><span class="line">            sizeCtl &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable &#x3D; nextTab;</span><br><span class="line">        transferIndex &#x3D; n;</span><br><span class="line">    &#125;</span><br><span class="line">    int nextn &#x3D; nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd &#x3D; new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    boolean advance &#x3D; true;</span><br><span class="line">    boolean finishing &#x3D; false; &#x2F;&#x2F; to ensure sweep before committing nextTab</span><br><span class="line">    for (int i &#x3D; 0, bound &#x3D; 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;&#x3D; bound || finishing)</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line">            else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;</span><br><span class="line">                i &#x3D; -1;</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                        (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                        nextBound &#x3D; (nextIndex &gt; stride ?</span><br><span class="line">                                    nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound &#x3D; nextBound;</span><br><span class="line">                i &#x3D; nextIndex - 1;</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable &#x3D; null;</span><br><span class="line">                table &#x3D; nextTab;</span><br><span class="line">                sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断是会否是最后一个扩容线程</span><br><span class="line">                if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                finishing &#x3D; advance &#x3D; true;</span><br><span class="line">                i &#x3D; n; &#x2F;&#x2F; recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i)) &#x3D;&#x3D; null)</span><br><span class="line">            advance &#x3D; casTabAt(tab, i, null, fwd);</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 只有最后一个扩容线程才有机会执行这个分支</span><br><span class="line">            advance &#x3D; true; &#x2F;&#x2F; already processed</span><br><span class="line">        else &#123; &#x2F;&#x2F; 复制过程与HashMap类似，这里不再赘述</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">               &#x2F;&#x2F; 折叠</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在深入到源码细节之前我们先根据下图看一下在<code>Java 8</code>中<code>ConcurrentHashMap</code>扩容的几个特点：</p>
<ul>
<li>新的桶数组<code>nextTable</code>是原先桶数组长度的2倍，这与之前<code>HashMap</code>一致</li>
<li>参与扩容的线程也是分段将<code>table</code>中的元素复制到新的桶数组<code>nextTable</code>中</li>
<li>桶一个桶数组中的元素在新的桶数组中均匀的分布在两个桶中，桶下标相差n(旧的桶数组的长度)，这一点依然与<code>HashMap</code>保持一致</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">image-20210424202636495</p>
<h3 id="各个线程之间如何通力协作"><a href="#各个线程之间如何通力协作" class="headerlink" title="各个线程之间如何通力协作"></a>各个线程之间如何通力协作</h3><p>先看一个关键的变量<code>transferIndex</code>，这是一个被<code>volatile</code>修饰的变量，这一点可以保证所有线程读到的一定是最新的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile int transferIndex;</span><br></pre></td></tr></table></figure>

<p>这个值会被第一个参与扩容的线程初始化，因为只有第一个参与扩容的线程才满足条件<code>nextTab == null</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (nextTab &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F; initiating</span><br><span class="line">    try &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">        nextTab &#x3D; nt;</span><br><span class="line">    &#125; catch (Throwable ex) &#123;      &#x2F;&#x2F; try to cope with OOME</span><br><span class="line">        sizeCtl &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    nextTable &#x3D; nextTab;</span><br><span class="line">    transferIndex &#x3D; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在了解了<code>transferIndex</code>属性的基础上，上面的这个循环就好理解了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">while (advance) &#123;</span><br><span class="line">    int nextIndex, nextBound;</span><br><span class="line">      &#x2F;&#x2F; 当bound &lt;&#x3D; i &lt;&#x3D; transferIndex的时候i自减跳出这个循环继续干活</span><br><span class="line">    if (--i &gt;&#x3D; bound || finishing)</span><br><span class="line">        advance &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 扩容的所有任务已经被认领完毕，本线程结束干活</span><br><span class="line">    else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;</span><br><span class="line">        i &#x3D; -1;</span><br><span class="line">        advance &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 否则认领新的一段复制任务，并通过&#96;CAS&#96;更新transferIndex的值</span><br><span class="line">    else if (U.compareAndSwapInt</span><br><span class="line">                (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                nextBound &#x3D; (nextIndex &gt; stride ?</span><br><span class="line">                            nextIndex - stride : 0))) &#123;</span><br><span class="line">        bound &#x3D; nextBound;</span><br><span class="line">        i &#x3D; nextIndex - 1;</span><br><span class="line">        advance &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>transferIndex</code>就像是一个游标，每个线程认领一段复制任务的时候都会通过CAS将其更新为<code>transferIndex - stride</code>， <code>CAS</code>可以保证<code>transferIndex</code>可以按照<code>stride</code>这个步长降到0。</p>
<h3 id="最后一个扩容线程需要二次确认？"><a href="#最后一个扩容线程需要二次确认？" class="headerlink" title="最后一个扩容线程需要二次确认？"></a>最后一个扩容线程需要二次确认？</h3><p>对于每一个扩容线程，<code>for</code>循环的变量<code>i</code>代表要复制的桶的在桶数组中的下标，这个值的上限和下限通过游标<code>transferIndex</code>和步长<code>stride</code>计算得来，当<code>i</code>减小为负数，则说明当前扩容线程完成了扩容任务，这时候流程会走到这个分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; i &gt;&#x3D; n || i + n &gt;&#x3D; nextn现在看来取不到</span><br><span class="line">if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;</span><br><span class="line">    int sc;</span><br><span class="line">    if (finishing) &#123; &#x2F;&#x2F; 【A】完成整个扩容过程</span><br><span class="line">        nextTable &#x3D; null;</span><br><span class="line">        table &#x3D; nextTab;</span><br><span class="line">        sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 【B】判断是否是最后一个扩容线程，如果是，则需要重新扫描一遍桶数组，做二次确认</span><br><span class="line">    if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;</span><br><span class="line">        &#x2F;&#x2F; (sc - 2) &#x3D;&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT 说明是最后一个扩容线程</span><br><span class="line">        if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F; 重新扫描一遍桶数组，做二次确认</span><br><span class="line">        finishing &#x3D; advance &#x3D; true;</span><br><span class="line">        i &#x3D; n; &#x2F;&#x2F; recheck before commit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为变量<code>finishing</code>被初始化为<code>false</code>，所以当线程第一次进入这个<code>if</code>分支的话，会先执行注释为【B】的这个分支，同时因为<code>sizeCtl</code>的低16位被初始化为参与扩容的线程数加一，因此，当条件<code>(sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT</code>满足时，就能证明当前线程就是最后一个扩容线程了，这这时候将<code>i</code>置为<code>n</code>重新扫描一遍桶数组，并且将<code>finishing</code>置为<code>true</code>保证当桶数组被扫描结束后能够进入注释为【A】的分支结束扩容。</p>
<p>这里就有一个问题，按照我们前面的分析，扩容线程能够通力协作，保证各自负责的桶数组的分段不重不漏，这里为什么还需要做二次确认么？有一个开发者在<code>concurrency-interest</code>这个邮件列表中也关于这件事咨询了<code>Doug Lea</code>(地址：<a target="_blank" rel="noopener" href="http://cs.oswego.edu/pipermail/concurrency-interest/2020-July/017171.html)%EF%BC%8C%E4%BB%96%E7%BB%99%E5%87%BA%E7%9A%84%E5%9B%9E%E5%A4%8D%E6%98%AF%EF%BC%9A">http://cs.oswego.edu/pipermail/concurrency-interest/2020-July/017171.html)，他给出的回复是：</a></p>
<blockquote>
<p>Yes, this is a valid point; thanks. The post-scan was needed in a previous version, and could be removed. It does not trigger often enough to matter though, so is for now another minor tweak that might be included next time CHM is updated.</p>
</blockquote>
<p>虽然<code>Doug</code>在邮件中的措辞用了could be, not often enough等，但也确认了最后一个扩容线程的二次检查是没有必要的。具体的复制过程与<code>HashMap</code>类似，感兴趣的读者可以翻一下<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzk0NjExMjU3Mg==&mid=2247484593&idx=1&sn=1329f371cc600813034535411c3a987f&chksm=c30a55e2f47ddcf47a6fc2fbd67be93ec4a87dd00dccbd60d9b602f591f9218cb526ac739a16&scene=21#wechat_redirect">高端的面试从来不会在HashMap的红黑树上纠缠太多</a>这篇文章。</p>
<h2 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a><code>size()</code>方法</h2><h3 id="addCount-方法"><a href="#addCount-方法" class="headerlink" title="addCount()方法"></a><code>addCount()方法</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 记录map元素总数的成员变量</span><br><span class="line">private transient volatile long baseCount;</span><br></pre></td></tr></table></figure>

<p>在<code>put</code>方法的最后，有一个<code>addCount</code>方法，因为<code>putVal</code>执行到此处说明已经成功新增了一个元素，所以<code>addCount</code>方法的作用就是维护当前<code>ConcurrentHashMap</code>的元素总数，在<code>ConcurrentHashMap</code>中有一个变量<code>baseCount</code>用来记录<code>map</code>中元素的个数，如下图所示，如果同一时刻有n个线程通过CAS同时操作<code>baseCount</code>变量，有且仅有一个线程会成功，其他线程都会陷入无休止的自旋当中，那一定会带来性能瓶颈。</p>
<p>为了避免大量线程都在自旋等待写入<code>baseCount</code>，<code>ConcurrentHashMap</code>引入了一个辅助队列，如下图所示，现在操作<code>baseCount</code>的线程可以分散到这个辅助队列中去了，调用<code>size()</code>的时候只需要将<code>baseCount</code>和辅助队列中的数值相加即可，这样就实现了调用<code>size()</code>无需加锁。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Image">image-20210420222306734</p>
<p>辅助队列是一个类型为<code>CounterCell</code>的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended static final class CounterCell &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">    CounterCell(long x) &#123; value &#x3D; x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以简单理解为只是包装了一个<code>long</code>型的变量<code>value</code>，还需要解决一个问题是，对于某个具体的线程它是如何知道操作辅助队列中的哪个值呢？答案是下面的这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int getProbe() &#123;</span><br><span class="line">    return UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProbe</code>方法会返回当前线程的一个唯一身份码，这个值是不会变的，因此可以将<code>getProbe</code>的返回值与辅助队列的长度作求余运算得到具体的下标，它的返回值可能是0，如果返回0则需要调用<code>ThreadLocalRandom.localInit()</code>初始化。<code>addCount</code>方法中有两个细节需要注意</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">    CounterCell[] as; long b, s;</span><br><span class="line">    &#x2F;&#x2F; 注意这里的判断条件，是有技巧的</span><br><span class="line">    if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">        !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123;</span><br><span class="line">        CounterCell a; long v; int m;</span><br><span class="line">        boolean uncontended &#x3D; true;</span><br><span class="line">        if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">            (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">            &#x2F;&#x2F; 变量uncontended记录着这个CAS操作是否成功</span><br><span class="line">            !(uncontended &#x3D;</span><br><span class="line">                U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &lt;&#x3D; 1)</span><br><span class="line">            return;</span><br><span class="line">        s &#x3D; sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    if (check &gt;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 检查是否需要扩容，后面再详细看</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节一：</p>
<p>首先我们要注意方法中刚进来的<code>if</code>判断条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">    !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者在这里巧妙的运用了逻辑短路，如果<code>(as = counterCells) != null</code>则后面的<code>CAS</code>是不会执行的，为什么要这么设置呢？作者有两点考虑：</p>
<ol>
<li>原因在于如果<code>(as = counterCells) != null</code>，则说明辅助队列已经初始化好了，相比于所有的线程都自旋等待<code>baseCount</code>这一个变量，让线程通过<code>CAS</code>去操作队列中的值有更大的可能性成功，因为辅助队列的最大长度为大于当前处理器个数的2的正整数幂，可以支持更大的并发</li>
<li>如果辅助队列还没有初始化好，直到有必要的时候再去创建队列，如何判断“必要性”呢？就看对<code>baseCount</code>的<code>CAS</code>操作能否成功，如果失败，就说明当前系统的并发已经比较高了，需要队列的辅助，否则直接操作<code>baseCount</code></li>
</ol>
<p>细节二：</p>
<p>只有当辅助队列已存在，且由<code>ThreadLocalRandom.getProbe()</code>在辅助队列中确定的位置不为<code>null</code>时，才对其做<code>CAS</code>操作，这本来是一个正常的防御性判断，但是<code>uncontended</code>记录了<code>CAS</code>是否成功，如果失败，则会在<code>fullAddCount</code>中调用<code>ThreadLocalRandom.advanceProbe</code>换一个身份码调整下当前线程在辅助队列的位置，避免所有线程都在辅助队列的同一个坑位自旋等待。</p>
<h3 id="fullAddCount-方法"><a href="#fullAddCount-方法" class="headerlink" title="fullAddCount()方法"></a><code>fullAddCount()</code>方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; See LongAdder version for explanation</span><br><span class="line">&#x2F;&#x2F; wasUncontended 记录着调用方CAS是否成功，如果失败则换一个辅助队列的元素继续CAS</span><br><span class="line">private final void fullAddCount(long x, boolean wasUncontended) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    if ((h &#x3D; ThreadLocalRandom.getProbe()) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      &#x2F;&#x2F; force initialization</span><br><span class="line">        h &#x3D; ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean collide &#x3D; false;                &#x2F;&#x2F; True if last slot nonempty</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; int n; long v;</span><br><span class="line">        &#x2F;&#x2F; 【A】如果辅助队列已经创建，则直接操作辅助队列</span><br><span class="line">        if ((as &#x3D; counterCells) !&#x3D; null &amp;&amp; (n &#x3D; as.length) &gt; 0) &#123;</span><br><span class="line">            if ((a &#x3D; as[(n - 1) &amp; h]) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (cellsBusy &#x3D;&#x3D; 0) &#123;            &#x2F;&#x2F; Try to attach new Cell</span><br><span class="line">                    CounterCell r &#x3D; new CounterCell(x); &#x2F;&#x2F; Optimistic create</span><br><span class="line">                    if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">                        boolean created &#x3D; false;</span><br><span class="line">                        try &#123;               &#x2F;&#x2F; Recheck under lock</span><br><span class="line">                            CounterCell[] rs; int m, j;</span><br><span class="line">                            if ((rs &#x3D; counterCells) !&#x3D; null &amp;&amp;</span><br><span class="line">                                (m &#x3D; rs.length) &gt; 0 &amp;&amp;</span><br><span class="line">                                rs[j &#x3D; (m - 1) &amp; h] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                rs[j] &#x3D; r;</span><br><span class="line">                                created &#x3D; true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            cellsBusy &#x3D; 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (created)</span><br><span class="line">                            break;</span><br><span class="line">                        continue;           &#x2F;&#x2F; Slot is now non-empty</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (!wasUncontended)       &#x2F;&#x2F; 如果调用方CAS失败了，本轮空跑，下一个循环换下标继续操作</span><br><span class="line">                wasUncontended &#x3D; true;      &#x2F;&#x2F; Continue after rehash</span><br><span class="line">            else if (U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))</span><br><span class="line">                break;</span><br><span class="line">            else if (counterCells !&#x3D; as || n &gt;&#x3D; NCPU) </span><br><span class="line">                &#x2F;&#x2F; 如果辅助队列长度已经超过了CPU个数，本轮空跑，下一个循环换下标继续操作</span><br><span class="line">                collide &#x3D; false;            &#x2F;&#x2F; At max size or stale</span><br><span class="line">            else if (!collide) &#x2F;&#x2F; 如果上一次操作失败了(CAS失败或者新建CounterCell失败)，本轮空跑，下一个循环换下标继续操作</span><br><span class="line">                collide &#x3D; true;</span><br><span class="line">            else if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; &#x2F;&#x2F; 如果连续两次操作辅助队列失败，则考虑扩容</span><br><span class="line">                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (counterCells &#x3D;&#x3D; as) &#123;&#x2F;&#x2F; Expand table unless stale</span><br><span class="line">                        CounterCell[] rs &#x3D; new CounterCell[n &lt;&lt; 1];</span><br><span class="line">                        for (int i &#x3D; 0; i &lt; n; ++i)</span><br><span class="line">                            rs[i] &#x3D; as[i];</span><br><span class="line">                        counterCells &#x3D; rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    cellsBusy &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                collide &#x3D; false;</span><br><span class="line">                continue;                   &#x2F;&#x2F; Retry with expanded table</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果上一次操作失败或者调用方CAS失败，都会走到这里，变换要操作的辅助队列下标</span><br><span class="line">            h &#x3D; ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 【B】如果辅助队列还未创建，则加锁创建</span><br><span class="line">        else if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; counterCells &#x3D;&#x3D; as &amp;&amp;</span><br><span class="line">                    U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">            boolean init &#x3D; false;</span><br><span class="line">            try &#123;                           &#x2F;&#x2F; Initialize table</span><br><span class="line">                if (counterCells &#x3D;&#x3D; as) &#123;</span><br><span class="line">                    CounterCell[] rs &#x3D; new CounterCell[2];</span><br><span class="line">                    rs[h &amp; 1] &#x3D; new CounterCell(x);</span><br><span class="line">                    counterCells &#x3D; rs;</span><br><span class="line">                    init &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                cellsBusy &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (init)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 【C】如果辅助队列创建失败(拿锁失败)，则尝试直接操作&#96;baseCount&#96;</span><br><span class="line">        else if (U.compareAndSwapLong(this, BASECOUNT, v &#x3D; baseCount, v + x))</span><br><span class="line">            break;                          &#x2F;&#x2F; Fall back on using base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>counterCells</code>是一个普通的数组，因此对其的写操作，包括初始化，扩容以及元素的写都需要加锁，加锁的方式是对全局变量<code>cellsBusy</code>的自旋锁。先看最外层的三个分支：</p>
<ul>
<li>【B】如果辅助队列还没有创建，则加锁创建</li>
<li>【C】如果因为拿锁失败导致辅助队列创建失败，则尝试自旋写入变量<code>baseCount</code>，万一真的成功了呢</li>
<li>【A】如果辅助队列已经创建了，则直接去操作辅助队列相应的元素</li>
</ul>
<p>注释中标注【A】的这个分支代码较多，其主要思路是如果通过<code>CAS</code>或者加锁操作辅助队列中的某个元素失败，则首先通过调用<code>ThreadLocalRandom.advanceProbe(h)</code>换一个队列中的元素继续操作，这次操作是否成功会记录在临时变量<code>collide</code>中。如果下一次操作还是失败，则说明此时的并发量比较大需要扩容了。如果辅助队列的长度已经超过了<code>CPU</code>的个数，那就不再扩容，继续换一个元素操作，因为同一时间能运行的线程数最大不会超过计算机的<code>CPU</code>个数。</p>
<p>在这个过程中有四个细节仍然需要注意：</p>
<p>细节一：</p>
<p><code>counterCells</code>只是一个普通的数组，因此并不是线程安全的，所以对其写操作需要加锁保证并发安全</p>
<p>细节二：</p>
<p>加锁的时候，作者做了一个<code>double-check</code>的动作，我看有的文章将其解读为“类似于单例模式的<code>double-check</code>”，这个是不对的，作者这样做的原因我们在上一篇文章中有讲过，首先第一个检查<code>cellsBusy == 0</code>是流程往下走的基础，如果<code>cellsBusy == 1</code>则直接拿锁失败退出，调用<code>h = ThreadLocalRandom.advanceProbe(h);</code>更新<code>h</code>后重试，如果<code>cellsBusy == 0</code>校验通过，则调用<code>CounterCell r = new CounterCell(x);</code>初始化一个<code>CounterCell</code>，这样做是为了减少自旋锁的临界区的大小，以此来提升并发性能</p>
<p>细节三：</p>
<p>在加锁的时候先判断下<code>cellsBusy</code>是否为0，如果为1那直接宣告拿锁失败，为什么这么做呢？因为相比于调用<code>UNSAFE</code>的<code>CAS</code>操作，直接读取<code>volatile</code>的消耗更少，如果直接读取<code>cellsBusy</code>已经能判断出拿锁失败，那就没必要再调用耗时更多的<code>CAS</code>了</p>
<p>细节四：</p>
<p>对<code>cellsBusy</code>从0到1的更改调用了<code>CAS</code>但是从1置为0却只用了赋值操作，这是因为<code>CAS</code>可以保证能走到这条语句的只有一个线程，因此可以用赋值操作来更改<code>cellsBusy</code>的值。</p>
<h3 id="sumCount"><a href="#sumCount" class="headerlink" title="sumCount"></a><code>sumCount</code></h3><p>前面两个方法主要是把<code>ConcurrentHashMap</code>中的元素个数分散的记录到<code>baseCount</code>和辅助队列中，调用<code>size()</code>方法的时候只需要把这些值相加即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    long n &#x3D; sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as &#x3D; counterCells; CounterCell a;</span><br><span class="line">    long sum &#x3D; baseCount;</span><br><span class="line">    if (as !&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a &#x3D; as[i]) !&#x3D; null)</span><br><span class="line">                sum +&#x3D; a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-concurrent-ConcurrentHashMap/" data-id="cm6lsyz5o006tk2dl6qtpfmqc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/shiro%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02-shiro%E5%85%A5%E5%8F%A3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          shiro框架
        
      </div>
    </a>
  
  
    <a href="/2021/04/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/springboot/springboot-04-%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">springboot-04-父子容器</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/">juc</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/oom/">oom</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/oom/">oom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/spring/">spring</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/" rel="tag">JDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/annotation/" rel="tag">annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cluster/" rel="tag">cluster</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jstack/" rel="tag">jstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock/" rel="tag">lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/net/" rel="tag">net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/next/" rel="tag">next</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/" rel="tag">reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-starter/" rel="tag">spring starter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/startup/" rel="tag">startup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transaction/" rel="tag">transaction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtual-machine/" rel="tag">virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vm/" rel="tag">vm</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDK/" style="font-size: 11.11px;">JDK</a> <a href="/tags/annotation/" style="font-size: 10px;">annotation</a> <a href="/tags/cluster/" style="font-size: 10px;">cluster</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/hexo/" style="font-size: 12.22px;">hexo</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/jstack/" style="font-size: 14.44px;">jstack</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/lock/" style="font-size: 10px;">lock</a> <a href="/tags/mysql/" style="font-size: 16.67px;">mysql</a> <a href="/tags/net/" style="font-size: 10px;">net</a> <a href="/tags/next/" style="font-size: 11.11px;">next</a> <a href="/tags/redis/" style="font-size: 15.56px;">redis</a> <a href="/tags/reflect/" style="font-size: 10px;">reflect</a> <a href="/tags/spring-starter/" style="font-size: 10px;">spring starter</a> <a href="/tags/springboot/" style="font-size: 18.89px;">springboot</a> <a href="/tags/startup/" style="font-size: 17.78px;">startup</a> <a href="/tags/transaction/" style="font-size: 11.11px;">transaction</a> <a href="/tags/virtual-machine/" style="font-size: 12.22px;">virtual machine</a> <a href="/tags/vm/" style="font-size: 13.33px;">vm</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%A1%86%E6%9E%B6-04-bean%E5%8C%85-Bean/">spring框架-04-bean包-Bean</a>
          </li>
        
          <li>
            <a href="/2022/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-HashMap/">JDK-util-HashMap</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E5%9C%BA%E6%99%AF/">mysql - 常见事务问题解决方案</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">mysql - 面试问题</a>
          </li>
        
          <li>
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">交换排序-冒泡排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 Fei Qi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>