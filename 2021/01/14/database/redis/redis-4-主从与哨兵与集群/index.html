<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>redis-4-主从与哨兵与集群 | BootFei&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主从复制 主 Redis 中的数据有两个副本( replication )即从 redis1 和从 redis2 ，即使一台 Redis 服 务器宕机其它两台 Redis 服务也可以继续提供服务。 主 Redis 中的数据和从 Redis 上的数据保持实时同步，当主 Redis 写入数据时通过主从复制机制 会复制到两个从 Redis 服务上。 只有一个主 Redis ，可以有多个从 Redis 。">
<meta property="og:type" content="article">
<meta property="og:title" content="redis-4-主从与哨兵与集群">
<meta property="og:url" content="http://example.com/2021/01/14/database/redis/redis-4-%E4%B8%BB%E4%BB%8E%E4%B8%8E%E5%93%A8%E5%85%B5%E4%B8%8E%E9%9B%86%E7%BE%A4/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="主从复制 主 Redis 中的数据有两个副本( replication )即从 redis1 和从 redis2 ，即使一台 Redis 服 务器宕机其它两台 Redis 服务也可以继续提供服务。 主 Redis 中的数据和从 Redis 上的数据保持实时同步，当主 Redis 写入数据时通过主从复制机制 会复制到两个从 Redis 服务上。 只有一个主 Redis ，可以有多个从 Redis 。">
<meta property="og:locale">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1227483/201802/1227483-20180201103511703-1604168118.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-cc94828d6884eac1cc59ea312727307b_1440w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-40e7dd00ad78ec9f3fd8c1cb36e32b26_1440w.jpg">
<meta property="og:image" content="http://dunwu.test.upcdn.net/snap/20200131135847.png">
<meta property="og:image" content="http://dunwu.test.upcdn.net/cs/database/redis/redis-cluster-trib.png">
<meta property="og:image" content="http://dunwu.test.upcdn.net/cs/database/redis/redis-ask.png">
<meta property="article:published_time" content="2021-01-14T07:59:03.000Z">
<meta property="article:modified_time" content="2021-02-20T15:26:41.872Z">
<meta property="article:author" content="Fei Qi">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images2017.cnblogs.com/blog/1227483/201802/1227483-20180201103511703-1604168118.png">
  
    <link rel="alternate" href="/atom.xml" title="BootFei&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BootFei&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-database/redis/redis-4-主从与哨兵与集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/14/database/redis/redis-4-%E4%B8%BB%E4%BB%8E%E4%B8%8E%E5%93%A8%E5%85%B5%E4%B8%8E%E9%9B%86%E7%BE%A4/" class="article-date">
  <time datetime="2021-01-14T07:59:03.000Z" itemprop="datePublished">2021-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      redis-4-主从与哨兵与集群
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><ul>
<li>主 Redis 中的数据有两个副本( replication )即从 redis1 和从 redis2 ，即使一台 Redis 服 务器宕机其它两台 Redis 服务也可以继续提供服务。</li>
<li>主 Redis 中的数据和从 Redis 上的数据保持实时同步，当主 Redis 写入数据时通过主从复制机制 会复制到两个从 Redis 服务上。</li>
<li>只有一个主 Redis ，可以有多个从 Redis 。 主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求。 一个 Redis 可以即是主又是从，如下图<img src="https://images2017.cnblogs.com/blog/1227483/201802/1227483-20180201103511703-1604168118.png" alt="img" style="zoom:50%;" />

</li>
</ul>
<h2 id="主配置"><a href="#主配置" class="headerlink" title="主配置"></a>主配置</h2><p>无</p>
<h2 id="从配置"><a href="#从配置" class="headerlink" title="从配置"></a>从配置</h2><p>修改从服务器上的 redis.conf 文件:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示当前【从服务器】对应的【主服务器】的IP是192.168.10.135，端口是6379。 </span></span><br><span class="line">slaveof 192.168.10.135 6379  #老版本命令</span><br><span class="line">replicaof 192.168.19.135 6379 #新版本</span><br></pre></td></tr></table></figure>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><img src="https://pic4.zhimg.com/80/v2-cc94828d6884eac1cc59ea312727307b_1440w.jpg" alt="img" style="zoom:67%;" />

<ul>
<li>Redis 的主从同步，分为<a href="">全量同步</a> 和<a href="">增量同步</a> </li>
<li>只有从机第一次连接上主机是全量同步 。</li>
<li>断线重连有可能触发<a href="">全量同步</a>也有可能是<a href="">增量同步</a> ( master 判断 runid 是否一致)。</li>
<li>除此之外的情况都是<a href="">增量同步</a> 。</li>
</ul>
<h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><img src="https://pic3.zhimg.com/80/v2-40e7dd00ad78ec9f3fd8c1cb36e32b26_1440w.jpg" alt="img" style="zoom:50%;" />

<ul>
<li>同步快照阶段：Master 创建并发送快照给 Slave ， Slave 载入并解析快照。 Master 同时将此阶段所产生的新的写命令存储到缓冲区。</li>
<li>同步写缓冲阶段：Master 向 Slave 同步存储在缓冲区的写操作命令。 <!--解决第一步中产生的问题--></li>
<li>同步增量阶段：Master 向 Slave 同步写操作命令。<!--第二部是增量操作--></li>
</ul>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><ul>
<li>Redis 增量同步主要指 <strong>Slave 完成初始化后开始正常工作</strong>时，<strong>Master 发生的写操作同步到 Slave 的过程</strong>。</li>
<li>通常情况下，Master 每执行一个写命令就会向 Slave 发送相同的<strong>写命令</strong>，然后 Slave接收并执行。</li>
</ul>
<h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><p>Redis 主从复制的缺点:没有办法对 master 进行动态选举，需要使用 Sentinel 机制完成动态选举</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis 哨兵（Sentinel）是 Redis 的<strong>高可用性</strong>（Hight Availability）解决方案：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<img src="http://dunwu.test.upcdn.net/snap/20200131135847.png" alt="img" style="zoom:33%;" />



<h2 id="Sentinel主要功能"><a href="#Sentinel主要功能" class="headerlink" title="Sentinel主要功能"></a>Sentinel主要功能</h2><ul>
<li><strong><code>监控（Monitoring）</code></strong> - Sentinel 不断检查主从服务器是否正常在工作。</li>
<li><strong><code>通知（Notification）</code></strong> - Sentinel 可以通过一个 api 来通知系统管理员或者另外的应用程序，被监控的 Redis 实例有一些问题。</li>
<li><strong><code>自动故障转移（Automatic Failover）</code></strong> - 如果一个主服务器下线，Sentinel 会开始自动故障转移：把一个从节点提升为主节点，并重新配置其他的从节点使用新的主节点，使用 Redis 服务的应用程序在连接的时候也被通知新的地址。</li>
<li><strong><code>配置提供者（Configuration provider）</code></strong> - Sentinel 给客户端的服务发现提供来源：对于一个给定的服务，客户端连接到 Sentinels 来寻找当前主节点的地址。当故障转移发生的时候，Sentinel 将报告新的地址。</li>
</ul>
<h2 id="启动Sentinel"><a href="#启动Sentinel" class="headerlink" title="启动Sentinel"></a>启动Sentinel</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>

<p><strong>Sentinel 本质上是一个运行在特殊状模式下的 Redis 服务器</strong>。</p>
<h2 id="故障判定原理"><a href="#故障判定原理" class="headerlink" title="故障判定原理"></a>故障判定原理</h2><ul>
<li>通过ping-pang机制使用Sentinel的监控功能：<ol>
<li>默认情况下，<strong>每个</strong> <code>Sentinel</code> 节点会以 <strong>每秒一次</strong> 的频率对 <code>Redis</code> 节点和 <strong>其它</strong> 的 <code>Sentinel</code> 节点发送 <code>PING</code> 命令，并通过节点的 <strong>回复</strong> 来判断节点是否在线。<ul>
<li><strong>主观下线ODOWN</strong>：<strong>主观下线</strong> 适用于所有 <strong>主节点</strong> 和 <strong>从节点</strong>。如果在 <code>down-after-milliseconds</code> 毫秒内，<code>Sentinel</code> 没有收到 <strong>目标节点</strong> 的有效回复，则会判定 <strong>该节点</strong> 为 <strong>主观下线</strong>。</li>
<li><strong>客观下线SDOWN</strong>：<strong>客观下线</strong> 只适用于 <strong>主节点</strong>。当 <code>Sentinel</code> 将一个主服务器判断为主管下线后，为了确认这个主服务器是否真的下线，会向同样监视这一主服务器的其他 Sentinel 询问，看它们是否也认为主服务器已经下线。当足够数量的 Sentinel 认为主服务器已下线，就判定其为客观下线，并对其执行故障转移操作。</li>
</ul>
</li>
<li>如果一个实例(instance)距离最后一次有效回复 PING 命令的时间超过 down-after- milliseconds 选项所指定的值， 则这个实例会被 Sentinel(哨兵)进程标记为(ODOWN)。</li>
<li>如果一个Master主服务器被标记为主观下线(SDOWN)，则正在监视这个Master主服务器的所有 Sentinel(哨兵)以每秒一次的频率确认Master主机的确进入SDOWN</li>
<li>当足够数量的 Sentinel (&gt;=配置文件中的值)认为主服务器已下线，就判定其为客观下线ODWON</li>
</ol>
</li>
<li>获取服务器信息：<ol start="5">
<li>在一般情况下， 每个 Sentinel(哨兵)进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。<strong>Sentinel 向主服务器发送 <code>INFO</code> 命令，获取主服务器及它的从服务器信息</strong>。</li>
<li>当Master主服务器被 Sentinel(哨兵)进程标记为ODOWN时，Sentinel(哨兵)进程向<a href="">下线的 Master主服务器</a>的<a href="">所有 Slave从服务器</a>发送 INFO 命令的频率会从10秒一次改为每秒一次。</li>
</ol>
</li>
<li>故障判断：<ol start="7">
<li>若没有足够数量的 Sentinel(哨兵)进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel(哨兵)进程发送 PING 命令 返回有效回复， Master 主服务器的主观下线状态就会被移除。</li>
</ol>
</li>
</ul>
<h2 id="自动故障迁移"><a href="#自动故障迁移" class="headerlink" title="自动故障迁移"></a>自动故障迁移</h2><ul>
<li>它会将失效Master 的其中一个Slave升级为新的Master , 并让失效Master的其他Slave改为复制新的 Master ;</li>
<li>当客户端试图连接失效的 Master 时，集群也会向客户端返回新 Master 的地址，使得集群可以使 用现在的Master 替换失效 Master 。</li>
<li>Master 和 Slave 服务器切换后， <a href="">Master 的 redis.conf</a> 、 <a href="">Slave 的 redis.conf</a> 和<a href="">sentinel.conf</a> 的配置文件的内容都会发生相应的改变，即Master 主服务器的 redis.conf 配置文件中会多一行 slaveof 的配置， sentinel.conf 的监控目标会随之调换。</li>
</ul>
<h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><p><strong><a target="_blank" rel="noopener" href="https://redis.io/topics/cluster-tutorial">Redis 集群（Redis Cluster） (opens new window)</a>是 Redis 官方提供的分布式数据库方案</strong>。</p>
<p>既然是分布式，自然具备分布式系统的基本特性：可扩展、高可用、一致性。</p>
<ul>
<li>Redis 集群通过划分 hash 槽来分片，进行数据分享。</li>
<li>Redis 集群采用主从模型，提供复制和故障转移功能，来保证 Redis 集群的高可用。</li>
<li>根据 CAP 理论，Consistency、Availability、Partition tolerance 三者不可兼得，而 Redis 集群的选择是 AP。Redis 集群节点间采用异步通信方式，不保证强一致性，尽力达到最终一致性。</li>
</ul>
<h2 id="架构细节"><a href="#架构细节" class="headerlink" title="架构细节"></a>架构细节</h2><p>(1)所有的redis节点彼此互联(ping-pong机制 ),内部使用二进制协议优化传输速度和带宽. </p>
<p>(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.</p>
<p>(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一 个可用节点即可</p>
<p>(4)redis-cluster把所有的物理节点映射到[0-16383] 上,cluster 负责维护node\slot\value</p>
<h2 id="Redis-Cluster-分区"><a href="#Redis-Cluster-分区" class="headerlink" title="Redis Cluster 分区"></a>Redis Cluster 分区</h2><h3 id="集群节点"><a href="#集群节点" class="headerlink" title="集群节点"></a>集群节点</h3><p>Redis 集群由多个节点组成，节点刚启动时，彼此是相互独立的。<strong>节点通过握手（ <code>CLUSTER MEET</code> 命令）来将其他节点添加到自己所处的集群中</strong>。</p>
<p>向一个节点发送 <code>CLUSTER MEET</code> 命令，可以让当前节点与指定 IP、PORT 的节点进行握手，握手成功时，当前节点会将指定节点加入所在集群。</p>
<p><strong>集群节点保存键值对以及过期时间的方式与单机 Redis 服务完全相同</strong>。</p>
<p>Redis 集群节点分为主节点（master）和从节点（slave），其中<a href="">主节点用于处理槽</a>，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p>
<h3 id="分配-Hash-槽"><a href="#分配-Hash-槽" class="headerlink" title="分配 Hash 槽"></a>分配 Hash 槽</h3><p>分布式存储需要解决的首要问题是把 <strong>整个数据集</strong> 按照 <strong>分区规则</strong> 映射到 <strong>多个节点</strong> 的问题，即把 <strong>数据集</strong> 划分到 <strong>多个节点</strong> 上，每个节点负责 <strong>整体数据</strong> 的一个 <strong>子集</strong>。</p>
<p><strong>Redis 集群通过划分 hash 槽来将数据分区</strong>。Redis 集群通过分片的方式来保存数据库的键值对：<strong>集群的整个数据库被分为 16384 个哈希槽（slot）</strong>，数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。<strong>如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态</strong>。</p>
<p>通过向节点发送 <a target="_blank" rel="noopener" href="https://redis.io/commands/cluster-addslots"><code>CLUSTER ADDSLOTS</code> (opens new window)</a>命令，可以将一个或多个槽指派给节点负责。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; CLUSTER ADDSLOTS 1 2 3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>集群中的每个节点负责一部分哈希槽，比如集群中有３个节点，则：</p>
<ul>
<li>节点Ａ存储的哈希槽范围是：0 – 5500</li>
<li>节点Ｂ存储的哈希槽范围是：5501 – 11000</li>
<li>节点Ｃ存储的哈希槽范围是：11001 – 16384</li>
</ul>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>当客户端向节点发送与数据库键有关的命令时，接受命令的节点会<strong>计算出命令要处理的数据库属于哪个槽</strong>，并<strong>检查这个槽是否指派给了自己</strong>：</p>
<ul>
<li>如果键所在的槽正好指派给了当前节点，那么当前节点直接执行命令。</li>
<li>如果键所在的槽没有指派给当前节点，那么节点会向客户端返回一个 MOVED 错误，指引客户端重定向至正确的节点。</li>
</ul>
<h4 id="计算键属于哪个槽"><a href="#计算键属于哪个槽" class="headerlink" title="计算键属于哪个槽"></a>计算键属于哪个槽</h4><p>决定一个 key 应该分配到那个槽的算法是：<strong>计算该 key 的 CRC16 结果再模 16384（2^14）</strong>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot = CRC16(KEY) &amp; 16384</span><br></pre></td></tr></table></figure>

<p>当节点计算出 key 所属的槽为 i 之后，节点会根据以下条件判断槽是否由自己负责：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clusterState.slots[i] == clusterState.myself</span><br></pre></td></tr></table></figure>

<h4 id="MOVED-错误"><a href="#MOVED-错误" class="headerlink" title="MOVED 错误"></a>MOVED 错误</h4><p>当节点发现键所在的槽并非自己负责处理的时候，节点就会向客户端返回一个 <code>MOVED</code> 错误，指引客户端转向正在负责槽的节点。</p>
<p><code>MOVED</code> 错误的格式为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>个人理解：MOVED 这种操作有点类似 HTTP 协议中的重定向。</p>
</blockquote>
<h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>Redis 集群的<strong>重新分片操作可以将任意数量的已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点</strong>。</p>
<p>重新分片操作<strong>可以在线进</strong>行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</p>
<p>Redis 集群的重新分片操作由 Redis 集群管理软件 <strong>redis-trib</strong> 负责执行的，redis-trib 通过向源节点和目标节点发送命令来进行重新分片操作。</p>
<p>重新分片的实现原理如下图所示：</p>
<img src="http://dunwu.test.upcdn.net/cs/database/redis/redis-cluster-trib.png" alt="img" style="zoom: 50%;" />

<h3 id="ASK-错误"><a href="#ASK-错误" class="headerlink" title="ASK 错误"></a>ASK 错误</h3><p><code>ASK</code> 错误与 <code>MOVED</code> 的区别在于：<strong>ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施</strong>，在客户端收到关于槽 i 的 ASK 错误之后，客户端只会在接下来的一次命令请求中将关于槽 i 的命令请求发送至 ASK 错误所指示的节点，但这种转向不会对客户端今后发送关于槽 i 的命令请求产生任何影响，客户端仍然会将关于槽 i 的命令请求发送至目前负责处理槽 i 的节点，除非 ASK 错误再次出现。</p>
<p>判断 ASK 错误的过程如下图所示：</p>
<img src="http://dunwu.test.upcdn.net/cs/database/redis/redis-ask.png" alt="img" style="zoom:50%;" />



<h2 id="Redis-Cluster-故障转移"><a href="#Redis-Cluster-故障转移" class="headerlink" title="Redis Cluster 故障转移"></a>Redis Cluster 故障转移</h2><h3 id="复制"><a href="#复制" class="headerlink" title="#复制"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-cluster.html#%E5%A4%8D%E5%88%B6">#</a>复制</h3><p>Redis 复制机制可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-replication.html">Redis 复制</a></p>
<h3 id="故障检测"><a href="#故障检测" class="headerlink" title="#故障检测"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-cluster.html#%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B">#</a>故障检测</h3><blockquote>
<p>什么时候整个集群不可用(cluster_state:fail)?</p>
<ul>
<li><p>如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。 </p>
</li>
<li><p>如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态</p>
</li>
</ul>
</blockquote>
<p><strong>集群中每个节点都会定期向集群中的其他节点发送 PING 消息，以此来检测对方是否在线</strong>。</p>
<p>节点的状态信息可以分为：</p>
<ul>
<li>在线状态；</li>
<li>下线状态（FAIL）;</li>
<li>疑似下线状态（PFAIL），即在规定的时间内，没有应答 PING 消息；</li>
</ul>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="#故障转移"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-cluster.html#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB">#</a>故障转移</h3><ol>
<li>下线主节点的所有从节点中，会有一个从节点被选中。</li>
<li>被选中的从节点会执行 <code>SLAVEOF no one</code> 命令，成为新的主节点。</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>
<li>新的主节点向集群广播一条 PONG 消息，告知其他节点这个从节点已变成主节点。</li>
</ol>
<h4 id="选举新的主节点"><a href="#选举新的主节点" class="headerlink" title="#选举新的主节点"></a><a target="_blank" rel="noopener" href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-cluster.html#%E9%80%89%E4%B8%BE%E6%96%B0%E7%9A%84%E4%B8%BB%E8%8A%82%E7%82%B9">#</a>选举新的主节点</h4><p>Redis 集群选举新的主节点流程基于<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e4bbe7e276c">共识算法：Raft(opens new window)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/14/database/redis/redis-4-%E4%B8%BB%E4%BB%8E%E4%B8%8E%E5%93%A8%E5%85%B5%E4%B8%8E%E9%9B%86%E7%BE%A4/" data-id="cm6lrrhnm000vnsdlbot49dcb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/01/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%8A%80%E6%9C%AF/myCat%20intro/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          mycat intro
        
      </div>
    </a>
  
  
    <a href="/2021/01/14/database/redis/redis-5-%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">redis-5-主从复制与集群</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/">juc</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/juc/oom/">oom</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/oom/">oom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/spring/">spring</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/" rel="tag">JDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/annotation/" rel="tag">annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cluster/" rel="tag">cluster</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jstack/" rel="tag">jstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock/" rel="tag">lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/net/" rel="tag">net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/next/" rel="tag">next</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/" rel="tag">reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-starter/" rel="tag">spring starter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/startup/" rel="tag">startup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transaction/" rel="tag">transaction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtual-machine/" rel="tag">virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vm/" rel="tag">vm</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDK/" style="font-size: 11.11px;">JDK</a> <a href="/tags/annotation/" style="font-size: 10px;">annotation</a> <a href="/tags/cluster/" style="font-size: 10px;">cluster</a> <a href="/tags/git/" style="font-size: 12.22px;">git</a> <a href="/tags/hexo/" style="font-size: 12.22px;">hexo</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/jstack/" style="font-size: 14.44px;">jstack</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/lock/" style="font-size: 10px;">lock</a> <a href="/tags/mysql/" style="font-size: 16.67px;">mysql</a> <a href="/tags/net/" style="font-size: 10px;">net</a> <a href="/tags/next/" style="font-size: 11.11px;">next</a> <a href="/tags/redis/" style="font-size: 15.56px;">redis</a> <a href="/tags/reflect/" style="font-size: 10px;">reflect</a> <a href="/tags/spring-starter/" style="font-size: 10px;">spring starter</a> <a href="/tags/springboot/" style="font-size: 18.89px;">springboot</a> <a href="/tags/startup/" style="font-size: 17.78px;">startup</a> <a href="/tags/transaction/" style="font-size: 11.11px;">transaction</a> <a href="/tags/virtual-machine/" style="font-size: 12.22px;">virtual machine</a> <a href="/tags/vm/" style="font-size: 13.33px;">vm</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring/spring%E6%A1%86%E6%9E%B6-04-bean%E5%8C%85-Bean/">spring框架-04-bean包-Bean</a>
          </li>
        
          <li>
            <a href="/2022/04/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/jdk/JDK-util-HashMap/">JDK-util-HashMap</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E5%B8%B8%E8%A7%81%E4%BA%8B%E5%8A%A1%E5%9C%BA%E6%99%AF/">mysql - 常见事务问题解决方案</a>
          </li>
        
          <li>
            <a href="/2022/03/08/database/mysql/mysql-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">mysql - 面试问题</a>
          </li>
        
          <li>
            <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">交换排序-冒泡排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 Fei Qi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>