<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="https:&#x2F;&#x2F;blog.csdn.net&#x2F;lovejavaydj&#x2F;category_9267782.html   servelet容器是用来处理请求servlet资源，为web client端填充response对象的模块。servlet容器是org.apache.catalina.Container接口的实现。     5.1 Container接口一个容器必须实现 org.apache.ca">
<meta property="og:type" content="article">
<meta property="og:title" content="chapter05-servlet容器">
<meta property="og:url" content="http://example.com/2021/10/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter05-servlet%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="https:&#x2F;&#x2F;blog.csdn.net&#x2F;lovejavaydj&#x2F;category_9267782.html   servelet容器是用来处理请求servlet资源，为web client端填充response对象的模块。servlet容器是org.apache.catalina.Container接口的实现。     5.1 Container接口一个容器必须实现 org.apache.ca">
<meta property="og:locale">
<meta property="og:image" content="https://img-blog.csdn.net/20170115205718774?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170115210024548?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170115210322558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="article:published_time" content="2021-10-07T12:14:36.000Z">
<meta property="article:modified_time" content="2021-10-14T00:59:41.006Z">
<meta property="article:author" content="Fei Qi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdn.net/20170115205718774?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">


<link rel="canonical" href="http://example.com/2021/10/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter05-servlet%E5%AE%B9%E5%99%A8/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en,cn'
  };
</script>

  <title>chapter05-servlet容器 | BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Container%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text">5.1 Container接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E7%AE%A1%E9%81%93%E4%BB%BB%E5%8A%A1"><span class="nav-number">2.</span> <span class="nav-text">5.2 管道任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-Pipeline%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.</span> <span class="nav-text">5.2.1 Pipeline接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-Valve%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.2.</span> <span class="nav-text">5.2.2 Valve接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-ValveContext%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.3.</span> <span class="nav-text">5.2.3 ValveContext接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-Contained%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.4.</span> <span class="nav-text">5.2.4 Contained接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-Wrapper%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">5.3 Wrapper接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-Context%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.</span> <span class="nav-text">5.4 Context接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-Wrapper%E5%BA%94%E7%94%A8Demo"><span class="nav-number">5.</span> <span class="nav-text">5.5 Wrapper应用Demo</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#core-SimpleLoader"><span class="nav-number">5.0.1.</span> <span class="nav-text">core.SimpleLoader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#core-SimplePipeline"><span class="nav-number">5.0.2.</span> <span class="nav-text">core.SimplePipeline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#core-SimpleWrapper"><span class="nav-number">5.0.3.</span> <span class="nav-text">core. SimpleWrapper</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#core-SimpleWrapperValve"><span class="nav-number">5.0.4.</span> <span class="nav-text">core. SimpleWrapperValve</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ex05-pyrmont-valves-ClientIPLoggerValve"><span class="nav-number">5.0.5.</span> <span class="nav-text">ex05.pyrmont. valves. ClientIPLoggerValve</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ex05-pyrmont-valves-HeaderLoggerValve"><span class="nav-number">5.0.6.</span> <span class="nav-text">ex05.pyrmont. valves. HeaderLoggerValve</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pyrmont-startup-Bootstrap1"><span class="nav-number">5.0.7.</span> <span class="nav-text">pyrmont.startup.Bootstrap1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-8-%E8%BF%90%E8%A1%8CDemo"><span class="nav-number">5.0.8.</span> <span class="nav-text">5.5.8 运行Demo</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-Context%E5%BA%94%E7%94%A8Demo"><span class="nav-number">6.</span> <span class="nav-text">5.6 Context应用Demo</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-1-core-SimpleContextValve"><span class="nav-number">6.0.1.</span> <span class="nav-text">5.6.1 core.SimpleContextValve</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-2-core-SimpleContextMapper"><span class="nav-number">6.0.2.</span> <span class="nav-text">5.6.2 core.SimpleContextMapper</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7%E5%B0%8F%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">5.7小结</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">246</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter05-servlet%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          chapter05-servlet容器
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-07 20:14:36" itemprop="dateCreated datePublished" datetime="2021-10-07T20:14:36+08:00">2021-10-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-14 08:59:41" itemprop="dateModified" datetime="2021-10-14T08:59:41+08:00">2021-10-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lovejavaydj/category_9267782.html">https://blog.csdn.net/lovejavaydj/category_9267782.html</a></p>
<!--socket转化为request和response这项工作已经被httpConnector和httpProcessor解决了，那么如何处理请求交给servlet容器，比如日志、添加请求头、业务..-->

<p>servelet容器是用来处理请求servlet资源，为web client端填充response对象的模块。servlet容器是org.apache.catalina.Container接口的实现。</p>
<!--org.apache.catalina包是接口, -org.apache.catalina.core包是具体实现-->



<h2 id="5-1-Container接口"><a href="#5-1-Container接口" class="headerlink" title="5.1 Container接口"></a>5.1 Container接口</h2><p>一个容器必须实现 org.apache.catalina.Container 接口。如第4章中看到，传递一个 Container 实例给 Connector 对象的 setContainer()方法，然后Connector 就可以调用 container 的 invoke() 方法，重新看第4章中Bootstrap 类的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpConnector connector = <span class="keyword">new</span> HttpConnector();</span><br><span class="line">SimpleContainer container = <span class="keyword">new</span> SimpleContainer();</span><br><span class="line">connector.setContainer(container);</span><br></pre></td></tr></table></figure>

<p>首先需要注意的是，对于 Catalina 容器，在不同的概念上，它一共有4种不同类型的容器：</p>
<p>1》Engine：表示整个 Catalina 的 servlet 引擎<br>2》Host：表示一拥有数个上下文(context)的虚拟主机<br>3》Context：表示一 Web 应用，一个 context 包含一个或多个wrapper<br>4》Wrapper：表示一个独立的 servlet</p>
<p>上面的每个概念级别都由org.apache.catalin包中的接口表示。Engine、Host、Context和 Wrapper 接口都实现了 Container 接口。它们的标准实现是 StandardEngine,StandardHost, StandardContext, StandardWrapper，它们都是org.apache.catalina.core 包的一部分。</p>
<p>图 5.1 表示了 Container 接口和它的子接口的结构图。注意接口都是org.apache.catalina 包的，而所有的类都是 org.apache.catalina.core 包的。<br><img src="https://img-blog.csdn.net/20170115205718774?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>图 5.1: Container相关类图</p>
<blockquote>
<p>注意:</p>
<p>所有的类都扩展自抽象类 ContainerBase。</p>
<p>Catalina 功能部署不一定需要所有的四种类型容器。例如本章第一个应用程序就仅包括一个 wrapper，而第二个应用程序包含 Context 和wrapper 容器模块。在本章附带的应用程序中不需要host和engine。</p>
</blockquote>
<p>一个容器可以有一个或多个低层次上的子容器。例如，一个 Context 有一个或多个 wrapper；一个host有零个或多个context。 然而 wrapper 作为最底层容器，则不能包含子容器。把个容器添加到另一容器中可以使用 Container 接口中定义的 addChild()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加子容器；Host容器下只能添加Context容器。。。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Container child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除子容器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Container child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名称查找子容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Container <span class="title">findChild</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找子容器集合</span></span><br><span class="line">    <span class="keyword">public</span> Container[] findChildren();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它组件的get/set方法，包括：载入器（Loader）、记录器（Logger）、Session管理器（Manager）、领域（Realm）、资源（Resource）</span></span><br><span class="line"></span><br><span class="line">    容器是Tomcat的核心，所以才将所有组件都与容器连接起来，而且通过Lifecyle接口，使我们可以只启动容器组件就可以了（他帮我们启动其它组件）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：这是组合模式的一种使用</p>
</blockquote>
<p>一个容器还包含一系列的部分如 Lodder、Loggee、Manager、Realm 和Resources。我们将会在后边章节中讨论这些组成部分。</p>
<p>更有意思的是Container接口被设计成Tomcat管理员可以通过server.xml文件配置来决定其工作方式的模式。它通过一个 pipeline和容器中一系列的valves来实现，这些内容将会在下一节 “管道流水线任务”中讨论。</p>
<h2 id="5-2-管道任务"><a href="#5-2-管道任务" class="headerlink" title="5.2 管道任务"></a>5.2 管道任务</h2><p>本章节介绍当connector 调用容器(container)的 invoke() 方法会发生什么。后续子章节中讨论org.apache.catalina 中4个相关接口：Pipeline, Valve, ValveContext和Contained。</p>
<p>这里是 Container 接口中 invoke() 方法在org.apache.catalina.core.ContainerBase 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    pipeline.invoke(request, response); <span class="comment">//这里pipeline是容器中 Pipeline 接口的一个实例。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个管道(pipeline)中包含了该容器要调用的所有任务。每一个阀门(valve)表示着一特定任务。一个容器的管道中有一个<font color="red">基本的阀门</font>，但是我们可以添加任意想要添加的阀门。阀门的数目定义为添加的阀门的个数（不包括基本阀门）。有趣的是，阀门可以通过编辑 Tomcat 的配置文件 server.xml 来动态地添加。</p>
<p>一个管道线就像一个过滤链，每一个阀门像一个过滤器。跟过滤器一样，一个阀门可以操作处理传递给它的 request 和 response 对象。一个阀门完成处理后，它则进一步调用管道中的下一个阀门，基本阀门总是在最后才被调用。</p>
<p>一个容器可以有一个管道。当容器的 invoke() 方法被调用时，容器将通过管道处理，且管理调用在其中的第一个阀门，一个接一个阀门的调用处理，直到所有阀门都被处理完毕。可以想象管道的 invoke() 方法的伪代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invoke each valve added to the pipeline</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;valves.length; n++) &#123;</span><br><span class="line">    valve[n].invoke( ... );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then, invoke the basic valve</span></span><br><span class="line">basicValve.invoke( ... );</span><br></pre></td></tr></table></figure>

<p>但是，Tomcat 设计者通过引入org.apache.catalina.ValveContext接口选择了一种不同处理方式。这里将介绍它是如何工作的。</p>
<p><a href="">容器不会硬编码它的invoke()方法被调用时应该做什么。反而，容器调用的是管道的 invoke()方法</a>。管道接口的 invoke() 方法跟容器接口的invoke() 方法签名相同，方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br></pre></td></tr></table></figure>

<p>一个Pipeline的 invoke() 方法可以如下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">   <span class="comment">// Invoke the first Valve in this pipeline for this request</span></span><br><span class="line">   (<span class="keyword">new</span> SimplePipelineValveContext()).invokeNext(request, response);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><a href="">现在，管道必须保证添加给它的阀门必须如基本阀门一样被调用一次。</a><strong>管道通过创建一</strong><br><strong>个 ValveContext 接口的实例来实现</strong>。ValveContext 是管道的内部类，这样 ValveContext 就可以访问管道中所有成员。ValveContext 中最重要的方法是 invokeNext() 方法：</p>
<p>在创建一个 ValveContext 实例之后，管道调用 ValveContext 的 invokeNext()方法。ValveContext 会先唤起管道中的第一个阀门，然后第一个阀门会在完成它的任务之前继续唤起下一个阀门。ValveContext 将它自己传递给每一个阀门，那么该阀门就可以调用 ValveContext 的 invokeNext() 方法。</p>
<p>Valve 接口的 invoke()签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">invoke</span><span class="params">(Request request, Response response,</span></span></span><br><span class="line"><span class="function"><span class="params">    ValveContext ValveContext)</span> <span class="keyword">throws</span> IOException, ServletException</span></span><br></pre></td></tr></table></figure>

<p>一个Valve的 invoke() 方法可以如下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response,</span></span></span><br><span class="line"><span class="function"><span class="params">    ValveContext valveContext)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// Pass the request and response on to the next valve in our pipeline</span></span><br><span class="line">    valveContext.invokeNext(request, response);</span><br><span class="line">    <span class="comment">// now perform what this valve is supposed to do，</span></span><br><span class="line">    ...比如下文的HeaderLoggerValve的逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.apache.catalina.core.StandardPipeline 类是所有容器中Pipeline的实现。在Tomcat4 中，这个类中有一个<a href="">内部类 StandardPipelineValveContext</a> 实现了ValveContext 接口，</p>
<blockquote>
<p>仔细推敲会发现，每个Valve都是先调用ValveContext的invokeNext，然后才做自己的工作，所以“第一个”被 pipeline调用的Valve，实际却是最后一个完成自己工作的，有点类似“压栈”操作，第一个Valve最先被压进去，却是最后一个从堆栈中弹出来 的。如果不信，可以做个试验，眼见为实。</p>
</blockquote>
<p>Listing 5.1: Tomcat 4中的StandardPipelineValveContext 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pipeline的内部类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardPipelineValveContext</span> <span class="keyword">implements</span> <span class="title">ValveContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> stage = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeNext</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> subscript = stage;</span><br><span class="line">        stage = stage + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Invoke the requested Valve for the current request thread</span></span><br><span class="line">        <span class="keyword">if</span> (subscript &lt; valves.length) &#123;</span><br><span class="line">            valves[subscript].invoke(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((subscript == valves.length) &amp;&amp; (basic != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            basic.invoke(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException (sm.getString(<span class="string">&quot;standardPipeline.noValve&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>invokeNext()方法中使用subscript和stage记住哪个阀门被唤醒。当第一次唤醒时，subscript的值是 0，stage的值是 1。所以，第一个阀门(数组下标是0)被唤醒，管道的阀门获得 ValveContext 实例接收到ValveContext实例并调用它的 invokeNext() 方法。这时subscript的值是 1， 所以第二个阀门被唤醒，然后一步步地这样继续进行。<!--疑惑，stage作为类变量，是线程安全的吗--></p>
<p>当invokeNext()在最后一个阀门中调用时，subscript值等于总阀门的个数。因此这时，基本阀门被唤醒调用。</p>
<h3 id="5-2-1-Pipeline接口"><a href="#5-2-1-Pipeline接口" class="headerlink" title="5.2.1 Pipeline接口"></a><strong>5.2.1 Pipeline接口</strong></h3><p>我们提到的Pipeline接口的第一种方法是invoke()方法，容器调用它来开始调用管道中的阀门和基本阀门。Pipeline接口允许我们通过addValve()方法添加一个新的阀门或者通过removeValve()方法删除一个阀门。最后，可以使用 setBasic()方法来分配一个基本阀门给管道，使用getBasic()方法会得到基本阀门。最后调用的基本阀门负责处理请求和相应的响应。</p>
<p>Listing 5.3: Pipeline接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">public interface Pipeline &#123;</span><br><span class="line">    public Valve getBasic();</span><br><span class="line">    public void setBasic(Valve valve);</span><br><span class="line">    public void addValve(Valve valve);</span><br><span class="line">    public Valve[] getValves();</span><br><span class="line">    public void invoke(Request request, Response response)</span><br><span class="line">        throws IOException, ServletException;</span><br><span class="line">    public void removeValve(Valve valve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-Valve接口"><a href="#5-2-2-Valve接口" class="headerlink" title="5.2.2 Valve接口"></a><strong>5.2.2 Valve接口</strong></h3><p>Value接口表示一个阀门，该组件负责处理请求。该接口有两个方法，invoke() 和getInfo()方法。invoke()方法如上面已讨论过，getInfo()方法返回阀门的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">public interface Valve &#123;</span><br><span class="line">    public String getInfo();</span><br><span class="line">    public void invoke(Request request, Response response,</span><br><span class="line">        ValveContext context) throws IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-ValveContext接口"><a href="#5-2-3-ValveContext接口" class="headerlink" title="5.2.3 ValveContext接口"></a><strong>5.2.3 ValveContext接口</strong></h3><p>ValveContext接口有两个方法，invokeNext()方法如上已讨论，getInfo()方法会返回valveContext的实现信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">public interface ValveContext &#123;</span><br><span class="line">    public String getInfo();</span><br><span class="line">    public void invokeNext(Request request, Response response)</span><br><span class="line">        throws IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-Contained接口"><a href="#5-2-4-Contained接口" class="headerlink" title="5.2.4 Contained接口"></a><strong>5.2.4 Contained接口</strong></h3><p>阀门类可以选择性实现org.apache.catalina.Contained接口。此接口指定实现类最多与一个相关联容器实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line"></span><br><span class="line">public interface Contained &#123;</span><br><span class="line">    public Container getContainer();</span><br><span class="line">    public void setContainer(Container container);</span><br><span class="line">&#125;123456</span><br></pre></td></tr></table></figure>



<h2 id="5-3-Wrapper接口"><a href="#5-3-Wrapper接口" class="headerlink" title="5.3 Wrapper接口"></a>5.3 Wrapper接口</h2><p>org.apache.catalina.Wrapper 接口表示一个包装器。包装器是表示单个servlet定义的容器。包装器继承了Container接口，并且添加了几个方法。包装器的实现类负责管理其servlet 的生命中期，包括 servlet 的init()、service()、和 destroy()方法。由于包装器是最底层的容器，所以不可以将子容器添加给它。<a href="">如果 addChild()方法被调用，则会产生IllegalArgumantException 异常。</a></p>
<p>包装器接口中重要方法有 allocate() 和 load() 方法。allocate() 方法负责定位该包装器表示的 servlet 的实例。allocate()方法必须考虑一个 servlet 是否实现了javax.servlet.SingleThreadModel 接口，该部分内容将会在 11 章中进行讨论。load() 方法负责加载和初始化 servlet 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 载入并加载servlet，在它的子类StandardWrapper中直接调用的loadServlet方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法会返回已加载的servlet类，还要考虑它是否实现了SingleThreadModel</span></span><br><span class="line"><span class="function">Servlet <span class="title">allocate</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-Context接口"><a href="#5-4-Context接口" class="headerlink" title="5.4 Context接口"></a><strong>5.4 Context接口</strong></h2><p>一个 context 容器表示一个 web 应用。一个 context 通常含有一个或多个包装器作为其子容器。重要的方法包括 addWrapper(), createWrapper() 等方法。该接口将会在第 12 章中详细介绍。</p>
<h2 id="5-5-Wrapper应用Demo"><a href="#5-5-Wrapper应用Demo" class="headerlink" title="5.5 Wrapper应用Demo"></a><strong>5.5 Wrapper应用Demo</strong></h2><p>这个应用Demo展示了如何写一个简单的容器模型。该应用程序的核心类是ex05.pyrmont.core.SimpleWrapper，它实现了 Wrapper 接口。SimpleWrapper类包括一个 Pipeline（由 ex05.pyrmont.core.SimplePipeline 实现）和一个Loader 类（ex05.pyrmont.core.SimpeLoader）来加载一个 servlet。管道包括一个基本阀门（ex05.pyrmont.core.SimpleWrapperValve）和两个另外的阀门<br>(ex05.pyrmont.core.ClientIPLoggerValve 和ex05.pyrmont.core.HeaderLoggerValve)。该应用的类结构图如图 5.3 所示：</p>
<p><img src="https://img-blog.csdn.net/20170115210024548?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>注意：该容器使用的是Tomcat 4的默认连接器</p>
<p>包装器包装的是前面章节已经使用过的 ModernServlet类。这个应用程序表示一个 servlet 容器可以只有一单一的包装器构成。这些类都没有完整的实现，只是实现了必要方法。接下来看程序的具体实现。</p>
<h4 id="core-SimpleLoader"><a href="#core-SimpleLoader" class="headerlink" title="core.SimpleLoader"></a><strong>core.SimpleLoader</strong></h4><p>容器中加载 servlet 的任务分配给了 Loader 实现。在该程序中 SimpleLoader就是一个 Loader 实现。它知道如何定位一个 servlet，并且通过 getClassLoader()获得一个 java.lang.ClassLoader 实例用来查找 servlet 类位置。</p>
<ul>
<li>SimpleLoader定义了 3 个变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个是 WEB_ROOT 用来指明在哪里查找 servlet 类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEB_ROOT =</span><br><span class="line">        System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + File.separator + <span class="string">&quot;webroot&quot;</span>;</span><br><span class="line"><span class="comment">//另外两个变量是 ClassLoader 和 Container：</span></span><br><span class="line">ClassLoader classLoader = <span class="keyword">null</span>;</span><br><span class="line">Container container = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>SimpleLoader 类的构造器初始化类加载器，以便于准备返回一个 SimpleWrapper实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL[] urls = <span class="keyword">new</span> URL[l];</span><br><span class="line">        URLStreamHandler streamHandler = <span class="keyword">null</span>;</span><br><span class="line">        File classPath = <span class="keyword">new</span> File(WEB_ROOT);</span><br><span class="line">        String repository = (<span class="keyword">new</span> URL(<span class="string">&quot;file&quot;</span>, <span class="keyword">null</span>,</span><br><span class="line">            classPath.getCanonicalPath() + File.separator)).toString() ;</span><br><span class="line">        urls[<span class="number">0</span>] = <span class="keyword">new</span> URL(<span class="keyword">null</span>, repository, streamHandler);</span><br><span class="line">        classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的构造器用于初始化一个类加载器如前面章节所用的一样。container变量表示容器跟该加载器是相关联。</p>
<p>注意：加载器将在第8章详细讨论。</p>
<h4 id="core-SimplePipeline"><a href="#core-SimplePipeline" class="headerlink" title="core.SimplePipeline"></a><strong>core.SimplePipeline</strong></h4><p>SimplePipeline 实现了 org.apache.catalina.Pipeline 接口。该类中最重要的方法是 invoke() 方法，其中包括了一个内部类 SimplePipelineValveContext。SimplePipelineValveContext 实现了 org.apache.catalina.ValveContext 接口如上面章节所介绍。</p>
<h4 id="core-SimpleWrapper"><a href="#core-SimpleWrapper" class="headerlink" title="core. SimpleWrapper"></a><strong>core. SimpleWrapper</strong></h4><p>该类实现了 org.apache.catalina.Wrapper 接口并且实现了 allocate() 方法和load() 方法，并声明了如下变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private Loader loader;</span><br><span class="line">protected Container parent &#x3D; null;</span><br></pre></td></tr></table></figure>

<p>loader 变量用于加载一个 servlet 类。parent 变量表示该包装器的父容器。这意味着，该容器可以是其它容器的子容器，例如 Context。</p>
<p>需要特别注意 getLoader()方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Loader <span class="title">getLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (loader);</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (parent.getLoader());</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getLoader()方法用于返回一个 Loader 对象用于加载一个 servlet 类。如果一个包装器跟一个加载器相关联，会返回该加载器。否则返回其父容器的加载器，如果没有父容器，则返回 null。</p>
<p>SimpleWrapper 类有一个管道和该管道的基本阀门。这些工作在SimpleWrapper 的构造函数中完成。</p>
<p>Listing 5.8:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中，pipeline是 SimplePipeline 类的一个实例：</span></span><br><span class="line"><span class="keyword">private</span> SimplePipeline pipeline = <span class="keyword">new</span> SimplePipeline(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipeline.setBasic(<span class="keyword">new</span> SimpleWrapperValve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="core-SimpleWrapperValve"><a href="#core-SimpleWrapperValve" class="headerlink" title="core. SimpleWrapperValve"></a><strong>core. SimpleWrapperValve</strong></h4><p>SimpleWrapperValve 类是一个给 SimpleWrapper 类专门处理请求的<a href="">基本阀门</a>。它实现了 org.apache.catalina.Valve 接口和org.apache.catalina.Contained接口。最重要的方法是 invoke() 方法，如 Listing5.9 所示：</p>
<p>Listing 5.9: SimpleWrapperValve类的invoke()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    SimpleWrapper wrapper = (SimpleWrapper) getContainer();</span><br><span class="line">    ServletRequest sreq = request.getRequest();</span><br><span class="line">    ServletResponse sres = response.getResponse();</span><br><span class="line">    Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line">    HttpServletRequest hreq = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (sreq <span class="keyword">instanceof</span> HttpServletRequest)</span><br><span class="line">      hreq = (HttpServletRequest) sreq;</span><br><span class="line">    HttpServletResponse hres = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (sres <span class="keyword">instanceof</span> HttpServletResponse)</span><br><span class="line">      hres = (HttpServletResponse) sres;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a servlet instance to process this request</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      servlet = wrapper.allocate();</span><br><span class="line">      <span class="keyword">if</span> (hres!=<span class="keyword">null</span> &amp;&amp; hreq!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        servlet.service(hreq, hres);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        servlet.service(sreq, sres);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">由于 SimpleWrapperValve 被当做一基本阀门来使用，所以它的 invoke() 方法不需要invokeNext()方法。</font></p>
<p>invoke()方法调用SimpleWrapper的allocate()方法获得servlet的实例。然后调用 servlet 的 service() 方法。注意包装器管道的基本阀门唤醒的是 servlet 的 service ()方法，而不是 wrapper自己。</p>
<h4 id="ex05-pyrmont-valves-ClientIPLoggerValve"><a href="#ex05-pyrmont-valves-ClientIPLoggerValve" class="headerlink" title="ex05.pyrmont. valves. ClientIPLoggerValve"></a><strong>ex05.pyrmont. valves. ClientIPLoggerValve</strong></h4><p>ClientIPLoggerValve 是一个阀门，它打印客户端的 IP 地址到控制台。该类如 Listing5.10:</p>
<p>Listing 5.10: ClientIPLoggerValve类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex05.pyrmont.valves;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Valve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.ValveContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Contained;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Container;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientIPLoggerValve</span> <span class="keyword">implements</span> <span class="title">Valve</span>, <span class="title">Contained</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Container container;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass this request on to the next valve in our pipeline</span></span><br><span class="line">    valveContext.invokeNext(request, response);</span><br><span class="line">    System.out.println(<span class="string">&quot;Client IP Logger Valve&quot;</span>);</span><br><span class="line">    ServletRequest sreq = request.getRequest();</span><br><span class="line">    System.out.println(sreq.getRemoteAddr());</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.container = container;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p> invoke() 方法，它的第一件事情是调用阀门上下文 invokeNext ()方法来唤醒下一个阀门，然后它会打印出请求对象的 getRemoteAddr() 方法的输出。</p>
</blockquote>
<h4 id="ex05-pyrmont-valves-HeaderLoggerValve"><a href="#ex05-pyrmont-valves-HeaderLoggerValve" class="headerlink" title="ex05.pyrmont. valves. HeaderLoggerValve"></a><strong>ex05.pyrmont. valves. HeaderLoggerValve</strong></h4><p>该类跟 ClientIPLoggerValve 类非常相似。HeaderLoggerValve 是一个阀门打印请求头部信息到控制台上。该类如 Listing5.11：</p>
<p>Listing 5.11: HeaderLoggerValve 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex05.pyrmont.valves;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Valve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.ValveContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Contained;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Container;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderLoggerValve</span> <span class="keyword">implements</span> <span class="title">Valve</span>, <span class="title">Contained</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Container container;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass this request on to the next valve in our pipeline</span></span><br><span class="line">    valveContext.invokeNext(request, response);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Header Logger Valve&quot;</span>);</span><br><span class="line">    ServletRequest sreq = request.getRequest();</span><br><span class="line">    <span class="keyword">if</span> (sreq <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">      HttpServletRequest hreq = (HttpServletRequest) sreq;</span><br><span class="line">      Enumeration headerNames = hreq.getHeaderNames();</span><br><span class="line">      <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">        String headerName = headerNames.nextElement().toString();</span><br><span class="line">        String headerValue = hreq.getHeader(headerName);</span><br><span class="line">        System.out.println(headerName + <span class="string">&quot;:&quot;</span> + headerValue);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      System.out.println(<span class="string">&quot;Not an HTTP Request&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.container = container;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>其 invoke() 方法，该方法首先调用阀门的 invokeNext()方法唤醒下一个阀门。然后打印出头部的值。</p>
</blockquote>
<h4 id="pyrmont-startup-Bootstrap1"><a href="#pyrmont-startup-Bootstrap1" class="headerlink" title="pyrmont.startup.Bootstrap1"></a><strong>pyrmont.startup.Bootstrap1</strong></h4><p>Bootstrap1 用于启动这个应用程序。</p>
<p>Listing 5.12: Bootstrap1 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex05.pyrmont.startup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.core.SimpleLoader;</span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.core.SimpleWrapper;</span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.valves.ClientIPLoggerValve;</span><br><span class="line"><span class="keyword">import</span> ex05.pyrmont.valves.HeaderLoggerValve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Loader;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Pipeline;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Valve;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Wrapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.http.HttpConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* call by using http://localhost:8080/ModernServlet,</span></span><br><span class="line"><span class="comment">   but could be invoked by any name */</span></span><br><span class="line"></span><br><span class="line">    HttpConnector connector = <span class="keyword">new</span> HttpConnector();</span><br><span class="line">    Wrapper wrapper = <span class="keyword">new</span> SimpleWrapper();</span><br><span class="line">    <span class="comment">//创建 HttpConnector 和 SimpleWrapper 类的实例后，分配ModernServlet 给 SimpleWrapper 的 setServletClass() 方法，告诉包装器要加载的类的名字以便于加载。</span></span><br><span class="line">    wrapper.setServletClass(<span class="string">&quot;ModernServlet&quot;</span>);</span><br><span class="line">    <span class="comment">//然后创建了加载器和两个阀门，然后将其加载器赋给包装器：</span></span><br><span class="line">    Loader loader = <span class="keyword">new</span> SimpleLoader();</span><br><span class="line">    Valve valve1 = <span class="keyword">new</span> HeaderLoggerValve();</span><br><span class="line">    Valve valve2 = <span class="keyword">new</span> ClientIPLoggerValve();</span><br><span class="line">    wrapper.setLoader(loader);</span><br><span class="line">     <span class="comment">//然后把两个阀门添加到包装器管道中：</span></span><br><span class="line">    ((Pipeline) wrapper).addValve(valve1);</span><br><span class="line">    ((Pipeline) wrapper).addValve(valve2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后，把包装器当做容器添加到连接器中，然后初始化并启动连接器：</span></span><br><span class="line">    connector.setContainer(wrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      connector.initialize();</span><br><span class="line">      connector.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// make the application wait until we press a key.</span></span><br><span class="line">      System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-8-运行Demo"><a href="#5-5-8-运行Demo" class="headerlink" title="5.5.8 运行Demo"></a><strong>5.5.8 运行Demo</strong></h4><p>在 Linux 下，使用冒号分开两个库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .&#x2F;lib&#x2F;servlet.jar:.&#x2F; ex05.pyrmont.startup.Bootstrap11</span><br></pre></td></tr></table></figure>

<p>可以使用下面的 URL 来请求servlet：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:80801</span><br></pre></td></tr></table></figure>

<p>浏览器将会显示从 ModernServlet 得到的响应回复。跟下面相似的内容会显示在控制台上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ModernServlet -- init</span><br><span class="line">Client IP Logger Valve</span><br><span class="line">127.0.0.1</span><br><span class="line">------------------------------------</span><br><span class="line">Header Logger Valve</span><br><span class="line">host:localhost:8080</span><br><span class="line">user-agent:Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko&#x2F;20100101 Firefox&#x2F;50.0</span><br><span class="line">accept:text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">accept-language:zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3</span><br><span class="line">accept-encoding:gzip, deflate</span><br><span class="line">connection:keep-alive</span><br><span class="line">upgrade-insecure-requests:1</span><br><span class="line">------------------------------------</span><br></pre></td></tr></table></figure>

<!--果然最先添加的valve，是最后执行的，递归操作，类似stack-->



<h2 id="5-6-Context应用Demo"><a href="#5-6-Context应用Demo" class="headerlink" title="5.6 Context应用Demo"></a><strong>5.6 Context应用Demo</strong></h2><p>在本章第一个Demo中，介绍了如何部署一个仅仅包括一个包装器(Wrapper)的简单web应用。该程序仅包括一个 servlet。也许会有一些应用仅仅需要一个 servlet，可是大多数的网络应用需要多个 servlet。在这些应用中，我们需要一个跟包装器（wrapper）不同的容器：上下文（context）。</p>
<p>第二个Demo将会示范如何使用一个包含两个包装器的上下文来包装两个servlet 类。当有多于一个包装器时，需要一个 map 来处理这些子容器——本Demo中使用Context容器，对于特殊的请求可以使用特殊的子容器来处理。</p>
<blockquote>
<p>注意 使用 map 方法是在 Tomcat4 中，Tomcat 5 使用了另一种机制来查找子容器。</p>
</blockquote>
<p>在这个程序中，mapper 是 ex05.pyrmont.core.SimpleContextMapper 类的一个实例，它继承Tomcat 4 中org.apache.catalina.Mapper 接口。一个容器也可以有多个 mapper 来支持多协议。例如容器可以用一个 mapper 来支持 HTTP 协议，而使用另一个 mapper 来支持 HTTPS 协议。Listing5.13 提供了 Tomcat4 中的 Mapper 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina;</span><br><span class="line"></span><br><span class="line">public interface Mapper &#123;</span><br><span class="line">    public Container getContainer();</span><br><span class="line">    public void setContainer(Container container);</span><br><span class="line">    public String getProtocol();</span><br><span class="line">    ublic void setProtocol(String protocol);</span><br><span class="line">    ublic Container map(Request request, boolean update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getContainer()获取该容器的 mapper，setContainer() 方法用于关联一个容器到mapper。getProtocol() 返回该 mapper 负责处理的协议，setProtocol()用于分配该容器要处理的协议。map()方法返回处理一个特殊请求的子容器。<br><img src="https://img-blog.csdn.net/20170115210322558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUphdmFZREo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>图 5.4 是该Demo结构图。</p>
<p>SimpleContext表示一个上下文，它使用SimpleContextMapper作为它的mapper，SimpleContextValve 作为它的基本阀门。该上下文包括两个阀门ClientIPLoggerValve 和 HeaderLoggerValve。用 SimpleWrapper 表示的两个包装器作为该上下文的子容器被添加到其中。包装器 SimpleWrapperValve 作为它的基阀门，但是没有其它的阀门了。</p>
<p>该Context应用程序使用同一个加载器、两个阀门。<a href="">但是加载器和阀门是跟该Context关联的，而不是跟包装器关联</a>。这样，两个包装器就可以都使用该加载器。该Conetext被当做连接器的容器。因此，连接器每次收到一个 HTTP 请求可以使用上下文的 invoke() 方法。根据前面介绍的内容，其余的不难理解。</p>
<p>1》一个容器有一个管道，容器的 invoke() 方法会调用管道的invoke()方法<br>2》管道的 invoke()方法会调用添加到容器中的阀门的 invoke()方法，然后调用基本阀门的 invoke()方法<br>3》在一包装器中，基本阀门负责加载相关的 servlet 类并对请求作出相应<br>4》在一个有子容器的上下文中，基阀门使用 mapper 来查找负责处理请求的子容器。如果一个子容器被找到，子容器的 invoke() 方法会被调用，然后返回步骤 1</p>
<p>现在让我们看看实现中的处理流程。</p>
<p>SimpleContext 的 invoke() 方法调用管道的 invoke() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line">        pipeline.invoke(request, response);</span><br><span class="line">&#125;1234</span><br></pre></td></tr></table></figure>

<p>pipeline是SimplePipeline 类实例，用来表示管道，它的 invoke()方法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line">    &#x2F;&#x2F; Invoke the first Valve in this pipeline for this request</span><br><span class="line">    (new SimplePipelineValveContext()).invokeNext(request, response);</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure>

<p>如“管道任务”一节中介绍的，该段代码唤醒所有阀门，然后调用基阀门的invoke()方法。在SimpleContext中SimpleContextValve代表着基阀门。在它的invoke()方法中SimpleContextValve使用上下文的mapper是查找一个包装器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Select the Wrapper to be used for this Request</span><br><span class="line">Wrapper wrapper &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    wrapper &#x3D; (Wrapper) context.map(request, true);</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure>

<p>如果一个包装器被找到，它的invoke()方法会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrapper.invoke(request, response);1</span><br></pre></td></tr></table></figure>

<p>本Demo着通过SimpleWrapper表示一个包装器。如下是其invoke()方法，和SimpleContext类的invoke()方法完全一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line">    pipeline.invoke(request, response);</span><br><span class="line">&#125;1234</span><br></pre></td></tr></table></figure>

<p>管道是SimplePipeline的一个实例，其调用方法已在上面列出。本Demo中包装器是SimpleWrapperValve的实例，它除了有基阀门外没其它阀门。包装器的管道调用SimpleWrapperValve类的invoke()方法，它分配一个servlet并调用其service()方法，如上文“Wrapper应用Demo”一节中所述。</p>
<p>注意，包装器不与加载器相关联，而是上下文与其关联。 因此，SimpleWrapper类的getLoader()方法返回父级（Context）的加载器。</p>
<p>有4个类：SimpleContext, SimpleContextValve, SimpleContextMapper和Bootstrap2在前面小节没被提到，在下面将讨论。</p>
<h4 id="5-6-1-core-SimpleContextValve"><a href="#5-6-1-core-SimpleContextValve" class="headerlink" title="5.6.1 core.SimpleContextValve"></a><strong>5.6.1 core.SimpleContextValve</strong></h4><p>此类作为SimpleContext的基阀门。它的最重要的方法invoke()代码如Listing 5.14：</p>
<p>Listing 5.14: SimpleContextValve类的invoke()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response, ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// Validate the request and response object types</span></span><br><span class="line">    <span class="keyword">if</span> (!(request.getRequest() <span class="keyword">instanceof</span> HttpServletRequest) ||</span><br><span class="line">      !(response.getResponse() <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;     <span class="comment">// NOTE - Not much else we can do generically</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disallow any direct access to resources under WEB-INF or META-INF</span></span><br><span class="line">    HttpServletRequest hreq = (HttpServletRequest) request.getRequest();</span><br><span class="line">    String contextPath = hreq.getContextPath();</span><br><span class="line">    String requestURI = ((HttpRequest) request).getDecodedRequestURI();</span><br><span class="line">    String relativeURI =</span><br><span class="line">      requestURI.substring(contextPath.length()).toUpperCase();</span><br><span class="line"></span><br><span class="line">    Context context = (Context) getContainer();</span><br><span class="line">    <span class="comment">// Select the Wrapper to be used for this Request</span></span><br><span class="line">    Wrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      wrapper = (Wrapper) context.map(request, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      badRequest(requestURI, (HttpServletResponse) response.getResponse());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">      notFound(requestURI, (HttpServletResponse) response.getResponse());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ask this Wrapper to process this Request</span></span><br><span class="line">    response.setContext(context);</span><br><span class="line">    wrapper.invoke(request, response);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-2-core-SimpleContextMapper"><a href="#5-6-2-core-SimpleContextMapper" class="headerlink" title="5.6.2 core.SimpleContextMapper"></a><strong>5.6.2 core.SimpleContextMapper</strong></h4><p>SimpleContextMapper类实现Tomcat4中的org.apache.catalina.Mapper接口，并被设计成和SimpleContext实例相关联。</p>
<p>Listing 5.15: The SimpleContext 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleContextMapper</span> <span class="keyword">implements</span> <span class="title">Mapper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SimpleContext context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(container <span class="keyword">instanceof</span> SimpleContext))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span><br><span class="line">        (<span class="string">&quot;Illegal type of container&quot;</span>);</span><br><span class="line">    context = (SimpleContext) container;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProtocol</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the child Container that should be used to process this Request,</span></span><br><span class="line"><span class="comment">   * based upon its characteristics.  If no such child Container can be</span></span><br><span class="line"><span class="comment">   * identified, return &lt;code&gt;null&lt;/code&gt; instead.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">map</span><span class="params">(Request request, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Identify the context-relative URI to be mapped</span></span><br><span class="line">    String contextPath =</span><br><span class="line">      ((HttpServletRequest) request.getRequest()).getContextPath();</span><br><span class="line">    String requestURI = ((HttpRequest) request).getDecodedRequestURI();</span><br><span class="line">    String relativeURI = requestURI.substring(contextPath.length());</span><br><span class="line">    <span class="comment">// Apply the standard request URI mapping rules from the specification</span></span><br><span class="line">    Wrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">    String servletPath = relativeURI;</span><br><span class="line">    String pathInfo = <span class="keyword">null</span>;</span><br><span class="line">    String name = context.findServletMapping(relativeURI);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span>)</span><br><span class="line">      wrapper = (Wrapper) context.findChild(name);</span><br><span class="line">    <span class="keyword">return</span> (wrapper);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们传递一个不是SimpleContext实例的容器给setContainer()方法时，它将抛出IllegalArgumentException异常。map()方法返回一个子容器（wrapper），它负责处理请求。map()方法接收二个参数，一个是请求对象，一个是布尔值。这里的方法实现忽略了第二个参数。该方法执行的操作是检索从请求对象中得到上下文路径，并使用context的findServletMapping()方法获取与其路径关联的名称。 如果找到名称，它使用context的findChild()方法来获取Wrapper的实例。</p>
<p><strong>5.6.3 ex05.pyrmont.core.SimpleContext</strong></p>
<p>SimpleContext类是本Demo中Context一个实现。它是分配给连接器的主容器。然而，每个单独的servlet的处理由包装器执行。本应用Demo有2个servlet：PrimitiveServlet和ModernServlet，如此一来就有2个包装器。每个包装器都有名字。名称为Primitive是PrimitiveServlet的包装器，Modern是ModernServlet的包装器。对于每个请求，SimpleContext要决定调用哪个包装器，这个必须使用包装器的名称映射匹配请求URL。在此应用程序中，我们有两个可用于调用2个包装器的URL模式。第一个模式是/ Primitive，它映射到Primitive包装器。 第二个模式是/ Modern，它被映射到Modern包装器。 当然，对于给定的servlet，我们可以使用多个模式。 我们只需要添加这些模式即可。</p>
<p>从Container和Context接口有很多方法，SimpleContext必须实现。 大多数方法是留白，但是这些与映射相关的方法给予了实现代码。 这些方法如下：</p>
<p>1》addServletMapping()方法——添加URL/包装器名称映射对。 添加的每一个，可用于调用具有给定名称的包装器<br>2》findServletMapping()方法——获取和URL对应的包装器名称。这个方法用于为一个指定的URL查找哪个包装器应该被调用。如果给定的模式之前未通过addServletMapping()方法添加过，那么此方法将返回null<br>3》addMapper()方法——添加一个mapper给context。SimpleContext申明mapper和mappers变量。mapper为默认的mapper，mappers包含SimpleContext实例中所有mapper。第一个添加到SimpleContext中的mapper将作为默认mapper<br>4》findMapper()方法——查找当前mapper。在SimpleContext中，返回默认mapper。<br>5》map()方法——返回负责处理此请求的包装器</p>
<p>此外SimpleContext也提供了addChild(),findChild(), 和findChildren()方法实现。addChild()用于添加一个wrapper给context；findChild()用于获取指定名称的wrapper；findChildren()返回SimpleContext实例当中的所有包装器。</p>
<p><strong>5.6.4 ex05.pyrmont.startup.Bootstrap2</strong></p>
<p>Listing 5.16: The Bootstrap2 类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package ex05.pyrmont.startup;</span><br><span class="line"></span><br><span class="line">import ex05.pyrmont.core.SimpleContext;</span><br><span class="line">import ex05.pyrmont.core.SimpleContextMapper;</span><br><span class="line">import ex05.pyrmont.core.SimpleLoader;</span><br><span class="line">import ex05.pyrmont.core.SimpleWrapper;</span><br><span class="line">import ex05.pyrmont.valves.ClientIPLoggerValve;</span><br><span class="line">import ex05.pyrmont.valves.HeaderLoggerValve;</span><br><span class="line">import org.apache.catalina.Context;</span><br><span class="line">import org.apache.catalina.Loader;</span><br><span class="line">import org.apache.catalina.Mapper;</span><br><span class="line">import org.apache.catalina.Pipeline;</span><br><span class="line">import org.apache.catalina.Valve;</span><br><span class="line">import org.apache.catalina.Wrapper;</span><br><span class="line">import org.apache.catalina.connector.http.HttpConnector;</span><br><span class="line"></span><br><span class="line">public final class Bootstrap2 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HttpConnector connector &#x3D; new HttpConnector();</span><br><span class="line">    Wrapper wrapper1 &#x3D; new SimpleWrapper();</span><br><span class="line">    wrapper1.setName(&quot;Primitive&quot;);</span><br><span class="line">    wrapper1.setServletClass(&quot;PrimitiveServlet&quot;);</span><br><span class="line">    Wrapper wrapper2 &#x3D; new SimpleWrapper();</span><br><span class="line">    wrapper2.setName(&quot;Modern&quot;);</span><br><span class="line">    wrapper2.setServletClass(&quot;ModernServlet&quot;);</span><br><span class="line"></span><br><span class="line">    Context context &#x3D; new SimpleContext();</span><br><span class="line">    context.addChild(wrapper1);</span><br><span class="line">    context.addChild(wrapper2);</span><br><span class="line"></span><br><span class="line">    Valve valve1 &#x3D; new HeaderLoggerValve();</span><br><span class="line">    Valve valve2 &#x3D; new ClientIPLoggerValve();</span><br><span class="line"></span><br><span class="line">    ((Pipeline) context).addValve(valve1);</span><br><span class="line">    ((Pipeline) context).addValve(valve2);</span><br><span class="line"></span><br><span class="line">    Mapper mapper &#x3D; new SimpleContextMapper();</span><br><span class="line">    mapper.setProtocol(&quot;http&quot;);</span><br><span class="line">    context.addMapper(mapper);</span><br><span class="line">    Loader loader &#x3D; new SimpleLoader();</span><br><span class="line">    context.setLoader(loader);</span><br><span class="line">    &#x2F;&#x2F; context.addServletMapping(pattern, name);</span><br><span class="line">    context.addServletMapping(&quot;&#x2F;Primitive&quot;, &quot;Primitive&quot;);</span><br><span class="line">    context.addServletMapping(&quot;&#x2F;Modern&quot;, &quot;Modern&quot;);</span><br><span class="line">    connector.setContainer(context);</span><br><span class="line">    try &#123;</span><br><span class="line">      connector.initialize();</span><br><span class="line">      connector.start();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; make the application wait until we press a key.</span><br><span class="line">      System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657</span><br></pre></td></tr></table></figure>

<p>main()方法由实例化Tomcat默认连接器和两个wrappers，wrapper1和wrapper2开始。 这些包装器被命名为Primitive和Modern。 Primitive和Modern的servlet类是PrimitiveServlet和ModernServlet。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpConnector connector &#x3D; new HttpConnector();</span><br><span class="line">Wrapper wrapper1 &#x3D; new SimpleWrapper();</span><br><span class="line">wrapper1.setName(&quot;Primitive&quot;);</span><br><span class="line">wrapper1.setServletClass(&quot;PrimitiveServlet&quot;);</span><br><span class="line">Wrapper wrapper2 &#x3D; new SimpleWrapper();</span><br><span class="line">wrapper2.setName(&quot;Modern&quot;);</span><br><span class="line">wrapper2.setServletClass(&quot;ModernServlet&quot;);1234567</span><br></pre></td></tr></table></figure>

<p>然后，main()方法创建一个SimpleContext实例，并将wrapper1和wrapper2添加为SimpleContext的子容器。它还实例化两个阀门ClientIPLoggerValve和HeaderLoggerValve，并将它们添加到SimpleContext。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Context context &#x3D; new SimpleContext();</span><br><span class="line">context.addChild(wrapper1);</span><br><span class="line">context.addChild(wrapper2);</span><br><span class="line">Valve valve1 &#x3D; new HeaderLoggerValve();</span><br><span class="line">Valve valve2 &#x3D; new ClientIPLoggerValve();</span><br><span class="line">((Pipeline) context).addValve(valve1);</span><br><span class="line">((Pipeline) context).addValve(valve2);1234567</span><br></pre></td></tr></table></figure>

<p>接下来，它从SimpleMapper类构造一个映射器对象并将其添加到SimpleContext。 此映射器负责在上下文中查找子容器来处理HTTP请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mapper mapper &#x3D; new SimpleContextMapper();</span><br><span class="line">mapper.setProtocol(&quot;http&quot;);</span><br><span class="line">context.addMapper(mapper);123</span><br></pre></td></tr></table></figure>

<p>要加载servlet类，则需要一个加载器。 在这里我们使用SimpleLoader类，正如在第一个应用Demo一样。 但是，不是将它添加到两个包装器，而是loader被添加到context中。 包装器将使用它的getLoader()找到加载器，因为context是其父级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loader loader &#x3D; new SimpleLoader();</span><br><span class="line">context.setLoader(loader);12</span><br></pre></td></tr></table></figure>

<p>现在，是时候添加servlet映射了。 我们为2个包装器添加了2个匹配模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; context.addServletMapping(pattern, name);</span><br><span class="line">context.addServletMapping(&quot;&#x2F;Primitive&quot;, &quot;Primitive&quot;);</span><br><span class="line">context.addServletMapping(&quot;&#x2F;Modern&quot;, &quot;Modern&quot;);123</span><br></pre></td></tr></table></figure>

<p>最后，将上下文指定为连接器的容器，并初始化和启动连接器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connector.setContainer(context);</span><br><span class="line">try &#123;</span><br><span class="line">    connector.initialize();</span><br><span class="line">    connector.start();1234</span><br></pre></td></tr></table></figure>

<p><strong>5.6.5 运行Demo</strong></p>
<p>在 Linux 下，使用冒号分开两个库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .&#x2F;lib&#x2F;servlet.jar:.&#x2F; ex05.pyrmont.startup.Bootstrap21</span><br></pre></td></tr></table></figure>

<p>调用PrimitiveServlet，可以使用下面的 URL 来请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;Primitive</span><br></pre></td></tr></table></figure>

<p>调用ModernServlet，可以使用下面的 URL 来请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;Modern</span><br></pre></td></tr></table></figure>

<h2 id="5-7小结"><a href="#5-7小结" class="headerlink" title="5.7小结"></a><strong>5.7小结</strong></h2><p>容器是连接器之后的第二个主模块。 容器使用许多其它模块，如Loader，Logger，Manager等。有4种类型容器：Engine，Host，Context和Wrapper。 Catalina部署没有必需所有4个容器都存在。 本章中的两个应用Demo展现了：部署可以具有单个Wrapper或含有几个wrapper的Context。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%208%20%E5%AE%9E%E6%88%98/Chapter-4%20%E5%BC%95%E5%85%A5%E6%B5%81/" rel="prev" title="chapter4-引入流">
                  <i class="fa fa-chevron-left"></i> chapter4-引入流
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/11/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-quick-sorting/" rel="next" title="quick sorting">
                  quick sorting <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
