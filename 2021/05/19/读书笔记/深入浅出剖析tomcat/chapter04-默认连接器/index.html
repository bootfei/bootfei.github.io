<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="简介第三章的连接器只是一个学习版，是为了介绍tomcat的默认连接器而写。第四章会深入讨论下tomcat的默认连接器（这里指的是tomcat4的默认连接器，现在该连接器已经不推荐使用，而是被Coyote取代）。  tomcat的连接器是一个独立的模块，可被插入到servlet容器中。目前已经有很多连接器的实现，包括Coyote，mod_jk，mod_jk2，mod_webapp等。tomcat的连">
<meta property="og:type" content="article">
<meta property="og:title" content="chapter04-默认连接器">
<meta property="og:url" content="http://example.com/2021/05/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter04-%E9%BB%98%E8%AE%A4%E8%BF%9E%E6%8E%A5%E5%99%A8/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="简介第三章的连接器只是一个学习版，是为了介绍tomcat的默认连接器而写。第四章会深入讨论下tomcat的默认连接器（这里指的是tomcat4的默认连接器，现在该连接器已经不推荐使用，而是被Coyote取代）。  tomcat的连接器是一个独立的模块，可被插入到servlet容器中。目前已经有很多连接器的实现，包括Coyote，mod_jk，mod_jk2，mod_webapp等。tomcat的连">
<meta property="og:locale">
<meta property="og:image" content="http://sishuok.com/forum/upload/2012/4/12/35840e616ec2b6f657d035945d0bd813__%E6%9C%AA%E5%91%BD%E5%90%8D.jpg">
<meta property="og:image" content="http://example.com/Users/qifei/Documents/blog/source/_posts/读书笔记/深入浅出剖析tomcat/chapter02-默认连接器时序图.png">
<meta property="article:published_time" content="2021-05-19T00:32:39.000Z">
<meta property="article:modified_time" content="2021-10-07T12:02:12.778Z">
<meta property="article:author" content="Fei Qi">
<meta property="article:tag" content="how tomcat works">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://sishuok.com/forum/upload/2012/4/12/35840e616ec2b6f657d035945d0bd813__%E6%9C%AA%E5%91%BD%E5%90%8D.jpg">


<link rel="canonical" href="http://example.com/2021/05/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter04-%E9%BB%98%E8%AE%A4%E8%BF%9E%E6%8E%A5%E5%99%A8/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en,cn'
  };
</script>

  <title>chapter04-默认连接器 | BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP1-1%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">HTTP1.1新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Connector%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">Connector接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HttpConnector%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">HttpConnector类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAServerSocket"><span class="nav-number">4.1.</span> <span class="nav-text">创建ServerSocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4HttpProcessor%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="nav-number">4.2.</span> <span class="nav-text">维护HttpProcessor对象池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BE%9BHttp%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1"><span class="nav-number">4.3.</span> <span class="nav-text">提供Http请求服务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HttpProcessor%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">HttpProcessor类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%AD%E7%9A%84HttpConnector%E7%B1%BB%E7%9A%84run%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">第三章中的HttpConnector类的run方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84HttpConnector%E7%B1%BB%E7%9A%84run%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">默认的HttpConnector类的run方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84HttpProcessor%E5%AE%9E%E4%BE%8B%E7%9A%84run%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">默认的HttpProcessor实例的run方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Connector%E5%92%8CProcessor%E7%BA%BF%E7%A8%8B%E4%BA%92%E7%9B%B8%E9%80%9A%E7%9F%A5%E5%AF%B9%E6%96%B9"><span class="nav-number">5.4.</span> <span class="nav-text">Connector和Processor线程互相通知对方</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Processor%E7%9A%84assign-%E6%96%B9%E6%B3%95-%E8%BF%90%E8%A1%8C%E5%9C%A8Connector%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.4.1.</span> <span class="nav-text">Processor的assign()方法 (运行在Connector线程)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Processor%E7%9A%84await-%E6%96%B9%E6%B3%95-%E8%BF%90%E8%A1%8C%E5%9C%A8Processor%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.4.2.</span> <span class="nav-text">Processor的await()方法  (运行在Processor线程)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">5.4.3.</span> <span class="nav-text">问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SimpleContainer%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">SimpleContainer类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">7.</span> <span class="nav-text">验证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BootStrap%E7%B1%BB"><span class="nav-number">7.1.</span> <span class="nav-text">BootStrap类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">7.2.</span> <span class="nav-text">启动命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90tomcat/chapter04-%E9%BB%98%E8%AE%A4%E8%BF%9E%E6%8E%A5%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          chapter04-默认连接器
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-19 08:32:39" itemprop="dateCreated datePublished" datetime="2021-05-19T08:32:39+08:00">2021-05-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-07 20:02:12" itemprop="dateModified" datetime="2021-10-07T20:02:12+08:00">2021-10-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>第三章的连接器只是一个学习版，是为了介绍tomcat的默认连接器而写。第四章会深入讨论下tomcat的默认连接器（这里指的是tomcat4的默认连接器，现在该连接器已经不推荐使用，而是被Coyote取代）。</p>
<p> tomcat的连接器是一个独立的模块，可被插入到servlet容器中。目前已经有很多连接器的实现，包括Coyote，mod_jk，mod_jk2，mod_webapp等。tomcat的连接器需要满足以下要求：</p>
<p>​     （1）实现org.apache.catalina.Connector接口；</p>
<p>​     （2）负责创建实现了org.apache.catalina.Request接口的request对象；</p>
<p>​     （3）负责创建实现了org.apache.catalina.Response接口的response对象。</p>
<blockquote>
<p>tomcat4的连接器与第三章实现的连接器类似，</p>
<ol>
<li>等待http请求，创建request和response对象，</li>
<li>调用org.apache.catalina.Container的invoke方法将request对象和response对象传入container。在invoke方法中，container负责载入servlet类，调用其call方法，管理session，记录日志等工作</li>
</ol>
</blockquote>
<p>​     tomcat的默认连接器中有一些优化操作没有在chap3的连接器中实现。首先是提供了一个对象池，避免频繁创建一些创佳代价高昂的对象。其次，默认连接器中很多地方使用了字符数组而非字符串。</p>
<p>​     本章的程序是实现一个使用默认连接器的container。但本章的重点不在于container，而是connector。另一个需要注意的是，默认的connector实现了HTTP1.1，也可以服务HTTP1.0和HTTP0.9的客户端。</p>
<h2 id="HTTP1-1新特性"><a href="#HTTP1-1新特性" class="headerlink" title="HTTP1.1新特性"></a>HTTP1.1新特性</h2><p>持久连接</p>
<p>块编码</p>
<p>状态码100的使用</p>
<h2 id="Connector接口"><a href="#Connector接口" class="headerlink" title="Connector接口"></a>Connector接口</h2><p>tomcat的connector必须实现org.apache.catalina.Connector接口。该接口有很多方法，最重要的是getContainer，setContainer，createRequest和createResponse。</p>
<blockquote>
</blockquote>
<p>setContainer方法用于将connector和container联系起来，getContainer则可以返回响应的container，createRequest和createResponse则分别负责创建request和response对象。</p>
<p> org.apache.catalina.connector.http.HttpConnector类是Connector接口的一个实现，将在下一章讨论。响应的uml图如下所示</p>
<img src="http://sishuok.com/forum/upload/2012/4/12/35840e616ec2b6f657d035945d0bd813__%E6%9C%AA%E5%91%BD%E5%90%8D.jpg" alt="img" style="zoom:75%;" />

<blockquote>
<p>注意，connector和container是一对一的关系，而connector和processor是一对多的关系。</p>
</blockquote>
<img src="/Users/qifei/Documents/blog/source/_posts/读书笔记/深入浅出剖析tomcat/chapter02-默认连接器时序图.png" style="zoom:67%;" />

<h2 id="HttpConnector类"><a href="#HttpConnector类" class="headerlink" title="HttpConnector类"></a>HttpConnector类</h2><p>在第三章中，已经实现了一个与org.apache.catalina.connector.http.HttpConnector类似的简化版connector。它实现了org.apache.catalina.Connector接口，java.lang.Runnable接口（确保在自己的线程中运行）和org.apache.catalina.Lifecycle接口。Lifecycle具体内容将在第六章介绍。</p>
<p>下面要介绍一些与第三章不同的功能：创建ServerSocket，维护HttpProcessor池，提供Http请求服务。</p>
<h3 id="创建ServerSocket"><a href="#创建ServerSocket" class="headerlink" title="创建ServerSocket"></a>创建ServerSocket</h3><p>HttpConnector的initialize方法会调用一个私有方法open，返回一个java.net.ServerSocket实例，赋值给成员变量serverSocket。这里并没有直接调用ServerSocket的构造方法，而是用过open方法调用ServerSocket的一个工厂方法来实现。具体的实现方式可参考ServerSocketFactory类和DefaultServerSocketFactory类（都在org.apache.catalina.net包内）。</p>
<h3 id="维护HttpProcessor对象池"><a href="#维护HttpProcessor对象池" class="headerlink" title="维护HttpProcessor对象池"></a>维护HttpProcessor对象池</h3><p>在第三章的程序中，每次使用HttpProcessor时，都会创建一个实例。而在tomcat的默认connector中，使用了一个HttpProcessor的对象池， 其中的每个对象都在其自己的线程中使用。因此，connector可同时处理多个http请求。</p>
<p>HttpConnector维护了一个HttpProcessor的对象池，避免了频繁的创建HttpProcessor对象。该对象池使用java.io.Stack实现。</p>
<blockquote>
<p>在HttpConnector中，创建的HttpProcessor数目由两个变量决定：minProcessors和maxProcessors。</p>
<p>默认情况下，minProcessors=5，maxProcessors=20，可通过其setter方法修改。</p>
</blockquote>
<ol>
<li>初始化<br>HttpConnector会创建minProcessors个HttpProcessor对象。若不够用就继续创建，直到到达maxProcessors个。此时，若还不够，则后达到的http请求将被忽略。若是不希望对maxProcessors进行限制，可以将其置为负数。此外，变量curProcessors表示当前已有的HttpProcessor实例数目。</li>
</ol>
<p>​     下面是start方法中初始化HttpProcessor对象的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (curProcessors &lt; minProcessors) &#123;   </span><br><span class="line">     <span class="keyword">if</span> ((maxProcessors &gt; <span class="number">0</span>) &amp;&amp; (curProcessors &gt;= maxProcessors))   </span><br><span class="line">       <span class="keyword">break</span>;   </span><br><span class="line">     HttpProcessor processor = newProcessor();   </span><br><span class="line">     recycle(processor);   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建HttpProcessor<br>其中newProcessor方法负责创建HttpProcessor实例，并将curProcessors加1。</li>
<li>recycle方法<br>将新创建的HttpProcessor对象入栈。</li>
<li>每个HttpProcessor对象负责解析请求行和请求头，填充request对象。因此，每个HttpProcessor对象都关联一个request对象和response对象。HttpProcessor的构造函数会调用HttpConnector的createRequest方法和createResponse方法。</li>
</ol>
<h3 id="提供Http请求服务"><a href="#提供Http请求服务" class="headerlink" title="提供Http请求服务"></a>提供Http请求服务</h3><p>HttpConnector类的主要业务逻辑在其run方法中（例如第三章的程序中那样）。run方法中维持一个循环体，该循环体内，服务器等待http请求，直到HttpConnector对象回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!stopped) &#123;   </span><br><span class="line">     Socket socket = <span class="keyword">null</span>;   </span><br><span class="line">     <span class="keyword">try</span> &#123;   </span><br><span class="line">       socket = serverSocket.accept();   </span><br><span class="line">     ...  </span><br></pre></td></tr></table></figure>

<p>对于每个http请求，通过调用其私有方法createProcessor获得一个HttpProcessor对象。</p>
<blockquote>
<p>这里，实际上是从HttpProcessor的对象池中拿一个对象。</p>
</blockquote>
<p>注意，若是此时对象池中已经没有空闲的HttpProcessor实例可用，则createProcessor返回null。此时，服务器会直接关闭该连接，忽略该请求。如代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (processor == <span class="keyword">null</span>) &#123;   </span><br><span class="line">       <span class="keyword">try</span> &#123;   </span><br><span class="line">         log(sm.getString(<span class="string">&quot;httpConnector.noProcessor&quot;</span>));   </span><br><span class="line">         socket.close();   </span><br><span class="line">       &#125;   </span><br><span class="line">       ...   </span><br><span class="line">       <span class="keyword">continue</span>;    </span><br></pre></td></tr></table></figure>

<p>若是createProcessor方法返回不为空，则调用该HttpProcessor实例的assign方法，并将客户端socket对象作为参数传入给HttpProcessor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processor.assign(socket); </span><br></pre></td></tr></table></figure>

<p>这时，HttpProcessor实例开始读取socket的输入流，解析http请求。这里有一个重点，assign方法必须立刻返回，不能等待HttpProcessor实例完成解析再返回，这样才能处理后续的http请求。由于每个HttpProcessor都可以使用它自己的线程进行处理，所以这并不难实现。</p>
<h2 id="HttpProcessor类"><a href="#HttpProcessor类" class="headerlink" title="HttpProcessor类"></a>HttpProcessor类</h2><p>HttpProcessor类与第三章中的实现相类似。本章讨论下它的assign方法是如何实现异步功能的（即可同时处理多个http请求）。</p>
<p>在第三章中，HttpConnector类运行在其自己的线程中。在处理下一个请求之前，它必须等待当前请求的处理完成。</p>
<h3 id="第三章中的HttpConnector类的run方法"><a href="#第三章中的HttpConnector类的run方法" class="headerlink" title="第三章中的HttpConnector类的run方法"></a>第三章中的HttpConnector类的run方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      ...   </span><br><span class="line">     <span class="keyword">while</span> (!stopped) &#123;   </span><br><span class="line">       Socket socket = <span class="keyword">null</span>;   </span><br><span class="line">       <span class="keyword">try</span> &#123;   </span><br><span class="line">         socket = serversocket.accept();   </span><br><span class="line">       &#125;        <span class="keyword">catch</span> (Exception e) &#123;   </span><br><span class="line">         <span class="keyword">continue</span>;   </span><br><span class="line">       &#125;   </span><br><span class="line">       <span class="comment">// Hand this socket off to an Httpprocessor   </span></span><br><span class="line">       HttpProcessor processor = <span class="keyword">new</span> Httpprocessor(<span class="keyword">this</span>);   <span class="comment">//没有使用processor池</span></span><br><span class="line">       processor.process(socket);   <span class="comment">//同步的！！！</span></span><br><span class="line">     &#125;   </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>

<p>process方法是同步的。</p>
<h3 id="默认的HttpConnector类的run方法"><a href="#默认的HttpConnector类的run方法" class="headerlink" title="默认的HttpConnector类的run方法"></a>默认的HttpConnector类的run方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      ...   </span><br><span class="line">     <span class="keyword">while</span> (!stopped) &#123;   </span><br><span class="line">       Socket socket = <span class="keyword">null</span>;   </span><br><span class="line">       <span class="keyword">try</span> &#123;   </span><br><span class="line">         socket = serversocket.accept();   </span><br><span class="line">       &#125;        <span class="keyword">catch</span> (Exception e) &#123;   </span><br><span class="line">         <span class="keyword">continue</span>;   </span><br><span class="line">       &#125;   </span><br><span class="line">       <span class="comment">// Hand this socket off to an Httpprocessor   </span></span><br><span class="line">       HttpProcessor processor = createProcessor(); </span><br><span class="line">       processor.start();</span><br><span class="line">       processor.assign(socket);   </span><br><span class="line">     &#125;   </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>

<p>但是在tomcat的默认连接器中，HttpProcessor实现了java.lang.Runnable接口，每个HttpProcessor的实例都可以在其自己的线程中运行，成为“处理器线程”。HttpConnector创建每个HttpProcessor实例时，都会调用其start方法，启动其处理器线程。</p>
<h3 id="默认的HttpProcessor实例的run方法"><a href="#默认的HttpProcessor实例的run方法" class="headerlink" title="默认的HttpProcessor实例的run方法"></a>默认的HttpProcessor实例的run方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">  <span class="comment">// Process requests until we receive a shutdown signal   </span></span><br><span class="line">  <span class="keyword">while</span> (!stopped) &#123;   </span><br><span class="line">    <span class="comment">// Wait for the next socket to be assigned by HttpConnector  </span></span><br><span class="line">    Socket socket = await();     <span class="comment">//阻塞了！！！</span></span><br><span class="line">    <span class="keyword">if</span> (socket == <span class="keyword">null</span>)   </span><br><span class="line">      <span class="keyword">continue</span>;   </span><br><span class="line">    <span class="comment">// Process the request from this socket   </span></span><br><span class="line">    <span class="keyword">try</span> &#123;   </span><br><span class="line">      process(socket);   </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;   </span><br><span class="line">      log(<span class="string">&quot;process.invoke&quot;</span>, t);   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// Finish up this request   </span></span><br><span class="line">    connector.recycle(<span class="keyword">this</span>);   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="comment">// Tell threadStop() we have shut ourselves down successfully   </span></span><br><span class="line">  <span class="keyword">synchronized</span> (threadSync) &#123;   </span><br><span class="line">    threadSync.notifyAll();   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这个循环体做的事是：<a href="">等待HttpConnector给予socket</a>，<a href="">进行处理</a>，<a href="">调用connector的recycle方法将当前的HttpProcessor入栈</a>。</p>
<blockquote>
<p>注意，循环体在执行到await方法时会暂停当前处理器线程的控制流，直到获取到一个新的socket。换句话说，在HttpConnector调用HttpProcessor实例的assign方法前，HttpProcessor在await()会一直等下去。但是，assign方法并不是在当前线程中执行的，而是在HttpConnector的run方法中被调用的。这里称HttpConnector实例所在的线程为连接器线程。</p>
</blockquote>
<h3 id="Connector和Processor线程互相通知对方"><a href="#Connector和Processor线程互相通知对方" class="headerlink" title="Connector和Processor线程互相通知对方"></a>Connector和Processor线程互相通知对方</h3><p>那么，assign方法是如何通知await方法它已经被调用了呢？方法是使用一个成为available的boolean变量和java.lang.Object的wait和notifyAll方法。</p>
<blockquote>
<p>注意，wait方法会暂停本对象所在的当前线程，使其处于等待状态，直到另一线程调用了该对象的notify或notifyAll方法。</p>
</blockquote>
<h4 id="Processor的assign-方法-运行在Connector线程"><a href="#Processor的assign-方法-运行在Connector线程" class="headerlink" title="Processor的assign()方法 (运行在Connector线程)"></a>Processor的assign()方法 (运行在Connector线程)</h4><blockquote>
<p>在Connector的run()中被调用,processor.assign(socket)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Socket socket)</span> </span>&#123; </span><br><span class="line">   <span class="comment">// Wait for the processor to get the previous socket </span></span><br><span class="line">   <span class="keyword">while</span> (available) &#123; </span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">       wait(); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">     &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">// Store the newly available Socket and notify our thread </span></span><br><span class="line">   <span class="keyword">this</span>.socket = socket; </span><br><span class="line">   available = <span class="keyword">true</span>; </span><br><span class="line">   notifyAll(); </span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Processor的await-方法-运行在Processor线程"><a href="#Processor的await-方法-运行在Processor线程" class="headerlink" title="Processor的await()方法  (运行在Processor线程)"></a>Processor的await()方法  (运行在Processor线程)</h4><blockquote>
<p>在Connector的run()中被调用,processor.start()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> available = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The socket we are currently processing a request for.  This object</span></span><br><span class="line"><span class="comment">     * is used for inter-thread communication only.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> Socket socket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Socket <span class="title">await</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="comment">// Wait for the Connector to provide a new Socket </span></span><br><span class="line">    <span class="keyword">while</span> (!available) &#123; </span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">       wait(); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">     &#125; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Notify the Connector that we have received this Socket </span></span><br><span class="line">   Socket socket = <span class="keyword">this</span>.socket; </span><br><span class="line">   available = <span class="keyword">false</span>; </span><br><span class="line">   notifyAll(); </span><br><span class="line">   <span class="keyword">return</span> (socket); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当处理器线程刚刚启动时，available值为false，线程在循环体内wait，直到任意一个HttpProcessor线程调用了notify或notifyAll方法。也就是说，调用wait方法会使线程暂定，直到连接器线程调用HttpProcessor实例的notify或notifyAll方法。<!--wait()是Object的方法，所以wait()会释放锁资源，从而其他processor线程执行await()不会block了--></p>
<p>当一个新socket被设置后，连接器线程调用HttpProcessor的assign方法。此时available变量的值为false，会跳过循环体，该socket对象被设置到HttpProcessor实例的socket变量中。然后连接器变量设置了available为true，调用notifyAll方法，唤醒HttpProcessor线程。此时available的值为true，跳出循环体，将socket对象赋值给局部变量，将available设置为false，调用notifyAll方法，并将给socket返回。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li><p>为什么await方法要使用一个局部变量保存socket对象的引用，而不返回实例的socket变量呢？是因为在当前socket被处理完之前，可能会有新的http请求过来，产生新的socket对象将其覆盖。 <!--虽然现在的processor是从线程池里面获取复用，每个processor线程都有自己的对象（比如socket,availbale），但是考虑这种线程安全的情况：使用栈内的局部变量，保证线程独有。否则，对象的域socket（句柄），可能会被重新赋值，指向堆中的新的socket对象--></p>
</li>
<li><p>为什么await方法要调用notifyAll方法？考虑这种情况，当available变量的值还是true时，有一个新的socket达到。在这种情况下，连接器线程会在assign方法的循环体中暂停，直到处理器线程调用notifyAll方法。</p>
</li>
</ul>
<!--对象的变量-->

<h2 id="SimpleContainer类"><a href="#SimpleContainer类" class="headerlink" title="SimpleContainer类"></a>SimpleContainer类</h2><p>本章目的是介绍如何使用默认连接器。该应用程序包括SimpleContainer和BootStrap类。SimpleContainer类实现了Container接口。这里只是实现了Container的invoke方法，因为默认连接器会调用该方法。<font color="red">invoke方法会创建一个类载入器，载入相关的servlet类，并调用该servlet类的serivce()方法</font>，该方法与第三章中的HttpProcessor类的process方法类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex04.pyrmont.core;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleContainer</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEB_ROOT =</span><br><span class="line">    System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + File.separator  + <span class="string">&quot;webroot&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String servletName = ( (HttpServletRequest) request).getRequestURI();</span><br><span class="line">    servletName = servletName.substring(servletName.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    URLClassLoader loader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      URL[] urls = <span class="keyword">new</span> URL[<span class="number">1</span>];</span><br><span class="line">      URLStreamHandler streamHandler = <span class="keyword">null</span>;</span><br><span class="line">      File classPath = <span class="keyword">new</span> File(WEB_ROOT);</span><br><span class="line">      String repository = (<span class="keyword">new</span> URL(<span class="string">&quot;file&quot;</span>, <span class="keyword">null</span>, classPath.getCanonicalPath() + File.separator)).toString() ;</span><br><span class="line">      urls[<span class="number">0</span>] = <span class="keyword">new</span> URL(<span class="keyword">null</span>, repository, streamHandler);</span><br><span class="line">      loader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      System.out.println(e.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">    Class myClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      myClass = loader.loadClass(servletName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      System.out.println(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      servlet = (Servlet) myClass.newInstance();</span><br><span class="line">      servlet.service((HttpServletRequest) request, (HttpServletResponse) response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      System.out.println(e.toString());</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="BootStrap类"><a href="#BootStrap类" class="headerlink" title="BootStrap类"></a>BootStrap类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HttpConnector connector = <span class="keyword">new</span> HttpConnector();</span><br><span class="line">    SimpleContainer container = <span class="keyword">new</span> SimpleContainer();</span><br><span class="line">    connector.setContainer(container);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      connector.initialize();</span><br><span class="line">      connector.start(); <span class="comment">//注意这里还仅仅是单纯的函数调用,眼下跟线程还没关系,还没run呢</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// make the application wait until we press any key.</span></span><br><span class="line">      System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath ./lib/servlet.jar;./   ex04.pyrmont.startup.Bootstrap</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Connector要在自己的线程中将socket赋予给Processor，所以Processor在启动run以后，需要等待socket</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/how-tomcat-works/" rel="tag"># how tomcat works</a>
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%81%A5%E5%A3%AE%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1/" rel="prev" title="健壮后端服务">
                  <i class="fa fa-chevron-left"></i> 健壮后端服务
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/05/19/database/Mybatis/Mybatis-PageHelper%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0/" rel="next" title="Mybatis-PageHelper插件实现">
                  Mybatis-PageHelper插件实现 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
