<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="Abstract：第二章开头指出，要编写正确的并发程序，关键在与：在访问共享的可变状态时，需要正确的管理。第二章通过同步，避免多个线程同时访问相同的变量 (在《高性能MySQL》书中，这叫做避免并发)；而本章介绍如何共享和发布对象，从而使多个线程可以同时安全的访问相同的变量。这两章合在一起就形成了构建线程安全类以及通过java.util.concurrent类库来构建并发应用程序的重要基础。 sy">
<meta property="og:type" content="article">
<meta property="og:title" content="chapter3对象的共享">
<meta property="og:url" content="http://example.com/2020/11/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter3%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="Abstract：第二章开头指出，要编写正确的并发程序，关键在与：在访问共享的可变状态时，需要正确的管理。第二章通过同步，避免多个线程同时访问相同的变量 (在《高性能MySQL》书中，这叫做避免并发)；而本章介绍如何共享和发布对象，从而使多个线程可以同时安全的访问相同的变量。这两章合在一起就形成了构建线程安全类以及通过java.util.concurrent类库来构建并发应用程序的重要基础。 sy">
<meta property="og:locale">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190316230729391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTUxOTgz,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-11-13T01:19:03.000Z">
<meta property="article:modified_time" content="2021-03-20T03:13:16.360Z">
<meta property="article:author" content="Fei Qi">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190316230729391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTUxOTgz,size_16,color_FFFFFF,t_70">


<link rel="canonical" href="http://example.com/2020/11/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter3%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en,cn'
  };
</script>

  <title>chapter3对象的共享 | BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B1%E6%95%88%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.</span> <span class="nav-text">失效数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%8E%9F%E5%AD%90%E7%9A%8464%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">非原子的64位操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.3.</span> <span class="nav-text">锁和可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.</span> <span class="nav-text">volatile变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E9%80%B8%E5%87%BA"><span class="nav-number">2.</span> <span class="nav-text">发布与逸出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.</span> <span class="nav-text">直接发布对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E6%8E%A5%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.</span> <span class="nav-text">间接发布对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">安全对象构造过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD"><span class="nav-number">3.</span> <span class="nav-text">线程封闭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ad-hoc-%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD"><span class="nav-number">3.1.</span> <span class="nav-text">Ad-hoc 线程封闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%B0%81%E9%97%AD"><span class="nav-number">3.2.</span> <span class="nav-text">栈封闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E7%B1%BB"><span class="nav-number">3.3.</span> <span class="nav-text">ThreadLocal 类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">不可变性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%9F%9F"><span class="nav-number">4.1.</span> <span class="nav-text">final域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Volatile%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%8F%91%E5%B8%83%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1-%E6%88%91%E7%A7%B0%E4%B9%8B%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%B0%81%E9%97%AD"><span class="nav-number">4.2.</span> <span class="nav-text">示例：使用Volatile类型来发布不可变对象(我称之为对象封闭)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E7%94%9F%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.2.1.</span> <span class="nav-text">发生竞态条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.2.2.</span> <span class="nav-text">解决竞态条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%91%E4%B8%AA%E4%BA%BA%E7%9A%84%E7%96%91%E6%83%91"><span class="nav-number">4.3.</span> <span class="nav-text">我个人的疑惑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E7%9A%84%E5%88%86%E6%9E%90"><span class="nav-number">4.3.1.</span> <span class="nav-text">我的分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E8%80%85%E7%9A%84%E6%9C%AC%E6%84%8F"><span class="nav-number">4.3.2.</span> <span class="nav-text">作者的本意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Arrays-copyOf%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">4.3.3.</span> <span class="nav-text">使用Arrays.copyOf的目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8final%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">4.3.4.</span> <span class="nav-text">使用final的目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8volatile%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">4.3.5.</span> <span class="nav-text">使用volatile的目的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83"><span class="nav-number">5.</span> <span class="nav-text">安全发布</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%8F%91%E5%B8%83%EF%BC%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%A2%AB%E7%A0%B4%E5%9D%8F"><span class="nav-number">5.1.</span> <span class="nav-text">不正确的发布：正确的对象被破坏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">不可变对象与初始化安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%EF%BC%89"><span class="nav-number">5.3.</span> <span class="nav-text">安全发布的常用模式（可变对象的安全发布）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%AE%9E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.4.</span> <span class="nav-text">事实不可变对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E2%80%93-gt-%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8D%E5%8F%AF%E5%8F%98-%E4%BA%8B%E5%AE%9E%E4%B8%8D%E5%8F%AF%E5%8F%98-%E5%8F%AF%E5%8F%98%EF%BC%89%E7%9A%84%E5%8F%91%E5%B8%83%E7%BA%A6%E6%9D%9F"><span class="nav-number">5.5.</span> <span class="nav-text">可变对象–&gt;对象（不可变&#x2F;事实不可变&#x2F;可变）的发布约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%9C%B0%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.6.</span> <span class="nav-text">安全地共享对象</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter3%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          chapter3对象的共享
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-13 09:19:03" itemprop="dateCreated datePublished" datetime="2020-11-13T09:19:03+08:00">2020-11-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-20 11:13:16" itemprop="dateModified" datetime="2021-03-20T11:13:16+08:00">2021-03-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Abstract：第二章开头指出，要编写正确的并发程序，关键在与：在访问共享的可变状态时，需要正确的管理。第二章通过<strong>同步</strong>，避免多个线程同时访问相同的变量 (在《高性能MySQL》书中，这叫做<strong>避免并发</strong>)；而本章介绍如何<strong>共享</strong>和<strong>发布对象</strong>，从而使多个线程可以同时安全的访问相同的变量。这两章合在一起就形成了构建线程安全类以及通过java.util.concurrent类库来构建并发应用程序的重要基础。</p>
<p><a href="">synchronized不仅仅只有原子性，还具有内存可见性</a>。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化<!--这种内存可见性像MySQL中所说的Read Uncomitted事务隔离级别的可见性-->。如果没有同步，那么这种情况就无法实现。你可以通过显式地同步或者类库中内置的同步来保证对象被安全地发布。</p>
<!--这里注意：synchronized保障了变量不可修改，但是这个变量必须在同步代码块执行完了，才能被其他线程访问到最新变化。所以，我现在希望这个变量的变化，在同步代码块还没执行完时，就能及时被其他线程获取到最新数据，怎么办呢？就是volatile,使用可见性-->

<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready)</span><br><span class="line">                Thread.yield();</span><br><span class="line"><span class="comment">//这里可能输出0，也可能永远都不会输出</span></span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可能会产生两个问题</p>
<ul>
<li>一是程序可能一直保持循环，因为对于读线程来说，ready的值可能永远不可见。</li>
<li>二是输入的number为0，这是因为重排序引起的，在写线程将ready与number从工作内存中写回到主内存中时，在没有同步的机制下，先写ready还是先写number这是不确定的，也就是说将它们写回到主内存时的顺序可能与程序逻辑顺序恰好相反，这是因为在单个线程下，只要重排序不会对结果产生影响，这是允许的。<!--在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。-->

</li>
</ul>
<h3 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h3><p>除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。</p>
<p>上面NoVisibility程序在多线程环境下还可能读取到过期数据，比如当ready为true时，写线程已将number域的值置为了42，但在它还未来得及将这个新值从工作内存中写回到主内存前，读线程就已将ready从主内存中读取出来了，这时的值还是为初始的默认值0，这个值显然是一个已过期了的值，因为number现在真的值应该为42，而不是0。</p>
<!--拓展：在没有同步的情况下读取数据类似于数据库中使用READ_UNCOMMITTED（未提交读）隔离级别，这时你更愿意用准确性来交换性能。-->

<p>在NoVisibility中，过期数据可能导致它打印错误数值，或者程序无法终止。过期数据可能会使对象引用中的数据更加复杂，比如链指针在链表中的实现。过期数据还可能引发严重且混乱的错误，比如意外的异常，脏的数据结构，错误的计算和无限的循环。</p>
<p>下面的程序更对过期数据尤为敏感：如果一个线程调用了set，但还未来得及将这个新值写回到主内存中时，而另一个线程此时正在调用get，它就可能看不到更新的数据了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将set与get同步，使之成为线程安全的。注，仅仅同步某个方法是没有用的。</p>
<h3 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h3><p>非volatile类型的64位数值变量（double和long）。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，当对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值得低32位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。</p>
<h3 id="锁和可见性"><a href="#锁和可见性" class="headerlink" title="锁和可见性"></a>锁和可见性</h3><p>内置锁可以用来确保一个线程以某种可预见的方法看到另一个线程的影响，像下图一样。当B执行到与A相同的锁监视的同步块时，A在同步块之中所做的每件事，对B都是可见的，如果没有同步，就没有这样的保证。<br><img src="https://img-blog.csdnimg.cn/20190316230729391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTUxOTgz,size_16,color_FFFFFF,t_70" style="zoom:67%;" /></p>
<p>现在我们可以进一步理解为什么在访问某个共享且可变的变量时要求所有线程在<strong>同一个锁上同步</strong>，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果一个线程在未持有正确锁的情况下去读某个变量，那么读到的可能是一个失效值。</p>
<blockquote>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
</blockquote>
<h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><p>volatile是一种弱同步的形式，它确保对一个变量的更新后对其他线程是可见的。当一个域声明为volatile类型后，编译器与运行时会监视这个变量：它是共享的，而且对它的操作不会与其他的内存操作一起被重排序。volatile变量不会缓存在寄存器或者缓存其他处理器隐藏的地方 ==&gt; 所以，<strong>读一个volatile类型的变量时，总会返回由某一线程所写入的最新值</strong>。</p>
<p><strong>读取volatile变量的操作不会加锁，也就不会引起执行线程的阻塞</strong>，<!--允许并发访问进行读-->这使得volatile变量相对于sychronized而言，只是轻量级的同步机制<!--针对可见性而言-->。</p>
<p>volatile变量对可见性的影响所产生的价值远远高于变量本身。线程A向volatile变量写入值，随后线程B读取该变量，所有A执行写操作前可见的变量的值，在B读取了这个volatile变量后，对B也是可见的（与解锁前所有动作对后继加锁后的动作可见是一样的）。所以<a href="">从内存可见性的角度来看</a>，写入volatile变量就像退出同步块，读取volatile变量就像进入同步块。但是我们并不推荐过度依赖volatile变量所提供的可见性。因为依赖volatile变量来控制状态可见性的代码，比使用锁的代码更脆弱，更难以理解。</p>
<blockquote>
<p>仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标示一些重要的程序生命周期事件的发生（例如，初始化或关闭）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一定要加上volatile，否则其他线程更新后可能不可见，因为必须等到执行线程同的步代码块全部执行完，其他线程才能看见</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> asleep;</span><br><span class="line"><span class="keyword">while</span> (!asleep)</span><br><span class="line">    countSomeSheep();</span><br></pre></td></tr></table></figure>

<p>volatile变量固然方便，但也存在限制，它们通常被当作标识完成、中断、状态的标记使用，比如上面程序中的asleep变量。尽管volatile也可以用来标示其他类型的状态信息，但是<strong>决定这样做之前请格外小心，如volatile的语义不足以使用自增操作（i++）原子化。</strong></p>
<blockquote>
<p>加锁可以保证可见性与原子性；volatile变量只能保证可见性。</p>
</blockquote>
<p>只有满足了下面所有的标准后，你才能使用volatile变量：<!--其实就是不需要保证原子性，只需要可见性--><br>1、 写入变量时并不依赖变量的当前值；或者能够能够确保只有单一线程修改变量的值；<br>2、 变量不需要与其他的状态变量共同参与不变约束；<br>3、 访问变量时，没有其他的原因需要加锁。</p>
<h2 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h2><p><strong>发布</strong>一个对象的意思是，使对象能够被当前作用域之外的代码中使用。比如将一个指向该对象的引用存储到其他代码可以访问的地方、在一个非私有的方法中返回这个引用、也可以把它传递到共他类的方法中。在很多情况下，我们需要确保对象及它们的内部状态不被暴露，在另外一些情况下，为了正当的使用目的，我们又的确希望发布一个对象，这时为了线程安全可能需要同步。如果变量发布了内部状态，就可能危及到封装性，并使用程序难以维持稳定；如果发布对象时，它还没有完成构造，同样危及线程安全。一个对象在尚未准备地时就将它发布，这种情况称作<strong>逸出</strong>。下面看看一个对象是如何逸出的。</p>
<h3 id="直接发布对象"><a href="#直接发布对象" class="headerlink" title="直接发布对象"></a>直接发布对象</h3><p>最常见的发布对象的方式是将对象的引用存储到公共静态域，任何类和线程都能看到这个域。initialize方法实例化一个新的HashSet实例，并通过将它存储到knownSecrets引用，从而发布了这个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发布对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    knownSecrets = <span class="keyword">new</span> HashSet&lt;Secret&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="间接发布对象"><a href="#间接发布对象" class="headerlink" title="间接发布对象"></a>间接发布对象</h3><p>发布一个对象还会间接地发布其他对象。如果你将一个Secret对象加入集合knownSecrets中，你就已经发布了这个对象，因为任何代码都可以遍历并获得新Secret对象的引用。类似地，从非私有方法中返回引用，也能发布返回的对象，下面发布了包含洲名的数组，而这个数组本应是私有的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部可变的数据逸出（不要这样做）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">&quot;AK&quot;</span>, <span class="string">&quot;AL&quot;</span> ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123; <span class="keyword">return</span> states; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以这种方式发布states会出问题，这样会允许内部可变的数据逸出，请不要这样做。因为任何一个调用者都能修改它的内容。在这个例子中，数组states已经逸出了它所属的范围，这个本就是私有的数据，事实上已经变成公有的了。</p>
<p><strong>当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。一般来说，如果一个已经发布的对象通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。</strong></p>
<p>假定有一个类C，对于C来说，“外部方法”是指行为并不完全由C来规定的方法，包括其他类中定义的方法以及类C中可以被改写的方法（既不是私有[private]方法也不是终结[final]方法）。当把一个对象传递给某个外部方法时，就相当于发布了这个对象。</p>
<p>无论其他的线程会对已发布的线程执行何种操作，其实都不重要，因为误用该引用的风险始终存在。当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。</p>
<p>最后一种发布对象和它的内部状态的机制是发布一个内部类实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="keyword">new</span> EventListener() &#123;<span class="comment">//会过早地暴露this</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当ThisEscape发布EventListener时，也隐含地发布了ThisEscape实例本身，因为在这个内部类的实例中包含了对ThisEscape实例的隐含引用。</p>
<h3 id="安全对象构造过程"><a href="#安全对象构造过程" class="headerlink" title="安全对象构造过程"></a>安全对象构造过程</h3><p><a href="">当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态</a>。从构造函数内部发布的对象，只是一个未完成构造的对象。甚至即使是在构造函数的最后一行发布的引用也是如此。如果this引用在构造器中逸出，这样的对象被认为是“没有正确构建的”，所以不要让this引用在构造期间逸出。</p>
<blockquote>
<p>不要在构造构造过程中使this引用逸出</p>
</blockquote>
<p>一个导致this引用在构造期间逸出的常见错误，是在构造函数中创建局部、匿名线程并启动它或者启动一个线程并显示地将this传递过去，这都是不安全的，因为新的线程在所属对象完成构造前就能看见了。在构造器中创建线程并没有错，但是最好不要立即启动它，取而代之的是，发布一个start或initialize方法来启动对象拥有的线程。</p>
<p>另外，构造器中调用一个覆盖的实例方法（既不是私有方法，也不是终结方法）同样会导致this引用在构造期间逸出。</p>
<p>如果想要在构造器中注册监听器或启动线程，你可以使用一个私有的构造函数和一个公有的工厂方法，这样避免了不正确的构造过程。<br>下面是使用工厂方法防止this引用在构造期间逸出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span> </span>&#123;<span class="comment">//私有构造器</span></span><br><span class="line">        listener = <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态 工厂方法安全发布对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        SafeListener safe = <span class="keyword">new</span> SafeListener();<span class="comment">//等构造完后再注册</span></span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;<span class="comment">//安全发布对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有当构造函数返回时，this引用才应该从线程中逸出。构造函数可以将this引用保存到某个地方，只要其他线程不会在构造函数完成之前使用它。</p>
</blockquote>
<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭。它是实现线程安全性最简单的方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。</p>
<p>在Java语言中并没有强制规定某个变量由锁来保护，同样在Java语言中也无法强制将对象封闭在某个线程中。线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。Java语言及其核心库提供了一些核心机制来帮助维持线程封闭性，例如局部变量和ThreadLocal类，即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。</p>
<h3 id="Ad-hoc-线程封闭"><a href="#Ad-hoc-线程封闭" class="headerlink" title="Ad-hoc 线程封闭"></a>Ad-hoc 线程封闭</h3><p>Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。由于Ad-hoc 线程封闭技术的脆弱性，因此在程序中尽量很少用它，在可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭或ThreadLocal类）。</p>
<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中<!--更准确的说，是栈帧中-->，其他线程无法访问这个栈。</p>
<p>局部变量是线程安全的，只要我们不要将它们逸出。</p>
<h3 id="ThreadLocal-类"><a href="#ThreadLocal-类" class="headerlink" title="ThreadLocal 类"></a>ThreadLocal 类</h3><p>这个类能使先回城中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前线程在调用set时设置的最新值。</p>
<p>ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。</p>
<p>例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有自己的连接，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder </span><br><span class="line">    = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conncetionHolder.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用这项技术。</p>
<p>当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。从概念上看，你可以将ThreadLocal<T>视为包含了Map&lt; Thread,T&gt;对象，其中保存了特定于该线程的值，当ThreadLocal的实现并非如此。这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。</p>
<p>假设你需要将一个单线程应用程序移植到多程序环境中，通过将共享的全局变量转换为ThreadLocal（如果全局变量的语义允许），可以维护线程安全性。然而，如果将应用程序范围内的转换为线程局部的缓存，就不会有太大作用<!--这是因为缓存本来就是全局唯一，供所有的线程共享，如果转换为ThreadLocal，那么每个线程都会有一个缓存，缓存就失去原本的意义-->。</p>
<p>开发人员经常滥用ThreadLocal，例如将所有全局变量都作为ThreadLocal对象，或者作为一种“隐藏”方法参数的手段。ThreadLocal变量类似于全局变量，他能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。</p>
<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>满足同步需求的另一种方法是使用不可变对象。</p>
<p>创建后状态不能被修改的对象叫做不可变对象。不可变对象天生就是线程安全。它们常量域是在构造函数中创建的。既然它们的状态无法被修改，这些常量永远不会变。所以不可变对象永远是线程安全的。</p>
<blockquote>
<p>不可变对象一定是线程安全的。</p>
</blockquote>
<p>不可变性并不简单地等于将对象中的所有域都声明为final类型，所有域都是final类型的对象仍然可能是可变的，因为final域可以获得一个到可变对象的引用。</p>
<blockquote>
<p>只有满足如下状态，一个对象才是不可变的：<br>1、 对象的状态不能在创建后再被修改；<br>2、 对象的所有域都是final类型；<br>3、 对象被正确创建（创建期间没有发生this引用逸出）。</p>
</blockquote>
<p>在不可变对象的内部，同样可以使用可变性对象来管理它们的状态，如下面代码，虽然域stooges是可变的，但它满足了以上三点，所以是一个不可变对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span><span class="comment">//不可变对象可以基于可变对象来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stooges.add(<span class="string">&quot;Moe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final域"><a href="#final域" class="headerlink" title="final域"></a>final域</h3><p>final类型的域时不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的<!--毕竟final类型的域，其实是个地址，这个地址是不可变的，但是地址指向的对象是可变的-->）。然而，在Java内存模型中，final域还有着特殊的语义。final域能确保初始化过程的安全性 <!--???why？看下边注解-->，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。</p>
<!--
我们认为的执行过程是怎么样的呢？
（1）给Holder对象分配内存
（2）调用Holder的构造函数，也就是给n赋值的过程，初始化了成员字段
（3）将holder引用指向我们分配的内存空间
我们认为既然第3步已经执行了（holder引用已经指向最新了），那1、2步肯定已经完成了。可是，在JVM自身的性能优化中，是允许这个顺序乱序执行的。也就是说，它不能保证执行的顺序是1、2、3，也有可能是1、3、2。假设执行了1、3，这是引用已经是最新的了，但2的构造函数没有执行，那你的对象的状态值就是失效的，另一个线程调用assertSanity自然会报出异常
-->

<!--
对于含有final域的对象，JVM必须保证对对象的初始引用在构造函数之后执行，不能乱序执行（out of order），也就是可以保证一旦你得到了引用，final域的值都是完成了初始化的，也就是书中所说的“初始化安全性”的保证。
-->

<p>仅包含一个或两个可变状态的“基本不可变”对象仍然比包含多个可变状态的对象简单。通过将域声明为final类型的，也相当于告诉维护人员这些域时不会变化的。</p>
<blockquote>
<p>正如“除非需要更高的可见性，否则应将所有的域声明为私有域是一个良好的编程习惯，”除非需要某个域是可变的，否则应将其声明为final域“也是一个良好的编程习惯。</p>
</blockquote>
<h3 id="示例：使用Volatile类型来发布不可变对象-我称之为对象封闭"><a href="#示例：使用Volatile类型来发布不可变对象-我称之为对象封闭" class="headerlink" title="示例：使用Volatile类型来发布不可变对象(我称之为对象封闭)"></a>示例：使用Volatile类型来发布不可变对象(我称之为对象封闭)</h3><h4 id="发生竞态条件"><a href="#发生竞态条件" class="headerlink" title="发生竞态条件"></a>发生竞态条件</h4><p>尽管原子引用自身是线程安全的，不过UnsafeCachingFactorizer中存在竞争条件 <!--"读取-修改-写入"，并且违背了约束条件，读取了过期数据-->，当前线程在执行到A 与 B之间或者C 与 D之间，都有可能切换到其他线程，从而造成错误的结果。<!--这里的线程安全问题，是lastNumber和lastFactors不一致--></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有正确原子化的Servlet试图缓存它的最新结果。</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCachingFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger&gt; lastNumber</span><br><span class="line">         = <span class="keyword">new</span> AtomicReference&lt;BigInteger&gt;();<span class="comment">//缓存最后一次客户请求因式分解的数</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger[]&gt;  lastFactors</span><br><span class="line">         = <span class="keyword">new</span> AtomicReference&lt;BigInteger[]&gt;();<span class="comment">//缓存最后一次客户请求因式分解的结果</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">         BigInteger i = extractFromRequest(req);</span><br><span class="line">       	 <span class="comment">//先检查后执行，必须保证lastNumber不是过期数据</span></span><br><span class="line">         <span class="keyword">if</span> (i.equals(lastNumber.get()))<span class="comment">//A</span></span><br><span class="line">             encodeIntoResponse(resp,  lastFactors.get() );<span class="comment">//B</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             BigInteger[] factors = factor(i);</span><br><span class="line">           	 <span class="comment">//lastNumber和lastFactors必须维持状态的约束条件</span></span><br><span class="line">             lastNumber.set(i);<span class="comment">//C</span></span><br><span class="line">             lastFactors.set(factors);<span class="comment">//D</span></span><br><span class="line">             encodeIntoResponse(resp, factors);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决竞态条件"><a href="#解决竞态条件" class="headerlink" title="解决竞态条件"></a>解决竞态条件</h4><p><a href="">如果上面的A与B这个复合操作操作、以及C与D这个复合操作如果是原子性的，那么将不会出现线程安全性问题。</a><!--比如使用chapter2中synchronized加锁--></p>
<p><a href="">如果为这两组操作创建一个不可变的类，即使在不使用同步的情况也能解决安全共享问题。</a> </p>
<p>下面就为UnsafeCachingFactorizer创建一个OneValueCache类，对以上操作进行了封装，它是一个不可变对象，进（构造时传进的参数）出（使用时）都对状态进行了拷贝。因为BigInteger是不可变的，所以直接使用了Arrays.copyOf来进行拷贝了，如果状态所指引的对象不是不可变对象时，就要不能使用这项技术了，因为外界可以对这些状态所指引的对象进行修改，如果这样只能使用new或深度克隆技术来进行拷贝了。</p>
<blockquote>
<p>每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber  = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于在访问和更新多个相关变量时出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。</p>
<ul>
<li><p>如果是一个可变的对象，那么就必须使用锁来确保原子性。</p>
</li>
<li><p>如果是一个不可变对象，那么当线程获得了对该对象的引用后，就不必担心另一个线程会修改对象的状态。</p>
</li>
<li><p>如果要更新这些变量，那么可以创建一个新的容器对象，但其他使用原有对象的线程仍然会看到对象处于一致的状态。</p>
</li>
</ul>
<p>当一个线程将volatile类型的cache设置为引用一个新的OndeValueCache时，其实线程就会立即看到新缓存的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache =</span><br><span class="line">        <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//使用volatile安全发布</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            <span class="comment">//由于cache为volatile，所以最新值立即能让其它线程可见</span></span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与cache相关的操作不会相互干扰，因为OneValueCache是不可变的，并且在每条相应的代码路径中只会访问它一次 。通过使用包含过个状态变量的容器对象来维护不可变条件，并使用一个volatile类型的引用来确保可见性，使得Volatile Cached Factorizer在没有显式地使用锁的情况下仍然是线程安全的。</p>
<h3 id="我个人的疑惑"><a href="#我个人的疑惑" class="headerlink" title="我个人的疑惑"></a>我个人的疑惑</h3><h4 id="我的分析"><a href="#我的分析" class="headerlink" title="我的分析"></a>我的分析</h4><ul>
<li>程序清单3-13中存在『先检查后执行』（Check-Then-Act）的竞态条件。</li>
<li>OneValueCache类的<strong>不可变性</strong>仅保证了对象的原子性。</li>
<li>volatile仅保证可见性，无法保证线程安全性。</li>
</ul>
<p><strong>综上，对象的不可变性+volatile可见性，并不能解决竞态条件的并发问题，所以原文的这段结论是错误的。</strong></p>
<blockquote>
<p>比如，假设现在缓存lastNumber是x，lastFactor是y</p>
<p>线程A进入cache.getFactor（i）函数中的else语句Arrays.copyOf(lastFactors, lastFactors.length);，</p>
<p>线程B判断没有缓存</p>
<p>线程B更新了OneValueCache，</p>
<p>线程A获取了的是失效的缓存之值1,这不应该啊，线程A获取的不应该是失效的值，这不就线程不安全了吗？</p>
</blockquote>
<p>简单代码1: 对操作封装在一个类中</p>
<ul>
<li>将先检查后执行操作A、B，还有约束条件C、D，封装为一个类的同步方法</li>
<li>这么做，其实和chapter2的代码一样，每个请求阻塞、串行执行，并发效率低</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getFactors</span><span class="params">(BigInteger i)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">if</span> (i.equals(lastNumber.get()))<span class="comment">//A</span></span><br><span class="line">             encodeIntoResponse(resp,  lastFactors.get() );<span class="comment">//B</span></span><br><span class="line">      	<span class="keyword">else</span> &#123;</span><br><span class="line">             BigInteger[] factors = factor(i);</span><br><span class="line">             lastNumber.set(i);<span class="comment">//C</span></span><br><span class="line">             lastFactors.set(factors);<span class="comment">//D</span></span><br><span class="line">             encodeIntoResponse(resp, factors);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单代码2: 鉴于代码1只对方法进行了封装，再考虑对类的数据进行了封装</p>
<ul>
<li>把lastNum和lastFactors变量进行封装，放在一个类中OneValueCache，使得lastNum和lastFactors能维持约束性，从而保证线程安全</li>
<li>以前的A、B操作，是判断lastNum和返回lastFactors; 现在的A、B操作，是交给OneValueCache类判断和OneValueCache类返回。好像线程安全性问题还是没有解决？<ul>
<li>线程安全有没有解决，就是看OneValueCache能不能维持lastNum和lastFactors约束性？当然可以！</li>
<li>写操作：因为OneValueCache能被写入的操作，只有构造函数；而且cache = new OneValueCache(i, factors)中的i和factor(i)属于方法的临时变量，是线程安全的</li>
<li>读操作：因为cache.getFactors(i)第一次用于判断，第二次用于返回，在此期间，其他线程会通过构造函数修改cache，可能会失效，所以线程不安全</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber  = i;</span><br><span class="line">        lastFactors = factors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> lastFactors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req); <span class="comment">//局部变量，没有线程安全性 </span></span><br><span class="line">        <span class="keyword">if</span> ( cache.getFactors(i) != <span class="keyword">null</span>) &#123; <span class="comment">//判断是否命中缓存, 对应以前的A</span></span><br><span class="line">             encodeIntoResponse(resp, cache.getFactors(i)); <span class="comment">//对应以前的B </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         		BigIntegers[] factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">          	encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单代码3: 鉴于代码2中只有读cache时，可能2次获取的cache.getFactors(i)不一致，产生线程不安全，所以现在想办法保证读操作时，保证2次获取的cache.getFactors(i)的约束性，就OK了</p>
<ul>
<li>使用临时变量BigInteger[] factors, 保存cache.getFactors(i)；再使得factors线程安全<ul>
<li>前半部分很简单</li>
<li>后半部分，使factors线程安全，常见的解决方法就是使factors变成临时变量or不可变，那么就可以让cache.getFactors(i)每次返回的都是一个新的句柄和一个新的句柄指向的对象，这样在方法中就成为了一个局部变量，每个线程都有自己的一个句柄和句柄指向的对象，那么factors句柄就不会被其他线程获取</li>
<li>使用Arrays.copyOf()</li>
</ul>
</li>
<li>再想一想，写操作本身维持了约束，但是因为构造函数中lastFactors = factors，把lastFactors通过factors暴露出来了，就是逸出了，调用者可以通过factors修改lastFactors数据，那会不会有什么影响？<ul>
<li>目前来看，没有线程安全问题；但是lastFactors不能逸出被其他调用者修改，所以也需要Arrays.copyOf()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber  = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> Arrays.copyOf(lastFactors,lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req); <span class="comment">//局部变量，没有线程安全性 </span></span><br><span class="line">      	BigIntegers[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> ( factors != <span class="keyword">null</span>) &#123; <span class="comment">//判断是否命中缓存, 此时factors指向的对象，只有该线程能访问，其他线程无法访问，所以对象不可变</span></span><br><span class="line">             encodeIntoResponse(resp, factors); <span class="comment">//对应以前的B，factors由于不可变性，所以安全 </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         		factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">          	encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单代码4: 简单代码3已经做到了很好的线程安全性</p>
<ul>
<li>对象初始化也需要安全，所以使用final修饰</li>
</ul>
<h4 id="作者的本意"><a href="#作者的本意" class="headerlink" title="作者的本意"></a>作者的本意</h4><p><strong>Short answer:</strong></p>
<p><a href="">Thread safety is not really an absolute</a>. You have to determine the desired behavior, and <em>then</em> ask whether the implementation gives you that behavior that in the presence of multithreading.</p>
<p><strong>Longer answer:</strong></p>
<p>So, what’s the desired behavior here? Is it just that the right answer is always given, or is it also that it’s always implemented exactly once if two threads ask for it in a row?</p>
<p>If it’s the latter — that is, if you really want to save every bit of CPU — then you’re right, this isn’t thread-safe. <a href="">Two requests could come in at the same time (or close enough to it) to get the factors for the same number N, and if the timings worked out, both threads could end up calculating that number.</a> <!--这就是我疑惑的地方，但是程序目的并不是这样；如果要达到这种程度的线程安全性，使用锁来保证线程之间的执行顺序，避免重复计算，就像解决Redis缓存击穿--></p>
<p>But with a single-value cache, you already have the problem of recalculating things you already knew. For instance, <a href="">what if three requests come in, for N, K, and N again? The request for K would invalidate the cache at N, and so you’d have to recalculate it.</a><!----></p>
<p>So, this cache is really optimized for “streaks” of the same value, and as such the cost of twice-calculating the first couple (or even few!) answers in that streak might be an acceptable cost: in return, you get code that’s free of any blocking and pretty simple to understand.</p>
<p><a href="">What’s crucial is that it never gives you the <em>wrong</em> answer. That is, if you ask for N and K at the same time, the response for K should never give you the answer for N. This implementation gets you that guarantee, so I would call it thread safe.</a><!--程序的目的是为了保证状态的约束性，就是lastNumbers和lastFactors一致--></p>
<h4 id="使用Arrays-copyOf的目的"><a href="#使用Arrays-copyOf的目的" class="headerlink" title="使用Arrays.copyOf的目的"></a>使用Arrays.copyOf的目的</h4><p><a href="">其实就是返回一个新的句柄和句柄所指向新的对象</a></p>
<p>If you return <code>this.lastFactors</code> instead of returning a copy, the caller can do (for example)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigInteger[] lastFactors = cache.getFactors(...);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastFactors.length; i++) &#123;</span><br><span class="line">    lastFactors[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and thus mutate the state of the cache, which is supposed to be immutable.</p>
<p>The explanation is similar for the constructor. If the constructor didn’t make a copy, the caller could do</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">factors = factor(i);</span><br><span class="line">cache = <span class="keyword">new</span> OneValueCache(i, factors); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastFactors.length; i++) &#123;</span><br><span class="line">    factors[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and thus once again mutate the state of the cache.</p>
<p>Rule of thumb: an array is always mutable (except the empty array). So, if the state of an immutable class contains an array, then the caller must not be able to have a reference to the array.</p>
<h4 id="使用final的目的"><a href="#使用final的目的" class="headerlink" title="使用final的目的"></a>使用final的目的</h4><p>为了保障对象初始化的线程安全</p>
<h4 id="使用volatile的目的"><a href="#使用volatile的目的" class="headerlink" title="使用volatile的目的"></a>使用volatile的目的</h4><p>因为程序并没有使用锁，而是通过不可变对象，使得每个线程获取到的都是一个新句柄和新内存（在线程调用的方法中就是局部变量），所以不会有线程安全性问题</p>
<p>现在程序有个这样的情况</p>
<ul>
<li>比如3个请求R1, R2, R1，第2个R1会再次计算，这其实是正常情况</li>
<li>比如2个请求R2, R1, R1，第1和第2个R1可能也都会计算，所以使用volatile尽可能地将最新的结果通知其他线程，最大可能避免重复计算；比如第1个R1把新的结果写入内存，即使R1线程没执行完，但是R2已经获取了最新结果了。</li>
</ul>
<h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><p>到目前为止，我们重点讨论的是如何确保对象不被发布，比如让对象封闭在线程或者另一个对象内部。当然，我们希望多个线程间安全地进行共享数据。下面程序中简单地将对象的引用存储到public域中，这不足以安全地发布它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不安全的发布：在没有适当的同步情况下就发布对象</span></span><br><span class="line"><span class="keyword">public</span> Holder holder;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于存在可见性问题，其他线程看到的Holder对象将处于不一致的状态，即便在该对象的构造函数中已经正确地构建了不变性条件。这种不正确的发布导致其他线程看到尚未创建完成的对象。</p>
<h3 id="不正确的发布：正确的对象被破坏"><a href="#不正确的发布：正确的对象被破坏" class="headerlink" title="不正确的发布：正确的对象被破坏"></a>不正确的发布：正确的对象被破坏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n != n)<span class="comment">//在不正确的发布中，是很有可能出现不等</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;This statement is false.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序的问题是由于对象的可见性问题引起的，发布的对象可能还处于构造期间，所以是不稳定的。因为没有同步来确保Holder对其他线程可见，所以我们称Holder是“非正确发布”。</p>
<p>由于上面 n != n 会从主存中两次读取，这有可能从这两次读操作间切换到其他线程，这就有可能出 n!=n奇怪的问题。</p>
<!--看看stack上，大神怎么解释的-->

<blockquote>
<p>he reason why this is possible is that Java has a weak memory model. It does not guarantee ordering of read and writes.</p>
<p>This particular problem can be reproduced with the following two code snippets representing two threads.</p>
<p>Thread 1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someStaticVariable = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>Thread 2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someStaticVariable.assertSanity(); <span class="comment">// can throw</span></span><br></pre></td></tr></table></figure>

<p>On the surface it seems impossible that this could ever occur. In order to understand why this can happen, you have to get past the Java syntax and get down to a much lower level. If you look at the code for thread 1, it can essentially be broken down into a series of memory writes and allocations:</p>
<ol>
<li>Alloc memory to pointer1</li>
<li>Write 42 to pointer1 at offset 0</li>
<li>Write pointer1 to someStaticVariable</li>
</ol>
<p>Because Java has a weak memory model, it is perfectly possible for the code to actually execute in the following order from the perspective of thread 2:</p>
<ol>
<li>Alloc Memory to pointer1</li>
<li>Write pointer1 to someStaticVariable</li>
<li>Write 42 to pointer1 at offset 0</li>
</ol>
<p>Scary? Yes but it can happen.</p>
<p>What this means though is that thread 2 can now call into <code>assertSanity</code> before <code>n</code> has gotten the value 42. It is possible for the value <code>n</code> to be read twice during <code>assertSanity</code>, once before operation #3 completes and once after and hence see two different values and throw an exception.</p>
</blockquote>
<h3 id="不可变对象与初始化安全性"><a href="#不可变对象与初始化安全性" class="headerlink" title="不可变对象与初始化安全性"></a>不可变对象与初始化安全性</h3><p>Java内存模型为共享不可变对象提供了特殊的初始化安全性的保证，即对象在完全初始化之后才能被外界引用，所以只要是不可变对象，一旦构建完成，就可以安全地发布了。</p>
<p>即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一致的视图，就必须使用同步。</p>
<p>即使发布对象引用时没有使用同步，不可变对象仍然可以被安全地访问（注，只能保证一旦看到的对象就是完整的，在没有使用同步的情况下是不能保证对象引用的可见性，所以不可变对象只能保证初始化完后的就处于稳定状态）。<strong>为了获得这种初始化安全性的保证上，应该满足所有不可变性的条件</strong>：<!--不可修改的状态、所有域都是final类型的、正确的构造-->。（如果上面的Holder是不可变的，那么即使Holder没有正确的发布，assertSanity也不会抛出AssertionError。）</p>
<blockquote>
<p>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。</p>
</blockquote>
<p>这个保证还会延伸到一个正确创建的对象中所有final类型域的值。final域可以在没有额外的同步情况下被安全地访问（因为只要构造器一旦调用完毕，则final域的也会随之初始化完并可见），然而，如果final域指向可变对象，那么访问这些对象的状态时仍然需要同步的。</p>
<h3 id="安全发布的常用模式（可变对象的安全发布）"><a href="#安全发布的常用模式（可变对象的安全发布）" class="headerlink" title="安全发布的常用模式（可变对象的安全发布）"></a>安全发布的常用模式（可变对象的安全发布）</h3><p>如果一个对象不是不可变的，它就必须要被安全的发布，通常发布线程与消费线程都必须同步。我们要确保消费线程能够看到处于发布当时的对象状态。</p>
<blockquote>
<p>为了安全地发布一个可变对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用；static{}</li>
<li>将对象的引用保存到volatile类型的域或者AtomicReferance对象中</li>
<li>将对象的引用保存到某个正确构造对象的final类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
</blockquote>
<p>线程安全中的容器提供了线程安全保证（即变向地将对象置于了同步器中进行访问），正是遵守了上述最后一条要求。</p>
<p>线程安全库中的容器类提供了以下的安全发布保证：</p>
<ul>
<li>通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。</li>
<li>通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。</li>
<li>通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。</li>
</ul>
<p>类库中的其他数据传递机制（例如Future和Exchanger）同样能实现安全发布。</p>
<p>要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Holder holder &#x3D; new Holder(42);</span><br></pre></td></tr></table></figure>

<p>静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。</p>
<p><strong>如果对象在创建后被修改，那么安全发布仅仅可以保证“发布当时”状态的可见性。不仅仅在发布对象时需要同步，而且在对象发布后修改了对象状态又要让其他线程可见，则也需要对每次状态的访问进行同步。为了安全地共享可变对象，可变对象必须被安全发布，同时对状态的访问需要同步化。</strong></p>
<h3 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h3><p>对于对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布时足够的。</p>
<p>如果对象从技术上来看时可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象”。</p>
<p>用事实不可变对象可以简化开发，并且由于减少了同步的使用，还会提高性能。</p>
<blockquote>
<p>在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。</p>
</blockquote>
<p>比如，Date自身是可变的（这也许是类库设计的一个错误），但是如果你把它当作不可变对象来使用就可以忽略锁。否则，每当Date被跨线程共享时，都要用锁确保安全。假设你正在维护一个Map，它存储了每位用户的最近登录时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Date&gt; lastLogin =</span><br><span class="line">Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Date&gt;());</span><br></pre></td></tr></table></figure>

<p>如果Date值在转入Map中后就不会改变，那么，synchronizedMap中同步的实现就足以将Date安全地发布，并且访问这些Date值时就不再需要额外的同步。</p>
<!--stack上的回答-->

<blockquote>
<p>If you use an <code>un-synchronized</code> <code>mutable map</code> and share it across <code>threads</code> then you will have two <code>thread-safety</code> issues :<code>visibility</code> and <code>atomicity</code>. <code>Thread-1</code> wont know if <code>Thread-2</code> has removed a <code>Map-Entry</code> or it replaced its value by a new <code>Date</code> object.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not atmoic and doesn&#x27;t guarantee visiblity</span></span><br><span class="line"><span class="keyword">if</span>(map.contains(key))&#123;</span><br><span class="line"> map.put(key,newDate); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="可变对象–-gt-对象（不可变-事实不可变-可变）的发布约束"><a href="#可变对象–-gt-对象（不可变-事实不可变-可变）的发布约束" class="headerlink" title="可变对象–&gt;对象（不可变/事实不可变/可变）的发布约束"></a>可变对象–&gt;对象（不可变/事实不可变/可变）的发布约束</h3><p>如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续操作的可见性。<strong>要安全地共享可变对象，这些对象就必须被安全地发布，并且必须是线程安全的活着由某个锁保护起来。</strong></p>
<blockquote>
<p>对象的发布需求取决于它的可变性：<br>* 不可变对象可以通过任意机制来发布<br>* 事实不可变对象必须通过安全方式来发布<br>* 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来</p>
</blockquote>
<h3 id="安全地共享对象"><a href="#安全地共享对象" class="headerlink" title="安全地共享对象"></a>安全地共享对象</h3><p>当获得对象的一个引用时，你需要知道在这个引用上可以执行哪些操作。在使用它之前是否需要获得一个锁？是否可以修改它的状态，或者只能读取它？许多错误都是由于没有理解共享对象的这些“既定规则”而导致。当发布一个对象时，必须明确地说明对象的访问方式。</p>
<blockquote>
<p>在并发程序中使用和共享对象时，可以使用一些使用的策略，包括：<br><strong>线程封闭</strong>。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。<br><strong>只读共享。</strong>在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。<br><strong>线程安全共享。</strong>线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。<br><strong>保护对象。</strong>被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%94%AF%E4%B8%80ID/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80ID/" rel="prev" title="分布式集群下生成唯一ID">
                  <i class="fa fa-chevron-left"></i> 分布式集群下生成唯一ID
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter2-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/" rel="next" title="chapter2:java内存模型与内存溢出">
                  chapter2:java内存模型与内存溢出 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
