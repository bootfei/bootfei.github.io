<!DOCTYPE html>
<html lang="en,cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="大多数并发应用程序都是围绕 任务执行（Task Execution）来进行构造的，任务通常是一些抽象的且离散的工作单元。 通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种「自然的事务边界」来优化错误的恢复过程，以及提供一种自然的「并行工作结构」来提升并发性。 6.1 在线程中执行任务当围绕 「任务执行」 来设计应用程序结构时，第一部就是要找出清晰的「任务边界」。在理想的情况下">
<meta property="og:type" content="article">
<meta property="og:title" content="chapter6任务执行">
<meta property="og:url" content="http://example.com/2020/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/index.html">
<meta property="og:site_name" content="BootFei&#39;s Blog">
<meta property="og:description" content="大多数并发应用程序都是围绕 任务执行（Task Execution）来进行构造的，任务通常是一些抽象的且离散的工作单元。 通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种「自然的事务边界」来优化错误的恢复过程，以及提供一种自然的「并行工作结构」来提升并发性。 6.1 在线程中执行任务当围绕 「任务执行」 来设计应用程序结构时，第一部就是要找出清晰的「任务边界」。在理想的情况下">
<meta property="og:locale">
<meta property="article:published_time" content="2020-12-25T06:35:00.000Z">
<meta property="article:modified_time" content="2020-12-27T11:50:00.876Z">
<meta property="article:author" content="Fei Qi">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2020/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en,cn'
  };
</script>

  <title>chapter6任务执行 | BootFei's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BootFei's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">敬畏耶和华是智慧的开端，认识至圣者就是聪明</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E5%9C%A8%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.</span> <span class="nav-text">6.1 在线程中执行任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-%E4%B8%B2%E8%A1%8C%E5%9C%B0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.1.</span> <span class="nav-text">6.1.1 串行地执行任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-%E6%98%BE%E7%A4%BA%E5%9C%B0%E4%B8%BA%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">6.1.2 显示地为任务创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E9%80%9A%E8%BF%87%E6%97%A0%E9%99%90%E5%88%B6%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">a. 通过无限制创建线程的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E6%97%A0%E9%99%90%E5%88%B6%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="nav-number">1.2.2.</span> <span class="nav-text">b. 无限制创建线程的不足</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-Executor-%E6%A1%86%E6%9E%B6"><span class="nav-number">2.</span> <span class="nav-text">6.2 Executor 框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9F%BA%E4%BA%8E-Executor%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">6.2.1 示例：基于 Executor的Web服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5"><span class="nav-number">2.2.</span> <span class="nav-text">6.2.2 执行策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.3.</span> <span class="nav-text">6.2.3 线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-4-Executor-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.4.</span> <span class="nav-text">6.2.4 Executor 的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1"><span class="nav-number">2.5.</span> <span class="nav-text">6.2.5 延迟任务与周期任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E6%89%BE%E5%87%BA%E5%8F%AF%E5%88%A9%E7%94%A8%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">6.3 找出可利用的并行性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%B2%E8%A1%8C%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="nav-number">3.1.</span> <span class="nav-text">6.3.1 示例：串行的页面渲染器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-%E6%90%BA%E5%B8%A6%E7%BB%93%E6%9E%9C%E7%9A%84%E4%BB%BB%E5%8A%A1-Callable-%E4%B8%8EFuture"><span class="nav-number">3.2.</span> <span class="nav-text">6.3.2 携带结果的任务 Callable 与Future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-%E7%A4%BA%E4%BE%8B%EF%BC%9A-%E4%BD%BF%E7%94%A8-Future-%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">6.3.3 示例： 使用 Future 实现页面的渲染器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-4-%E5%9C%A8%E5%BC%82%E6%9E%84%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C%E5%8C%96%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B1%80%E9%99%90"><span class="nav-number">3.4.</span> <span class="nav-text">6.3.4 在异构任务并行化中存在的局限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-5-CompletionService%EF%BC%9AExecutor-%E4%B8%8E-BlockingQueue"><span class="nav-number">3.5.</span> <span class="nav-text">6.3.5 CompletionService：Executor 与 BlockingQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-6-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-CompletionService-%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="nav-number">3.6.</span> <span class="nav-text">6.3.6 示例：使用 CompletionService 实现页面渲染器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-7-%E4%B8%BA%E4%BB%BB%E5%8A%A1%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%99%90"><span class="nav-number">3.7.</span> <span class="nav-text">6.3.7 为任务设置时限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-8-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%97%85%E8%A1%8C%E9%A2%84%E8%AE%A2%E9%97%A8%E6%88%B7%E7%BD%91%E7%AB%99"><span class="nav-number">3.8.</span> <span class="nav-text">6.3.8 示例：旅行预订门户网站</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei Qi</p>
  <div class="site-description" itemprop="description">learn more, forget more; practice more, get more.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en,cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei Qi">
      <meta itemprop="description" content="learn more, forget more; practice more, get more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BootFei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          chapter6任务执行
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-25 14:35:00" itemprop="dateCreated datePublished" datetime="2020-12-25T14:35:00+08:00">2020-12-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-27 19:50:00" itemprop="dateModified" datetime="2020-12-27T19:50:00+08:00">2020-12-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>大多数并发应用程序都是围绕 <strong>任务执行（Task Execution）</strong>来进行构造的，<strong>任务</strong>通常是一些抽象的且离散的工作单元。<!--我们一直在说并发，但是巨人们已经总结了并发的使用场景和构造方法--></p>
<p>通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种<strong>「自然的事务边界」</strong>来优化错误的恢复过程，以及提供一种自然的<strong>「并行工作结构」</strong>来提升并发性。<!--有了使用场景和构造方法，如何解决构造过程中出现的问题，这里巨人们也给出了方案--></p>
<h3 id="6-1-在线程中执行任务"><a href="#6-1-在线程中执行任务" class="headerlink" title="6.1 在线程中执行任务"></a>6.1 在线程中执行任务</h3><p>当围绕 <strong>「任务执行」</strong> 来设计应用程序结构时，第一部就是要找出<strong>清晰</strong>的<strong>「任务边界」</strong>。在理想的情况下，各个任务之间是独立的：任务并不依赖于其他任务的状态，结果或边界效应。</p>
<p><strong>「独立性」</strong>有助于实现并发，如果存在足够多的「资源」，那么这些独立的任务都可以并行执行。为了在<strong>「调度」</strong>与<strong>「负载均衡」</strong>等过程中实现更高的<strong>「灵活性」</strong>,每项任务还表示应用程序的一小部分处理能力。</p>
<p>在<strong>「正常的负载」</strong>下，服务器应用程序应该同时表现出良好<strong>「吞吐量」</strong> 和 快速的 <strong>「响应性」</strong>。 应用程序提供商希望支持尽可能多的用户，而用户希望得到尽可能快的响应。当「负荷过载」时，应用程序的性能应该是逐渐降低，而不是直接失败。</p>
<p>要实现上述目标，应该选择清晰的<strong>「任务边界」</strong>以及明确的任务执行策略（<a target="_blank" rel="noopener" href="https://github.com/funnycoding/blog/issues/31">参见6.2.2 节</a>。）</p>
<p>大多数服务器应用程序都提供了一种自然的任务边界选择方式：以<strong>「独立的客户请求」</strong>为边界。</p>
<p>Web 服务器，邮件服务器，文件服务器，EJB 容器以及数据库服务器等，这些服务器都通过网络接受远程客户的连接请求。将<strong>「独立的请求」</strong>作为<strong>「任务边界」</strong>，既可以实现「任务的独立性」，又可以实现合理的「任务规模」。<!--非常巧妙的设计，即满足了并行工作结构的前提条件（任务边界），又尽量使用独立性有助于实现并发--></p>
<p>例如：在向邮件服务器提交一个消息后得到的结果，并不受其他正在处理的消息的影响，而且在处理单个消息时通常只需要服务器总处理能力的很小一部分。</p>
<h4 id="6-1-1-串行地执行任务"><a href="#6-1-1-串行地执行任务" class="headerlink" title="6.1.1 串行地执行任务"></a>6.1.1 串行地执行任务</h4><p>在应用程序中可以通过多种策略来调度任务，而其中一些策略能够更好地利用潜在的并发性。最简单的策略就是在单个线程中<strong>「串行」</strong>地执行各项任务。 <strong>&lt;—【也就是不使用多线程技术，所有业务逻辑都在一个线程中完成】</strong></p>
<p><strong>程序清单 6-1</strong> 中的 <code>SingleThreadWebServer</code> 将串行地处理它的任务（通过 80 端口接收到的 HTTP 请求）。 至于如何处理任务的细节问题，在这里并不重要，我们感兴趣的是<strong>「如何表征不同调度策略的同步特性」</strong>。</p>
<blockquote>
<p>程序清单 6-1 串行的 Web 服务器：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 接收客户端的请求</span></span><br><span class="line">            Socket connection = socket.accept();</span><br><span class="line">            <span class="comment">// 以串行的形式处理请求,具体对请求做处理的逻辑，在这里我们不需要关心</span></span><br><span class="line">            handleRequest(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的，但执行性能却很糟糕，因为它「每次只能处理一个请求」。</p>
<p>主线程在「接受连接 <code>accept</code>」与处理相关请求 <code>handleRequest</code> 等操作之间不断地交替运行。当服务器正在处理请求时，新到来的连接必须等待直到服务器处理完成上一次的请求，然后服务器再次调用 <code>accpt</code>，来接受这一次请求。如果处理请求的速度很快，并且 <code>handleRequest</code> 可以立即返回，那么这种方法是可行的，但是现实世界中的 Web 服务器的情况却并非如此。</p>
<p>在 <strong>「Web请求的处理」</strong> 中包含了一组不同的运算与 I/O 操作。 服务器必须处理 套接字 I/O 以读取请求和写回响应，这些操作通常会由于 <strong>「网络拥塞」</strong> 或 <strong>「连接性问题」</strong>而被<strong>「阻塞」</strong>。 此外，服务器还可能处理 文件I/O 或者 数据库请求，这些操作同样会阻塞。 在单线程的服务器中，阻塞不仅会推迟当前请求的完成时间，而且还将彻底阻塞等待中的请求被处理。</p>
<ul>
<li><p>如果请求<strong>「阻塞」</strong>的时间过长，用户将任务服务器是不可用的，因为服务器看似失去了响应。</p>
</li>
<li><p>同时，服务器的<strong>「资源利用率」</strong> 非常低，因为当单线程在等待 I/O 操作完成时， CPU 将处于空闲状态。</p>
</li>
</ul>
<p>在服务器应用程序中，<strong>「串行处理机制」</strong>通常都无法提供「高吞吐率」<strong>或</strong>「快速响应性」。</p>
<!--【在某些情况中，串行处理方式能带来「简单性」和 「安全性」。大多数 GUI 框架都通过单一的线程来串行地处理任务。 第9章 将再次减少串行模型】-->

<h4 id="6-1-2-显示地为任务创建线程"><a href="#6-1-2-显示地为任务创建线程" class="headerlink" title="6.1.2 显示地为任务创建线程"></a>6.1.2 显示地为任务创建线程</h4><h5 id="a-通过无限制创建线程的方式"><a href="#a-通过无限制创建线程的方式" class="headerlink" title="a. 通过无限制创建线程的方式"></a>a. 通过无限制创建线程的方式</h5><p>通过为每个请求创建一个新的线程来提供服务，从而实现更高的响应性。</p>
<blockquote>
<p>程序清单6-2 在 Web服务器中为每个请求都启动一个新的线程<strong>（不要这么做）</strong>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = serverSocket.accept();</span><br><span class="line">            Runnable task = () -&gt; handleRequest(connection);</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadPerTaskWebServer</code> 在结构上类似之前的单线程版本 —— 主线程仍然不断地 交替执行 「接受外部链接」与 「分发请求」 这两个操作。 区别在于，对于每个连接，主循环都将创建一个新线程来处理请求，而不是在 「主循环」 中进行处理，由此可得到<strong>3个主要结论</strong>：</p>
<ul>
<li>任务处理过程从主线程中分离出来，到每个新创建的子线程中去，使得主循环能更快地重新等待下一个到来的连接，使得不必等待上一个连接处理完成就可以接受新的请求，提高了<strong>「响应性」</strong>。</li>
<li>任务可以<strong>「并行处理」</strong>，从而能同时服务多个请求。如果有「多个处理器」，或者由于某种原因被「阻塞」，例如 「等待I/O完成」，获取锁资源 或者资源可用性等，程序的吞吐量将得到提高。【也就是同时可以处理更多的任务】</li>
<li><strong><u>任务处理代码</u>，即handleRequest(connection), 必须是「线程安全」</strong>的，因为当有多个任务时，会并发地调用这段代码。<!--这块和前面4章的线程安全联系起来了--></li>
</ul>
<p>在「正常负载情况下」，「为每个任务分配一个线程」的方法能提升「串行执行」的性能。只要请求到达速率不超出服务器的请求处理能力，那么这种方法可以同时带来 <strong>「更快的响应性」</strong> 和 <strong>「更高的吞吐率」</strong>。</p>
<h5 id="b-无限制创建线程的不足"><a href="#b-无限制创建线程的不足" class="headerlink" title="b. 无限制创建线程的不足"></a>b. 无限制创建线程的不足</h5><p>可以想到，这样为每个请求都创建一个线程的方法肯定有诸多不妥，尤其是有大量请求时，那就需要创建大量的线程：</p>
<ul>
<li><strong>线程生命周期的开销非常高。</strong> 线程的创建与销毁并非没有代价，线程的创建过程都会需要「时间」，「延迟处理的请求」，并且需要 「JVM」 和 「操作系统」提供一些辅助操作。如果请求的到达率非常高且请求的处理过程是轻量级的，大多数服务器应用程序就是这种情况，那么为每个请求创建一个线程这种操作将消耗大量的计算资源。<!--极端情况，请求的处理速度handleRquest()比线程的创建销毁的速度都快，哈哈--></li>
<li><strong>资源消耗。</strong> 「活跃的线程」会消耗「系统资源」，尤其是内存。如果可运行的线程数量多于可用处理的数量，那么有些线程将「闲置」。大量的空余线程会占用许多「内存」，给「垃圾回收器」带来压力， 而且大量线程在竞争 CPU 资源时还将产生 「其他性能开销」。所以如果已经有足够多的线程使 CPU 保持忙碌状态，那么此时创建「更多的线程」反而会「降低」性能。<!--这里就用到了JVM的运行时数据区的知识了，虚拟机栈是线程私有的，不管线程是否运行，只要线程被创建了而且存在着，线程都会占着茅坑不拉屎，消耗内存--></li>
<li><strong>稳定性</strong>。 在「可创建线程」的数量上存在着一个限制。这个限制随着「平台」不同而不同，并且受多个因素制约，包括「JVM 的启动参数」，「<code>Thread</code>构造函数中请求的「栈」大小」，以及「底层系统」 对线程的限制等①。 如果破坏了这些限制，那么很可能抛出 <code>OutOfMemoryError</code>异常，要想从这种错误中恢复过来很危险，更好的方法是通过「构造程序」 避免超过这些限制。</li>
</ul>
<p>①【在 32位的机器上，其中一个主要的 <strong>「限制因素」</strong> 是 <strong>线程栈的 地址空间</strong>。 每个线程都维护 <strong>「两个」</strong> 线程栈，一个用于 <strong>「Java 代码」</strong>，另一个用于 <strong>「原生代码」</strong>。通常 JVM 在「默认情况」下会生成一个 <strong>「复合的栈」</strong>，大小约为 0.5MB (可以通过 JVM 标志 <code>-Xss</code> 或者通过 <code>Thread</code> 的构造函数来修改这个值。)如果将 2^32（32位系统下内存的最大值） 除以每个栈的大小<strong>，那么线程数量将被限制为 「几千」 到 「几万」</strong>。其他的一些因素，例如操作系统的限制等，则可能施加更加严格的约束。】</p>
<p><strong>在一定范围内，增加线程可以提高系统的吞吐率，当超过这个阈值，再创建更多的线程只会降低程序的执行速度，过多的创建线程，则会使整个应用程序崩溃。</strong></p>
<p>要想避免这种危险，就需要对程序可以创建的线程数量进行「限制」，并且全面地测试应用程序，从而确保达到线程最大限制数量时，程序也不会因「耗尽资源」而崩溃。</p>
<p>「为每个任务分配一个线程」 这种方法的问题在于”没有限制可创建线程的数量，只限制了远程用户提交 HTTP 请求的速率。”<!--划重点，这是主要原因，没有限制是多么可怕的事情，所以管理资源是多么重要的事情--> 与其他 「并发危险」 一样，在原型设计和开发阶段，无限制的创建线程或许还能正常运行，当到了应用程序部署后并处于高负载下运行时，才会有问题不断地暴露出来。某个恶意用户或者过多的用户同时访问，都会使 Web 服务器的负载达到阈值，从而崩溃。</p>
<p>如果服务器需要提供 高可用性，并且在<strong>「高负载」</strong>情况下<strong>「平缓地降低」</strong>性能，那么这将是一个严重的故障。</p>
<h3 id="6-2-Executor-框架"><a href="#6-2-Executor-框架" class="headerlink" title="6.2 Executor 框架"></a>6.2 Executor 框架</h3><p><strong>「任务」</strong>是一组<strong>「逻辑工作」</strong>单元，而线程则是使「任务」<strong>异步执行</strong>的机制。<!--看看巨人们总结的，任务和线程之间的关系--></p>
<p>之前已经分析过「两种」 通过线程来执行任务的策略：</p>
<ul>
<li>把所有任务在单个线程中串行执行。</li>
<li>将每个任务放在各自的线程中执行。</li>
</ul>
<p>上面这两种方式都存在一些严格的限制：<strong>「串行执行」</strong>的问题在于及其糟糕的响应性和吞吐量，而<strong>「为每个任务分配一个线程」</strong>的问题在于<strong>「资源管理的复杂性」</strong>。</p>
<p>第五章中，我们通过「有界队列」来防止高负荷的应用程序耗尽内存。 「线程池」简化了线程的管理工作，并且 <code>java.util.concurrent</code> 提供了一种灵活的线程池作为 <code>Executor</code>框架的一部分。</p>
<p>在 Java 类库中，<strong>任务执行</strong>的主要抽象不是 <code>Thread</code>，而是 <code>Executor</code>，如下面的程序所示：<!--小伙伴们，这里有个新概念，任务执行，千万要搞清楚 任务、线程、任务执行 这3者之间的关系--></p>
<blockquote>
<p>程序清单6-3 <code>Executor</code> 接口：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">  void execute (Runnable commoand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Executor</code>为灵活且强大的<strong>「异步任务执行框架」</strong>提供了基础，该框架能支持多种不同类型的任务<strong>「执行策略」</strong>。它提供了一种标准的方法将任务的<strong>「提交」</strong>与<strong>「执行」</strong>过程解耦，使用 <code>Runnbale</code>来表示任务。<!--提交与执行的解耦，为能够方便地修改执行策略打下了基础--></p>
<p><code>Executor</code>的实现还提供了对<strong>「生命周期」</strong>的支持，以及<strong>「统计信息收集」</strong>、<strong>「应用程序管理机制」</strong>和<strong>「性能监视」</strong>等机制。</p>
<p><code>Executor</code>基于<strong>「生产者—消费者」</strong>模式，提交任务的操作相当于<strong>「生产者」</strong>（生产待完成的工作单元），执行任务的线程则相当于 「消费者」（执行完这些工作单元）。</p>
<h4 id="6-2-1-示例：基于-Executor的Web服务器"><a href="#6-2-1-示例：基于-Executor的Web服务器" class="headerlink" title="6.2.1 示例：基于 Executor的Web服务器"></a>6.2.1 示例：基于 Executor的Web服务器</h4><p>基于 <code>Executor</code>构建 Web服务器 非常容易。</p>
<blockquote>
<p>程序清单 6-4 基于线程池的 <strong>Web服务器</strong>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutionWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N_THREADS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec = Executors.newFixedThreadPool(N_THREADS);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line">            Runnable task = () -&gt; handleRequest(connection);</span><br><span class="line">            exec.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>TaskExecutionWebServer</code>中，通过使用 <code>Executor</code> 将请求处理任务的「提交」 与任务的实际 「执行」 解耦开，并且只需要采用另一种不同的 <code>Executor</code> 实现，就可以改变服务器的行为。 改变 <code>Executor</code> 实现或配置所带来的影响要远远小于改变「任务提交方式」所带来的影响。</p>
<p>通常，<code>Executor</code>的配置是一次性的，因此在部署阶段可以完成，而提交任务的代码却会不断地「扩散」到整个程序，增加了修改的难度。</p>
<p>我们可以很容易地将 <code>TaskExecutionWebServer</code>修改为类似 <code>ThreadPerTaskWebServer</code> 的行为，只需要使用为每个请求都创建新线程的线程池，编写这样的 <code>Executor</code>也很简单，如下所示：</p>
<blockquote>
<p>程序清单6-5 为每个请求启动一个新线程的 <code>Executor</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为每个请求都创建一个线程的 Executor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，还可以编写一个 <code>Executor</code>使 <code>TaskExecutionWebServer</code>的行为类似于单线程程序的行为 —— 以「同步」 的方式执行每个任务，然后再返回，如下所示：</p>
<blockquote>
<p>程序清单6-6 在调用线程中以同步方式执行所有任务的 <code>Executor</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让线程池以单线程的串行形式执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithinThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-执行策略"><a href="#6-2-2-执行策略" class="headerlink" title="6.2.2 执行策略"></a>6.2.2 执行策略</h4><p>通过将任务的「提交」与 「执行」 解耦，从而无需太大的困难就可以为某种类型的任务指定和修改执行策略。<!--这就是把提交与执行解耦的一个原因--></p>
<p>在执行策略中定义了任务执行的<strong>「What」</strong>、<strong>「Where」</strong>、<strong>「When」</strong>、<strong>「How」</strong>等方面，具体意义如下：</p>
<ul>
<li>在什么（What）线程中执行任务？</li>
<li>任务按照什么（What）顺序执行（FIFO、LIFO、优先级）？</li>
<li>有多少个（How Many）任务能「并发」执行？</li>
<li>在队列中有多少个（How Many）任务在等待执行？</li>
<li>如果系统由于「过载」而需要拒绝一个任务，那么应该选择哪一个（Which）任务？另外，如何（How）通知应用程序有任务被拒绝？</li>
<li>在执行一个任务之前或之后，应该进行哪些（What）动作？</li>
</ul>
<p>各种<strong>「执行策略」</strong>都是一种<strong>「资源管理工具」</strong>，最佳策略取决于<strong>「可用的计算资源」</strong>以及<strong>「服务质量的需求」</strong>。</p>
<p>通过<strong>「限制并发任务的数量」</strong>，可以确保应用程序不会由于<strong>「资源耗尽」</strong>而失败，或者由于在稀缺资源上发生竞争而严重影响性能。</p>
<p>通过将任务的提交与执行的策略分离开，有助于在<strong>「部署阶段」</strong>选择与「<strong>可用硬件资源」</strong>最匹配的执行策略。</p>
<blockquote>
<p>每当看到下面这种形式的代码时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Thread(runnable).start()</span><br></pre></td></tr></table></figure>

<p>如果你希望获得一种更灵活的执行策略时，请考虑使用 <code>Executor</code>来代替直接使用 <code>Thread</code>。</p>
</blockquote>
<!--看看大师们的开发经验，非常实际的应用-->

<h4 id="6-2-3-线程池"><a href="#6-2-3-线程池" class="headerlink" title="6.2.3 线程池"></a>6.2.3 线程池</h4><p><strong>「线程池」</strong>指管理一组<strong>「同构」</strong>工作线程的资源池。线程池与<strong>「工作队列（Work Queue)」</strong>关系密切。<!--大意了啊，不要忘记线程池和工作队列可是息息相关的--></p>
<p>在「工作队列」中保存了所有等待执行的任务。<strong>「工作者线程（Work Thread）」</strong>的任务很简单：从<strong>「工作队列」</strong>中获取一个任务，执行任务，然后返回线程池并等待下一个任务。</p>
<p>“在线程池中执行任务”与比”为每个任务分配一个线程”有众多优势。首先重用线程而不是创建新线程，可以在处理多个请求时「分摊」线程创建和销毁过程中的巨大开销。另外当用户请求到达时，线程已经被创建好，因此省去了等待线程创建的时间，提高了「响应性」。</p>
<p>通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌姿态，同时还可以「防止过多」线程相互竞争资源而使应用程序「耗尽内存」或「失败」。</p>
<p>类库提供了一个灵活的线程池以及一些有用的「默认配置」。可以通过 Executors 中的静态工厂方法之一来创建一个线程池，下面是不同的线程池类型：</p>
<ul>
<li><code>newFixedThreadPool</code>，创建一个固定长度的线程池，每提交一个任务该线程池中就创建一个线程，直到达到线程池「最大数量」。这时线程池的规模将不再变化（如果有线程在执行时遇到「未预期」的 <code>Exception</code>而结束，那么线程池会补充一个新的线程） &lt;—【也就是对于意外减员的应对情况】</li>
<li><code>newCachedThreadPool</code>，创建了一个「可缓存」的线程池，如果线程池的当前规模超过了处理器的需求，那么将「回收」空闲的线程，而当需求增加时，则可以添加新的线程，该线程池的规模不存在任何限制。</li>
<li><code>newSingleThreadExecutor</code>，一个单线程的线程池，它创建单个工作线程来执行任务，如果这个线程「异常结束」，会创建另一个线程进行代替。<code>newSingleThreadExecutor</code>能确保依照任务在队列中的顺序来「串行」执行（例如FIFO，LIFO，优先级） <!--单线程的 `Executor`提供了大量的「内部」同步机制，从而确保了任务执行的任何内存写入操作对于后续任务来说都是「可见」的。这意味着，即使这个线程会时不时被「另一个线程替代」，但对象总是可以「安全」地「封闭」在「任务线程」 中。--></li>
<li><code>newScheduledThreadPool</code>，创建了一个固定长度的线程池，而且以「延迟」或定时的方式来执行任务，类似于 <code>Timer</code>。</li>
</ul>
<p><code>newFixedThreadPool</code> 和 <code>newCachedThreadPool</code> 这两个工厂方法返回「通用」 的 <code>ThreadPoolExecutor</code> 实例，这些实例可以直接用来构造专门用途的 <code>executor</code>。 将在 第8章 中深入讨论「线程池的各个配置选项」。</p>
<p><code>TaskExecutionWebService</code> 中的 Web服务器使用了一个带有 有界线程池 的 <code>Executor</code>。通过 <code>execute</code> 方法将任务提交到工作队列中，工作线程反复地从工作队列汇总取出并执行它们。</p>
<h4 id="6-2-4-Executor-的生命周期"><a href="#6-2-4-Executor-的生命周期" class="headerlink" title="6.2.4 Executor 的生命周期"></a>6.2.4 Executor 的生命周期</h4><p>之前已经说了如何「创建」一个 <code>Executor</code>，但是没有讨论如何关闭它。 <code>Executor</code> 的实现通常会创建线程来执行任务，但 <code>JVM</code> 只有在所有（非守护）线程全部终止之后才会退出。</p>
<p><strong>「因此，如果无法正确地关闭 <code>Executor</code>，那么 <code>JVM</code> 将无法结束。」</strong> <!--所以关闭任务执行框架非常的重要--></p>
<p>由于 <code>Executor</code>以 「异步」 方式来执行任务，因此在任何时刻，之前提交任务的状态不是「立即可见」的。有些任务可能已经完成，有些可能正在运行，而其他的任务可能在队列中等待执行。</p>
<p>当关闭应用程序时，可能使用的是「最平缓」的关闭形式（完成所有已经启动的任务，并且不再接受「任何形式」 的新任务），也可能采用的是「最粗暴」的关闭形式 —— 直接关掉机房的电源，以及其他各种可能的形式。</p>
<p>既然 <code>Executor</code>是为应用程序提供服务的，所以它们也是可关闭的（无论是采用平缓的还是粗暴的方式），并将在关闭操作中「受影响的任务」的状态反馈给「应用程序」。</p>
<p>为了解决 任务执行框架 <code>Executor</code> 的生命周期问题，<code>ExecutorService</code>扩展了 <code>Executor</code> 接口，（这里翻译有一个<strong>重大问题</strong>，明明 <code>ExecutorService</code> 是对 <code>Executor</code> 的扩展，原书把关系写反了翻译成了 <code>Executor</code> 是对 <code>ExcutorService</code> 的扩展。原文：**[�the� ExecutorService �interface �extends� Executor** , adding� a� number� of� methods� for� lifecycle� management�]）添加了一些用于「管理」 生命周期的方法（还有一些用于提交任务的便利方法），具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line">    void shutdown();</span><br><span class="line">    List&lt;Runnable&gt; shutdownNow();</span><br><span class="line">    boolean isShutdown();</span><br><span class="line">    boolean isTerminated();</span><br><span class="line">    boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">		</span><br><span class="line">  &#x2F;&#x2F; ... 其他用于任务提交的便利方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Executor</code> 的<strong>「生命周期」</strong> 有3种状态：运行、关闭和已终止。</p>
<p><code>ExecutorService</code>在初始创建时处于「运行」状态。</p>
<p><code>shutdown</code>方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括那些「还未开始执行」的任务。</p>
<p><code>shutdownNow</code>方法则是粗暴的关闭过程：它将尝试「取消」所有「运行中的」任务，并且不再启动队列中尚未开始执行的任务。</p>
<p>在 <code>ExecutorService</code> 关闭后提交的任务将由 “拒绝执行处理器”（Rejected Execution Handler）处理，它会「抛弃」任务，或者使得 <code>execute</code>方法抛出一个未检查的 <code>RejectedExcutionException</code> 。等所有任务都完成后，<code>ExecutorService</code>将转入终止状态。可以调用 <code>awaitTermination</code> 来等待 <code>ExecutorService</code>到达终止状态，或者调用 <code>isTerminated</code> 来 「轮询」 <code>ExecutorService</code> 是否已经终止。</p>
<p>通常在调用 <code>awaitTermination</code> 之后会立即调用 <code>shutdown</code>，从而产生「同步地关闭」 <code>ExecutorService</code> 的效果。（第7章 将进一步介绍 Executor 的关闭和任务取消方面的内容）</p>
<p>程序清单 6-8 的 <code>LifecycleWebServer</code> 通过增加生命周期支持来 「扩展」 Web服务器的功能。 可以通过两种方法来关闭 Web 服务器：</p>
<ul>
<li>在程序中调用 <code>stop</code></li>
<li>以客户端请求的形式向 Web服务器 发送一个特定格式的 HTTP 请求</li>
</ul>
<blockquote>
<p>程序清单 6-8 支持关闭操作的 Web 服务器：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持关闭操作的 Web 服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="comment">// 只要任务执行框架没有被通知关闭，则一直执行主循环，同时可能因为 ExecutorService 被关闭抛出 拒绝异常，此时需要对异常进行处理</span></span><br><span class="line">        <span class="keyword">while</span> (!exec.isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Socket conn = socket.accept();</span><br><span class="line">                exec.execute(() -&gt; handleRequest(conn));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!exec.isShutdown()) &#123;</span><br><span class="line">                    log(<span class="string">&quot;task submission reject&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对连接进行业务处理，首先判断封装的程序是否处于关闭状态，如果是，则调用 ExecutorService 的shutdown() 方法，否则进行任务分发</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span> </span>&#123;</span><br><span class="line">        Request req = readRequest(connection);</span><br><span class="line">        <span class="keyword">if</span> (isShutdownRequest(req)) &#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dispatchRequest(req);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isShutdownRequest</span><span class="params">(Request req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-5-延迟任务与周期任务"><a href="#6-2-5-延迟任务与周期任务" class="headerlink" title="6.2.5 延迟任务与周期任务"></a>6.2.5 延迟任务与周期任务</h4><p><code>Timer</code> 类负责管理延迟任务（例如在 100ms 后执行的任务）以及周期任务（”以每 10ms 执行一次的任务”）。</p>
<p>然而 <code>Timer</code> 存在一些缺陷，因此应该考虑使用 <code>ScheduledThreadPoolExecutor</code> 来代替它。（<code>Timer</code>支持的是基于「绝对时间」的调度机制，因此任务的执行对「系统时钟」的变化很敏感，而 <code>ScheduledThreadPool</code> 只支持基于相对时间的调度）。</p>
<p>可以通过 <code>ScheduledThreadPoolExecutor</code> 的构造函数或 <code>newScheduledThreadPool</code> 工厂方法来创建该类的对象。</p>
<p><code>Timer</code> 在执行「所有定时任务」时只会创建一个线程。如果某个线程执行时间过长，那么将<strong>「破坏」</strong>其他 <code>TimerTask</code> 的<strong>「定时精确性」</strong>。<!--单线程。。。。Timer的设计师怎么想的。。。--></p>
<p>例如某个周期 TimerTask 需要 每 10ms 执行一次，而另一个 TimerTask 需要执行 40ms，那么这个周期任务或者在 40ms 任务执行完成后快速连续地调用 4次，或者彻底「丢失」4次调用（取决于它是基于<strong>「固定速率」</strong>还是基于<strong>「固定延迟」来</strong>进行调度）。线程池能弥补这个缺陷，它可以提供「多个线程」来执行 延时任务 和 周期任务。</p>
<p><code>Timer</code> 的另一个问题是：如果 <code>TimerTask</code> 抛出了一个「未检查的异常」，那么 <code>Timer</code> 将表现出糟糕的行为。</p>
<p><code>Timer</code>线程并不捕获异常，因此当 <code>TimerTask</code> 抛出未检查异常时将 「终止」 定时线程。 这种情况下 <code>Timer</code> 不会恢复线程的执行，而是会「错误地」 认为整个 Timer 都被取消了。<!--坑爹，抛出未受检查的异常。。。。，找事情啊--></p>
<p>因此「已经调度」但「尚未执行」的 <code>TimerTask</code> 将不会再执行，而新的任务也不能被调度（这个问题称为「线程泄漏」）</p>
<p>在 <strong>程序清单6-9</strong> 的 <code>OutOfTime</code> 中给出了 <code>Timer</code> 为什么出现这种问题的原因，以及如何使得试图提交 <code>TimerTask</code> 的调用者也出现问题。 你可能认为程序会运行6秒后退出，但实际情况是运行1秒就结束了，并抛出一个异常消息 —— “Timer already cancelled”。</p>
<p><code>ScheduledThreadPoolExector</code> 能正确处理这些表现出错误的行为的任务，在 <code>Java5.0</code> 或更高的 <code>JDK</code>中，很少使用 <code>Timer</code>。</p>
<p>如果要构建自己的「调度服务」，可以使用 <code>DelayQueue</code>，它实现了 <code>BlockingQueue</code> 并为 <code>SCheduledThreadPoolExecutor</code> 提供 「调度」 功能。</p>
<p><code>DelayQueue</code> 管理着一组 <code>Delayed</code> 对象。每个 <code>Delayed</code> 对象都有一个相应的延迟时间：在 <code>DelayQueue</code> 中，只有某个元素「逾期」后，才能从 <code>DelayQueue</code> 中执行 <code>take</code> 操作，从 <code>DelayQueue</code> 中返回的对象将根据它们的 「延迟时间」 进行排序。</p>
<h3 id="6-3-找出可利用的并行性"><a href="#6-3-找出可利用的并行性" class="headerlink" title="6.3 找出可利用的并行性"></a>6.3 找出可利用的并行性</h3><p><code>Executor</code> 框架使确定执行策略更加容易，但如果要使用 <code>Executor</code>，必须将任务表述为一个 <code>Runnable</code>。在大多数服务器应用程序中都存在一个「明显的任务边界」：单个用户请求。</p>
<p>但有时候，任务边界并非是显而易见的，例如在很多「桌面应用程序中」。即使是 「服务器应用程序」，在单个客户请求中可能存在可发掘的「并行性」，例如 「数据库服务器」。</p>
<blockquote>
<p>程序清单 6-9 错误的 <code>Timer</code> 行为：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Timer 因抛出异常错误结束的情景</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfTime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">// 执行到这里时 Timer因为抛出了 未预料的异常，之后的代码也无法继续进行了</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> ThrowTask(),<span class="number">1</span>);</span><br><span class="line">        SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> ThrowTask(),<span class="number">1</span>);</span><br><span class="line">        SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这一节中将开发一些「不同版本」 的组件，并且每个版本都实现了「不同程度」的并发性。</p>
<p>该示例组件实现浏览器程序中的 页面渲染（Page-Rendering）功能，它的作用是将 HTML 页面绘制到图像缓存中。为了简便，假设 HTML 页面只包含「标签文本」，以及预定义大小的「图片」和 URL。</p>
<h4 id="6-3-1-示例：串行的页面渲染器"><a href="#6-3-1-示例：串行的页面渲染器" class="headerlink" title="6.3.1 示例：串行的页面渲染器"></a>6.3.1 示例：串行的页面渲染器</h4><p>最简单的方法就是对 <code>HTML</code> 文档进行「串行处理」。当遇到文本标签时，将其绘制到「图像缓存」中。 当遇到图像引用时，先通过网络获取它，然后再将其绘制到图像缓存中。</p>
<p>优点是这种方法非常简单：程序只需要将输入中的每个元素处理一次（甚至不需要缓存文档），<strong>但这种方法会让用户等待很长的时间</strong>，因为获取图片可能需要的时间很久，他们必须一直等待，直到显示所有文本。</p>
<p>另一种「串行」执行的方法更好一些，它先绘制文本元素，同时为图像预留出矩形的占位空间，在处理完了第一遍文本后，程序再开始下载图像，并将他们绘制到相应的占位空间中。</p>
<p>在 <strong>程序清单 6-10</strong> 的 <code>SingleThreadRenderer</code>中给出了上述这种方法的实现。</p>
<p>图像下载过程的大部分时间都是在 「等待 I/O」 操作执行完成。 在这期间 CPU 几乎没有任何工作。</p>
<p>因此，这种串行执行方法没有充分地利用 CPU，使得用户看到最终页面之前要等待过长的时间。</p>
<p>通过将问题「分解」为多个独立的任务「并发执行」，能够获得更高的 「CPU 利用率」和「响应灵敏度」。</p>
<blockquote>
<p>程序清单 6-10 串行地渲染页面元素：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行渲染页面元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadRenderer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先渲染文字</span></span><br><span class="line">        renderText(source);</span><br><span class="line">        <span class="comment">// 定义页面图像引用</span></span><br><span class="line">        List&lt;ImageData&gt; imageData = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 通过source分析出其包含的图像信息 并将其添加到之前定义的 imageData 中</span></span><br><span class="line">        <span class="keyword">for</span> (ImageInfo imageInfo : scanForImageInfo(source)) &#123;</span><br><span class="line">            imageData.add(imageInfo.downloadImage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 渲染页面图片</span></span><br><span class="line">        <span class="keyword">for</span> (ImageData data : imageData) &#123;</span><br><span class="line">            renderImage(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-2-携带结果的任务-Callable-与Future"><a href="#6-3-2-携带结果的任务-Callable-与Future" class="headerlink" title="6.3.2 携带结果的任务 Callable 与Future"></a>6.3.2 携带结果的任务 Callable 与Future</h4><p><code>Executor</code> 框架使用 <code>Runnable</code> 作为其「基本的任务表示形式」。 <code>Runnable</code> 是一种有很大局限性的抽象，虽然 <code>run</code> 能写入到日志文件或者将结果放入某个 「共享的数据结构」，但它<strong>不能</strong> 「返回一个值」 或 「抛出一个受检查的异常」。</p>
<p>许多任务实际上都是存在「延迟计算」这种情况的，例如「执行数据库查询」，「从网络上获取资源」，或者计算某个复杂的功能。</p>
<p>对于上述类型的任务 <code>Callable</code>是一种更好的抽象：它认为主入口点 <code>call</code> 方法将返回一个值，并可能「抛出一个异常」。（要使用 <code>Callable</code> 来表示一个无返回值的任务，可使用 <code>Callable&lt;Void&gt;</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent/Callable.java</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Executor</code> 中包含了一些「辅助方法」能将其他类型的任务「封装」为一个<code>Callable</code>，例如 <code>Runnable</code> 和 <code>java.security.PrivilegedAction</code>。</p>
<p><code>Runnable</code> 和 <code>Callable</code> 描述的都是「抽象的计算任务」。 这些任务通常是「有范围」的 —— 都有一个明确的起始点，并且最终会结束。</p>
<p><code>Executor</code> 执行的任务有 4 个生命周期阶段：<strong>「创建、提交、开始、完成」</strong>。</p>
<p>由于有些任务可能执行时间很长，因此通常希望能够取消这些任务。 在 <code>Executor</code> 框架中，已提交但尚未开始的任务可以取消，但是对于那些<strong>「已经开始」</strong>的任务，只有当它们能<strong>「响应」</strong>中断操作时，才能取消。取消一个已经「完成」的任务不会有任何影响（第7章将进一步介绍取消操作）。</p>
<p><code>Future</code> 表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及「获取任务的结果」和「取消任务」等。 在 <strong>程序清单 6-11</strong> 中给出了 <code>Callable</code> 和 <code>Future</code>。<!--Callable与Future各自的作用一定要清楚，Callable是被提交给Executor的任务单元；Future是Executor获取Callable以后，Executor的返回结果--></p>
<p><code>Future</code> 规范中包含的<strong>「隐含意义」</strong> 是：任务的生命周期「只能前进」，不能后退，就像 <code>ExecutorService</code> 的生命周期一样，当某个任务完成后，它就只能永远停留在「完成」状态上。<!--生命周期只能前进，合理！！！--></p>
<p><code>get</code>方法的行为「取决于任务的状态」（尚未开始、正在运行、已完成）。 如果任务已经完成，那么 <code>get</code> 会立即返回或者抛出一个 <code>Exception</code> ，如果任务没有完成，那么 <code>get</code> 将阻塞并直到任务完成。如果任务抛出了异常，那么 <code>get</code> 将该异常封装为 <code>ExecutionException</code>并重新抛出。 如果任务被取消，那么 <code>get</code> 将抛出 <code>CancellationException</code>。如果 <code>get</code> 抛出了 <code>ExecutionException</code>，那么可以通过 <code>getCause</code> 来获得被封装的「初始异常」。</p>
<p>【看了一下源码，更加实际的体会上述可能抛出异常的多种情况】</p>
<blockquote>
<p><strong>程序清单 6-11</strong> <code>Callable</code> 与 <code>Future</code> 接口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    boolean isDone();</span><br><span class="line"></span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过许多方法创建一个 <code>Future</code> 来 「描述」 任务。 <code>ExecutorService</code> 中的所有 <code>submit</code> 方法都将返回一个 <code>Future</code>，从而将一个 <code>Runnable</code> 或 <code>Callable</code> 提交给 <code>Executor</code>，并得到一个 <code>Future</code> 用来获得任务的执行结果或者取消任务。</p>
<p>还可以显式地位某个指定的 <code>Runnable</code> 或 <code>Callable</code> 实例化一个 <code>FutureTask</code>。（由于 <code>FutureTask</code> 实现了<code>Runnable</code> ，因此可以将它提交给 <code>Executor</code> 来执行，或者直接调用它的 <code>run</code> 方法）</p>
<p>从 <code>Java6</code> 开始，<code>ExecutorService</code> 的实现可以改写为 <code>AbstractExecutorService</code> 中的 <code>newTaskFor</code>方法，从而根据已提交的 <code>Runnable</code> 或 <code>Callable</code> 来控制 <code>Future</code>的「实例化过程」。</p>
<p>在默认实现中仅创建了一个新的 <code>FutureTask</code> 如下所示：</p>
<blockquote>
<p>程序清单 6-12 <code>ThreadPoolExecutor</code> 中的 <code>newTaskFor</code> <strong>的默认实现</strong>：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;</span><br><span class="line">    return new FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上 <code>newTaskFor</code> 这个方法不再 <code>ThreadPoolExecutor.java</code> 中，而是在 ``AbstractExecutorService.java<code>中，但是 </code>ThreadPoolExecutor` 继承 该类，说是默认实现也没问题。】</p>
<p>将 <code>Runnable</code> 或 <code>Callbale</code> 提交到 <code>Executor</code> 的过程中，包含了一个 「安全发布」的过程（参见3.5） —— 将 <code>Runnable</code> 或 <code>Callable</code> 从「提交线程」 发布到最终 「执行任务的线程」。 类似地，在设置 <code>Future</code> 结果的过程中也包含了一个安全发布，将这个结果从计算它的线程发布到任何通过 <code>get</code> 获得它的线程。</p>
<h4 id="6-3-3-示例：-使用-Future-实现页面的渲染器"><a href="#6-3-3-示例：-使用-Future-实现页面的渲染器" class="headerlink" title="6.3.3 示例： 使用 Future 实现页面的渲染器"></a>6.3.3 示例： 使用 Future 实现页面的渲染器</h4><p>为了使页面渲染器实现更高的「并发性」，我们将渲染过程分解为「两个任务」：</p>
<ul>
<li>渲染所有文本 （CPU密集型）</li>
<li>下载所有的图像 （I/O 密集型）</li>
</ul>
<p>这样将 CPU密集型 和 I/O 密集型的任务分解开，即使在单 CPU 系统上也能提升性能。</p>
<p><code>Callable</code> 和 <code>Future</code> 有助于表示这些协同任务之间的交互，在 <strong>程序清单 6-13</strong> 的 <code>Future Renderer</code> 中创建了一个 <code>Callable</code> 来下载所有的图像，并将其提交到一个 <code>ExecutorService</code>。 这将返回一个 「描述任务执行情况」的 <code>Future</code>。 当主任务需要图像时，它会等待 <code>Future.get</code> 的调用结果。</p>
<p>如果幸运的话，当开始请求时所有图像就已经下载完成了，即使没有，下载图像的任务也已经提前开始了。</p>
<blockquote>
<p>程序清单 6-13 使用 <code>Future</code> 等待图像下载：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Future 等待下载图像任务的完成</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureRenderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class="line">        <span class="comment">// 创建一个 Callable 开启一个线程专门下载图片</span></span><br><span class="line">        Callable&lt;List&lt;ImageData&gt;&gt; task = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;ImageData&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ImageInfo imageInfo : imageInfos) &#123;</span><br><span class="line">                result.add(imageInfo.downloadImage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 提交这个 Callable 到 Executor 中，获得一个返回的 Future</span></span><br><span class="line">        <span class="keyword">final</span> Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染文字</span></span><br><span class="line">        renderText(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始获取下载图片的结果</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;ImageData&gt; imageData = future.get();</span><br><span class="line">            <span class="comment">// 渲染图片</span></span><br><span class="line">            imageData.forEach(<span class="keyword">this</span>::renderImage);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 重新声明线程的中断状态</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="comment">// 此时这个 Future 的结果已经不需要了，所以关闭这个任务</span></span><br><span class="line">            future.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> LaunderThrowable.launderThrowable(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get</code> 方法拥有 「状态依赖」 的内在特性，因而调用者不需要知道任务的状态，此外在任务 「提交」 和 「获得结果」 中包含的安全发布属性也确保了这个方法是 「线程安全」的。</p>
<p><code>Future.get</code> 的异常处理代码将处理两个可能的问题：</p>
<ul>
<li>任务遇到了一个 Exception</li>
<li>或者调用 <code>get</code> 的线程在获得结果之前被中断（参见 5.5.2 和 5.4 节）</li>
</ul>
<p><code>FutureRenderer</code> 使得渲染文本任务与下载图像数据的任务「并发」 地执行。 当所有图像下载完成后，会显示到页面上。 这将提升「用户体验」，不仅使用户更快地看到结果，还有效地利用了「并行性」，但我们还可以做的更好：<strong>「用户不必等待所有图像都下载完成，而是希望每下载完成一个就显示出一个」</strong>。</p>
<h4 id="6-3-4-在异构任务并行化中存在的局限"><a href="#6-3-4-在异构任务并行化中存在的局限" class="headerlink" title="6.3.4 在异构任务并行化中存在的局限"></a>6.3.4 在异构任务并行化中存在的局限</h4><p>上个例子中，我们尝试并行地执行两个<strong>「不同类型」</strong>的任务 —— 「下载图像」与 「渲染页面」。然而，通过对 <strong>「异构任务」</strong> 进行并行化来获得重大的性能提升是很困难的。<!--异构，这个词语，记住了啊--></p>
<p>如果工作类型相同，比如都是洗完，那么两个人可以很好地分摊工作，一个负责清洗，一个负责烘干，增加人手可以直接提升工作效率。然而，如果将「不同类型的任务」 平均分配给每个工人却并不容易。</p>
<p>当人数增加时，如果没有在「相似」 的任务之间找出细粒度的「并行性」，那么这种方法带来的好处将减少。</p>
<p>当在多个工人之间分配「异构」 任务时，还有一个问题就是各个任务的「大小」可能完全不同。</p>
<p>如果将两个任务 A 和 B 分配给两个工人，但是「 A 的执行时间是 B 的10倍。」，那么整个过程也只能加速 <strong>9%</strong></p>
<p>当在多个工人之间分解任务时，还需要一定的任务协调开销：「为了使任务分解能提高性能，这种开销不能高于并行性实现的提升。」</p>
<p><code>FutureRenderer</code> 使用了两个任务，其中一个负责<strong>「渲染文本」</strong>，另一个负责<strong>「下载图像」</strong>。 如果渲染文本的速度远高于下载图像的速度（这个可能性很大），那么程序的最终性能与串行执行时的性能差别不大（因为需要等待 下载图像，而渲染文本的耗时可以忽略不计，所以和串行执行几乎差不多），而并行执行任务的代码却更复杂了。因此，虽然做了许多工作来并发执行「异构任务」 以提高并发度，但从中获得的 「并发性」 却十分有限。 （在 11.4.2 节 和 11.4.3节） 中的示例说明了同一个问题。</p>
<p>只有当大量「相互独立」 且 「同构」（相同类型工作）的任务可以进行并发处理时，才能体现出将程序的工作负载分配到「多个任务」 中带来的真正性能提升。</p>
<h4 id="6-3-5-CompletionService：Executor-与-BlockingQueue"><a href="#6-3-5-CompletionService：Executor-与-BlockingQueue" class="headerlink" title="6.3.5 CompletionService：Executor 与 BlockingQueue"></a>6.3.5 CompletionService：Executor 与 BlockingQueue</h4><p>如果向 <code>Executor</code> 提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与任务关联的 <code>Future</code>，然后反复使用 <code>get</code>方法，同时将参数 <code>timeout</code> 指定为 0，从而通过轮询来判断任务是否完成。<!--好繁琐，真的希望有一个阻塞方法，until an available result, 哈哈，下文就有这个阻塞方法--></p>
<p>这种方法虽然可行，却有些「繁琐」。还有一种更好的方法：<strong>「完成服务」</strong>（<code>CompletionService</code>）</p>
<p><code>CompletionService</code> 将 <code>Executor</code> 和 <code>BlockingQueue</code> 的功能融合在一起。 你可以将 <code>Callable</code> 任务提交给它来执行，然后使用类似于队列操作的 <code>take</code> 和 <code>poll</code> 等方法来获得已完成的结果，而这些结果会在完成时被封装为 <code>Future</code>。</p>
<p><code>ExecutorCompletionService</code> 实现了 <code>CompletionService</code>，并将<strong>「计算部分」</strong>委托给了一个 <code>Executor</code>。<!--其实这块的设计，需要仔细想一下设计模式的概念，如果你想为一个类开发一个全新的功能，你会怎么做呢？JAVA的设计师使用了组合方法，计算部分仍然交给Executor，全新的功能交给CompletionService,那么CompletionService持有一个Exectuor对象即可--></p>
<p><code>ExecutorCompletionService</code> 的实现非常简单。 在构造函数中创建一个 <code>BlockingQueue</code> 来保存计算完成的结果。<!--Executor有工作队列，现在ExcutorCompletionService多了个结果队列--></p>
<p>当计算完成时，调用 <code>FutureTask</code> 中的 <code>done</code> 方法。</p>
<p>当提交某个任务时，该任务将首先包装为一个 <code>QueueingFuture</code> ，这是 <code>FutureTask</code> 的一个子类，然后再改写子类的 <code>done</code> 方法，并将结果放入 <code>BlockingQueue</code> 中，如 <strong>程序清单 6-14</strong> 所示 —— <code>take</code> 和 <code>pool</code> 方法委托于 <code>BlockingQueue</code> ，这些方法在得到结果之前将被「阻塞」。</p>
<blockquote>
<p>程序清单 6-14 由 <code>ExecutorCompletionService</code> 使用的 <code>QueueingFuture</code> 类：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 8 的 QueueingFuture</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">            <span class="keyword">super</span>(task, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// JDK 6的 QueueingFuture ，书中给的例子</span></span><br><span class="line">     <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        QueueingFuture(Callable&lt;V&gt; c) &#123;<span class="keyword">super</span>(c);&#125;</span><br><span class="line">        QueueingFuture(RunnableFuture t,V r) &#123;</span><br><span class="line">            <span class="keyword">super</span>(t r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; completionQueue.add(<span class="keyword">this</span>); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到随着 <code>JDK</code> 的演化，底层的实现还是有些许不同的地方的。</p>
<h4 id="6-3-6-示例：使用-CompletionService-实现页面渲染器"><a href="#6-3-6-示例：使用-CompletionService-实现页面渲染器" class="headerlink" title="6.3.6 示例：使用 CompletionService 实现页面渲染器"></a>6.3.6 示例：使用 CompletionService 实现页面渲染器</h4><p>可以通过 <code>CompletionService</code> 从两个方面来提高页面渲染器的性能：</p>
<ul>
<li>缩短总运行时间</li>
<li>提高响应性</li>
</ul>
<p>为每一个图像的下载都创建一个「独立任务」，并在线程中执行它们，从而将「串行」的下载过程转变为「并行」过程。</p>
<p>此外，通过从 <code>CompletionService</code> 中获取结果以及使每张图片在下载完成后「立刻」 显示出来，能使用户获得一个更加「动态」和「更高响应性」 的用户界面，如下面的代码所示：</p>
<blockquote>
<p><strong>程序清单 6-15</strong> 使用 <code>CompletionService</code> 使页面元素在下载完成后立即显示出来：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为每个图片分配一个线程进行下载，并且当其下载完成后立即进行渲染</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过传入 ExecutorService 获得不同的特性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Renderer</span><span class="params">(ExecutorService executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; info = scanForImageInfo(source);</span><br><span class="line">        <span class="comment">// 初始化 ExecutorCompletionService</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorCompletionService&lt;ImageData&gt; completionService =</span><br><span class="line">                <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executor);</span><br><span class="line">        <span class="comment">// 为每个图片分配一个线程进行下载</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ImageInfo imageInfo : info) &#123;</span><br><span class="line">            completionService.submit(imageInfo::downloadIamge);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 渲染页面文字</span></span><br><span class="line">        renderText(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; info.size(); t++) &#123;</span><br><span class="line">                <span class="comment">// 获取下载任务关联的 Future</span></span><br><span class="line">                <span class="keyword">final</span> Future&lt;ImageData&gt; f = completionService.take();</span><br><span class="line">                <span class="comment">// 获取下载任务的结果 ——&gt; ImageData</span></span><br><span class="line">                <span class="keyword">final</span> ImageData imageData = f.get();</span><br><span class="line">                <span class="comment">// 渲染页面图片</span></span><br><span class="line">                renderImage(imageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> LaunderThrowable.launderThrowable(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		<span class="class"><span class="keyword">interface</span> <span class="title">ImageInfo</span> </span>&#123;</span><br><span class="line">        <span class="function">ImageData <span class="title">downloadIamge</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个 <code>ExecutorCompletionService</code> 可以 「共享」 一个 <code>Executor</code>。 因此可以创建一个对于「特定计算」私有，又能「共享」一个公共 <code>Executor</code> 的 <code>ExecutorCompletionService</code> 。因此，<code>CompletionService</code> 的作用就相当于一组<strong>「计算句柄」</strong>，这与 <code>Future</code> 作为单个计算句柄是非常类似的。 通过记录提交给 <code>CompletionService</code> 的任务数量，并计算出已经获得的已完成结果的数量，即使使用一个 「共享的」 <code>Executor</code>，也能知道已经获得了所有任务结果的「时间」。</p>
<h4 id="6-3-7-为任务设置时限"><a href="#6-3-7-为任务设置时限" class="headerlink" title="6.3.7 为任务设置时限"></a>6.3.7 为任务设置时限</h4><p>有时候，如果某个任务无法在指定时间内完成，那么将不再需要它结果，此时可以放弃这个任务。<!--非常常见的业务场景，具有强时效性的任务--></p>
<p>例如：某个 Web 应用程序从外部的广告服务器上获取广告信息，但如果该应用程序在两秒内得不到响应，那么将显示一个默认的广告，这样即使不能获得广告信息，也不会「降低」 网站的响应性能。 类似地，一个门户网站可以从多个数据源「并行地」获取数据，但可能值会在「指定的时间」内等待数据，一旦超出了等待时间，那么将只显示已经获得的数据。</p>
<p>在有限的时间内执行任务的主要困难在于：<strong>「确保得到答案的时间不会超过限定的时间」</strong>，或者在限定的时间内无法获得答案时做出对应的处理。</p>
<p>在支持「时间限制」的 <code>Future.get</code> 中支持这种需求： 当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，将抛出 <code>TimeoutException</code>。</p>
<p>在使用时限任务时需要注意，当这些任务超时后应该 「立即停止」，从而避免为无效的任务浪费计算资源。 要实现这个功能，可以由 「任务本身」 来管理它自己的限定时间，并且在超时后 「中止」 或 「取消」 任务。<!--这里，用"中止"和"取消"，比"放弃"任务更加准确，因为"中止"是java线程的一种状态--></p>
<p>此时可再次使用 <code>Future</code> ,如果一个限时的 <code>get</code> 方法抛出了 <code>TimeoutException</code> ,那么可以通过 <code>Future</code> 来取消任务。</p>
<p>如果编写的任务是「可取消」的（参见第7章），那么可以提前中止它，以免消耗过多的资源。 在程序清单 6-13 和 6-16 的代码中使用了这项技术。【提前中止】</p>
<p>程序清单 6-16 给出了限时 <code>Future.get</code> 的一种 「典型应用」 —— 在生成的页面中包括「响应用户请求的内容」以及从广告服务器上获得的「广告」。 它将获取广告的「任务」 提交给一个 Executor，然后计算剩余的文本页面内容，最后等待广告信息，直到超出指定的时间。（传递给 <code>get</code> 的 <code>timeout</code> 参数的计算方法是： 将指定时间 - 当前时间。 这样可能得到 「负数」，但 <code>java.util.concurrent</code> 中所有与「时限」 相关的方法都将负数视为零，因此不需要额外的代码来处理这种情况）。</p>
<p>如果 <code>get</code> 超时，那么将取消获取广告的任务，并转而使用默认的广告信息。（<code>Future.cancel</code> 的参数为 <code>true</code> 表示任务线程可以在运行中中断，详见 第7章）</p>
<blockquote>
<p><strong>程序清单 6-16</strong> 在指定时间内获取广告信息：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用有时限的任务来放弃超时的失效 Task</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RederWithTimeBudget</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 广告信息，初始化时使用默认广告信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Ad DEFAULT_AD = <span class="keyword">new</span> Ad();</span><br><span class="line">    <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_BUDGET = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 初始化任务执行框架</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里没有处理被中断的异常，而是将其抛给了调用者进行处理</span></span><br><span class="line">    <span class="function">Page <span class="title">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> endNanos = System.nanoTime() + TIME_BUDGET;</span><br><span class="line">        <span class="comment">// 提交一个获取广告的任务到任务执行框架中</span></span><br><span class="line">        <span class="keyword">final</span> Future&lt;Ad&gt; f = exec.submit(<span class="keyword">new</span> FetchAdTask());</span><br><span class="line">        <span class="comment">// Render the page while waiting for the ad 在等待获取广告的同事，渲染这个页面</span></span><br><span class="line">        <span class="keyword">final</span> Page page = renderPageBody();</span><br><span class="line">        Ad ad;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Only wait for the remaining time budget</span></span><br><span class="line">            <span class="comment">// 获取任务执行时间，如果超时则直接抛弃任务 ，如果获取成功则将其赋值给之前定义的广告引用</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> timeLeft = endNanos - System.nanoTime();</span><br><span class="line">            ad = f.get(timeLeft, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">// 发生异常时，将广告信息设置为默认信息</span></span><br><span class="line">            ad = DEFAULT_AD;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="comment">// 如果获取广告的任务超时，不仅将广告设置为默认信息，同时关闭这个获取广告的任务</span></span><br><span class="line">            ad = DEFAULT_AD;</span><br><span class="line">            f.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        page.setAd(ad);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-8-示例：旅行预订门户网站"><a href="#6-3-8-示例：旅行预订门户网站" class="headerlink" title="6.3.8 示例：旅行预订门户网站"></a>6.3.8 示例：旅行预订门户网站</h4><p>「预定时间」 方法可以很容易地 「扩展」 到任意数量的任务上。</p>
<p>例如这样一个旅行预定门户网站：用户输入旅行的「日期」 和其他要求，门户网站获取并显示来自多条航线，旅店或汽车租赁公司的报价。</p>
<p>在获取不同公司报价的过程中，可能会调用「Web服务」，「访问」 数据库，执行一个 EDI 事务或其他机制。在这种情况下，不应该让页面的响应时间 受限于 「最慢服务」的响应时间，而应该只显示在 「指定时间」内接收到的信息。 对于没有及时响应的服务提供者，页面可以忽略它们，或者显示一个提示信息，例如”未在指定时间内获取到 xxx 信息”。<!--一组任务分解为多个任务上，并且抛弃超时的任务--></p>
<p>从一个公司获得报价的过程 与 从其他公司获得报价的过程无关。因此可以将获取报价的过程当成「一个任务」，从而使获得报价的过程能「并发执行」。</p>
<p>创建 n 个任务，将其提交到一个线程池，保留 n 个 <code>Future</code>，并使用限时的 <code>get</code> 方法通过 <code>Future</code> 串行地获取每一个结果 ，这一切都很简单，但还有个更简单的方法 ——&gt; <code>invokeAll</code>。</p>
<p>下面的示例代码中使用了支持限时的 <code>invokeAll</code> ，将多个任务提交到 「一个」 <code>ExecutorService</code> 并获得结果。</p>
<p><code>InvokeAll</code> 方法的参数为 「一组任务」，并返回一组 <code>Future</code>。 这两个集合有着相同的结构，<code>invokeAll</code> 按照任务集合中迭代器的顺序将所有的 <code>Future</code> 添加到返回的集合中，从而使调用者能降各个 <code>Future</code> 与其表示的 <code>Callable</code> 关联起来。<!--太好了，而且集合能将Callable任务单元 与 Future任务结果状态一一对应--></p>
<p>当所有任务都执行完毕时，或者调用线程被中断时，又或者超过指定时限时， <code>invokeAll</code> 将返回。</p>
<p>当超过 「指定时限」后，任务还未完成的任务都会「取消」。 当 <code>invokeAll</code> 返回后，每个任务要么正常地完成，要么被取消。 而客户端代码可以调用 <code>get</code> 或 <code>isCancelled</code> 来判断具体是什么情况。</p>
<blockquote>
<p>程序清单 6-17 在预定时间内请求旅游报价：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requesting travel quotes under a time budget</span></span><br><span class="line"><span class="comment">// 使用 invokeAll 来获取一组报价，这个类的设计非常严谨</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeBudget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取报价的方法 在这里调用 QuoteTask 中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TravelQuote&gt; <span class="title">getRankedTravelQuotes</span><span class="params">(TravelInfo travelInfo, Set&lt;TravelCompany&gt; companies,</span></span></span><br><span class="line"><span class="function"><span class="params">            Comparator&lt;TravelQuote&gt; ranking, <span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 轮询调用每个旅行社指定 TravelInfo 的报价</span></span><br><span class="line">        <span class="keyword">for</span> (TravelCompany company : companies) &#123;</span><br><span class="line">            tasks.add(<span class="keyword">new</span> QuoteTask(company, travelInfo));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知任务执行框架开始这一组任务，并获取其 Future</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;Future&lt;TravelQuote&gt;&gt; futures = exec.invokeAll(tasks, time, unit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来保存真正获取到的报价信息 其数量与获取报价任务的数量相等</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;TravelQuote&gt; quotes = <span class="keyword">new</span> ArrayList&lt;&gt;(tasks.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取任务的迭代器</span></span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;QuoteTask&gt; taskIter = tasks.iterator();</span><br><span class="line">        <span class="comment">// 遍历 Future 获取其任务执行完成的信息</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;TravelQuote&gt; f : futures) &#123;</span><br><span class="line">            <span class="keyword">final</span> QuoteTask task = taskIter.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                quotes.add(f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="comment">// 发生异常时 ，在 task列表中 增加一个 获取失败的报价类</span></span><br><span class="line">                quotes.add(task.getFailureQuote(e.getCause()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                <span class="comment">// 收集因任务关闭导致获取报价失败的类</span></span><br><span class="line">                quotes.add(task.getTimeoutQuote(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(quotes, ranking);</span><br><span class="line">        <span class="keyword">return</span> quotes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取报价类的具体实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuoteTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">TravelQuote</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 旅行社</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelCompany company;</span><br><span class="line">    <span class="comment">// 不同航线</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuoteTask</span><span class="params">(TravelCompany company, TravelInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.company = company;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取失败的报价信息</span></span><br><span class="line">    <span class="function">TravelQuote <span class="title">getFailureQuote</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取超时的报价信息</span></span><br><span class="line">    <span class="function">TravelQuote <span class="title">getTimeoutQuote</span><span class="params">(CancellationException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TravelQuote <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 调用旅行社的获取具体航线信息报价的方法</span></span><br><span class="line">        <span class="keyword">return</span> company.solicitQuote(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表不同旅行社的类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TravelCompany</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回具体报价信息</span></span><br><span class="line">    <span class="function">TravelQuote <span class="title">solicitQuote</span><span class="params">(TravelInfo travelInfo)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报价</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TravelQuote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同航线的信息</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TravelInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/12/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/chapter7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="prev" title="chapter7:虚拟机类加载机制">
                  <i class="fa fa-chevron-left"></i> chapter7:虚拟机类加载机制
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/12/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%20concurrency%20in%20practice/chapter7%E5%8F%96%E6%B6%88%E4%B8%8E%E5%85%B3%E9%97%AD/" rel="next" title="chapter7取消与关闭">
                  chapter7取消与关闭 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei Qi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
