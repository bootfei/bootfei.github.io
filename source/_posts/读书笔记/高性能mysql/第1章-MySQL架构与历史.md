---
title: '第1章:MySQL架构与历史'
date: 2020-12-15 09:28:13
tags:
---



前言: MySQL最重要、最与众不同的是他的**存储引擎架构** ，这种设计将查询处理（Query Processing）以及其他系统任务（Server Task），与数据的存储/提取相分离。这种处理和存储互相分离的设计，可以根据业务的性能和特性要求，来选择数据的存储方式。

本书中，MySQL服务器与存储引擎是两个很重要的独立概念，他们分别是MySQL的3层架构中的上层和底层，但是确实是独立的概念。



# 1.1 MySQL逻辑架构

<img src="https://static.oschina.net/uploads/space/2017/0602/150012_BQzd_581386.png" style="zoom: 50%;"                  />      MySQL服务器逻辑架构图

最上层的服务并非MySQL所独有，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。诸如：连接处理、授权认证、安全等。

大多数MySQL核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。

最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。  存储引擎API包含了几十个底层函数，用于执行诸如"开始一个事务"或者"根据主键提取一行记录"等操作。但存储引擎不回去解析SQL。



## 1.1.1 连接管理与安全性

每个客户端连接在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，这个线程智能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，所以不需要为每一个新建的连接创建或者销毁线程。注意：Mysql5.5以后，提供了API，支持线程池插件，使用少量线程，服务大量链接。

当客户端（应用）连接到服务器后，服务器需要对其进行验证。



## 1.1.2 优化与执行

MySQL会解析查询，并生成内部数据结构（解析树），然后对其各种优化，包括选择合适的索引、决定表的读取顺序等。具体查看第6章内容。

优化器并不关心使用的存储引擎，但存储引擎对于优化有影响。关于索引和schema的优化，具体查看第4、5章。

对于Select语句，在查询之前，服务器会先检查查询缓存(Query Cache). 具体查看第7章内容。



# 1.2 并发控制

无论何时，只要同一时间有多个查询修改同一个数据，就会产生并发问题。

以Unix的email box为例，良好的邮箱投递系统会通过lock防止并发。如果客户试图投递邮件，而邮箱被其他客户锁住，那就必须等待，直到lock释放才行。但是，这种锁方案有其利弊:

pros: 在实际应用环境中工作良好

cons: 并不支持并发处理，因为在任意一个时刻，只有一个时刻，只有一个进程可以修改邮箱的数据，这在大容量的邮箱系统中是个问题。



## 1.2.1 读写锁

为了解决上述方案的弊端，可以通过实现两种类型的锁组成的锁系统来解决。共享锁和排它锁，又称为读锁和写锁。

- 读锁：共享，或者说是不阻塞的，多个查询在同一时刻可以同时读取同一数据
- 写锁：排他，或者说是一个写锁会阻塞其他读锁和写锁。



## 1.2.2 锁粒度

一种提高共享资源并发性的方式就是让锁的锁定对象更加有针对性。尽量只锁定需要修改的数据，而不是所有的资源。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高。

问题是加锁也是消耗资源的。

所以说，所谓的锁策略，就是在数据安全与锁的开销之间寻求平衡。这种平衡也会影响到性能，大多数都是在表上施加行级锁（row-level lock）

### 表锁（table lock）

表锁是***MySQL服务器***中最基本的锁策略。也是开销最小的锁策略。表锁意思很明确，就是锁定整张表。

一个用户在对表进行写操作时，会先获取写锁，这会阻塞其他用户的所有读写操作。只有没有写锁时，其他读取的用户才能获取读锁，读锁之间不会阻塞。

另外，读锁比写锁有更高的优先级，一个写锁的请求可能会被插入到读锁队列的前面。

尽管存储引擎可以管理自己的锁，MySQL服务器本身也是会使用各种有效的表锁来实现不同的目的。例如，MySQL服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。

### 行锁（row lock）

行锁只在***存储引擎***实现，而***MySQL服务器层***没有实现，服务层完全不了解存储引擎中的锁机制。行锁最大程度的支持并发，但也是开销最大的锁策略。



# 1.3 事务

事务就是一组原子性的SQL语句。如果数据库引擎能够全部成功执行该组语句，那么就执行该组语句。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有语句都不会执行。也就是说事务内的语句，要么全部执行成功，要么全部执行失败。

```mysql
start transaction;
select balance from checking where customer_id = 10233;
update checking set balance = balance - 200 where customer_id = 10233;
update savings  set balance = balance + 200 where customer_id = 10233;
commit;
```

**事务的四大特性**

- 原子性（atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。

- 一致性（consistency）：数据库总是从一个一致性状态转换成另外一个一致性状态。如上面的例子，一致性确保了，即使系统在第三条和第四条语句之间时系统崩溃了，支票账号也不会损失200元，因为事务没有提交，所以事务中的修改不会保存到数据库中。

- 隔离性（isolation）：通常来说，一个事务所作的修改在最终提交之前，对其他事务是不可见的。如上面的例子，当执行完第三条语句、第四条语句未执行时，此时另一个账户汇总程序开始运行，则其看到的支票账户的余额并没有减去200元。后面我们再讨论“**隔离级别**”时，会发现为什么会说“通常来说”是不可见的。

- 持久性（durability）：一旦事务提交，则其所作的修改就会永久保存到数据库中。即使系统崩溃，修改的数据也不会丢失。持久性也分很多级别，而且不可能做到100%的持久性保证的侧脸，否则备份有什么用呢？

就像锁粒度会增加系统开销一样，事务也会增加额外的安全性。有些存储引擎支持事务，有些不支持，所以需要根据业务需求是否需要事务去选择存储引擎。



## 1.3.1 隔离级别

SQL标准中，定义了4种隔离级别，每一种级别都规定了一个事务中所作的修改，哪些是在事务内和事务见可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

**Read Uncommitted（未提交读）**
在该隔离级别，事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，也被称之为脏读（Dirty Read）。从性能上来说，**Read Uncommitted**不会比其他级别好很多，但是缺乏更多的好处，所以实际生产中该级别用的很少。

**Read Committed（提交读）**
这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了前面提到的**隔离性(isolation)**的简单定义：一个事务开始时，只能"**看见**"已经提交的事务所做的修改。换句话说，就是事务从开始到提交之前，所做的任何修改，对其余事务都是不可见。这种隔离级有时候也叫**不可重复读**（Nonrepeatable Read），因为执行两次同样的查询，可能会得到不同的结果。

**Repeatable Read（可重复读）**
它确保同一事务的多次读取同样的记录的结果是一致的。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围内的记录时，另一个事务又在该范围内插入了新的记录，当用户再读取该范围的记录时，会发现有新的幻行。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。本章稍后继续讨论。

这是MySQL的默认事务隔离级别。

**Serializable（可串行化）**
这是最高的隔离级别，它强制事务都是串行执行的，解决前面所说的幻读问题。换言之，它是在读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用的问题。



| 事务隔离级别         | 脏读 | 不可重复读 | 幻读可能性 | 加锁读 |
| -------------------- | ---- | ---------- | ---------- | :----- |
| **Read Uncommitted** | Yes  | Yes        | Yes        | No     |
| **Read Committed**   | No   | Yes        | Yes        | No     |
| **Repeatable Read**  | No   | No         | Yes        | No     |
| **Serializable**     | No   | No         | No         | Yes    |



## 1.3.2

死锁是多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致的恶性循环。当多个事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时，也可能会导致死锁。比如，

事务1:

```mysql
start transaction;
update stockPrice set close = 45.50 where stock_id = 4 and date = '2002-05-01';
update stockPrice set close = 19.80 where stock_id = 3 and date = '2002-05-02';
commit;
```

事务2:

```mysql
start transaction;
update stockPrice set high = 20.12 where stock_id = 3 and date = '2002-05-02';
update stockPrice set high = 47.20 where stock_id = 4 and date = '2002-05-01';
commit;
```

如果凑巧，两个事务都执行了第一条update语句，更新了一行数据，同时也锁定了该行数据，然后，两个事务都尝试去执行第二条update语句，却发现该行都被对方锁住了，导致双方都在等待对方释放锁，同时又持有对方的锁。

为了解决这个问题，数据库问题实现了各种死锁检测机制和死锁超时机制。比如InnoDB存储引擎，能检测到死锁的循环依赖。InnoDB处理死锁的办法是，将持有最少排它锁（写锁）的事务进行回滚。另外，也可以使用锁等待超时，就放弃锁请求的方式，这种方式通常来说不太好。

大多数处理死锁的方式都是重新执行因死锁回滚的事务即可。



## 1.3.3 事务日志

