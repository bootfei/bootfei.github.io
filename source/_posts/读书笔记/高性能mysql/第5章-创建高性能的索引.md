---
title: '第5章:创建高性能的索引'
date: 2020-12-18 11:09:59
tags: [db,mysql]
---

索引在 MySQL 中也叫键（Key），是存储引擎用于快速找到记录的一种数据结构。

表的数据量增大时，索引对良好的性能非常关键。**索引是优化查询性能的最有效的手段。**

# 5.1 索引基础

MySQL 中，存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

```mysql
mysql> SELECT * FROM blog.user WHERE user_id = 5;
```

如果 user_id 列上建有索引，MySQL 将使用该索引找到 user_id 为 5 的行。MySQL 先在索引上按值进行查找，然后返回所有包含该值的数据行。

> 索引可以包含一个或多个列的值。如果包含多个列，MySQL 只能高效使用最左前缀列。

## 5.1.1 索引类型

### B-Tree 索引

B-Tree 索引使用 B-Tree 数据结构来存储数据。

**MySQL 的默认索引类型**，大多数存储引擎都支持，只是存储结构会有所差异。例如 InnoDB 使用 B+Tree<!--即每个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历-->

存储引擎以不同的方式使用B-Tree索引，性能也各有不同， 各有优劣。 例如， MyISAM使用前缀压缩技术使得索引更小， 但lnnoDB则按照原数据格式进行存储。 再如MyISAM索引通过数据的物理位置引用被索引的行， 而InnoDB则根据主键引用被索引的行。

**B-Tree通常意味着所有的值都是按顺序存储的， 并且每一个叶子页到根的距离相同**。图5-1展示了B-Tree索引的抽象表示， 大致反映了InnoDB索引是如何工作的。MyISAM使用的结构有所不同， 但基本思想是类似的。

![img](https://upload-images.jianshu.io/upload_images/12219352-d6faa5076cc31613.png)

**B-Tree索引能够加快访问数据的速度， 因为存储引擎不再需要进行全表扫描来获取需要的数据， 取而代之的是从索引的根节点（图示井未画出）开始进行搜索。**根节点的槽中存放了指向子节点的指针， 存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点， 这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值， 要么该记录不存在。

**叶子节点比较特别， 它们的指针指向的是被索引的数据， 而不是其他的节点页**（不同引擎的 ”指针” 类型不同）。 图5-1中仅绘制了一个节点和其对应的叶子节点， 其实在根节点和叶子节点之间可能有很多层节点页。 树的深度和表的大小直接相关。

**B-Tree 对索引列是顺序组织存储的， 所以很适合查找范围数据**。 例如， 在一个基于文本域的索引树上， 按字母顺序传递连续的值进行查找是非常合适的， 所以像 “找出所有以 I 到 K 开头的名字“ 这样的查找效率会非常高。

```mysql
create table people (
	last_name varchar(50) not null,
	first_name varchar(50) not null,
	dob date not null,
	gender enum('m','f') not null,
	key(last_name, first_name, dob)
);
```

**可以使用B-Tree索引的查询类型。 B-Tree索引适用于全键值、键值范围或键前缀查找**。其中键前缀查找只适用于根据最左前缀的查找。前面所述的索引对如下类型的查询有效。

> **全值匹配**
>
> 全值匹配指的是和索引中的所有列进行匹配， 例如前面提到的索引可用于查找姓名为CubaAllen、出生于1960-01-01 的人。
>
> **匹配最左前缀**
>
> 前面提到的索引可用于查找所有姓为Allen的人， 即只使用索引的第一列。
>
> **匹配列前缀**
>
> 也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只使用了索引的第一列。
>
> **匹配范围值**
>
> 例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。
>
> **精确匹配某一列并范围匹配另外一列**
>
> 前面提到的索引也可用于查找所有姓为Allen, 井且名字是字母K开头（比如Kim、Karl等） 的人。即第一列last_name全匹配，第二列first_name范围匹配。
>
> **只访问索引的查询**
>
> B-Tree通常可以支持“只访问索引的查询", 即查询只需要访问索引， 而无须访问数据行。后面我们将单独讨论这种“覆盖索引” 的优化。

因为索引树中的节点是有序的， 所以除了按值查找之外， 索引还可以用于查询中的ORDER BY操作（按顺序查找）。一般来说， 如果B-Tree可以按照某种方式查找到值， 那么也可以按照这种方式用于排序。所以， 如果ORDER BY子句满足前面列出的几种查询类型， 则这个索引也可以满足对应的排序需求。

下面是一些关于B-Tree索引的限制：

> • **如果不是按照索引的最左列开始查找， 则无法使用索引。**例如上面例子中的索引无法用于查找名字为Bill的人， 也无法查找某个特定生日的人， 因为这两列都不是最左数据列。类似地， **也无法查找姓氏以某个字母结尾的人**。
>
> •**不能跳过索引中的列**。 也就是说， 前面所述的索引无法用千查找姓为 Smith 并且在某个特定日期出生的人。 如果不指定名 (first_name), 则 MySQL 只能使用索引的 第一列。
>
> **•如果查询中有某个列的范围查询， 则其右边所有列都无法使用索引优化查找**。 例如 有查询 WHERE last_name='Smith' AND first_name LIKE 'J%' AND dob = '1976- 12-23 ', 这个查询只能使用索引的前两列， 因为这里LIKE是一个范围条件（但是服务器可以把其余列用于其他目的）。 如果范围查询列值的数最有限， 那么可以通过使用多个等于条件来代替范围条件。 

在优化性能的时候， 可能需要**使用相同的列但顺序不同的索引**来满足不同类型的查询需求。

### 哈希索引

哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hashcode), 哈希码是一个较小的值，井且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

在MySQL中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。值得一提的是，Memory引擎是支持非唯一哈希索引的， 这在数据库世界里面是比较与众不同的。如果多个列的哈希值相同，

索引会以链表的方式存放多个记录指针到同一个哈希条目中。

因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。 然而，哈希索引也有它的限制：

•	哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。 不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的 影响并不明显。

•	哈希索引数据并不是按照索引值顺序存储的，所以也就无法用千排序。

•	哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内 容来计算哈希值的。 例如，在数据列(A,B)上建立哈希索引，如果查询只有数据列A, 则无法使用该索引。

•	哈希索引只支持等值比较查询，包括＝、 IN() 、<:=>(注意<>和＜＝＞是不同的操作）。 也不支持任何范围查询，例如WHERE price> 100。

•	访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈 希值）。 当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行 比较，直到找到所有符合条件的行。

•	如果哈希冲突很多的话，一些索引维护操作的代价也会很高。 例如，如果在某个选择性很低（哈希冲突很多） 的列上建立哈希索引，那么当从表中删除一行时， 存储 引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多， 代价越大。

因为这些限制，哈希索引只适用于某些特定的场合。 而一且适合哈希索引，则它带来的 性能提升将非常显著。 举个例子，在数据仓库应用中有一种经典的 “星型" schema, 需要关联很多查找表，哈希索引就非常适合查找表的需求。

除了Memory引擎外，NOB集群引擎也支持唯一哈希索引，且在NDB集群引擎中作用 非常特殊，但这不属千本书的范围。

InnoDB引擎有一个特殊的功能叫做 “自适应哈希索引(adaptivehash index)"。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基千B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希 查找。 这是一个完全自动的、 内部的行为，用户无法控制或者配置，不过如果有必要， 完全可以关闭该功能。

创建自定义哈希索引。 如果存储引擎不支持哈希索引，则可以模拟像InnoDB一样创建哈希索引，这可以享受一些哈希索引的便利，例如只需要很小的索引就可以为超长的键创建索引。

思路很简单：在B-Tree基础上创建一个伪啥希索引。 这和真正的哈希索引不是一 回事， 因为还是使用B-Tree进行查找，但是它使用哈希值而不是键本身进行索引查找。 你需要做的就是在查询的WHERE子旬中手动指定使用哈希函数。

# 5.2 索引的优点

索引可以让服务器快速地定位到表的指定位置。 但是这并不是索引的唯一作用，到目前为止可以看到，根据创建索引的数据结构不同，索引也有一些其他的附加作用。

最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。 因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。 最后， 因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。 

> 据此特性，总结下来索引有如下三个优点：
>
> 1.	索引大大减少了服务器需要扫描的数据量。
>
> 2.	索引可以帮助服务器避免排序和临时表。
>
> 3.	索引可以将随机I/O变为顺序I/O。

# 5.3 高性能的索引策略

## 5.3.1 独立的列

如果查询中的列不是独立的则MySQL就不会使用索引。 **列不是独立的，指的是列是表达式的一部分，或函数参数**

```mysql
SELECT ... WHERE id + 1 = 5;
SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

## 5.3.2 前缀索引和索引选择性

在很长的字符列上使用索引时，会使索引大且慢。可以使用前面的模拟哈希索引。

也可以只索引开始的部分字符。对于 BLOB、TEXT 或很长的 VARCHAR 类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。需要选择足够长的前缀以保证较高的选择性（防止重复），同时不能太长以节约空间。

> 前缀索引的优缺点：
>
> - 使索引更小、更快。
> - MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。

### 确定合适的前缀长度

#### 1. 生成测试数据

在示例数据库 [sakila](https://blog.csdn.net/kikajack/article/details/80181263) 中没有合适的例子，需要从表 city 中生成一个示例表：

```mysql
-- <----从表 city 生成一个示例表 city_demo，这样就有足够的数据用来演示：
CREATE TABLE sakila.city_demo(city VARCHAR(50) NOT NULL);
INSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city;

-- <---- 这一行重复5次
INSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city_demo;   

-- <---- 执行下面 SQL 随机分布数据：
UPDATE sakila.city_demo SET city = (SELECT city FROM sakila.city ORDER BY RAND() LIMIT 1);

-- <----首先，我们找到最常见的城市列表：
mysql> SELECT COUNT(*) as cnt, city FROM city_demo GROUP BY city ORDER BY cnt DESC LIMIT 10;
+-----+-----------+
| cnt | city      |
+-----+-----------+
|  72 | London    |
|  48 | Baiyin    |
|  48 | Jinzhou   |
|  48 | Nador     |
|  47 | Isesaki   |
|  47 | Elista    |
|  47 | Garland   |
|  47 | Linz      |
|  46 | Compton   |
|  45 | Shikarpur |
+-----+-----------+
10 rows in set
```

#### 2. 现在查找最频繁出现的城市前缀

先从 3 个前缀字母开始：

```mysql
mysql> SELECT COUNT(*) as cnt, LEFT(city,3) AS pref FROM city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;
+-----+------+
| cnt | pref |
+-----+------+
| 418 | San  |
| 181 | Tan  |
| 175 | Cha  |
| 166 | Sal  |
| 161 | al-  |
| 147 | Shi  |
| 146 | Sou  |
| 133 | Kam  |
| 128 | Val  |
| 123 | Man  |
+-----+------+
10 rows in set
```

每个前缀都比原来的城市出现的次数更多，因此唯一前缀比唯一城市要少得多。然后我们增加前缀的长度，直到这个前缀的选择性接近完整列的选择性。经过实验后发现前缀长度为 7 时比较合适：

```mysql
mysql> SELECT COUNT(*) AS cnt, LEFT(city,7) AS pref FROM city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;
+-----+---------+
| cnt | pref    |
+-----+---------+
|  72 | San Fel |
|  72 | London  |
|  66 | Valle d |
|  54 | Santiag |
|  48 | Nador   |
|  48 | Baiyin  |
|  48 | Jinzhou |
|  47 | Isesaki |
|  47 | Elista  |
|  47 | Garland |
+-----+---------+
10 rows in set
```



#### 3. 计算最佳前缀长度

可以通过计算完整列的选择性来计算合适的前缀长度，使前缀的选择性接近于完整列的选择性。计算完整列的选择性：

```mysql
MariaDB [sakila]> SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;
+-------------------------------+
| COUNT(DISTINCT city)/COUNT(*) |
+-------------------------------+
| 0.0039                        |
+-------------------------------+
1 row in set (0.119 sec)
```

计算不同前缀长度的选择性：

```mysql
MariaDB [sakila]> SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3,
    -> COUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4,
    -> COUNT(DISTINCT LEFT(city, 5))/COUNT(*) AS sel5,
    -> COUNT(DISTINCT LEFT(city, 6))/COUNT(*) AS sel6,
    -> COUNT(DISTINCT LEFT(city, 7))/COUNT(*) AS sel7
    -> FROM sakila.city_demo;
+--------+--------+--------+--------+--------+
| sel3   | sel4   | sel5   | sel6   | sel7   |
+--------+--------+--------+--------+--------+
| 0.0030 | 0.0037 | 0.0038 | 0.0039 | 0.0039 |
+--------+--------+--------+--------+--------+
1 row in set (0.312 sec)
```

前缀长度达到 7 时，选择性提升的幅度基本稳定。

### 创建前缀索引

```mysql
MariaDB [sakila]> ALTER TABLE sakila.city_demo ADD KEY(city(7));
Query OK, 0 rows affected (3.350 sec)               
Records: 0  Duplicates: 0  Warnings: 0
```

### 创建后缀索引

比如，查找某个域名的所有电子邮件地址。MySQL原生并不支持反向索引，但是可以通过把字符串反转后存储，并基于此建立前缀索引。

## 5.3.3 多列索引

 一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

```mysql
create table t{
 c1 int,
 c2 int,
 c3 int,
 key(c1),
 key(c2),
 key(c3)
}
```

**在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能**。

## 5.3.4 选择合适的索引列顺序

我们遇到的最容易引起困惑的问题就是索引列的顺序。 正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要（顺便说明，本节内容适用于B-Tree索引；哈希或者其他类型的索引并不会像B-Tree索引一样按顺序存储数据）。

在一个多列B-Tree索引中，**索引列的顺序意味着索引首先按照最左列进行排序**，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。

所以多列索引的列顺序至关重要。对于如何选择索引的列顺序有一个经验法则：**将选择性最高的列放到索引最前列**。这个建议有用吗？在某些场景可能有帮助，但通常不如避免随机IO和排序那么重要。

**当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的**。这时候索引的作用只是用于优化WHERE条件的查找。

### 真实的案例分析1：

```sql
SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;
```

是应该创建一个 (staff_id,customer_id) 索引还是应该颠倒一下顺序？可以跑一些查询来确定在这个表中值的分布情况，并确定哪个列的选择性更高。先用下面的查询预测一下，看看各个 WHERE 条件的分支对应的数据基数有多大：

```sql
mysql> SELECT SUM(staff_id=2), SUM(customer_id=584) FROM payment\G;
*************************** 1. row ***************************
     SUM(staff_id=2): 7992
SUM(customer_id=584): 30
1 row in set (0.01 sec)
```

根据前面的经验法则，应该将索引列 custom_id 放到前面，因为对应条件值的 customer_id 数量更小。我们再来看看对于这个 customer_id 的条件值，对应的 staff_id 列的选择性如何：

```sql
mysql> SELECT SUM(staff_id=2) FROM payment WHERE customer_id=584\G;
*************************** 1. row ***************************
SUM(staff_id=2): 17
1 row in set (0.00 sec)
```

这样做有一个地方需要注意，查询的结果非常依赖于选定的具体值。如果按上述办法优化，可能对其他一些条件值的查询不公平，服务器的整体性能可能变得更糟，或者其他某些查询的运行变得不如预期。

如果是从诸如 pt-query-digest 这样的工具的报告中提取 “最差” 查询，那么再按上述办法选定的索引顺序往往是非常高效的。**如果没有类似的具体查询来运行，那么最好按经验法则来做，因为经验法则考虑的是全局基数和选择性，而不是某个具体查询**：

```sql
mysql> SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
    -> COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
    -> COUNT(*)
    -> FROM payment\G;
*************************** 1. row ***************************
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
1 row in set (0.01 sec)
```

customer_id 的选择性更高，所以答案是将其作为索引列的第一列：

```sql
mysql> ALTER TABLE payment ADD KEY(customer_id, staff_id);
Query OK, 0 rows affected (0.13 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

**当使用前缀索引的时候，在某些条件值的基数比正常值高的时候，问题就来了**。

### 真实的案例分析2：

下面是一个我们遇到过的真实案例，在一个用户分享购买商品和购买经验的论坛上，这个特殊表上的查询运行得非常慢：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201110015105316.png#pic_center)

这个查询看似没有建立合适的索引，所以客户咨询我们是否可以优化。EXPLAIN 的结果如下：

<img src="https://img-blog.csdnimg.cn/20201110015114505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JtMTk5OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:50%;" />

MySQL 为这个查询选择了索引 (groupId，userId)，如果不考虑列的基数，这看起来是一个非常合理的选择。但如果考虑一下 user ID 和 group ID 条件匹配的行数，可能就会有不同的想法了：

<img src="https://img-blog.csdnimg.cn/20201110015124615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JtMTk5OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:50%;" />

从上面的结果来看符合组 (groupId) 条件几乎满足表中的所有行，符合用户 (userId) 条件的有 130 万条记录——也就是说索引基本上没什么用。因为这些数据是从其他应用中迁移过来的，迁移的时候把所有的消息都赋予了管理员组的用户。这个案例的解决办法是修改应用程序代码，区分这类特殊用户和组，禁止针对这类用户和组执行这个查询。

**从这个小案例可以看到经验法则和推论在多数情况是有用的，但要注意不要假设平均情况下的性能也能代表特殊情况下的性能，特殊情况可能会摧毁整个应用的性能**。

最后，尽管关于选择性和基数的经验法则值得去研究和分析，但一定要记住别忘了 WHERE 子句中的排序、分组和范围条件等其他因素，这些因素可能对查询的性能造成非常大的影响。

## 5.3.5 聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，**但 InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行**。

**当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。术语 “聚簇” 表示数据行和相邻的键值紧凑地存储在一起<!--这并非总是成立，马上就可以看到-->。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引**（不过，覆盖索引可以模拟多个聚簇索引的情况，本章后面将详细介绍）。

因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。

图 5-3 展示了聚簇索引中的记录是如何存放的。**注意到，叶子页包含了行的全部数据，但是节点页只包含了索引列**。在这个案例中，索引列包含的是整数值。

<img src="https://img-blog.csdnimg.cn/20201118144745927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JtMTk5OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:33%;" />

**InnoDB 将通过主键聚集数据。如果没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引**。InnoDB 只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。

聚集的数据有一些重要的优点：

- **可以把相关数据保存在一起**。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 IO。
- **数据访问更快**。聚簇索引将索引和数据保存在同一个 B-Tree 中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
- **使用覆盖索引扫描的查询可以直接使用页节点中的主键值**。

同时，聚簇索引也有一些缺点：

- 聚簇数据最大限度的提高了 I/O 密集型应用的性能，但**如果数据全部都放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有那么优势了**。
- **插入速度严重依赖于插入顺序**。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表。
- **更新聚簇索引列的代价很高**，因为会强制 InnoDB 将每个被更新的行移动到新的位置。
- **基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临 “页分裂” 的问题**。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次分裂操作。页分裂会导致表占用更多的磁盘空间。
- **聚簇索引可能导致全表扫描变慢**，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
- **二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列**。
- **二级索引访问需要两次索引查找，而不是一次**。

最后一点可能让人有些疑惑，**为什么二级索引需要两次索引查找**？答案在于二级索引中保存的 “行指针” 的实质。要记住，二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。

这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次 B-Tree 查找而不是一次。对于 InnoDB，自适应哈希索引能够减少这样的重复工作。

### InnoDB和MyISAM的数据分布对比



### 在InnoDB表中按主键顺序插入行

**最好避免随机的聚簇索引，特别对于I/O密集型的应用。例如，从性能的角度考虑，使用UUID作为聚簇索引会很糟糕：它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。**

为了演示这一点，我们做如下两个基准测试。

第一个使用整数ID插入shopinfo表，整数ID自增且为主键：

第二个例子是shopinfo_uuid表，除了主键改为UUID，其余和前面的shopinfo表完全相同。

我们先向这两个表各插入1万条记录。然后再向这两个表继续插入9万条记录，观察这两个表的插入耗时和表索引大小，下表对测试结果进行比较。

| 表名          | 行数  |  时间   | 索引大小（MB） |
| ------------- | ----- | :-----: | :------------: |
| shopinfo      | 10000 | 0.755s  |      4.08      |
| shopinfo_uuid | 10000 | 1.699s  |      8.16      |
| shopinfo      | 90000 | 8.014s  |     29.47      |
| shopinfo_uuid | 90000 | 46.111s |     60.58      |

通过测试，插入同样的行数和内容（除主键内容），向UUID主键插入行不仅花费的时间更长，而且索引占用的空间也更大。[这一方面是由于主键字段更长，另一方面毫无疑问是由于页分裂和碎片导致的。]()

由于主键的值是顺序的，InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB默认的最大填充因子是页大小的15/16，留出的部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这样顺序的方式加载，主键页就会近似于被顺序的记录填满，这也是所期望的结果。

<img src="https://upload-images.jianshu.io/upload_images/3190591-341cb567b964f649.png" alt="img" style="zoom:50%;" />

而当采用UUID的聚簇索引的表往插入数据，因为新行的主键值不一定比之前的插入值大，所以InnoDB无法简单的总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置----通常是已有数据的中间位置----并且分配空间。这会增加很多额外的工作，并导致数据分布不够优化。

<img src="https://upload-images.jianshu.io/upload_images/3190591-429aa829eb39b79c.png" alt="img" style="zoom: 50%;" />

下面总结使用UUID作为主键的一些缺点：

> - 写入目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机I/O；
> - 因为写入是乱序的，InnoDB不得不频繁的做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个，包含两个叶子节点和一个父节点。
> - 由于频繁的页分裂，页会变得稀疏并被不规则的填充，所以最终数据会有碎片。

把这些随机值载入到聚簇索引以后，需要做一次optimize table来重建表并优化页的填充。

<!--顺序主键也有缺点：对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是auto_increment锁机制；如果遇到这个问题，则可能需要考虑重新设计表或者应用，比如应用层面生成单调递增的主键ID，插表不使用auto_increment机制，或者更改innodb_autonc_lock_mode配置。-->

## 5.3.6 覆盖索引

<!-- 举一反三的思路：通常大家都会根据查询的WHERE条件来创建合适的索引，不过这只是索引优化的一个方面。设计优秀的索引应该考虑到整个查询，而不单单是WHERE条件部分。索引确实是一种查找数据的高效方式，但是MySQL也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。如果索引的叶子节点中包含要查询的数据，那么还有什么必要再回表查询呢？。-->

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引“

覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下如果查询只需要扫描索引而无须回表，会带来多少好处：

- 索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存中（这对于MyISAM尤其正确，因为MyISAM能压缩索引以变得更小）。
- 因为索引是按照列值顺存储的<!--至少在单个页内是如此-->，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。对于某些存储引擎，例如MyISAM和Percona XtraDB，甚至可以通过OPTIMIZE命令使得索引完全顺序排列，这让简单的范围查询能使用完全顺序的索引访问。
- 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。
- 由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。

<!--在所有这些场景中，在索引中满足查询的成本一般比查询行要小得多。-->
**不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值**，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。另外，不同的存储引擎实现覆盖索引的方式也不同，而且不是所有的引擎都支持覆盖索引(在写作本书时，Memory存储引擎就不支持覆盖索引)。

### 示例1: Using Extra的使用

当发起一个被索引覆盖的查询（也叫做索引覆盖查询）时，在EXPLAIN的Extra列可以看到“Using index“的信息。例如，表skaila.inventory有一个多列索引(store_id,film_id)。MySQL如果只需访问这两列，就可以使用这个索引做覆盖索引，如下所示：
<img src="https://img-blog.csdn.net/20180302131848274?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlyZW50aWFucmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图1" style="zoom:33%;" />

### 示例2: 无法优化

索引覆盖查询还有很多陷阱可能会导致无法实现优化。MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。假设索引覆盖了WHERE条件的字段，但不是整个查询涉及的字段。如果条件为假（false），MySQL5.5和更早的版本也总是会回表获取数据行，尽管并不需要这一行且最终会被过滤掉。
来看看为什么会发生这样的情况，以及如何重写查询以解决该问题。

从下面的查询开始：
<img src="https://img-blog.csdn.net/20180302131909405?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlyZW50aWFucmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图2" style="zoom:33%;" />
这里索引无法覆盖查询，有两个原因：

- 没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。不过，理论上MySQL还有一个捷径可以利用：WHERE条件中的列是有索引可以覆盖的，因此MySQL可以使用该索引找到对应的actor并检查title是否匹配，过滤之后再读取需要的数据行。
- MySQL不能在索引中执行LIKE操作。这是底层存储引擎API的限制。MySQL能在索引中做最左前缀匹配的LIKE比较，因为该操作可以转换为简单的比较操作，但是如果是通配符开头的LIKE查询，存储引擎就无法做比较匹配。这种情况下，MySQL服务器只能提取数据行的值而不是索引值来做比较。

### 示例3: 延迟关联

也有办法可以解决上面说的两个问题，需要重写查询并巧妙地设计索引。先将索引扩展至三个数据列(artor,title,prod_id)，然后按如下方式重新查询：
<img src="https://img-blog.csdn.net/20180302131926690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlyZW50aWFucmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图3" style="zoom:33%;" />

我们把这种方式叫做延迟关联（deferred join），因为延迟了对列的访问。

> 在查询的第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id，然后根据这些prod_id值在外层查询匹配获取需要的所有列值。虽然无法使用索引覆盖整个查询，但总算比完全无法利用索引覆盖的好。这样优化的效果取决于WHERE条件匹配返回的行数。

假设这个products表有100万行，我们来看一下上面两个查询在三个不同的数据集上的表现，每个数据集都包含100万行：
1、 第一个数据集，Sean Carrey出演了30000部作品，其中有20000部的标题中包含了Apollo。
2、 第一个数据集，Sean Carrey出演了30000部作品，其中有40部的标题中包含了Apollo。
3、 第一个数据集，Sean Carrey出演了50部作品，其中有10部的标题中包含了Apollo。

使用上面的三种数据集来测试两种不同的查询
![图4](https://img-blog.csdn.net/20180302131947291?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlyZW50aWFucmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
下面是对结果的分析：

- 在示例1中，查询返回了一个很大的结果集，因此看不到优化的效果。大部分时间都花在读取和发送数据上了。
- 在示例2中，经过索引过滤，尤其是第二个条件过滤后只返回了很少的结果集，优化的效果非常明显：在这个数据集上性能提高了5倍，优化后的查询的效率主得益于需要读取40行完整数据行，而不是原查询中需要的30000行。
- 在示例3中，显示了子查询效率反而下降的情况。因为索引过滤时符合第一个条件的结果集已经很小，所以子查询带来的成本反而比从表中直接提取完整行更高。

在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的查询。不过，可以更进一步优化InnoDB。回想一下，InnoDB的二级索引的叶子节点都包含了主键的值，这意味着InnoDB的二级索引可以有效地利用这些“额外“的主键来覆盖查询。
例如，sakila.actor使用InnoDB存储引擎，并在last_name字段有二级索引，虽然该索引的列不包含主键actor_id，但也能够用于对actor_id做覆盖查询：
<img src="https://img-blog.csdn.net/20180302132006356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlyZW50aWFucmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图5" style="zoom:33%;" />



> 这里由于该书发布时间很早，现在MySQL版本5.6以后已经支持索引条件推送(index condition push):
>
> 将数据的过滤条件传送到存储引擎层，而不是传给服务器层





## 5.3.7 使用索引扫描来做排序

mySQL有两种方式可以生成有序的结果，通过排序操作或者按照索引顺序扫描；如果explain的type列的值为index，则说明mysql使用了索引扫描来做排序（不要和extra列的Using index搞混了，那个是使用了覆盖索引查询）。

扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录，但如果索引不能覆盖查询所需的全部列，那就不得不扫描一条索引记录就回表查询一次对应的整行，这基本上都是随机IO，因此按索引顺序读取数据的速度通常要比顺序地 <!--应该是主键顺序--> 全表扫描慢，尤其是在IO密集型的工作负载时。

mysql可以使用同一个索引既满足排序，又用于查找行，因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样是最好的。

只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方向（倒序或升序，创建索引时可以指定ASC或DESC）都一样时，mysql才能使用索引来对结果做排序，如果查询需要关联多张表，则只有当order by子句引用的字段全部为第一个表时，才能使用索引做排序，order by子句和查找型查询的限制是一样的，需要满足索引的最左前缀的要求，否则mysql都需要执行排序操作，而无法使用索引排序。

有一种情况下ORDER BY 子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE 子旬或者JOIN 子旬中对这些列指定了常量，就可以“弥补” 索引的不足。



## 5.3.8 索引压缩

## 5.3.9冗余和重复索引

​    MySQL允许在相同列上创建多个索引，无论是有意的还是无意的。 MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。

​    重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。 应该避免这样创建重复索引，发现以后也应该立即移除。

​    冗余索引和重复索引有一些不同。 如果创建了索引(A, B)， 再创建索引 (A) 就是冗余索引，因为这只是前一个索引的前缀索引。 因此索引(A, B) 也可以当作索引 (A) 来使用（这种冗余只是对B-Tree索引来说的）。 但是如果再创建索引,(B, A), 则不是冗余索引，索引 (B)也不是，因为 B不是索引 (A, B) 的最左前缀列。 另外，其他不同类型的索引（例如哈希索引或者全文索引） 也不会是B-Tree索引的冗余索引，而无论覆盖的索引列是什么。

​    冗余索引通常发生在为表添加新索引的时候。 例如，有人可能会增加一个新的索引(A, B)而不是扩展已有的索引 (A)。还有一种情况是将一个索引扩展为(A, ID), 其中 ID 是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。 但也有时候出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。

## 5.3.10 未使用的索引

## 5.3.11 索引和锁

索引可以让查询锁定更少的行。 如果你的查询从不访问那些不需要的行， 那么就会锁定 更少的行， 从两个方面来看这对性能都有好处。 首先， 虽然InnoDB的行锁效率很高，内存使用也很少， 但是锁定行的时候仍然会带来额外开销 ; 其次， 锁定超过需要的行会增加锁争用井减少并发性。

InnoDB只有在访问行的时候才会对其加锁， 而索引能够减少InnoDB访问的行数， 从而减少锁的数量。 但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。 如果索引无法过滤掉无效的行， 那么在InnoDB检索到数据返回给服务器层以后， MySQL服务器才能应用WHERE子句。 这时已经无法避免锁定行了： InnoDB已经锁住了这些行，到适当的时候才释放。 在MySQL5.1和更新的版本中，lnnoDB可以在服务器端过滤掉行后就释放锁， 但是在早期的MySQL版本中，InnoDB只有在事务提交后才能释放锁。

 尽可能将需要做范围查询的列放到索引的后面，以便优化器能使用尽可能多的索引列。

```mysql
mysql> set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select actor_id from actor where actor_id <5 and actor_id <>1 for update;
+----------+
| actor_id |
+----------+
|        2 |
|        3 |
|        4 |
+----------+
3 rows in set (0.00 sec)
```

这条sql仅仅返回2-4之间的行，但是实际上获取了1-4之间的行的排它锁。InnoDB会锁住第一行，这是因为Mysql为该查询选的执行计划是索引范围扫描。

```java
mysql> explain select actor_id from actor where actor_id <5 and actor_id <>1 for update;
+----+-------------+-------+-------+---------------+---------+---------+------+------+--------------------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra                    |
+----+-------------+-------+-------+---------------+---------+---------+------+------+--------------------------+
|  1 | SIMPLE      | actor | range | PRIMARY       | PRIMARY | 2       | NULL |    3 | Using where; Using index |
+----+-------------+-------+-------+---------------+---------+---------+------+------+--------------------------+
1 row in set (0.00 sec)
```

换句话说，存储引擎的操作时"从索引的开头开始获取满足条件actor_id < 5的记录"，服务器并没有告诉Innodb可以过滤掉第一行的where条件。[注意到Explain中的extra出现了"using where"，这表示MySQL服务器将存储引擎返回行以后在应用where过滤条件。]()

下面的第二个查询就能证明第1行确实被锁了，尽管第一个查询的结果并没有出现第1行。

```mysql
-- 第一个查询
mysql> set autocommit=0;
mysql> begin;
mysql> select actor_id from actor where actor_id <5 and actor_id <>1 for update;
mysql> commit;

-- 第二个查询
#另外开启一个新事务
mysql> begin;
mysql> select actor_id from actor where actor_id =1 for update;
+----------+
| actor_id |
+----------+
|        1 |
+----------+
1 row in set (12.82 sec) #第一个连接commit释放锁之后才能执行查询3
```

> 在MySQL中大多数情况下会使用B-Tree索引。编写查询语句时应该尽可能选择合适的索引以避免单行查找，尽可能使用数据原生顺序，尽可能使用索引覆盖查询。

就像上面的例子展示的，即使使用索引，InnoDB也可能锁住不需要的数据。如果不使用索引查找和锁定行的话，MySQL会做全表扫描并且锁住所有的行，这实在太糟糕了。

> InnoDB在二级索引上使用的是共享（读）锁，但访问主键索引需要排他（写）锁。这消除了使用覆盖索引的可能性，并且使得select for update 比lock in share mode或非锁定查询要慢很多。

注意：尽管理论上使用基于行的日志模式 <!--MVCC-->，在某些事物隔离级别下，服务器不再需要锁定行，但实践中经常无法实现这种预期。比如在Read-commited隔离级别和基于行的日志模式下。



# 5.5 维护索引和表

5.