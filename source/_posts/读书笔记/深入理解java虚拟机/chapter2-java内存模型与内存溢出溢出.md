---
title: 'chapter2:java内存模型与内存溢出溢出'
date: 2020-11-14 08:17:53
tags: [java]
---



### 2.1 概述

### 2.2 运行时数据区域

Java 虚拟机会在程序执行时将数据划分为几个不同的数据区域。 这些区域有着**`不同的用途`**，**`创建和销毁的时间`**，有的区域随着虚拟机进程的启动而一直存在，有的区域则随着用户线程的启动和结束而建立和销毁。

根据 **《Java虚拟机规范》**的规定，Java虚拟机管理的内存区域包括以下几个**`运行时`**区域：

<img src="https://img-blog.csdn.net/20161026225551801" style="zoom: 67%;"/>


#### 2.2.1 程序计数器

**`性质：线程私有，占用空间小，不会发生OOM，是当前线程执行字节码的行号指示器。`**这块空间是线程私有的，因为每个线程都有自己的执行进度。

在 **`Java 虚拟机的概念模型`  **①中：**`字节码解释器`**工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，**`分支`**、**`循环`**、**`跳转`**、**`依赖`**、**`异常处理`**、**`线程恢复`**等基础功能都需要依赖这个计数器来完成。

Java 虚拟机中的**`多线程`**是通过**`线程轮流切换，分配CPU执行时间片`**的方式实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说，是其中的一个内核）都只会执行一条线程中的指令。而程序计数器就担任着线程切换后继续执行线程代码的责任，所以每条线程都有一个独立的「**`程序计数器`**」，各线程之间的计数器`互不影响，独立存储`，我们称这样的区域为「**`线程私有`**」内存。

**`程序计数器存储的内容：`**

- 如果线程执行的是 `Java 方法`，则记录的是正在执行**`的 虚拟机字节码指令地址`**
- 如果正在执行的是`本地方法`（`Native`），则**`程序计数器的值为空`**（`Undefined`）

**`该区域是《Java虚拟机规范》中唯一一个没有规定任何OOM发生的区域，即该区域不会产生内存溢出错误。`**



#### 2.2.2 Java 虚拟机栈

**`性质：线程私有，生命周期与线程相同`**

**`虚拟机栈描述的是 Java 方法执行的线程内存模型`**：每个方法被执行的时候，Java虚拟机都会同步的创建一个「**栈桢」①（`Stack Frame`）**，用于存储 「**`局部变量表`**」、「**`操作数栈`**」，「**`动态连接`**」，「**`方法出口`**」 等信息。

每一个方法从被**调用**到**执行完毕**这个过程就对应着一个`栈桢`在`虚拟机`中从`入栈`到`出栈`的过程。

> 方法调用 ==> 栈帧入栈
>
> 方法执行完成 ==>栈帧出栈

我们经常将 Java 中的内存区域简单粗暴的划分为 「**`堆`**」 和 「**`栈`**」，所谓的栈指的就是这里的「**`虚拟机栈`**」了，或者更多情况下其内容仅仅对应的是 虚拟机栈中的「**`局部变量表`**」 部分。

**`局部变量表`**：存放了`编译期`间可知的各种

- `Java 虚拟机基本数据类型`（`boolean`，`byte`，`char`，`short`，`int`，`float`，`long`，`double`）
- **`对象引用`**（**`reference`** 类型，它可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）
- **`returnAddress`** 类型（**`指向一条字节码指令的地址`**）

**局部变量表中的具体存储模式**：使用**`变量槽（Slot）存储数据`**，64位长度的 long 和 double 类型的会占用2个变量槽，其余数据类型占用1个。

`局部变量表`所需的内存空间在编译期就已经完成分配（因为是可知的），当进入一个方法时，这个`方法`需要在`栈桢中`分配多大的`局部变量空间是完全确定`的，`在方法运行期间不会改变局部变量表的大小。`<!--这里的大小指的是变量槽的数量，而每个槽对应的真实内存占用大小则是虚拟机自行实现。-->

虚拟机栈中可能发生的2种异常：

- **`StackOverflowError`**：当**`线程请求的栈深度大于虚拟机允许的栈深度`**时，出现该异常。
- **`OutOfMemoryError`**:  如果虚拟机栈可以动态拓展，而且拓展时无法申请到足够的内存

> **`①`**：栈桢是方法运行时期很重要的数据结构，在本书的 第8章 中对其进行详细讲解。



#### 2.2.3 本地方法栈

本地方法栈与虚拟机栈所发挥的作用**`非常相似`**，`区别`是本地方法栈为虚拟机使用到的`本地方法`服务，而虚拟机栈则是为虚拟机使用到的 `Java 方法`服务。

《Java 虚拟机规范》对本地方法栈中的方法使用的`语言`，`使用方式`，`数据结构`**`没有任何强制规定`**，具体的虚拟机可以根据需要自由地实现。例如 **`HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一`**。



#### 2.2.4 Java 堆

对于 Java 应用程序来说，「**`堆`**」 是 虚拟机所管理的内存中**`最大的一块`**，堆也是线程中**`共享`**的一块内存区域，在**`虚拟机启动时创建`**。

> **`Java 堆中存放着几乎所有的对象实例`**。`《Java 虚拟机规范》` 中这样描述堆：所有的`对象实例`以及`数组`都应当在堆上分配。

而这里的`几乎`是指从实现角度来看，随着 Java 语言的发展，现在已经能看到一些迹象表示日后可能出现**值类型**的支持，即使只考虑现在，由于**`即时编译`**技术的进步，尤其是**`逃逸分析`**技术的日渐强大，**`栈上分配、标量替换`**优化手段已经导致并不是绝对的所有对象都在堆上产生。

**`Java 堆是垃圾收集器管理的内存区域`**，因此一些资料中它也被称为 GC 堆。从回收内存的角度来看，由于现代垃圾收集器大部分都是基于「**`分代收集`**」理论设计，所以 Java 堆中经常出现**`「新生代」、「老年代」、「永久代」、「Eden空间」、「From Survivor 空间」、「To Survivor 空间」`**等名词、这些区域的划分仅仅是一些垃圾收集器的**`共同特性`**或者**`设计风格`**而已，**`而非某个 Java 虚拟机具体实现的固有内存布局，更不是《Java 虚拟机规范》里对 Java 堆的进一步细致划分。`**

在**`十年前`**，以 \**`G1`\** 收集器的出现作为分界，作为业界绝对主流的 `HotSpot` 虚拟机的内部垃圾收集器全部基于「**`经典分代`**」设计，需要 `新生代`、`老年代`收集器搭配才能工作，在这样的背景下，上面的说法还算是不会产生太大歧义。但是**`到了今天`**，垃圾收集器技术与十年前已经不可用同日而语，**`HotSpot`** 里也出现了**`不采用 分代设计的新垃圾收集器`**，再按之前的说法来定义就有很多不准确的地方了。

> 从分配内存的角度看：所有线程共享的 Java 堆中可以划分出多个`线程私有`的「**`分配缓冲区`**」（Thread Local Allocation Buffer TLAB）来**`提升对象分配时的效率`**。

但是不管如何划分，都不会改变 **Java堆中存储的内容的性质**：无论哪个区域，存储的都只能是「`对象实例`」，将Java 堆进行细分的目的是为了**`更好地回收内存，或者更快的分配内存`**。

根据 `《Java 虚拟机规范》` 规定，**Java 堆可以处于`物理上不连续`的内存空间中，但是`逻辑上是连续`的**，这就像是用磁盘存储文件一样，并不要求每个文件连续存放，但对于大对象（比如数组）多数虚拟机实现出于简单、存储高效的考虑，很可能会要求连续的内存空间来存放数组。

Java堆可以是**`固定大小`**，也可以是**`可扩展`**的，通过 `-Xmx` 和 `-Xms` 参数设定。如果Java堆中没有足够的内存完成实例分配，并且堆也无法继续扩展，则抛出**`OOM内存溢出异常`**。


#### 2.2.5 方法区

**`方法区（Method Area)`** ：**线程共享**，存储已被虚拟机加载的`类型信息`、`常量`、`静态变量`、`即时编译器编译后的代码缓存`等数据。

> 《Java 虚拟机规范》中把方法区描述为「**`堆的一个逻辑部分`**」，但是方法区有一个别名叫做「**`非堆`**」（Non-Heap），目的是与 Java堆区分开。

到了 **`JDK8`**，**`完全废弃`了`永久代`的概念**，此时`HotSpot` 与 `JRockit` 、`J9`一样，在**`本地内存`**中实现的**`元空间`**（Meta-sapace）代替了之前的永久代，将 JDK7 中永久代的剩余内容（主要是**`类型信息`**）移动到元空间中。

`《Java 虚拟机规范》`对于方法区的约束非常宽松，**该区域可以使用不连续的内存，可以选择固定大小和可扩展大小，甚至可以选择不实现垃圾收集**。这部分区域的内存回收目标主要是针对「**`常量池`**」的`回收`和对Java **`类型的卸载`**，一般来说针对这个区域的回收`效果并不令人满意`，尤其是类型卸载的条件非常苛刻，但是对于这部分的回收又是必要的，之前出现过若干严重bug就是这部分区域的回收出现问题导致**`内存泄漏`**。

根据`《Java虚拟机规范》`规定，`方法区如果无法满足新的内存分配需求`，抛出 `OOM` 异常。

**为什么要将永久代（PermGen）替换为元空间（MetaSpace）呢？**

> 其中一个原因是因为 **永久代受 JVM本身设置影响，有固定的内存大小上限**，而元空间使用的是机器的`直接内存`，只受本机可用内存限制，不会出现 `OOM` 异常。
>
> 可以使用 `-XX:MaxMetaSpaceSize` 设置最大元空间大小，默认值 `unlimited`。

#### 2.2.6 运行时常量池(属于方法区)

**`运行时常量池（Runtime Constant Pool）是方法区的一部分。`** `Class 文件`中除了有 `类的版本`、`字段`、`方法`、`接口`等**`描述信息`**外，还有一项信息是「**`常量池表`**」（Constant Pool Table），用于存放编译期生成的各种**`字面量`**与**`符号引用`**，这部分内容将在**类加载后**放到**`方法区的运行时常量池`**中。

**`Java虚拟机对于 Class 文件的每一部分都有严格规定`** —— 例如每个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机`认可`、`加载`和`执行`，但**对于运行时常量池，《Java 虚拟机规范》没有做任何细节要求**，这使得不同提供商实现的虚拟机可以按照自己的需求来实现这个内存区域。

一般来说，除了保存 Class 文件中描述的**`符号引用`**外，还会把**`符号引用翻译出来的直接引用`**也**存储在运行时常量池中**。①

**`运行时常量池`**相对于 **`Class 文件常量池`**的另外一个重要特征是：**具备动态性**。 Java 语言并不要求常量一定只有在编译期才能产生，也就是说，并非只有预置在 Class 文件常量池中的内容才能进入方法区运行时常量池，在程序运行期间也可以将新的常量添加到池中。比如 `String` 类的 **`intern()`** 方法就是将字符串添加到运行时常量池中。

**运行时常量池是方法区的一部分，所以当常量池无法再申请到内存时会抛出 OOM 异常。**

#### 2.2.7 直接内存

**直接内存不是虚拟机运行时数据区域的一部分**，也不是《Java 虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且可能导致 OOM 异常出现，所以作者在这里一起进行讲解。

`JDK 1.4` 中加入了 `NIO`（New Input/Output)类，引入了一种「**`基于通道`**」（Channel）与「**`缓冲区`**」（Buffer）的`I/O` 方式，**它可以使用 `Native` 函数库直接分配堆外内存**，然后通过一个存储在 `Java` 堆中的 **`DirectByteBuffer`** 对象作为这块内存的**引用**进行**操作**。**这样在一些场景中能显著提高性能，因为避免了 `Java 堆`和 `Native 堆`之间来回`复制数据`的开销。**

`本机直接内存`是不会受到 `Java堆`大小的限制，但是既然是内存，则肯定还是受到本机总内存（包括物理内存，SWAP 分区或者分页文件）大小以及处理器寻址空间的限制，一般**配置虚拟机参数**时，会根据实际内存设置 `-Xmx`等参数信息，但经常`忽略了直接内存`，如果**各个内存区域的综合大于物理内存限制**（包括实际物理内存和操作系统级的内存限制）从而导致动态扩展时内存不够，就会发生**`OOM异常`**。



### 2.3 HotSpot虚拟机对象探秘

**本章主要内容：** `HotSpot` 虚拟机在Java 堆 中**对象分配**、**布局**和**访问**的全过程。

#### 2.3.1 对象的创建

最简单最常用的创建对象的方式：使用 `new` 操作符。在虚拟机中，以下是虚拟机中普通对象（仅限普通 Java 对象，不包括数组和 Class 类型对象）的创建过程：

当JVM 遇到一条内容是 `new` 的字节码指令时，**`首先检查`**这个指令的参数是否能在常量池<!--这里指的应该是方法区的运行常量池-->中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被`加载`、`解析`和`初始化`过。

**如果没有，则执行**「**`类加载`**」过程。这个过程在第7章中详细探讨。

当类加载检查通过后，**`接下来虚拟机为新生对象分配内存`**。 对象所需的内存大小在类加载完成后就可以完全确定下来，为对象分配空间相当于把一块确定大小的内存块从 Java 堆中划分出来。

- 如果Java 堆中的内存是绝对规整的，所有被使用过的内存都放在一边，没有使用的放在另一边，中间存在一个指针作为分界点的指示器，那么分配内存只需要将指向向空闲空间方向挪动一段与对象大小相等的距离即可，这种方式叫做「**`指针碰撞`**」（Bump The Pointer）。
- 如果 Java 堆中的内存并不是规整的，已被使用的内存和空间内存相互交错，那就没有办法简单地通过指针碰撞完成了，则虚拟机需要维护一个「**`空闲列表`**」（Free List）。

选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又取决于采用的垃圾收集器是否带有 「**空间压缩整理**」（Compact）能力决定。

- 当使用 **`Serial`**、**`ParNew`** 等带压缩整理过程的收集器时，系统采用的分配方法是「指针碰撞」，既简单又高效；
- 当使用 **`CMS`** 这种基于`清除（Sweep）算法`的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。

除了划分可用空间，还需要考虑对象的创建是非常频繁的行为，有可能存在正在给对象A 分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况，针对这个问题有两种解决方案：

- 对分配内存空间的动作进行同步处理 —— 实际上虚拟机是采用 **`CAS（Compare And Swap）`**配上失败重试的方式保证更新操作的原子性
- 把内存分配动作按线程划分在不同的空间之中进行 —— 每个线程在 Java 堆中预先分配一小块内存空间，称为「本地线程缓冲（TLAB）」，哪个线程要分配内存，就在那个线程的本地缓冲区中进行分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。是否使用TLAB 可以使用参数 `XX: +/- UseTLAB` 参数设定

从**虚拟机的视角**来看，**初始化零值之后**一个`新的对象`就`已经产生`了。但是从**Java程序视角**来看，对象的创建才`刚刚开始`——构造函数还没有执行，所有的类实例字段都是默认的零值，对象需要的其他资源和状态信息也没有按照预定的意图构造好。<!--哈哈，这也是面试常常问的点-->

一般来说，由字节码流中的 `new` 指令后面是否跟随 `invokespecial` 指令所决定， **Java 编译器**会在遇到 `new` 关键字的地方**同时生成这两条字节码指令**，但如果直接通过其他方式产生的对象则不一定如此。 new 指令之后会接着执行 `<init>()`方法，也就是构造函数中的对象初始化的内容，这样一个真正可用的对象才完全被构建完成。

HotSpot虚拟机对象在堆内存的**存储布局**分为3个部分：

- `对象头 Header`
- `实例数据 InstnaceData`
- `对齐填充 Padding`

对象头包括两类信息：

**`第一类`**用于存储「**对象自身的运行时数据**」，如 `哈希码`（HashCode）、`GC 分代年龄`、`锁状态标志`、`线程持有的锁`、`偏向线程ID`、`偏向时间戳等`。这部分数据在 32位和64位虚拟机中的长度分别为 32 和 64 个比特，官方称这部分为 "**Mark Word**"

对象需要存储的运行时数据很多，其实已经超出了 32、64位 `Bitmap` 结构所能记录的最大限度，但是对象头里的信息是**与对象自身定义的数据无关的额外存储成本**，考虑到虚拟机的空间效率，Mark Word 被设计成一个有着**动态定义的数据结构**，目的是在**极小的空间内存储尽可能多的数据，根据对象的状态复用自己的存储空间**。

例如在 32位 的 HotSpot 虚拟机中，对象未被同步锁锁定的状态下， Mark Word 的 32个 比特存储空间中的 `25个 比特存储对象哈希吗，4个比特存储对象分代年龄，2个比特存储锁标志位，1个比特固定为0`.

在其他状态（轻量级锁定，重量级锁定，GC标记、可偏向）下对象的存储内容如下表所示：

| 存储内容                             | 标志位 | 状态               |
| ------------------------------------ | ------ | ------------------ |
| 对象哈希码、对象分代年龄             | 01     | 未锁定             |
| 指向锁记录的指针                     | 00     | 轻量级锁定         |
| 指向重量级锁的指针                   | 10     | 膨胀（重量级锁定） |
| 空、不需要记录信息                   | 11     | GC 标记            |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01     | 可偏向             |

对象头中的另一部分存储的是 「**类型指针**」，即对象指向它的类型元数据的指针（也就是 Class类？），Java 虚拟机通过这个指针来确定该对象是哪个类的实例。

并不是所有虚拟机实现都必须在对象数据上保留类型指针，也就是说查**找对象的元数据信息并不一定要经过对象本身**。

如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录**数组长度**的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是如果数组的长度是不确定的，则无法通过元数据中的信息推断出数组的大小。



#### 2.3.2 对象的内存布局

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MDE3MTQwLTgwMzc0ZTY1YzZiMjBjYmU" style="zoom: 50%;" />

HotSpot虚拟机对象在堆内存的**存储布局**分为3个部分：

- `对象头 Header`
- `实例数据 InstnaceData`
- `对齐填充 Padding`

对象头包括两类信息：

**`第一类`**用于存储「**对象自身的运行时数据**」，如 `哈希码`（HashCode）、`GC 分代年龄`、`锁状态标志`、`线程持有的锁`、`偏向线程ID`、`偏向时间戳等`。这部分数据在 32位和64位虚拟机中的长度分别为 32 和 64 个比特，官方称这部分为 "**Mark Word**"

对象需要存储的运行时数据很多，其实已经超出了 32、64位 `Bitmap` 结构所能记录的最大限度，但是对象头里的信息是**与对象自身定义的数据无关的额外存储成本**，考虑到虚拟机的空间效率，Mark Word 被设计成一个有着**动态定义的数据结构**，目的是在**极小的空间内存储尽可能多的数据，根据对象的状态复用自己的存储空间**。

例如在 32位 的 HotSpot 虚拟机中，对象未被同步锁锁定的状态下， Mark Word 的 32个 比特存储空间中的 `25个 比特存储对象哈希吗，4个比特存储对象分代年龄，2个比特存储锁标志位，1个比特固定为0`.

在其他状态（轻量级锁定，重量级锁定，GC标记、可偏向）下对象的存储内容如下表所示：

| 存储内容                             | 标志位 | 状态               |
| ------------------------------------ | ------ | ------------------ |
| 对象哈希码、对象分代年龄             | 01     | 未锁定             |
| 指向锁记录的指针                     | 00     | 轻量级锁定         |
| 指向重量级锁的指针                   | 10     | 膨胀（重量级锁定） |
| 空、不需要记录信息                   | 11     | GC 标记            |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01     | 可偏向             |

对象头中的另一部分存储的是 「**类型指针**」，即对象指向它的类型元数据的指针（也就是 Class类？），Java 虚拟机通过这个指针来确定该对象是哪个类的实例。

并不是所有虚拟机实现都必须在对象数据上保留类型指针，也就是说查**找对象的元数据信息并不一定要经过对象本身**。

如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录**数组长度**的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是如果数组的长度是不确定的，则无法通过元数据中的信息推断出数组的大小。



#### 2.3.3 对象访问定位

创建对象的目的当然是访问对象，访问对象首先需要定位对象。 Java 程序通过**栈上** `reference` 数据来操作堆上的具体对象。对象的具体访问方式由虚拟机自己实现，《Java 虚拟机规范》中对于 reference 只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问对象。

目前的主流方式有两种：

1. **`使用句柄`**。
2. **`直接指针`**。

如果使用句柄，则 Java 堆中可能会划分出一块内存用来作为「**`句柄池`**」，`reference` 中存储的就是对象的`句柄地址`，而句柄中包含了「**`对象实例数据`**」与「**`类型数据`**」各自具体的地址信息。

![](http://static.oschina.net/uploads/space/2012/0219/232926_WTnX_103999.png)

如果使用直接指针访问， Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。

![](http://static.oschina.net/uploads/space/2012/0219/232935_FM5T_103999.png)

这两种访问方式`各有优势`：使用句柄访问最大的好处是在 `reference` 中存储的是**稳定句柄地址**，在**对象被移动**（垃圾收集时移动对象是非常普遍的行为）**时**只需要`改变句柄中的实例数据指针`，而 `reference` **本身不需要被修改。**

使用直接指针访问最大的好处就是速度更快，省去了一次指针定位的时间开销，由于对象访问这个操作在虚拟机中非常频繁，所以这类开销积少成多也是一项极为客观的执行成本。

`HotSpot` 主要使用第二种方式进行对象访问（也存在例外，如果使用了 `Shenandoah` 收集器也会有一次额外的转发）。

但是在各种语言、框架中使用句柄来访问对象的方式也十分常见。



​			

### 实验课：

-XX:+PrintGCDetails

1. 堆异常
   1. 通过参数-Xms20M   -Xmx20M 控制
2. 栈异常
   1. 通过-Xss128k
3. 方法区和运行时常量区异常
   1. 通过-XX:PermSize=10M -XX:MaxPermSize=10M
   2. String.intern()方法是一个Native方法，如果字符串常量池中已经包含了一个等于此String对象的字符串，则返回，否则，直接将此String对象包含的字符串加到常量池中，并返回引用。
   3. 小补充：比如CGLIB这种类增强技术，需要很大的方法区保证动态生成的Class可以加载到内存
   4. 现在jdk越来越“去永久代“