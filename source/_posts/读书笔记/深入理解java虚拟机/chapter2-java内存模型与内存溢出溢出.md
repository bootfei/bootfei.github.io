---
title: 'chapter2:java内存模型与内存溢出溢出'
date: 2020-11-14 08:17:53
tags: [java]
---





<img src="https://www.programmersought.com/images/459/32a80743681c44757daa599b4633e9bb.png" style="zoom: 67%;" />

1. java虚拟机所管理的内存，包含以下几个运行时数据区域:
   1. 程序计数器：线程私有，
      1. 表示当前线程所执行的字节码的行号指示器
      2. 如果线程正在执行JAVA方法，那么这个计数器指向的是虚拟机字节码指令的地址; 如果正在执行的是Native方法，则为空Undefined;
   2. 虚拟机栈：线程私有
      1. 表示Java方法执行的内存模型：每个方法执行时都会创建一个栈帧(stack frame),
         1. 用于存储局部变量表、操作数栈、动态链接、方法出口等信息
         2. 方法调用 ==> 栈帧入栈，方法执行完成 ==>栈帧出栈
         3. 局部变量：包括基本类型，
      2. 生命周期 = 线程周期
      3. 2种异常
         1. StackOverflowError:如果线程请求的栈深度大于虚拟机所允许的深度
         2. OutOfMemoryError: 如果虚拟机栈可以动态拓展，而且拓展时无法申请到足够的内存
   3. 本地方法栈:
      1. 和虚拟机栈基本一致，有些虚拟机将两者合二为一
      2. 虚拟机栈执行JAVA方法（字节码），本地方法栈执行Native方法
   4. 堆：线程共享
      1. 存放几乎所有的对象的实例
      2. 一种异常
         1. OutOfMemoryError:  通过-Xms -Xmx控制
   5. 方法区: 线程共享
      1. 存放虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码
      2. 运行时常量池：属于方法区的一部分
         1. 类加载时，Class文件中的常量池信息，会进入到此area
         2. 需要注意的是，不仅编译期间产生的常量，而且运行期间产生的常量，也可以进入常量池，比如String类的Intern()方法
      3. 有的虚拟机使用**永生代**实现方法区
2. 直接内存
   1. 不是虚拟机运行时数据区的一部分
   2. 一种异常OutOfMemory
   3. 原理
      1. JDK1.4中加入了NIO(New Input/Output类)，引入了Channel与Buffer的IO方式，这种方式可以直接使用Native函数直接分配**堆外内存**, 然后通过通过堆内的DirectByBuffer对象作为这块内存的引用进行操作
      2. 因为这种方式避免了在java堆和native堆中来回复制数据，所以在某些场景下提高了性能
3. 对象的创建
   1. 第一步:遇到了new指令, 先检查指令的参数是否能在**常量池**(应该是方法区中的常量池)中定位到一个**类的符号引用**，并且检查该符号代表的类是否已经被**加载、解析、初始化**。如果没有，则进行相应的**类加载**过程。
   2. 第二步:类加载检查通过后，在堆中为对象分配内存。对象所需要内存的大小在类加载完成后就可以确定。
      1. 假设java堆是绝对规整的，那么就有一个指针，作为内存是否空闲的分界点指示器。==>指针碰撞
      2. 假设java堆不是规整的，那么虚拟机需要维护一个记录可用内存的列表(Free List)。==> 空闲列表
      3. 采用哪种内存分配方式，是由内存是否规整决定的；内存是否规整，是由垃圾收集器是否有压缩整理功能决定的。所以，Serial,ParNew等有Compact过程的收集器，通常是指针碰撞；CMS等有Mark-Sweep算法的，通常是空闲列表。
      4. 分配内存过程中的线程安全性问题
         1. 线程A给对象A分配内存，修改了指针，同时线程B给对象B分配内存，也修改了指针
         2. 2种解决方案:
            1. 对分配内存的动作加上同步：实际上虚拟机采用CAS+失败重试保证更新指针的原子性
            2. TLAB(Thread Local Allocation Buffer): 
               1. 把内存的分配按照线程，划分在不同的空间之中进行。哪个线程需要分配内存，就在自己的线程中分配内存
               2. 只有TLAB用完并分配新的TLAB时，才需要同步锁定。
               3. 虚拟机使用+XX:+/-UseTLAB来决定是否使用
   3. 第三步: 内存分配完成后，对内存空间初始化为零值。这保证了对象的实例字段在JAVA代码中可以不被赋初始值就能直接使用
   4. 第四步:设置对象的对象头信息，比如这个对象是哪个类的实例，如何找到类的元数据信息等等
   5. 第五步:上面4步，从虚拟机角度，一个对象以及创建完成了。但从JAVA程序角度，对象刚刚创建，还需要执行 <init> 方法，否则，所有字段还是零值。所以，执行new指令以后都会紧跟<init>方法，按照程序员的意愿执行。
4. 对象的内存布局和访问定位
   1. 内存布局
      <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MDE3MTQwLTgwMzc0ZTY1YzZiMjBjYmU" style="zoom:67%;" />
      1. 对象头:包含2部分，分别是对象自身的运行时数据、类型指针
         1. 对象自身的运行时数据，称为Mark Word
         2. 类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例
      2. 实例数据:对象真正存储的有效信息,无论是从父类继承下来的字段，还是子类定义的
      3. 对齐填充
   2. 访问定位
      1. 有个概念必须澄清: JAVA程序是通过栈上的reference数据来操作堆上的具体对象，但是reference类型在虚拟机中只是规定了一个指向对象的引用，并没有定义这个引用该通过何种方式去定位、访问堆中对象的具体位置，所以对象的访问方式取决于虚拟机的实现。
      2. 主流的实现有：使用句柄和直接指针
         1. 使用句柄：java堆中，专门有一块内存作为句柄池，reference存储对象的句柄地址，句柄中包含了对象实例数据的地址和类型数据的地址
            ![](http://static.oschina.net/uploads/space/2012/0219/232926_WTnX_103999.png)
         2. 直接指针:  reference直接存储对象（不仅仅是对象实例地址）的地址，而且Java堆必须要将类型地址和数据地址一起放在对象地址中了
            ![](http://static.oschina.net/uploads/space/2012/0219/232935_FM5T_103999.png)



​			

实验课：
-XX:+PrintGCDetails

1. 堆异常
   1. 通过参数-Xms20M   -Xmx20M 控制
2. 栈异常
   1. 通过-Xss128k
3. 方法区和运行时常量区异常
   1. 通过-XX:PermSize=10M -XX:MaxPermSize=10M
   2. String.intern()方法是一个Native方法，如果字符串常量池中已经包含了一个等于此String对象的字符串，则返回，否则，直接将此String对象包含的字符串加到常量池中，并返回引用。
   3. 小补充：比如CGLIB这种类增强技术，需要很大的方法区保证动态生成的Class可以加载到内存
   4. 现在jdk越来越“去永久代“