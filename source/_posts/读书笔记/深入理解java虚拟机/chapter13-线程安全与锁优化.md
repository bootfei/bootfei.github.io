---
title: 'chapter13:线程安全与锁优化'
date: 2020-11-16 22:17:11
---

ref:

1. Java并发-atomic原子类包源码剖析
   https://www.jianshu.com/p/27e07df2672e



## 13.1 概述

本章将介绍如何保证并发的正确性和如何实现线程安全。

## 13.2 线程安全

见JCP的定义吧，这本书的定义不太好。

### 13.2.1 Java 语言中的线程安全

我们可以不把线程安全当做一个非真即假的二元排他选项来看待，按照线程安全的“安全程度”由强至弱来排序，我们可以将 Java 语言中各种操作共享的数据分为以下 5 类：

#### 1. 不可变

不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要采取任何的线程安全保障措施，final 关键字带来的可见性就提到这一点，只有一个不可变的对象被正确地构建出来（没有发生 this 逃逸的情况），那其外部的可见状态永远不会改变，永远也不会看到它在多线程之中处于不一致的状态。

保障对象行为不影响自己状态的途径很多，最简单的就是把对象中带有状态的变量都声明为 final，这样在构造函数结束之后，它就是不可变的。

#### 2. 绝对线程安全

 “不管运行时环境如何，调用者都不需要任何额外的同步措施” 通常需要付出很大的，甚至是不切实际的代价。在 Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。

##### 示例：

java.util.Vector 是一个线程安全的容器，它的 add()、get()、size() 这方法都是被 synchronized 修饰的，但是，也不意味着调用它的时候永远不需要同步手段。

很明显，尽管这里调用的 Vector 的 get()、remove()、size() 方法都是同步的，但是在多线程环境中，如果不在方法调用端做额外的同步措施，这段代码仍然是不安全的。因为如果另一个线程恰好在错误的时间里删除一个元素，导致序号 i 已经不再可用的话，再用 i 访问数组就会抛出一个 ArrayIndexOutOfBoundsException。

#### 3. 相对线程安全

<!--相对线程安全就是我们通常意义上讲的线程安全-->，**它需要保证这个对象单独的操作时线程安全的**，我们调用的时候不需要做额外的保障措施，但是对一些特定顺序的连续调用，就可能需要在调用端使用额外的不同手段来保证调用的正确性。

Java 中大部分的线程安全类都属于这种类型，如果 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。

#### 4. 线程兼容

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。比如 ArrayList 和 HashMap 等。

#### 5. 线程对立

线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。略。



### 13.2.2 线程安全的实现方法

本节，代码编写如何实现线程安全和虚拟机如何实现同步与锁这两者都会有所涉及，相对而言更偏重后者一些。

#### 1. 互斥同步（悲观锁）

互斥同步是常见的一种并发正确性保障手段<!--其实我认为是牺牲一定的并发性能，使得串行化和阻塞化，以保证正确性-->。

**同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用**。

**互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这 4 个字面里，互斥是因，同步时果；互斥是方法，同步是目的。**

> 互斥同步也叫阻塞同步。

Java 中最基本的互斥同步手段就是 synchronized 关键字，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码指令都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指明了对象参数，那就是说这个对象的 reference；如果没有明确指明，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。

根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，相应的，在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就释放了。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

首先，synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的情况。其次，同步块在已经进入的线程执行完成之前，会阻塞后面其他线程的进入。

Java 的线程是映射到操作系统的原生线程上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态上，因此状态转换需要耗费很多的处理器时间。对代码简单的同步块（如被 synchronized 修饰的 getter()或 setter() 方法），状态转换消耗的时间可能比用户代码执行的时间还要长。所以 synchronized 是 Java 语言中的一个重量级的操作。<!--而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，而避免频繁的切入到核心态之中。-->

除了 synchronized 之外，我们还可以使用 juc 包中的重入锁（ReentrantLock）来实现同步。它还有一些高级功能：等待可中断、可实现公平锁、以及锁可以绑定多个条件。

- 等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理器执行时间非常长的同步块很有帮助。比如 tryLock(long timeout, TimeUnit unit) 方法。
- 公平锁：指多个线程在等待同一个锁时，必须要按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 的锁是非公平的，ReentrantLock 默认情况下也是非公平的，可以通过带布尔值的构造函数创建公平锁。
- 锁绑定条件：指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外的添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition() 方法即可。

JDK 1.6  或以上的版本 synchronized 与 ReentrantLock 的性能基本上完全持平了。优先考虑使用 synchronized 来进行同步。

#### 2. 非阻塞同步（乐观锁）

互斥（阻塞）同步最主要的问题时进行线程阻塞和唤醒所带来的的性能问题。**它属于一种悲观的并发策略**，<!--总是认为只要不去做正确的同步措施（如加锁），那肯定会出现问题，无论是数据共享还是真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作-->。随着指令集的发展，我们有了另一个选择：基于冲突检测的并发策略，通俗的说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止）。这种**乐观的并发策略**的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。

因为我们需要操作和检测这两个步骤是具备原子性，硬件可以保证一个从遇上看起来需要多次操作的行为只通过一条处理器指令就能完成，这样指令常用的有：

- 测试并设置（test-and-set）。
- 获取并增加（fetch-and-increment）。
- 交换（swap）。
- 比较并交换（compare-and-swap，下文称为 CAS）。
- 加载链接/条件存储（load-linked/store-conditional，下文称 LL/SC）。

CAS 指令需要 3 个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 指令执行时，当前仅当 V 符合预期值 A 时，处理器就用新值更新 V 值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。

JDK 1.5 之后，Java 程序才可以使用 CAS 操作，该操作是由 sun.misc.Unsafe 类里面的 compareAndSwapInt() 等几个方法包装提供的。

JUC 中的 AtomicInteger 类中的 incrementAndGet() 方法就是使用 Unsafe 类的 getAndAddInt() 方法实现的。

```java
    // ... AtomicInteger 类 ...
    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }
    
    // ... Unsafe 类 ...
    public final int getAndAddInt(Object o, long offset, int delta) {
        int v;
        do {
            v = getIntVolatile(o, offset);
        } while (!compareAndSwapInt(o, offset, v, v + delta));
        return v;
    }
    
    public final native boolean compareAndSwapInt(Object o, long offset,
                                                  int expected,
                                                  int x);
```

CAS 还有一个逻辑漏洞：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，如果这期间它的值曾经被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的“ABA”问题。JUC 包中提供了一个一个带有标记的原子引用类“AtomicStampedReference”类来解决这个问题，它可以保证 CAS 的正确性。不过目前这个类比较“鸡肋”。大部分情况下 ABA 问题不会影响程序的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。

#### 3. 无同步方案

要保证线程安全，并不是一定要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性手段。如果一个方法本来就不涉及共享数据，那就自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。

##### 可重入代码

可重入代码也叫做纯代码，可以额在代码执行的任意时刻中断它，转而去执行另一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。

可重入的代码有一些公共的特征，比如不依赖存储在堆上的数据和公共系统资源、用到的状态量都是由参数传入、不可调用非可重入的方法等。<!--其实就是JCP说的线程封闭中的栈封闭，比如局部变量-->

##### 线程本地存储（Thread Local Storage）

如果一段代码所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样就无须同步也能保证线程之间不会出现数据争用的问题。

符合这种特点的应用程序有很多，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的应用实例就是经典 web 交互模式中的“一个请求对应一个服务器线程”的处理方式，这种处理方式的广泛应用使得很多 web 服务端应用都可以使用线程本地存储来解决线程安全问题。

在 Java 中可以通过 ThreadLocal类来实现线程本地存储的功能，每一个线程 Thread 对象都一个 ThreadLocalMap 对象，这个对象存储了一组以 ThreadLocal.threadLocalHashCode 为键，以本地线程变量为值的 K-V 值对，ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个 ThreadLocal 对象都包含了一个独一无二的 threadLocalHashCode 值，这个值就可以在线程 K-V 值对中找回对应的本地线程变量。



## 13.3 锁优化

高效并发是从 JDK 1.5 到 JDK 1.6 的一个重要改进，HotSpot 虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。

### 13.3.1 自旋锁与自适应自旋

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机开发团队发现很多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍微等一下”，但不放弃处理器的执行时间，看看持有的锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

**自旋锁等待不能代替阻塞，它本身虽然避免了线程切换的开销，但是它要占用处理器时间的**

> 如果锁被占用的时间很短，自旋等待的效果会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。

JDK 1.6 引入了自适应的自旋锁，意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。

### 13.3.2 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除技术主要判定来源于逃逸分析的数据支持，如果判断在一段代码上，堆上所有的数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然无须进行。

### 13.3.3 锁粗化

原则上我们编写代码时，总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。

大部分情况下，上面的原则是正确的，但是如果发生一系列的连续操作都是对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

如果虚拟机检测到这样的操作，就会将锁同步的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。

### 13.3.4 轻量级锁

轻量级锁是 JDK 1.6 中加入的新型加锁机制。它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

HotSpot 虚拟机的对象（对象头部分）的内存布局分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希吗（HashCode）、GC 分代年龄等，这部分数据的长度在 32 位和 64 位的虚拟机中分别为 32bit 和 64bit，官方它称为“Mark Word”，它是实现轻量级锁和偏向锁的关键。另一部分用户存储指向方法区对象类型的指针，如果是数据对象，还会有一个额外的部分用于存储数组长度。

对象头信息食欲对象自身定义的数据无关的额外存储成功，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如 32 位的 HotSpot 虚拟机中对象未被锁定的状态下，Mark Word 的 32bit 空间中的 25bit 用于存储对象哈希吗（HashCode），4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0；在其他状态（轻量级锁定、重量级锁定、GC 标记、可偏向）下对象的存储内容如下表：

![image](https://note.youdao.com/yws/public/resource/e5ba56d8a5585cac6e73e80de14f2f32/xmlnote/60906136B69B4E1080B14474EC105C1A/84583)

在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（lock record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀），这时候线程堆栈与对象头的状态如图 13-3 所示。

然后，虚拟机将使用 CAS 操作尝试将这个对象的 Mark Word 更新为指向 Lock Record 的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（ Mark Word 的最后 2bit）将转变为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图 13-4 所示。

![image](https://note.youdao.com/yws/public/resource/e5ba56d8a5585cac6e73e80de14f2f32/xmlnote/5F5DFBE021EC430993AF678E1A506CD2/84596)

如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

上面描述的是轻量级锁的加锁过程，它的解锁过程就是通过 CAS 操作来进行的，如果对象的 Mark Word 仍然指向着线程的锁记录，那就用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取锁，那就要在释放锁的同时，唤醒被挂起的线程。

轻量级锁能提升程序同步性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，但是如果存在竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

### 13.3.5 偏向锁

偏向锁也是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了。

偏向锁的“偏”是偏心、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

当锁对象第一次被线程获取的时候，虚拟机将会把这个对象头中的标志位设为“01”，即偏向模式。同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如 Locking、Unlocking 以及 Mark Word 的 Update 等）。

当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定状态（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如上面接收的轻量级锁那样执行。偏向锁、轻量级锁的状态转化以及对象 Mark Word 的关系如图所示。

![image](https://note.youdao.com/yws/public/resource/e5ba56d8a5585cac6e73e80de14f2f32/xmlnote/EAC7A78FC409443FA484195330BC73B0/84653)

偏向锁可以提高带有同步但无竞争的程序性能，它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向锁就是多余的。在具体问题分析的前提下，有时候使用 -XX:-UseBiasedLocking 来禁止偏向锁优化反而可以提升性能。



