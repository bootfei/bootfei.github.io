---
title: 设计模式
date: 2021-03-20 20:05:51
tags:
---

# 观察者模式

## 原理

属于接口之间通信的回调模式。事件event将自己的callback方法注册在监听器listner中，监听器维护事件列表，执行事件的callback

## 实践

以下伪代码是一个保存订单的功能，并会发送短信消息：

```
public class OrderServiceImpl implements OrderService {
    public void saveOrder() {
        System.out.println("订单创建成功");//1.创建订单
        System.out.println("恭喜您订单创建成功！----by sms");//2.1 发送短信通知      
    }
}
```

现有新需求：需要加一个微信通知的功能，代码如下：

```
public class OrderServiceImpl implements OrderService {
    public void saveOrder() {  
        System.out.println("订单创建成功");//1.创建订单
        
        System.out.println("恭喜您订单创建成功！----by sms");//2.1 发送短信通知      
        System.out.println("恭喜您订单创建成功！----by wechat"); //2.2 发送微信通知
    }
}
```

存在问题：每次创建订单需要加新功能（如新的通知方式），则要修改原有的类，难以维护。

违背设计模式的原则

1. 单一职责：订单保存功能，杂糅了消息通知这些功能
2. 开闭原则：对拓展开放，对修改关闭

优化方案：使用观察者模式，使创建订单和消息通知进行分离，低耦合。可以选择消息队列，spring事件机制等，本文选择Spring事件机制。



### 改造开始

#### 创建事件

```
import org.springframework.context.ApplicationEvent; 
/**
* 订单创建活动事件
*/
@Data
public class OrderCreateEvent extends ApplicationEvent {
    private String name;
    
    private List<String> contentList;//消息参数
 
    public OrderCreateEvent(Object source, String name, List<String> contentList) {
        super(source);
        this.name = name;
        this.contentList = contentList;
    }
}
```

#### 监听器

```java
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;
 
/**
* 短信监听器
* ApplicationListener是无序的
*/
@Component
public class SmsListener implements ApplicationListener<OrderCreateEvent> {
    @Override
    public void onApplicationEvent(OrderCreateEvent event) {
        //发送短信
        System.out.println(event.getContentList().get(0) + ",您的订单:" + event.getContentList().get(1) + "创建成功! ----by sms"); 
    }
}

/**
* 微信监听器
*/
@Component
public class WechatListener implements ApplicationListener<OrderCreateEvent> {
 
    @Override
    public void onApplicationEvent(OrderCreateEvent event) {
        //发送微信
        System.out.println(event.getContentList().get(0) + ",您的订单:" + event.getContentList().get(1) + "创建成功! ----by wechat");
    }
}
```

#### 事件发布

```java
package com.pengshu.magicwallet.admin.test;
 
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Service;
 
import javax.annotation.Resource;
import java.util.ArrayList;
 
@Service
public class OrderServiceImpl implements OrderService {
 
    @Resource
    private ApplicationContext applicationContext;
 
    @Autowired
    private ApplicationEventPublisher applicationEventPublisher;
 
    @Override
    public void saveOrder() {
        //1.创建订单
        System.out.println("订单创建成功");
        //2.发布事件通知
        ArrayList<String> contentList = new ArrayList<>();
        contentList.add("heling");
        contentList.add("123456789");
        OrderCreateEvent orderCreateEvent = new OrderCreateEvent(this, "订单创建", contentList);
        applicationContext.publishEvent(orderCreateEvent);//ApplicationContext是我们的事件容器上层，我们发布事件，也可以通过此容器完成发布
        //applicationEventPublisher.publishEvent(orderCreateEvent);//也可以
        System.out.println("finished!");
    }
}
```

打印结果：

```
订单创建成功

heling,您的订单:123456789创建成功! ----by sms

heling,您的订单:123456789创建成功! ----by wechat

finished!
```

### 如何异步执行监听器？

#### springboot开启事件异步设置

```java
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.transaction.annotation.EnableTransactionManagement;
 
@SpringBootApplication
@MapperScan("com.pengshu.magicwallet.mapper")
@PropertySource("classpath:authority.properties")
@EnableTransactionManagement
@EnableAsync //开启spring事件异步设置，加@Async注解
public class MagicWalletAdminApplication {
    public static void main(String[] args) {
        SpringApplication.run(MagicWalletAdminApplication.class, args);
    }
}
```

#### 监听器类或方法添加@Async注解

打印结果：

```
订单创建成功

finished!

heling,您的订单:123456789创建成功! ----by sms

heling,您的订单:123456789创建成功! ----by wechat
```

### 如何制定监听器执行顺序？

```java
/**
* 微信监听器
* SmartApplicationListener可以设置顺序等
*/
@Component
public class WechatListener implements SmartApplicationListener {
 
    //设置监听优先级
    @Override
    public int getOrder() {
        return 1;
    }
 
    //监听器智能所在之一，能够根据事件类型动态监听
    @Override
    public boolean supportsEventType(Class<? extends ApplicationEvent> aClass) {
        return aClass == OrderCreateEvent.class;
    }
 
    //监听器智能所在之二，能够根据事件发布者类型动态监听
    @Override
    public boolean supportsSourceType(Class<?> aClass) {
        return aClass == OrderServiceImpl.class;
    }
 
    @Override
  	@Async//开启异步
    public void onApplicationEvent(ApplicationEvent applicationEvent) {
        OrderCreateEvent event = (OrderCreateEvent) applicationEvent;
        //发送微信
        System.out.println(event.getContentList().get(0) + ",您的订单:" + event.getContentList().get(1) + "创建成功! ----by wechat");
 
    }
}
 
/**
* 短信监听器
*/
@Component
public class SmsListener implements SmartApplicationListener {
 
    @Override
    public int getOrder() {
        return 2;
    }
 
    @Override
    public boolean supportsEventType(Class<? extends ApplicationEvent> aClass) {
        return aClass == OrderCreateEvent.class;
    }
 
    @Override
    public boolean supportsSourceType(Class<?> aClass) {
        return aClass == OrderServiceImpl.class;
    }
 
    @Override
  	@Async //开启异步
    public void onApplicationEvent(ApplicationEvent applicationEvent) {
        OrderCreateEvent event = (OrderCreateEvent) applicationEvent;
        //发送短信
        System.out.println(event.getContentList().get(0) + ",您的订单:" + event.getContentList().get(1) + "创建成功! ----by sms");
 
    }
}
```

打印结果：

```
订单创建成功

heling,您的订单:123456789创建成功! ----by wechat

heling,您的订单:123456789创建成功! ----by sms

finished!
```

在实现了SmartApplicationListener的监听器中，我们通过重写GetOrder方法来修改不同监听器的顺序，**优先级越小，则越先被调用**。通过配置不同的优先级，且让监听器之间阻塞调用。我们就能实现流水线式的有序事件调用，这在实际应用场景中还是蛮有意义的

# 策略模式

## 原理

将众多的执行逻辑实现接口，封装到自己的类中（锦囊妙计中的妙计）；然后使用一个枚举类，把众多执行逻辑的类放在这里（锦囊的上面印着妙计列表）

## 实践

用户可以选择多种支付方式，比如微信、支付宝、网银等

```java
#公共接口
public interface Payment{
	public void pay(Long order, double amount);
}
```

```java
#具体实现
public class AliPay implements Payment {
    @Override
    public void pay(Long order, double amount) {
        System.out.println("----支付宝支付----");
        System.out.println("支付宝支付111元");
    }
}
```



### 使用前

if判断非常的多

```java
@PostMapping("/makeOrder")
public ResultData makeOrder(@RequestBody  Order order){
  // 生成自己的订单，并且设置订单的失效时间，并且定时回滚
  //  ... 此处代码省略

  // 处理支付方式
  if(order.getType=="alipay"){ // 支付宝
    this.payService.alipay(order);
  }else if (order.getType=="weixin"){ // 微信
    this.payService.weixinpay(order);
  }else if (order.getType=="jd"){ // 京东支付
    this.payService.jtpay(order);
  }else if (order.getType=="yunshanfu"){ // 云闪付
    this.payService.yunshanfupay(order);
  }
  // 发送到mq，进行广播。
  return this.ok(order);
}
```

### 使用后

增加一个枚举类，封装各种策略

```java
public enum PayType {
    //封装各种策略的实现
    ALI_PAY("1",new AliPay()),
    WECHAT_PAY("2",new WechatPay());

    private String payType;
    private Payment payment;
  
    PayType(String payType,Payment payment){
        this.payment = payment;
        this.payType = payType;
    }
    //通过get方法获取支付方式
    public static Payment get(String payType) {
        for (PayType e : PayType.values()) { //values就是ALI_PAY和WECHAT_PAY
            if (e.payType.equals(payType)) {
                return e.payment;
            }
        }
        return null;
    }
}
```

通过枚举类，省略了很多if语句

```java
 public ResultData makeOrder(Long goodsId,String type){
   //生成本地的订单
   Order order = this.orderService.makeOrder(goodsId);
   //选择支付方式
   Payment payment = PayType.get(type);
   //进行支付
   payment.pay(order.getId(),order.getAmount());
   return this.ok();
 }
```

