---
title: 高并发下保证接口的幂等性
date: 2021-04-28 12:12:34
tags:
---

## 什么是幂等

群里发了一个总共1千元的拼手气红包，共10个。静儿点进去，额，抢到了0.05元。这个不甘心啊。退出来重新打开了这个红包，你猜怎样？显示我抢到了0.05元！

这就是幂等(idempotence)，不管多少次请求某一个资源，对资源都具有相同的影响。幂等性是系统的接口对外一种承诺，承诺只要调用接口成功，外部多次调用对系统只产生一次副作用。



## **保证幂等的手段**

保证幂等需要理清楚两件事情：幂等条件和期望结果。

- 保证幂等的手段有[token令牌]()、[分布式锁]()、[去重表]()、[数据库唯一索引]()等，这些所谓的幂等手段实际上防重手段。防重本质是防止一个相同的请求被当成多个不同的请求来处理。

- 幂等的条件是知道这是一个相同的请求。防重和幂等本质上是两个不同的阶段。



## 使用幂等的场景

### 前端重复提交

用户注册，用户创建商品等操作，前端都会提交一些数据给后台服务，后台需要根据用户提交的数据在数据库中创建记录。如果用户不小心多点了几次，后端收到了好几次提交，这时就会在数据库中重复创建了多条记录。这就是接口没有幂等性带来的 bug。

### 接口超时重试

对于给第三方调用的接口，有可能会因为网络原因而调用失败，这时，一般在设计的时候会对接口调用加上失败重试的机制。如果第一次调用已经执行了一半时，发生了网络异常。这时再次调用时就会因为脏数据的存在而出现调用异常。

### 消息重复消费

在使用消息中间件来处理消息队列，且手动 ack 确认消息被正常消费时。如果消费者突然断开连接，那么已经执行了一半的消息会重新放回队列。

当消息被其他消费者重新消费时，如果没有幂等性，就会导致消息重复消费时结果异常，如数据库重复数据，数据库数据冲突，资源重复等。



## 防重手段实现幂等

### 加悲观锁

使用悲观锁实现幂等性，一般是配合事务一起来实现，在没有使用悲观锁时，我们通常的执行过程是这样的，首先来判断数据的状态，执行 SQL 如下：

```
select status from table_name where id='xxx';
```

然后再进行添加操作：

```
insert into table_name (id) values ('xxx');
```

最后再进行状态的修改：

```
update table_name set status='xxx';
```

[但这种情况因为是非原子操作，所以在高并发环境下可能会造成一个业务被执行两次的问题]()，当一个程序在执行中时，而另一个程序也开始状态判断的操作。因为第一个程序还未来得及更改状态，所以第二个程序也能执行成功，这就导致一个业务被执行了两次。

在这种情况下我们就可以使用悲观锁来避免问题的产生，实现 SQL 如下所示：

```sql
begin;  # 1.开始事务
select * from table_name where id='xxx' for update; # 2.查询状态
insert into table_name (id) values ('xxx'); # 3.添加操作
update table_name set status='xxx'; # 4.更改操作
commit; # 5.提交事务
```

在实现的过程中需要注意以下两个问题：

- 如果使用的是 MySQL 数据库，必须选用 innodb 存储引擎，因为 innodb 支持事务；
- id 字段一定要是主键或者是唯一索引，不然会锁表，影响其他业务执行。

### 多版本控制（乐观锁）

既然悲观锁有性能问题，为了提升接口性能，我们可以使用乐观锁。需要在表中增加一个`timestamp`或者`version`字段，这里以`version`字段为例。

由于第一次请求`version`等于`1`是可以成功的，操作成功后`version`变成`2`了。这时如果并发的请求过来，再执行相同的sql：

```
 update user set amount=amount+100,version=version+1where id=123 and version=1;
```

该`update`操作不会真正更新数据，最终sql的执行结果影响行数是`0`，因为`version`已经变成`2`了，`where`中的`version=1`肯定无法满足条件。但为了保证接口幂等性，接口可以直接返回成功，因为`version`值已经修改了，那么前面必定已经成功过一次，后面都是重复的请求

### 加唯一索引

我们可以创建一个唯一索引的表来实现幂等性，在每次执行业务之前，先执行插入操作，因为唯一字段就是业务的 ID，因此如果重复插入的话会触发唯一约束而导致插入失败。在这种情况下（插入失败）我们就可以判定它为重复提交的请求。

唯一索引表的创建示例如下：

```
CREATE TABLE `table_name` (
  `id` int NOT NULL AUTO_INCREMENT,
  `orderid` varchar(32) NOT NULL DEFAULT '' COMMENT '唯一id',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uq_orderid` (`orderid`) COMMENT '唯一约束'
) ENGINE=InnoDB;
```

虽说抛异常对数据来说没有影响，不会造成错误数据。但是为了保证接口幂等性，我们需要对该异常进行捕获，然后返回成功。

如果是`java`程序需要捕获：`DuplicateKeyException`异常，如果使用了`spring`框架还需要捕获：`MySQLIntegrityConstraintViolationException`异常。

### 加分布式锁

由于`数据库分布式锁`的性能不太好，我们可以改用：`redis`或`zookeeper`。

鉴于现在很多公司分布式配置中心改用`apollo`或`nacos`，已经很少用`zookeeper`了，我们以`redis`为例介绍分布式锁。

目前主要有三种方式实现redis的分布式锁：

1. setNx命令
2. set命令
3. Redission框架

> 需要特别注意的是：分布式锁一定要设置一个合理的过期时间，如果设置过短，无法有效的防止重复请求。如果设置过长，可能会浪费`redis`的存储空间，需要根据实际业务情况而定。

### 获取token

通过token 机制实现接口的幂等性,这是一种比较通用性的实现方法。

示意图如下：

<img src="https://filescdn.proginn.com/863953bbd02d158b7d726d78b269339e/47e6218040f85184d170ef253514ca59.webp" alt="img" style="zoom:67%;" />

具体流程步骤：

1. 客户端会先发送一个请求去获取 token，服务端会生成一个全局唯一的 ID 作为 token 保存在 redis 中，同时把这个 ID 返回给客户端
2. 客户端第二次调用业务请求的时候必须携带这个 token
3. 服务端会校验这个 token，如果校验成功，则执行业务，并删除 redis 中的 token
4. 如果校验失败，说明 redis 中已经没有对应的 token，则表示重复操作，直接返回指定的结果给客户端

注意：

1. 对 redis 中是否存在 token 以及删除的代码逻辑建议用 Lua 脚本实现，保证原子性
2. 全局唯一 ID 可以用百度的 uid-generator、美团的 Leaf 去生成