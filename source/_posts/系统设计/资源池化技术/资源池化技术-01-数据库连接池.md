---
title: 数据库连接池
date: 2021-05-13 09:17:35
tags:
---

![Image](https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhpjedFicXX7ME4G6DaHCAPicawvHUyibj5EkA6UE9hYJmgjkeHYHDo1e2WGAHU6N320X8Jnu79NzrIvg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

> 一个连接对应一个事务，多个连接的事务是不一样的

网上大部分人都是说数据库连接池是典型的用了threadloca的例子，然后我就又查数据库连接池和threadlocal的关系，但是99%都说threadlocal是为了在并发的情况下，为了保证线程安全，创建了副本的，其实这只是threadlocal的用法之一，它还有个用法就是确保同一线程之间不同方法进行参数传递

### 连接池和ThreadLocal区别

- 连接池是缓存并托管数据库连接，主要是为了提高性能。

- ThreadLocal缓存连接，是为了把同一个数据库连接“分享”给同一个线程的不同调用方法。（不管调用哪个方法，都是使用的同一个连接，方便进行“跨方法”的事务控制）

比如：

如果一个请求中Controller涉及多个 DAO 操作，而如果这些DAO中的Connection都是独立的话，就没有办法是一个事务。但是如果DAO 中的 Connection 是从 ThreadLocal 中获得的（意味着都是同一个Connection对象）， 那么这些 DAO 就会被纳入到同一个 Connection 之下。

### 重点要理解连接池

连接池里面有一定数量的连接资源，比如最大20个连接。

> 题外话：如果直接通过 Java原生API 获取“直连”的话：

#### 不使用连接池

底层方法一般都是这样写的：

```
java.sql.DriverManager.getConnection(url, props);

java.sql.Driver.connect(url, props);
```

这种方式没有使用数据库连接池

#### 使用连接池

使用[数据库连接池](http://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&mid=2247489135&idx=1&sn=651702e56157409ba6a1867f929ad7dc&chksm=fc7a7bc1cb0df2d7fce2cbd5a968e26a64b8cbd0fca948d8ea28ae4e0d6edf54f4602af3839d&scene=21#wechat_redirect)，通常都是得到javax.sql.DataSource[接口]的一个实例对象，它里面包含了许多Connection，并且数据库连接池工具类（比如C3P0、JNDI、DBCP等），重新定义了getConnection、closeConnection等方法。

所以每次得到的Connection，几乎都不是新建立的连接（而是已经建立好并放到缓存里面的连接），你调用closeConnection方法，也不是真正的关闭连接（一般都是起到一个标识作用，标识当前连接已经使用完毕，归还给连接池，让这个连接处于待分配状态）

> PS：使用数据库连接池时，还是要显式的调用数据库连接池API提供的关闭连接的方法。

理解一下这句话：

> 不同的线程在同一个时间（ 或者 同一个线程在多个地方）从连接池中拿到的Connection，肯定不是同一个连接。（反过来讲：不同时间的两个线程，一前一后，则有可能拿到同一个连接）

### 总结

- 为了避免单一数据库连接的创建和关闭耗费时间和性能，引入了数据库连接池，提前创建好了n条连接放入池中
- 多线程情况下，假设同一时间多个线程从数据库连接池获取连接，那肯定拿的是不同的连接，我当前线程和别的线程拿的连接不一样，那我当前在crud的时候，不在一个事务之内。
- 假设不同时间的多个线程要从数据库连接池拿连接，那这个时候就可能拿到的是同一个连接了，那我多个线程线程拿到的是同一个连接，也就是说在多个线程在同一个事务之内，线程a执行了插入还没来得及提交，线程b此时来了个更新，在线程a还未操作完之前，线程b更新完了后，直接把连接给close了，线程a插了一半发现插不了了。。。此时肯定在想，这™是谁在搞我。
- 为了确保不同时间多个线程可能拿到的是同一个连接，那么此时threadlocal闪亮登场，就算我拿的是“同一个连接”，在引入了threadlocal后，每个线程之间都会创建独立的连接副本，将collection各自copy一份，这样就互相不干扰了。

