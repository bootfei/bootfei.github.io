---
title: 数据库连接池
date: 2021-05-13 09:17:35
tags:
---



## 原理

### 每次请求建立连接

```java
Public void FindAllUsers(){
  //1、装载sqlserver驱动对象
  DriverManager.registerDriver(new SQLServerDriver());             
  //2、通过JDBC建立数据库连接
  Connection con =DriverManager.getConnection("jdbc:sqlserver://192.168.2.6:1433;DatabaseName=customer", "sa", "123");            
  //3、创建状态
  Statement state =con.createStatement();           
  //4、查询数据库并返回结果
  ResultSet result =state.executeQuery("select * from users");           
  //5、输出查询结果
  while(result.next()){
    System.out.println(result.getString("email"));
  }            
  //6、断开数据库连接
  result.close();
  state.close();
  con.close();
}
```

缺点：

- 每一次web请求都要建立一次数据库连接。每次都得花费0.05s～1s的时间，而且系统还要分配内存资源。在这种情况下，频繁的进行数据库连接操作势必占用很多的系统资源，网站的响应速度必定下降
- 对于每一次数据库连接，使用完后都得断开。否则如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏
- 不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏

### 每次请求访问连接池

改进：

- 预先在缓冲池中放入一定数量的连接。
- 查询完数据库后，不关闭连接，而是暂时存放起来，当别人使用时，把这个连接给他们使用。

优点：

- 避免了一次建立数据库连接和断开的操作时间消耗
- 通过设定连接池最大连接数来防止系统无限地与数据库连接。
- 通过连接池的管理机制监视数据库的连接的数量﹑使用情况，为系统开发﹑测试及性能调整提供依据。



## 实现原理

### DataSource作用

DataSource是javax.sql包中的类，是Java原生rt.jar包中的类。

avax.sql.DataSource定义的是抽象方法，通过Java JNDI的方式将具体实现开放给各个厂商、组织自己、个人自己实现。

在Spring框架中，通过DataSource + 配置的方式，来定义具体的数据库源。并向Spring框架提供数据源的Connection服务。

在Spring中若想实现多数据源，那么就需要在DataSource下手

### Connection作用

事务具有原子性。在java语言中，connection类本身提供了对事务的支持，可以通过设置connection的autocommit属性为false 然后显式的调用commit或rollback方法来实现。但要高效的进行connection复用，就必须提供相应的事务支持机制。[可采用每一个事务独占一个连接来实现]()，这种方法可以大大降低事务管理的复杂性。



### 简单实现

① 编写class 实现DataSource 接口

② 在class构造器一次性创建10个连接，将连接保存LinkedList中

③ 实现getConnection 从 LinkedList中返回一个连接

④ 提供将连接放回连接池中方法

#### 连接池代码

```java
public class MyDataSource implements DataSource {
  //链表 --- 实现栈结构
  privateLinkedList<Connection> dataSources = new LinkedList<Connection>();

  //初始化连接数量
  public MyDataSource() {
    //一次性创建10个连接
    for(int i = 0; i < 10; i++) {
        //1、装载sqlserver驱动对象
        DriverManager.registerDriver(new SQLServerDriver());
        //2、通过JDBC建立数据库连接
        Connection con =DriverManager.getConnection(
          "jdbc:sqlserver://192.168.2.6:1433;DatabaseName=customer", "sa", "123");
        //3、将连接加入连接池中
        dataSources.add(con);  
  }

  @Override
  public Connection synchronized getConnection() throws SQLException {
    return dataSources.removeFirst(); // 删除第一个连接返回
  }

  //将连接放回连接池
  public void releaseConnection(Connection conn) {
    dataSources.add(conn);
  }
}
```

#### 使用连接池

```java
//查询所有用户
Public void FindAllUsers(){
    //1、使用连接池建立数据库连接
    MyDataSource dataSource = new MyDataSource();
    Connection conn =dataSource.getConnection();        
    //2、创建状态
    Statement state =con.createStatement();           
    //3、查询数据库并返回结果
    ResultSet result =state.executeQuery("select * from users");           
    //4、输出查询结果
    while(result.next()){
      System.out.println(result.getString("email"));
    }            
    //5、断开数据库连接
    result.close();
    state.close();
    //6、归还数据库连接给连接池
    dataSource.releaseConnection(conn);
}

```

​       这就是数据库连接池的原理，它大大提供了数据库连接的利用率，减小了内存吞吐的开销。我们在开发过程中，就不需要再关心数据库连接的问题，自然有数据库连接池帮助我们处理。但连接池需要考虑的问题不仅仅如此，下面我们就看看还有哪些问题需要考虑。



## 常见问题

![Image](https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhpjedFicXX7ME4G6DaHCAPicawvHUyibj5EkA6UE9hYJmgjkeHYHDo1e2WGAHU6N320X8Jnu79NzrIvg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

> 一个连接对应一个事务，多个连接的事务是不一样的

网上大部分人都是说数据库连接池是典型的用了threadloca的例子，然后我就又查数据库连接池和threadlocal的关系，但是99%都说threadlocal是为了在并发的情况下，为了保证线程安全，创建了副本的，其实这只是threadlocal的用法之一，它还有个用法就是确保同一线程之间不同方法进行参数传递

### 连接池和ThreadLocal区别

- 连接池是缓存并托管数据库连接，主要是为了提高性能。

- ThreadLocal缓存连接，是为了把同一个数据库连接“分享”给同一个线程的不同调用方法。（不管调用哪个方法，都是使用的同一个连接，方便进行“跨方法”的事务控制）

比如：如果一个请求中Controller涉及多个 DAO 操作，而如果这些DAO中的Connection都是独立的话，就没有办法是一个事务。但是如果DAO 中的 Connection 是从 ThreadLocal 中获得的（意味着都是同一个Connection对象）， 那么这些 DAO 就会被纳入到同一个 Connection 之下。

### 重点要理解连接池

连接池里面有一定数量的连接资源，比如最大20个连接。

#### 不使用连接池

底层方法一般都是这样写的：

```
java.sql.DriverManager.getConnection(url, props);

java.sql.Driver.connect(url, props);
```

这种方式没有使用数据库连接池

#### 使用连接池

使用[数据库连接池](http://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&mid=2247489135&idx=1&sn=651702e56157409ba6a1867f929ad7dc&chksm=fc7a7bc1cb0df2d7fce2cbd5a968e26a64b8cbd0fca948d8ea28ae4e0d6edf54f4602af3839d&scene=21#wechat_redirect)，通常都是得到javax.sql.DataSource接口的一个实例对象，它里面包含了许多Connection，并且数据库连接池工具类（比如C3P0、JNDI、DBCP等），重新定义了getConnection、closeConnection等方法。

所以每次得到的Connection，几乎都不是新建立的连接（而是已经建立好并放到缓存里面的连接），你调用closeConnection方法，也不是真正的关闭连接（一般都是起到一个标识作用，标识当前连接已经使用完毕，归还给连接池，让这个连接处于待分配状态）

> PS：使用数据库连接池时，还是要显式的调用数据库连接池API提供的关闭连接的方法。



> 不同的线程在同一个时间（ 或者 同一个线程在多个地方）从连接池中拿到的Connection，肯定不是同一个连接。（反过来讲：不同时间的两个线程，一前一后，则有可能拿到同一个连接）

### 总结

- 多线程情况下，
  - 假设同一时间多个线程从数据库连接池获取连接，那肯定拿的是不同的连接，当前线程和别的线程拿的连接不一样，那当前线程在crud的时候，和其他线程不在一个事务之内。
  - 假设不同时间的多个线程要从数据库连接池后获取连接，那这个时候就可能拿到的是同一个连接了，那多个线程线程拿到的是同一个连接，也就是说在多个线程在同一个事务之内。
    - 比如，线程a(事务A)执行了插入还没来得及提交，此时线程b拿到了与线程a同样的connection，在线程a还未操作完之前，线程b更新完了后，直接把连接给close了，导致线程a无法进行提交了。我们希望线程a和线程b使用不同连接，即不同事务
    - 为了避免不同时间的多个线程可能是同一个连接，那么引入了threadlocal后，每个线程之间都会创建独立的连接副本，将collection各自copy一份，这样就互相不干扰了。

