---
title: wasm
date: 2022-12-08 18:39:15
tags:
---



## 2.所有权

变量A "【拥有】" 对象B：

- 只有A可以释放B
- 当A变成不可访问时，A必须释放B

rust中

- 引用失效了，必须释放拥有的对象，如变量a拥有对象4，在变量a失效后必须释放对象3（4）

- 引用不一定拥有某个对象，如变量a_ref，那么这个引用属于"借用"

- 引用失效了，如果没有拥有对象，则不释放对象，比如变量a_ref，并不拥有对象3（4），在括号末尾超出了【作用域】，也不能释放对象3（4）

- 【向量】是有【标头】和【缓冲区】，比如变量b只拥有向量【标头】，但是向量【标头】中的指针拥有【缓冲区】，所以b超出【作用域】时，只释放向量【标头】-> 向量【标头】释放时，向量【标头】不可访问 ->指针拥有【缓冲区】会被释放

  

```rust
let mut a = 3; // a拥有对象3
a=4; // a把对象3的值改成了4，仍然拥有这个变量
let b=vec![1,23,3,4]; //

{
  let a_ref  = &a //a_ref不拥有对象3
}
print!("{}",a);
```



## 4.赋值语义

### 赋值语义

```rust

let v1 = vec![1,2,3];
let v2 = v1;
```

1. 在栈中分配变量v1，指向向量标头；由于向量具有内容，所以堆中也要分配缓冲区
2. 在栈中分配变量v2， 希望使用变量v1初始化变量v2，该如何实现呢？



### 3种实现

- 共享语义：java
  - v1和v2引用同一个堆中的对象，但是在栈中是2个不同的标头
  - 若2个线程同时写一个对象，会造成读到脏数据
  - 若2个线程同时释放一个对象，或造成内存问题；所以引入GC
- 复制语义：c/c++（默认语义）、rust
  - v1和v2引用不同的对象

- 移动语义：rust（默认语义）、c/c++
  - v1不再指向对象，而是移交给v2

```
//c++复制语义
{

}
//c++移动语义
{

}
```



