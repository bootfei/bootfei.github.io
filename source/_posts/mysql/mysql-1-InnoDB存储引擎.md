---
title: mysql - 1.InnoDB存储引擎
date: 2020-10-08 15:59:03
tags: [mysql]
---

<img src="https://imgedu.lagou.com/131123de763c46a1b03b95c650ba32f0.jpg" style="zoom: 67%;" />

# InnoDB存储引擎

## 1. InnoDB架构图

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu7wvkdxyj30jg0eyq6j.jpg" style="zoom: 67%;" />

上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由**内存池，后台线程和磁**

**盘文件**三大部分组成。接下来我们就来简单了解一下内存相关的概念和原理。

## 2. InnoDB磁盘文件

> InnoDB的主要的磁盘文件主要分为三大块：**系统表空间**，**用户表空间**，redo日志文件和归档文件。
>
> 二进制文件(binlog)等文件是MySQL Server层维护的文件，所以未列入InnoDB的磁盘文件中。

### 2.1 系统表空间



<img src="https://imgedu.lagou.com/6feb838308f34b0791c07a2b2b157fcf.jpg" style="zoom: 50%;" />

系统表空间存储哪些数据？

> 系统表空间是一个共享的表空间，因为它是被多个表共享的。
>
> InnoDB系统表空间包含InnoDB数据字典(元数据以及相关对象)、double write buffer、change buffer、undo logs的存储区域。
>
> 系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。

系统表空间配置解析

> 系统表空间是由一个或者多个数据文件组成。
>
> 默认情况下，一个初始大小为10MB，名为ibdata1的系统数据文件在MySQL的data目录下被创建。
>

用户可以使用 innodb_data_file_path 对数据文件的大小和数量进行配置。

innodb_data_file_path 的格式如下：`innodb_data_file_path=datafile1[,datafile2]...`

示例(这里将**/db/ibdata1**和**/dr2/db/ibdata2**两个文件组成系统表空间)： `innodb_data_file_path=/db/ibdata1:1000M;/dr2/db/ibdata2:1000M:autoextend`

<!--如果这两个文件位于不同的磁盘上，磁盘的负载可能被平均，因此可以提高数据库的整体性能。-->

<!--两个文件的文件名之后都跟了属性，表示文件ibdata1的大小为1000MB，文件ibdata2的大小为1000MB，而且用完空间之后可以自动增长(autoextend)。-->

### 2.2 用户表空间

用户表空间只存储该表的

> - 数据
> - 索引
> - 插入缓冲BITMAP等信息
> - 其余信息还是存放在默认的系统表空间中。

如何使用用户表空间？

> 如果设置了参数**innodb_file_per_table**，则用户可以将每个基于InnoDB存储引擎的表产生一个独立的用户表空间。用户表空间的命名规则为：表名.ibd。通过这种方式，用户不用将所有数据都存放于默认的系统表空间中。

### 2.3 redo日志文件

#### 哪些文件是重做日志文件？

> 默认情况下，在InnoDB存储引擎的数据目录下会有两个名为**ib_logfile0**和**ib_logfile1**的文件，这就是InnoDB的**重做日志文件** **(redo log file)**，它记录了对于InnoDB存储引擎的事务日志。
>

#### 重做日志文件的作用

- **当InnoDB的数据存储文件发生错误时，重做日志文件就能派上用场**。InnoDB存储引擎可以使用重做日志文件将数据恢复为正确状态，以此来保证数据的正确性和完整性。

- 为了得到更高的可靠性，用户可以设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此来提高重做日志的**高可用性**。

#### 重做日志文件组如何写入数据

每个InnoDB存储引擎至少有1个重做日志文件组(group)，每个文件组下至少有2个重做日志文件，如默认的`ib_logfile0`和`ib_logfile1`。

> 在日志组中每个重做日志文件的**[大小一致]**，并以**[循环写入]**的方式运行。InnoDB存储引擎先写入重做日志文件1，当文件被写满时，会切换到重做日志文件2; 当重做日志文件2也被写满时，再切换到重做日志文件1。
>

#### 设置重做日志文件大小

用户可以使用`innodb_log_file_size`来设置重做日志文件的大小，这对InnoDB存储引擎的性能有着非常大的影响。

> 如果重做日志文件设置的**太大**，数据丢失时，恢复时可能需要很长的时间；
>
> 另一方面，如果设置的**太小**，重做日志文件太小会导致依据`checkpoint`的检查需要频繁刷新脏页到磁盘中，导致性能的抖动。
>

### 2.4 InnoDB逻辑存储结构

InnoDB存储引擎逻辑存储结构可分为五级：表空间、段、区、页、行。

<img src="https://static001.geekbang.org/infoq/71/715646b8db39a9537925e985c5140c70.png" style="zoom: 80%;" />

#### 1. 表空间

从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间(tablespace)。

从功能上来看，InnoDB存储引擎的表空间分为系统表空间，独占表空间，通用表空间，临时表空间，Undo表空间。InnoDB 存储引擎有一个共享表空间，叫做系统表空间，在磁盘上的文件名为ibdata1。

- 如果设置了独立表空间innodb_file_per_table=1，每张表的数据都会存储到一个独立的表空间，即一个单独的.ibd文件。

- 如果设置了参数innodb_file_per_table=0，关闭了独占表空间，则所有基于InnoDB存储引擎的表数据都会记录到系统表空间。

#### 2. 段

表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。

如果开启了独立表空间innodb_file_per_table=1，每张表的数据都会存储到一个独立的表空间，即一个单独的.ibd文件。

一个用户表空间里面由很多个段组成，创建一个索引时会创建两个段：数据段和索引段。

- 数据段存储着索引树中叶子节点的数据。

- 索引段存储着索引树中非叶子节点的数据。

一个段的空间大小是随着表的大小自动扩展的：表有多大，段就有多大。

一个段会包含多个区，至少会有一个区，段扩展的最小单位是区。

#### 3. 区

一个区由64个**连续**的页组成，一个区的大小=1M=64个页(16K)。**为了保证区中页的连续性**，区扩展时InnoDB 存储引擎会一次性从磁盘申请4 ~ 5个区。

#### 4. 页

![](https://img-blog.csdnimg.cn/20200705151425989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3eDkwMDEwMg==,size_16,color_FFFFFF,t_70)

InnoDB 每个页默认大小时是 16KB，页是 InnoDB管理磁盘的最小单位，也InnoDB中磁盘和内存交互的最小单位。

```mysql
show global variables like 'innodb_page_size';
```

索引树上一个节点就是一个页，MySQL规定一个页上最少存储2个数据项。

- 如果向一个页插入数据时，这个页已将满了，就会从区中分配一个新页。

- 如果向索引树叶子节点中间的一个页中插入数据，如果这个页是满的，就会发生页分裂。

操作系统管理磁盘的最小单位也是页，是操作系统读写磁盘最小单位，Linux中页一般是4K，可以通过命令查看。

```shell
#默认 4096 4K 
\> getconf PAGE_SIZE
```

所以InnoDB从磁盘中

- 读取一个数据页时，操作系统会**分4次**从磁盘文件中读取数据到内存。
- 写入也是一样的，需要**分4次**从内存写入到磁盘中。

#### 5. 行

InnoDB的数据是以行为单位存储的，1个页中包含多个行。在MySQL5.7中，InnoDB提供了4种行格式：Compact、Redundant、Dynamic和Compressed行格式，Dynamic为MySQL5.7默认的行格式。InnoDB行格式官网：https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html

创建表时可以指定行格式：

```mysql
CREATE TABLE t1 (c1 INT) ROW_FORMAT=DYNAMIC; 

ALTER TABLE tablename ROW_FORMAT=行格式名称; 

\#修改默认行格式 

SET GLOBAL innodb_default_row_format=DYNAMIC; 

\#查看表行格式 

SHOW TABLE STATUS LIKE 'student'\G; 
```



## 3 InnoDB内存结构

### 3.1 Buffer Pool

> InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。但是由于CPU速度和磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用**缓冲池**记录来提高数据库的的整体性能。
>

所以，缓冲池的大小直接影响着数据库的整体性能，可以通过配置参数 `innodb_buffer_pool_size`来设置。

> 具体来看，缓冲池中缓存的数据页类型有：
>
> **`索引页`**、**`数据页`**、
>
> **`undo页`**、
>
> **`插入缓冲(insert buffer)`**、
>
> **`自适应哈希索引(adaptive hash index)`**、
>
> **`InnoDB存储的锁信息(lock info)`**
>
> **`数据字典信息(data dictionary)`**

在架构图上可以看到，InnoDB存储引擎的内存区域除了有**`缓冲池`**之外，还有**`redo log buffer`**和**额外内存池**。

> InnoDB存储引擎首先将**redo日志信息**先放到这个缓冲区中，然后按照一定频率将其刷新到`redo日志文件`中。`redo log buffer`一般不需要设置的很大

该值可由配置参数 `innodb_log_buffer_size` 控制。

#### **数据页和索引页**

InnoDB存储引擎工作时，需要以**Page ** **页**为最小单位去将磁盘中的数据加载到内存中，与数据库相关的所有内容都存储在Page结构里。

Page分为几种类型，数据页和索引页就是其中最为重要的两种类型。

#### **插入缓冲**

> 主要针对**`次要索引`**的数据插入存在的问题而设计。

我们都知道，**在InnoDB引擎上进行插入操作时，一般需要按照主键顺序进行插入，这样才能获得较高的插入性能。**

当一张表中存在**次要索引**时，在插入时，数据页的存放还是按照主键进行顺序存放，但是对于次要索引叶节点的插入不再是顺序的了，这时就需要离散的访问**`次要索引页`**，由于随机读取的存在导致插入操作性能下降。

InnoDB为此设计了**`Insert Buffer`**来进行插入优化。对于次要索引的插入或者更新操作，不是每一次都直接插入到**`索引页`**中，而是先判断插入的非主键索引是否在**`缓冲池`**中，

- 若在，则直接插入到**`缓冲池`**中
- 若不在，则先放入到一个**`Insert Buffer`**中。

看似数据库这个非主键的索引已经插到叶节点，而实际没有，这时存放在另外一个位置。然后再以一定的频率和情况进行**`Insert Buffer`**和非聚簇索引页子节点的合并操作。这时通常能够将多个插入合并到一个操作中，这样就大大提高了对于非聚簇索引的插入性能。

#### **自适应哈希索引**

InnoDB会根据访问的频率和模式，为热点页建立哈希索引，来提高查询效率。

> 哈希(hash)是一种非常快的查找方法,在一般情况下这种查找的时间复杂度为O(1),即一般仅需要一次查找就能定位数据。而B+树的查找次数,取决于B+树的高度,在生产环境中,B+树的高度一般为3~4层,故需要3~4次的查询。

InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升,则建立哈希索引,称之为`自适应哈希索引`(Adaptive Hash Index,AHI) AHI是通过**`缓冲池`**的B+树页构造而来,因此建立的速度很快,而且不需要对整张表构建哈希索引。

 InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。

AHI有一个要求,即对这个页的连续访问模式必须是一样的。例如对于(a,b)这样的联合索引页,其访问模式可以是以下情况:

- WHERE a=xxx

- WHERE a= xxx and b=xxx

访问模式一样指的是査询的条件一样,若交替进行上述两种查询,那么 InnoDB存储引擎不会对该页构造AH此外AH还有如下的要求:

- 以该模式访问了100次

- 页通过该模式访问了N次,其中=页中记录*1/16

根据 InnoDB存储引擎官方的文档显示,启用AHI后,读取和写入速度可以提高2倍,辅助索引的连接操作性能可以提高5倍。毫无疑问,AHI是非常好的优化模式,其设计思想是数据库自优化的(self-tuning),即无需DBA对数据库进行人为调整。

```mysql
mysql> show engine innodb status \G 
```

可以通过参数innodb_adaptive_hash_index来考虑禁用或启动此特性，默认是开启状态。

#### **锁信息**

我们都知道，InnoDB存储引擎默认使用**`行锁`**。不过InnoDB也会在数据库内部其他很多地方使用锁，从而允许对多种不同资源提供并发访问。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。关于锁的具体知识我们之后再进行详细学习。

#### **数据字典信息**

InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典(Data Dictionary)。当InnoDB打开一张表，就增加一个对应的对象到数据字典。

数据字典是对数据库中的数据、库对象、表对象等的元信息的集合。在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。MySQL INFORMATION_SCHEMA库提供了对数据局元数据、统计信息、以及有关MySQL server的访问信息（例如：数据库名或表名，字段的数据类型和访问权限等）。该库中保存的信息也可以称为MySQL的数据字典。



### 3.2 Redo log buffer

当`Buffer Pool`中的`page`的版本比磁盘要新时，数据库需要将新版本的`page`从`Buffer Pool`刷新到磁盘。但是如果每次一个`page`发送变化，就进行刷新，那么性能开发是非常大的，于是InnoDB采用了`Write Ahead Log`策略，

> 即当事务提交时，先写`redo log file`，然后再择时将脏页写入磁盘。如果发生宕机导致数据丢失，就通过`redo log file`进行数据恢复。



<img src="https://imgedu.lagou.com/b04f46ad272941eea7621ce9cdecc242.jpg" alt="InnoDB数据写入示意图" style="zoom:67%;" />



InnoDB存储引擎会首先将**`redo log file`**先放入**`redo log buffer`**中，然后再按照一定频率将其刷新到**`redo log file`**。

`redo log buffer`一般不需要设置得很大，因为一般情况每一秒钟都会讲重做日志缓冲刷新到日志文件中。可通过配置参数`innodb_log_buffer_size`控制，默认为8MB。

除了每秒刷新机制之外，每次事务提交时重做日志缓冲也会刷新到日志中。InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，然后事务的提交操作完成才算完成。InnoDB的写入机制大致入下图所示。

为了确保每次日志都写入到重做日志文件，在每次讲重做日志缓冲写入重做日志后，必须调用一次fsync操作，将缓冲文件从文件系统缓存中真正写入磁盘。

可以通过innodb_flush_log_at_trx_commit来控制重做日志刷新到磁盘的策略。该参数默认值为1，表示事务提交必须进行一次fsync操作，还可以设置为0和2。

- 0表示事务提交时不进行写入重做日志操作，该操作只在主线程中完成，

- 2表示提交时写入重做日志，但是只写入文件系统缓存，不进行fsync操作。

由此可见，设置为0时，性能最高，但是丧失了事务的一致性。

### 3.3 Double Write

如上图所示，InnoDB在缓冲池中变更数据时，会首先将相关变更写入重做日志缓冲中，然后再按时或者当事务提交时写入磁盘，这符合Force-log-at-commit原则；

当重做日志写入磁盘后，缓冲池中的变更数据才会依据checkpoint机制择时写入到磁盘中，这符 合WAL原则。 

在checkpoint择时机制中，就有重做日志文件写满的判断，所以，如前文所述，如果重做日志文件太小，经常被写满，就会频繁导致checkpoint将更改的数据写入磁盘，导致性能抖动。操作系统的文件系统是带有缓存的，当InnoDB向磁盘写入数据时，有可能只是写入到了文件系统的缓存中，没有真正的“落袋为安”。

InnoDB的innodb_flush_log_at_trx_commit属性可以控制每次事务提交时InnoDB的行为。

- 当属性值为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入每秒写入一次；
- 当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；
- 当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用fsync，而是让文件系统自己去判断何时将缓存写入磁盘。

innodb_flush_log_at_commit是InnoDB性能调优的一个基础参数，涉及InnoDB的写入效率和数

据安全。当参数值为0时，写入效率最高，但是数据安全最低；参数值为1时，写入效率最低，但

是数据安全最高；参数值为2时，二者都是中等水平。一般建议将该属性值设置为1，以获得较高

的数据安全性，而且也只有设置为1，才能保证事务的持久性。

日志的刷盘机制如下图所示：