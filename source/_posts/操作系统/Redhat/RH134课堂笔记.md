| 第一天                      | 第二天               | 第三天              | 第四天                    | 第五天       |
| :-------------------------- | -------------------- | :------------------ | ------------------------- | ------------ |
| 1、提高命令行生产率         | 5、管理SELinux安全性 | 8、实施高级存储功能 | 11、管理网络安全firewalld | 13、容器介绍 |
| 2、计划将来的任务           | 6、管理基本存储      | 9、访问网络附加存储 | 12、安装rhel              | 14、总复习   |
| 3、调优系统性能             | 7、管理逻辑卷        | 10、控制启动过程    |                           |              |
| 4、使用FACL控制对文件的访问 |                      |                     |                           |              |

# 第一章 提高命令行生产率

## 脚本：

| 系统    |                                 |      |
| ------- | ------------------------------- | ---- |
| Windows | *.bat,*.cmd,.vbd                |      |
| Linux   | #!/bin/bash ,  chmod +x file.sh |      |

## 1.创建和执行BASH SHELL脚本

### 1.指定命令解释器（考点）

```bash
[root@foundation0 ~]# vim /test.sh     #掌握
#!/bin/bash                            #指定解释器为/bin/bash
date
echo  "hello world"

[root@foundation0 ~]# chmod +x test.sh  #赋予脚本执行权限
[root@foundation0 ~]# cd /
[root@foundation0 ~]# ./test.sh          #可以通过./这种相对路径方式执行脚本
[root@foundation0 ~]# /root/test.sh      #或通过绝对路径方式执行脚本

[root@foundation0 bin]# first.sh 
hello world
[root@foundation0 bin]# sh first.sh 
hello world
[root@foundation0 bin]# bash first.sh 
hello world
[root@foundation0 bin]# source first.sh 
hello world
[root@foundation0 bin]# . first.sh    
hello world
```

### 2.执行Bash Shell

不同用户，比如root\student， 变量地址就是不一样的，全局变量、用户变量

```bash
脚本中需要书写解释器#!/bin/bash，脚本内容可以是linux命令。linux系统可以通过/etc/shells查看支持的shell类型。

[root@foundation0 /]# which ls

[root@foundation0 /]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
```

练习：

```bash
[root@node1 opt]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
[root@node1 opt]# which ls
alias ls='ls --color=auto'
	/usr/bin/ls
[root@node1 opt]# cd /root/bin
-bash: cd: /root/bin: No such file or directory
[root@node1 opt]# mkdir /root/bin
[root@node1 opt]# mv /test.sh /root/bin/
[root@node1 opt]# ls /root/bin/
test.sh
[root@node1 opt]# test.sh
hello world
```

### 3.对特殊字符加引号

```bash
\, '' , ""   #掌握

# echo {1..10}
# echo $(seq 1 10)
[root@servera /]# echo hello    
hello
[root@servera /]# echo $PATH 
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
[root@servera /]# echo \$PATH
$PATH
[root@servera /]# echo '$PATH'
$PATH
[root@servera /]# echo "$PATH"
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin



【servera】
[root@servera ~]# echo $HOSTNAME
[root@servera ~]# ssh root@servera 'touch /tmp/$HOSTNAME'     
[root@servera ~]# ssh root@servera 'ls /tmp'
[root@servera ~]# ssh root@servera "touch /home/$HOSTNAME"     
[root@servera ~]# ssh root@servera 'ls -l /home'
```

### 4.``,$()

```bash
`命令`   #掌握
$(命令)


在shell中设置一个变量暂时使用
[root@servera /]# var=`date`
[root@servera /]# var=$(date)
[root@servera /]# echo 'to day $var'
to day $var
[root@servera /]# touch $(date +%H%M%S).txt
取消一个变量
[root@servera /]# unset var
[root@servera /]# echo $var

第二个例子
whoami
echo whoami
echo `whoami`
echo $(whoami)
date
echo `date`
man date
date +%y%m%d
date +%Y%m%d
date +%Y-%m-%d
echo $(date +%Y-%m-%d)
touch $(date +%Y-%m-%d).txt
ls
tar -zcvf $(date +%Y-%m-%d).tar.gz /etc/
ls
cd /

既然可以通过``和$()的结果，通过echo来通过标准输出打印到屏幕上，那么我们也可以将其应用到脚本。
vim os.current
#!/bin/bash
  
echo -e "User:\t" $(whoami)
echo -e "HOST:\t" `hostname`
echo -e "ipv4:\t" $(ip a s eth0 | awk '/inet / {print $2}')
echo -e "Memory:\t" $(free -h | awk '/Mem/ {print $2}') 
echo -e "Disk:\t" $(df -ht xfs | awk '/dev/ {print $4}')

chmod +x os.current 
./os.current 
```

## 2.使用循环更高效的运行命令

### 1.for语句

```bash
语法：
for variable in list
	do
		command variable
done
例子：
for i  in 1 2 3    
	do 
		echo $i
done


[root@servera ~]# echo {1..10}      #掌握
1 2 3 4 5 6 7 8 9 10
[root@servera ~]# echo $(seq 1 10)
1 2 3 4 5 6 7 8 9 10

[root@servera ~]# for i in host1 host2 host3;do echo $i;done    #掌握
host1
host2
host3
[root@servera ~]# for num in host{1..3};do echo $num;done 		  #掌握
host1
host2
host3
[root@servera ~]# for num in `ls /`;do echo $num;done			  #掌握
host1
host2
host3
[root@servera ~]# cd /opt/
[root@servera opt]# ls
[root@servera opt]# touch file{1..3}
[root@servera opt]# ls
file1  file2  file3
[root@servera opt]# for i in file*;do ls $i;done
file1
file2
file3


小技巧
[root@servera ~]# echo ${HOSTNAME}O
servera.lab.example.comO
[root@servera ~]# echo $HOSTNAME\O
servera.lab.example.comO

[root@servera ~]# vim user.sh
#!/bin/bash
for i in {1..10};do
        useradd user$i 2> /dev/null
        echo P@ssw0rd${i}a | passwd --stdin user$i
done
[root@servera ~]# sh user.sh
```

### 2.在脚本中使用退出代码

处理完自己的所有内容后，脚本会退出到调用它的进进程。但是，有时候可能需要载完成之前退出脚本，比如载遇到错误条件时。可以通过载脚本中使用exit命令来实现这一目的。当脚本遇到exit命令时，脚本将立即退出且不会对脚本的其余内容进行处理。

可以使用可选的整数参数（0到255之间，表示退出代码）来执行exit命令。退出代码进程完成后返回的代码。退出代码值0表示没有错误。所有其他非零值都表示存在错误的退出代码。尽可以使用不同的非零值来区分遇到的不同类型错误。此退出代码传回到父进程，后这将它存储在？变量中，并课通过$?进行访问。                                                                      

```bash
cat hello
#!/bin/bash
echo "hello world"
exit 1

echo $?
```

使用运算符执行测试

### 3.test, []

```bash
test 0 -ne 1 
   36  echo $?
   37  test 0 -ge 0 
   38  echo $?
   39  test 0 -ge 1 
   40  echo $?
   41  test 8 -gt 4
   42  echo $?
   43  [ 0 -ge 0 ]
   44  echo $?

-eq	等于则为真
-ne	不等于则为真
-gt	大于则为真
-lt	小于则为真
-ge	大于等于则为真
-le	小于等于则为真

字符串判断
= ==  != -z -n
```

### 4.exit ,if  elif  else 

```bash
if [ 条件 ]
  then
       声明
fi

if [ xx ];then
     command
fi
 
一、
vim tj.sh
#!/bin/bash
if [ 0 -ge 0 ];then
        echo ok
fi

二、
vim cjk.sh
#!/bin/bash
if [ -e /file1 ];then
        echo one
        exit 10
fi

三、
#!/bin/bash
if [ -e /file1 ];then
        echo one
        exit 10
else
        echo two
        exit 20
fi

四、
#!/bin/bash
if [ -e /file1 ];then
        echo one
        exit 10
elif [ -e /opt/file1 ];then
        echo two
        exit 20
else
        echo three
        exit 30
fi
```

### 5.$0，$1，$2..$9 ,$# 位置变量

```bash
vim ping.sh
#!/bin/bash
ping -c $2 172.25.254.$1

echo '$0: ' $0
echo '$1: ' $1
echo '$2: ' $2
echo '$3: ' $3
echo '$#: ' $#

[root@servera ~]# chmod +x ping.sh
[root@servera ~]# ./ping.sh 254 5
PING 172.25.254.254 (172.25.254.254) 56(84) bytes of data.
64 bytes from 172.25.254.254: icmp_seq=1 ttl=63 time=3.02 ms
64 bytes from 172.25.254.254: icmp_seq=2 ttl=63 time=0.976 ms
64 bytes from 172.25.254.254: icmp_seq=3 ttl=63 time=1.03 ms
64 bytes from 172.25.254.254: icmp_seq=4 ttl=63 time=1.09 ms
64 bytes from 172.25.254.254: icmp_seq=5 ttl=63 time=2.16 ms

--- 172.25.254.254 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 12ms
rtt min/avg/max/mdev = 0.976/1.654/3.015/0.808 ms
$0:  ./ping.sh       脚本名
$1:  254			 执行脚本时赋予脚本的第一个值
$2:  5				 执行脚本时赋予脚本的第二个值
$3: 
$#:  2				 一共赋予多少个值

$@					  具体赋予了什么值
$？					 看上一条命令的返回值0为正常执行，非0是非正常执行
$$
```

```bash
创建一个添加用户的脚本
在system1上创建一个脚本，名为/root/makeusers，此脚本能实现为系统system1创建本地用户，并且这些用户的用户名来自一个包含列表的文件。用户满足下列要求：
（1）	此脚本要求提供一个参数，此参数就是包含用户名列表的文件
（2）	如果没有提供参数，此脚本应该给出下面的提示信息 Usage: /root/makeusers userfile然后退出并返回相应的值
（3）	如果提供一个不存在的文件名，此脚本应该给出下面的提示信息 Input file not found然后退出并返回相应的值
（4）	创建的用户登录shell为/bin/false
（5）	此脚本不需要为用户设置密码
[root@servera ~]# cd /root/
[root@servera ~]# cat /root/userfile
testuser1
testuser2
testuser3

[root@servera ~]# vim /root/makeusers
#!/bin/bash
if [ $# -lt 1 ];then
        echo "Usage: $0 userfile"
        exit 1
elif [ ! -f $1 ];then
        echo "Input file not found"
        exit 1
else
        for i in `cat $1`;do
                /usr/sbin/useradd -s /bin/false $i
        done
fi
[root@servera ~]# ./root/makeusers /root/userlist
[root@servera ~]# 
```

## 3.grep,cut

```bash
grep root /etc/passwd   #重要 grep将文本中包含关键字的行打印出来，默认是从上到下的查询顺序。查文件内容用的
grep root /etc/passwd | cut  -d :  -f 1,3-5      #截取文本中的列 -d 指定分隔符号 -f 指定列     
grep root /etc/passwd | cut -c 1,3-5           #-c 指定字符        
grep ^root /etc/passwd
grep nologin$ /etc/passwd
cat -n /etc/passwd									 
grep -n ^# /etc/selinux/config 	
grep ^$ /etc/selinux/config 
grep ^$ /etc/selinux/config  | wc -l
grep -n ^$ /etc/selinux/config  
grep -v ^$ /etc/selinux/config 
grep ^# /etc/selinux/config 
grep -v ^# /etc/selinux/config 


cat /etc/selinux/config | grep -v ^# | grep -v ^$


[root@foundation0 /]# grep ng /usr/share/xml/iso-codes/iso_639_3.xml > /1.txt
[root@foundation0 /]# 
[root@foundation0 /]# 
[root@foundation0 /]# grep ^$ /1.txt
[root@foundation0 /]# grep ^$ /1.txt | wc -l
额外：
# grep -e root -e 0 /etc/passwd       grep -e可以在一个文件内单独匹配多个参数
root:x:0:0:root:/root:/bin/bash
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
# grep -E 'root|0' /etc/passwd

[root@foundation0 ~]# grep 'kiosk|root' /etc/passwd
[root@foundation0 ~]# egrep 'kiosk|root' /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
kiosk:x:1000:1000::/home/kiosk:/bin/bash
[root@foundation0 ~]# grep  -E 'kiosk|root' /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
kiosk:x:1000:1000::/home/kiosk:/bin/bash


grep -A  2 root #查看root关键字后两行
grep -B         #前x行
grep -C         #前后x行

grep -A 2 daemon   /etc/passwd

head -5 /etc/passwd
  137  head -5 /etc/passwd > /opt/passwd.tst
  138  ls
  139  cat passwd.tst 
  140  grep -A 2 daemon 
  141  grep -A 2 daemon passwd.tst 
  142  grep -B  2 daemon passwd.tst 
  143  grep -C  2 daemon passwd.tst 
```

### 正则表达式

```bash
[root@foundation0 /]# cat testfile 
cat
cot
cut
cut
cut
dog
dog
concatenate
dogma
category
educated
boondoggle
vindication
chilidog
aacat
caaaaaaaat

匹配行首和行尾
[root@foundation0 /]# grep ^cat testfile 
cat
category 
[root@foundation0 /]# grep cat$ testfile 
cat
aacat
[root@foundation0 /]# grep ^cat$ testfile 
cat

向正则表达式中添加通配符和倍数
1、.匹配换行符以外的任何“单”个字符
[root@servera opt]# grep c.t testfile 

2、选择[]内的一个字符。搜索结果应为c开头、中间a或o或u、结尾t
[root@servera opt]# grep c[aou]t testfile     cat cot cut

3、倍数* 匹配前面的子表达式零次或多次
[root@servera opt]# grep ca*t testfile  

4、倍数通常与通配符一起使用，如.*  这将匹配任何以包含c和t中间有0个或多个任意字符的行
[root@servera opt]# grep c.*t testfile 
```



# 第二章 Linux计划任务

## 1.at

```bash
[root@servera /]# rpm -qa at
at-3.1.20-11.el8.x86_64
[root@servera /]# systemctl status atd.service 

[root@servera /]# rpm -qc at
/etc/at.deny
/etc/pam.d/atd
/etc/sysconfig/atd

at 选项 参数

创建
13:49分时候执行touch指令
[root@servera /]# at 13:49
warning: commands will be executed using /bin/sh
at> touch /at.txt
at> <EOT>          ctrl+d退出

3分钟后执行
echo "date" >> /home/student/myjob.txt | at now +3min


明天17:20点执行echo
at 17:20 tomorrow
at> echo hello

三天后下午5:10分执行/bin/ls
at 5:10pm+3days
at> /bin/ls

使用时间，和月/日/年的方式指定任务
at 17:20 5/20/2022

在7月的31日上午10点
at 10am Jul 31


查看
[root@servera /]# atq
作业编号  执行日期和时间             队列a			运行作业所有者
7	     Sun Mar  8 13:51:00 2020 a         	 root
[root@servera /]# at -l

查看任务内容
[root@servera /]# at -c 7
删除
[root@servera /]# at -d 9
[root@servera /]# atrm 8

systemctl status atd
man at
at 17:30
man at
at - 1
at -c 1
atq
atrm 1
atq
at 17:20
atq
at 17:30 08/19/2022
at 17:30 2022-7-24
man at
at now +3min
at now +3hour
at now +3days
man at
at 4pm +3days
at 16:02 +3days
man at
at teatime
man at
history
echo 123 > /root/backup | at 17:20
atq
at -c 11
atq

监控任务
[root@servera ~]# watch atq      ctrl+c 退出监控模式

黑白名单
/etc/at.deny  哪个用户在黑名单里，哪个用户不能使用at，该文件默认存在
/etc/at.allow 在白名单的用户可以使用at，其他人不能使用，该文件优先级高于at.deny，该文件默认不存在。
```

## 2.crontab

```bash
[root@servera /]# systemctl status crond.service  #重要
[root@servera /]# systemctl  enable crond
[root@servera /]# systemctl is-enabled crond
[root@servera /]# systemctl enable --now crond


[root@servera /]# rpm -qa cron
[root@servera /]# rpm -qa | grep cron
cronie-anacron-1.5.2-2.el8.x86_64
cronie-1.5.2-2.el8.x86_64
crontabs-1.11-16.20150630git.el8.noarch
[root@servera /]#　rpm -qc crontabs
/etc/crontab

crontab 选项 
-e	编辑计划任务	crontab -e
-u	指定用户  crontab -u student -e
-r	删除
-l	列出

*       *       *       *       *       command
分		时     日 	 月       周		 任务内容
0-59    0-23   1-31    1-12    0-7

1.每年2月2日上午9点执行echo  hello
0       9       2       2       *       echo hello

2.每天3到6点 第2分 执行一个脚本/root/1.sh
2	3-6 *	*	* /bin/sh /root/1.sh

3.每两个小时的第2分钟，执行一个脚本/root/1.sh
2	*/2   *	*	*	 /bin/sh /root/1.sh

4.每年７月的第１天和第５天，两点２分，执行一个脚本/root/1.sh
2	2   1,5	 7	*	 /bin/sh /root/1.sh

5.配置cron任务，每隔2分钟运行logger “Ex200 in progress”，以harry用户身份运行
[root@servera /]# id harry 
[root@servera /]# crontab -u harry -e
[root@servera /]# crontab -u harry -l  (也可以ｓｕ切换到任务用户，运行crontab -l)
*/2 	*	*	* 	*    /usr/bin/logger “Ex200 in progress” 

删除某条可以crontab -e 进去编辑
删除用户的所有任务 crontab -r 	

 vim /etc/cron.deny  限制用户使用crond服务
 白名单：
mandb
man -k cron
man 1 crontab
echo harry >> /etc/cron.allow
   
  测试：
  su - harry   , crontab -e    #可以使用
  exit
  su - tom   , crontab -e     #不可使用
 
练习：
1、每年2月2日上午9点执行echo hello任务
2、七月每周5的9点和下午5点间，每5分钟执行echo hello
3、执行一个任务,该任务每隔2分钟运行以下命令/usr/bin/logger   "hello"
4、使用root身份为用户tom设置一个计划任务，每天的下午2点43分执行/home/tom/tom.sh脚本
5、每天凌晨2点10分，清除/var/log/abc.log文件
6、每周日下午3点，执行”/bin/sh     /usr/local/sbin/backup.sh“
7、每隔5分钟 通过ping -c 4 192.168.1.1命令来测试连通性
8、每天的，1点，6点，9点，将/var/log/messages文件进行归档，要求使用gzip工具，归档文件保存在/tmp/当前时间.tar.gz

0 1,6,9 * * *  tar -zcvf /tmp/$(date +%Y%m%d).tar.gz 
9、每天9点到18点执行 "/bin/sh  /root/test.sh"
10、不允许fred用户使用crontab任务
```

## 3.管理临时文件

rhel6 tmpwatch

systemd-tmpfiles

```bash
[root@servera /]# systemctl status systemd-tmpfiles-setup
[root@servera /]# rpm -qf /usr/lib/tmpfiles.d/tmp.conf 
systemd-239-13.el8.x86_64

cp /usr/lib/tmpfiles.d/tmp.conf /etc/tmpfiles.d/
cd /etc/tmpfiles.d/
vim tmp.conf
q /tmp 1777 root root 5d
systemd-tmpfiles --clean /etc/tmpfiles.d/tmp.conf 


清理临时文件
创建一个存放临时文件的目录，并且设置相应权限/run/momentary 0700 root root
[root@servera /]# vim /etc/tmpfiles.d/momentary.conf
d /run/momentary 0700 root root 30s
创建存放临时文件目录
[root@servera /]# systemd-tmpfiles --create /etc/tmpfiles.d/momentary.conf 
[root@servera /]# ll /run/momentary/ -d
drwx------. 2 root root 40 Mar  8 15:08 /run/momentary/
在目录中创建一个文件叫做mom.txt，此文件模拟临时文件
[root@servera /]# touch /run/momentary/mom.txt
[root@servera /]# sleep 30
[root@servera /]# ll /run/momentary/mom.txt 
-rw-r--r--. 1 root root 0 Mar  8 15:08 /run/momentary/mom.txt
输入清除临时文件命令，清除所有的临时文件
[root@servera /]# systemd-tmpfiles --clean /etc/tmpfiles.d/momentary.conf 
[root@servera /]# ll /run/momentary/mom.txt 
ls: cannot access '/run/momentary/mom.txt': No such file or directory
```

# 第三章 系统性能调优

## 1.tuned 

### 查看状态

```bash
[root@servera tmp]# yum install -y tuned
[root@servera tmp]# systemctl enable --now tuned
[root@servera tmp]# systemctl status tuned
```

### tuned-adm管理指令（考点）

```bash
[root@servera tmp]# tuned-adm list  #列出优化方案
[root@servera tmp]# tuned-adm recommend   #系统推荐的
[root@servera tmp]# tuned-adm profile virtual-guest 修改优化方案为virtual-guest
[root@servera tmp]# tuned-adm off #关闭优化，默认不关闭，考试时不要关闭
```

### 配置文件存储路径

```bash
每个优化方案对应要给配置文件，其中描述了修改的内核参数

路径：/usr/lib/tuned/
```

## 2.使用cockpit修改调优的方式

```bash
【servera】
systemctl start cockpit
【foundation】
打开浏览器输入：https://servera:9090--点击右侧高级选项---添加访问---账号密码：root redhat ----左边Overview---找到configure--找到调优

```

## 3.调节nice值

```bash
进程有默认优先级，但是优先级默认不能更改，但是可以通过修改nice值来影响进程优先级。
nice值+old优先级=new优先级
Nice值：
    root：修改范围-20~19    调节优先级的工作由root来执行
    user:   修改范围0~19        调节后无法降级
    
优先级：
        数值越大优先度越低
        数值越小优先级越高

nice 直接给一个新的指令设置优先级
renice 给一个现有的进程调节优先
```

nice值管理

```bash
语法：
nice 选项  command
选项：
-n ： -n 后面添加优先级 
例：
nice -n 10 vim 1.txt
语法：
renice 选项 进程号
-n：  -n 后面添加优先级 
例：
renice -n 10 pid
```

## 练习：

```bash
[root@clear ~]# cd /opt/
[root@clear opt]# ls
dir1  file1
[root@clear opt]# rm -rf *
[root@clear opt]# vim test.txt  &   #生成一个进程，&放后台
[1] 59090
[root@clear opt]# ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0    1139    1138  0  80   0 - 59210 -      pts/2    00:00:03 bash
0 T     0   59090    1139  1  80   0 - 60817 -      pts/2    00:00:00 vim  #出现了
0 R     0   59091    1139  0  80   0 - 63799 -      pts/2    00:00:00 ps
[root@clear opt]# nice -n 10 vim 1.txt &  #创建新进程 并且添加nice值为正10
[2] 59097
[root@clear opt]# ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0    1139    1138  0  80   0 - 59243 -      pts/2    00:00:03 bash
0 T     0   59090    1139  0  80   0 - 60817 -      pts/2    00:00:00 vim
0 T     0   59097    1139  2  90  10 - 60817 -      pts/2    00:00:00 vim  #在这里
0 R     0   59098    1139  0  80   0 - 63799 -      pts/2    00:00:00 ps
[2]+  Stopped                 nice -n 10 vim 1.txt
[root@clear opt]# renice -n -5 59090         #修改现有进程，nice值为负5，指定进程号
59090 (process ID) old priority 0, new priority -5
[root@clear opt]# ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0    1139    1138  0  80   0 - 59243 -      pts/2    00:00:03 bash
0 T     0   59090    1139  0  75  -5 - 60817 -      pts/2    00:00:00 vim   #已经改变了
0 T     0   59097    1139  0  90  10 - 60817 -      pts/2    00:00:00 vim
0 R     0   59100    1139  0  80   0 - 63799 -      pts/2    00:00:00 ps
[root@clear opt]# 
```



# 第四章 FACL访问控制列表

## 1 ACL概念

```bash
给单个用户或组针对文件设置权限。

acl可以针对以下对象设置权限：
user
group
mask(使用环境很少)
other(使用环境很少)
```

## 2 查看文件是否设置了acl

```bash
示例：
[root@servera /]# ll os.current 
-rwxrwxr-x+ 1 root root 246 Mar  8 10:14 os.current    #有+加号，证明设置了facl权限

提示：
#xfs ext3 ext4默认支持ACL
```

### 示例：

```bash
[root@clear /]# cd /opt/
[root@clear opt]# ls
[root@clear opt]# touch file1
[root@clear opt]# echo haha > file1
[root@clear opt]# ll file1
-rw-r--r--. 1 root root 5 Nov 19 04:59 file1
[root@clear opt]# ll file1
-rw-r--r--. 1 root root 5 Nov 19 04:59 file1
[root@clear opt]# setfacl -m u:student:rwx file1
[root@clear opt]# ll file1
-rw-rwxr--+ 1 root root 5 Nov 19 04:59 file1
[root@clear opt]# getfacl file1
# file: file1
# owner: root
# group: root
user::rw-
user:student:rwx
group::r--
mask::rwx
other::r--

[root@clear opt]# su - student
Last login: Tue Sep  1 08:19:05 EDT 2020 from 172.25.250.9 on pts/0
[student@clear ~]$ vim /opt/file1

```

### 练习：

```bash
语法：
setfacl [选项] ugmo:user/group:权限 文件名
选项
-m 设置acl权限   setfacl -m u:studnet:rwx file1
-x 删除acl	  setfacl -x u:student file1
-b 删除所有      setfacl -b file1
-R 递归         setfacl -Rm u:studnet:rwx file1  

getfacl
-R 递归         getfacl file1

-m 设置
[root@servera /]# touch file1
[root@servera /]# man setfacl 搜索EXAMPLES 复制例子
[root@servera /]# setfacl -m u:harry:rwx file1
[root@servera /]# getfacl  file1   #查看
# file: file1
# owner: root
# group: root
user::rwx
user:harry:rwx
group::r-x
mask::rwx
other::r-x

设置acl组权限
[root@servera /]# grep wheel /etc/group
[root@servera /]# setfacl -m g:wheel:rwx /opt/file1
[root@servera opt]# id student
uid=1000(student) gid=1000(student) groups=1000(student),10(wheel)
[root@servera opt]# su - student
[student@servera opt]# vim /opt/file1   应该可以编辑保存文件

了解mask值
[root@servera /]# setfacl -m m::rw- acltest.txt 
[root@servera /]# getfacl acltest.txt 
# file: acltest.txt
# owner: root
# group: root
user::rw-
group::r--
group:east:rwx			#effective:rw-  #user和group权限只有和mask权限重叠时才生效
mask::rw-
other::r--

设置原本组权限：
[root@servera opt]# setfacl -m g::rw acl.txt 

-x
[root@servera /]# setfacl -x g:east acltest.txt 
[root@servera /]# setfacl -x m: acltest.txt    #使用该条命令删除mask值时，不能存在其他用户
[root@servera /]# setfacl -x u:harry os.current 
[root@servera /]# getfacl os.current 
# file: os.current
# owner: root
# group: root
user::rwx
user:lisa:---
group::r-x
mask::r-x
other::r-x

-b
[root@servera /]# setfacl -b os.current


-R ，-Rb
[root@servera opt]# mkdir acldir
[root@servera opt]# touch acldir/acl.txt
[root@servera opt]# ls acldir/
acl.txt
[root@servera opt]# setfacl -Rm u:harry:rwx acldir/
[root@servera opt]# getfacl -R acldir/
# file: acldir/
# owner: root
# group: root
user::rwx
user:harry:rwx
group::r-x
mask::rwx
other::r-x

# file: acldir//acl.txt
# owner: root
# group: root
user::rw-
user:harry:rwx
group::r--
mask::rwx
other::r--

[root@servera opt]# setfacl -Rb acldir/
[root@servera opt]# getfacl -R acldir/
# file: acldir/
# owner: root
# group: root
user::rwx
group::r-x
other::r-x

# file: acldir//acl.txt
# owner: root
# group: root
user::rw-
group::r--
other::r--

作业：
1、课上练习
2、QA
```

# 第五章 管理SELinux

## **1 什么是selinux**

```
  SELinux 全称 Security Enhanced Linux (安全强化 Linux),是美国国家安全局2000年以 GNU GPL 发布，是 MAC (Mandatory Access Control，强制访问控制系统)的一个实现，目的在于明确的指明某个进程可以访问哪些资源(文件、网络端口等)。强制访问控制系统 的用途在于增强系统抵御 0-Day 攻击(利用尚未公开的漏洞实现的攻击行为)的能力。所以它不是网络防火墙或 FACL 的替代品，在用途上也 不重复。在目前的大多数发行版中，已经默认在内核集成了SELinux。
```

## **2 selinux实现原理**

```
1、普通权限和selinux权限对比：
​传统的Linux使用用户、文件权限的概念来限制资源的访问，通过对比进程的发起用户和文件权限以此来保证系统资源的安全，这是一种自由访问控制方式（DAC）
​Linux下的一种安全强化机制（SELinux），该机制为进程和文件加入了除权限之外更多的限制来增强访问条件，这种方式为强制访问控制（MAC）。进程和文件都有相应的标签，称为上下文，只有进程上下文和文件上下文对应上，该进程才可以访问文件。
​何为对应？系统中大量的进程和文件上下文已经被定义，如http服务进程上下文为httpd_t域，/var/www/html/目录上下文为httpd_sys_content_t，后者归属于前者的匹配域内，即可匹配。
```

| 分类                | 源             | 目的                       |
| ------------------- | -------------- | -------------------------- |
| 传统文件系统权限DAC | 用户           | 文件系统权限               |
| SELinux权限MAC      | 用户进程上下文 | 文件（或目录端口等）上下文 |

## 3 selinux的限制范围

```tcl
SElinux具有多种上下文类型，常见种类：（掌握上下文）
​安全上下文（限制文件的访问）：该种类上  下文存在于内存和文件中，进程访问文件inode时读取到上下文类型进行对比
​布尔值（限制软件功能的访问）：该种类型，主要控制某些进程是否可以访服务常用功能中出现的文件
​安全端口（限制服务的访问）：selinux会限制服务启用的非标准端口号
```

|  ID  |            |                         | SELinux                                                      |
| :--: | ---------- | ----------------------- | ------------------------------------------------------------ |
|  1   | Filesystem | chmod, chown, setfacl   | semanage fcontext ... restorecon ... chcon ... touch /.autorelabel |
|  2   | Service    | vim /etc/*.conf         | setsebool -P ...                                             |
|  3   | Firewall   | firewall-cmd ...        | semanage port ...                                            |
|  4   | SELinux    | vim /etc/selinux/config |                                                              |

## 4 如何查看上下文（掌握，会查看上下文）

```bash
进程：              
ps auxZ            
ps -eZ
[root@servera ~]# ps auxZ | grep httpd
system_u:system_r:httpd_t:s0    root      1971  0.0  1.2 273800 10496 ?        Ss   04:58   0:00 /usr/sbin/httpd -DFOREGROUND

文件：
ls -Z
[root@servera ~]# ll -dZ /var/www/html/
system_u:object_r:httpd_sys_content_t:s0 /var/www/html/

只要进程和文件的安全上下文匹配，该进程就可以访问该文件资源
```

## 5 security context介绍（这里的指令只为了帮助大家了解概念）

```bash
content一词使我们常说的上下文，安全上下文有5个字段，以：冒号分割，
unconfined_u   :object_r:   httpd_sys_content_t:  	  s0  					   [类别]   

身份		            角色            类型                               灵敏度（级别）     类别     

1) 身份字段（user)
   用于标识该数据被哪个身份所拥有，相当于权限中的用户身份。这个字段并没有特别的作用，知道就好。常见的身份类型有以下 3 种：
- root：表示安全上下文的身份是 root。
- system_u：表示系统用户身份，其中“_u”代表 user。
- user_u：表示与一般用户账号相关的身份，其中“_u”代表 user。
- 以使用 seinfo 命令来进行查询

2) 角色（role）
主要用来表示此数据是进程还是文件或目录。这个字段在实际使用中也不需要修改，所以了解就好。
常见的角色有以下两种：
- object_r：代表该数据是文件或目录，这里的“_r”代表 role。
- system_r：代表该数据是进程，这里的“_r”代表 role。

3) 类型（type）
   类型字段是安全上下文中最重要的字段，进程是否可以访问文件，主要就是看进程的安全上下文类型字段是否和文件的安全上下文类型字段相匹配，如果匹配则可以访问。

注意，类型字段在文件或目录的安全上下文中被称作类型（type），但是在进程的安全上下文中被称作域（domain）。也就是说，在主体（Subject）的安全上下文中，这个字段被称为域；在目标（Object）的安全上下文中，这个字段被称为类型。域和类型需要匹配（进程的类型要和文件的类型相匹配），才能正确访问。
context查询工具seinfo、sesearch
    seinfo -u    # 查询所有的user字段的种类
    seinfo -r    # 查询所有的role字段的种类
    seinfo -t    # 查询所有的type字段的种类 

sesearch -A 可以查询什么类型进程可以读取什么type类型的文件
    sesearch -A -s 进程type    # 查询type类型的进程能够读取的文件type   
    sesearch -A -b 规则（规则的boolean值，所以为-b选项，理解为bool规则）
    
[root@foundation0 ~]# sesearch -A -s httpd_t | grep '^allow httpd_t httpd_sys_content_t'

4) 灵敏度
   灵敏度一般是用 s0、s1、s2 来命名的，数字代表灵敏度的分级。数值越大，代表灵敏度越高。

5) 类别
   类别字段不是必须有的，所以我们使用 ls 和 ps 命令查询的时候并没有看到类别字段。通过seinfo -u -x查看
```

## 6 临时开启或关闭selinux（掌握）

```bash
[root@clear /]# getenforce 
Enforcing
[root@clear /]# setenforce 
usage:  setenforce [ Enforcing | Permissive | 1 | 0 ]
[root@clear /]# setenforce 0
[root@clear /]# getenforce 
Permissive
[root@clear /]# setenforce Permissive
[root@clear /]# getenforce 
Permissive
[root@clear /]# setenforce 1
[root@clear /]# getenforce 
Enforcing

```

## 7 永久开启或关闭selinux状态

```bash
[root@servera ~]# vim /etc/selinux/config
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=enforcing

修改后，重启操作系统生效
```

## 8 继承特性（了解）

```
继承：
1、在父目录下创建文件会继承selinux上下文touch
2、cp 
不继承：
创建了文件并且移动mv，会保留原来的父目录上下文关系
复制时cp  -a（rp） ，也会保留之前的上下文关系
```

### 继承特性练习（了解）

```bash
【servera】 
[root@servera /]# cd /var/www/html/
[root@servera html]# ll -dZ .
drwxr-xr-x. 2 root root system_u:object_r:httpd_sys_content_t:s0 23 May 21 09:13 .
[root@servera html]# touch haha.txt
[root@servera html]# ll -Z haha.txt 
-rw-r--r--. 1 root root unconfined_u:object_r:httpd_sys_content_t:s0 0 May 21 10:06 haha.txt


[root@servera ~]# cd /tmp/
[root@servera tmp]# touch file{1..3}
[root@servera tmp]# ls -Z /tmp/file*
unconfined_u:object_r:user_tmp_t:s0 /tmp/file1 
unconfined_u:object_r:user_tmp_t:s0 /tmp/file2 
unconfined_u:object_r:user_tmp_t:s0 /tmp/file3
[root@servera tmp]# ls -Z /tmp/file*
[root@servera tmp]# cp /tmp/file1 /var/www/html/
[root@servera tmp]# cp -a /tmp/file2 /var/www/html/
[root@servera tmp]# mv /tmp/file3 /var/www/html/
[root@servera tmp]# cd /var/www/html/
[root@servera html]# ls -Z *
unconfined_u:object_r:httpd_sys_content_t:s0 file1           unconfined_u:object_r:user_tmp_t:s0 file3
         unconfined_u:object_r:user_tmp_t:s0 file2
[root@servera html]# touch /var/www/html/file4
[root@servera html]# ll -Z /var/www/html/file4
-rw-r--r--. 1 root root unconfined_u:object_r:httpd_sys_content_t:s0 0 Apr 10 05:08 /var/www/html/file4
</pre>

[root@servera html]# restorecon -Rv /var/www/html/
```

## 9  定义selinux默认文件上下文规则 （考点）

```bash
方法1：永久设置，但不记录至数据库
	chcon 设置上下文关系

方法2：永久设置，记录至数据库
	semanage fcontext  添加、修改、查看、删除默认上下文
	restorecon 恢复默认上下文
```

### 9.1 chcon

```bash
 
语法：
chcon  -t  type  filename
例：【模拟考试环境】
[root@clear /]# setenforce 1  
[root@clear /]# vim /etc/httpd/conf/httpd.conf 
Listen 82 改成 Listen 80  
[root@clear /]# systemctl restart httpd 
[root@clear /]# ll -Z /var/www/html/
total 12
-rw-r--r--. 1 root root system_u:object_r:default_t:s0           14 Nov 19 04:28 file1
-rw-r--r--. 1 root root system_u:object_r:httpd_sys_content_t:s0 14 Nov 19 04:28 file2
-rw-r--r--. 1 root root system_u:object_r:httpd_sys_content_t:s0 14 Nov 19 04:28 file3
[root@clear /]# curl 172.25.250.10/file1
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>403 Forbidden</title>   #因为上下文不一致，导致无法访问网页
</head><body>
<h1>Forbidden</h1>
<p>You don't have permission to access /file1
on this server.<br />
</p>
</body></html>
[root@clear /]# curl 172.25.250.10/file2   #因为上下一致所以可以访问
EX200 Testing
[root@clear /]# curl 172.25.250.10/file3
EX200 Testing
[root@clear /]# chcon -t httpd_sys_content_t /var/www/html/file1  #修改上下文
[root@clear /]# ll -Z /var/www/html/
total 12
-rw-r--r--. 1 root root system_u:object_r:httpd_sys_content_t:s0 14 Nov 19 04:28 file1
-rw-r--r--. 1 root root system_u:object_r:httpd_sys_content_t:s0 14 Nov 19 04:28 file2
-rw-r--r--. 1 root root system_u:object_r:httpd_sys_content_t:s0 14 Nov 19 04:28 file3
[root@clear /]# curl 172.25.250.10/file1
EX200 Testing

```

### 9.2 semanage fcontext 

```bash
帮助中查看示例：
man semanage
man semanage fcontext
选项：
semanage fcontext 
-a 	添加   添加至数据库
-d	删除
-l	查看
-t	指定上下文
-m  修改

修改流程：
1、查看selinux标签数据库是否有记录？有就恢复，没有就添加
2、semanage fcontext添加文件标签类型至数据库. 添加后，文件并不会更改标签类型
3、使用restorecon命令同步和数据库一致

【servera】
-l
[root@clear /]# man semanage fcontext
[root@clear /]# semanage  fcontext -l | grep /var/www  看第一行即可
[root@clear /]# semanage  fcontext -l | grep /var/www/html/file1
/var/www/html/file1                                all files          system_u:object_r:default_t:s0 
[root@clear /]# semanage fcontext -m -t httpd_sys_content_t /var/www/html/file1
[root@clear /]# semanage  fcontext -l | grep /var/www/html/file1
/var/www/html/file1                                all files          system_u:object_r:httpd_sys_content_t:s0 

restorecon  恢复文件上下文和数据库一致
-v  显示修改标签内容
-R  递归

[root@clear /]# restorecon -R -v /var/www/html/file1
Relabeled /var/www/html/file1 from system_u:object_r:default_t:s0 to system_u:object_r:httpd_sys_content_t:s0
```

## 10  使用布尔值调整（有用，但不考）

1.关闭selinux正常使用  apache发布托管在用户主页上得web内容功能

```bash
1.关闭selinux
[root@clear /]# setenforce 0
2.编辑配置文件
[root@clear /]# vim /etc/httpd/conf.d/userdir.conf 
#UserDir disabled   #注释该行
UserDir public_html  #解除该行注释，启用该功能
3.切换student用户，制作发布目录和网页
[root@clear /]# su - student
[student@clear ~]$ mkdir public_html  #创建发布目录
[student@clear ~]$ echo  test_web_page > public_html/index.html #制作网页
[student@clear ~]$ logout  #退出
[root@clear /]# chmod 711 /home/student/  #root用户身份，修改用户家目录权限为711，目的是为了让其他人有权限访问子目录及文件
[root@clear /]# systemctl stop firewalld   
[root@clear /]# systemctl restart httpd
4.在foundation上做访问测试
firefox  http://172.25.250.10/~student/index.html
test_web_page

5.开启selinux再次访问
【172.25.250.10】
[root@clear /]# setenforce 1
【foundation】
firefox  http://172.25.250.10/~student/index.html
Forbidden
You don't have permission to access /~student/index.html on this server.

6.开启对应布尔值，允许该功能
[root@clear /]# yum install -y selinux-policy-doc
[root@clear /]# mandb
[root@clear /]# man -k 'http'
[root@clear /]# man 8 httpd_selinux    #文档里搜索homedirs，复制该命令，开启该功能
[root@clear /]# setsebool -P httpd_enable_homedirs 1
[root@clear /]# getsebool
[root@clear /]# getsebool -a
[root@clear /]# getsebool -a | grep http | grep homedir  #第一种查询方式
root@clear /]# semanage boolean -l | grep homedirs   #第二种查询方式，查布尔值数据库
httpd_enable_homedirs          (on   ,   on)  Allow httpd to enable homedirs
							  （功能打开，永久生效）
[root@clear /]# getenforce  

7.在foundation上做访问测试
firefox  http://172.25.250.10/~student/index.html
test_web_page
```

## 管理布尔值

```bash
布尔值主要对应的是应用的功能的开启或关闭
getsebool 		列出布尔值状态  user
setsebool 		设置布尔值开启或关闭on 开，off 关
-P				更改布尔值永久生效 setsebool -p
semanage boolean -l 查看布尔值是否永久


[root@servera /]# yum install -y selinux-policy-doc
[root@servera /]# mandb
[root@servera /]# man -k '_selinux' | grep httpd
[root@servera /]# man 8 httpd_selinux
[root@servera /]# man 8 httpd_selinux |  grep -B 1 homedir
[root@servera /]# getsebool -a  
[root@servera /]# getsebool -a |  grep httpd | grep homedir

修改布尔值状态
[root@servera /]# setsebool httpd_enable_homedirs on
[root@servera /]# semanage boolean -l  | grep httpd_enable_home
httpd_enable_homedirs          (off  ,  off)  Allow httpd to enable homedirs
[root@servera /]# setsebool -P httpd_enable_homedirs on  永久生效
[root@servera /]# semanage boolean -l  | grep httpd_enable_home
httpd_enable_homedirs          (on   ,   on)  Allow httpd to enable homedirs
[root@servera /]# setsebool -P httpd_enable_homedirs off
```

#### 十一 SElinux日志

SELinux 会使用被称为 AVC（Access Vector Cache，访问矢量缓存）的缓存，如果访问被拒绝（也被称为 AVC 拒绝），则会在一个日志文件中记录下拒绝消息。

这些被拒绝的消息可以帮助诊断和解决常规的 SELinux 策略违规行为，至于这些拒绝消息到底被记录在什么位置，则取决于 auditd 和 rsyslogd 守护进程的状态：
	若 auditd 守护进程正在运行，则拒绝消息将被记录与 /var/log/audit/audit.log 中。
	若 auditd 守护进程没有运行，但 rsyslogd 守护进程正在运行，则拒绝消息会记录到 /var/log/messages 中。

```bash
-a：分析指定的日志文件
sealert -a /var/log/audit/audit.log  回显比较慢多等一会
```



# 第六章 管理基本存储

## 1 磁盘分区基础概念

```
MBR分区方案
mbr叫做主引导记录，IBM公司提出的，它存在于磁盘的0柱面0磁道0扇区中，是磁盘的第一个扇区内，大小为512字节 446字节初始化程序加载器 64字节分区表 2字节校验码，每个分区16字节，所以最多4个分区，最大磁盘空间支持2T   

GPT分区方案
GPT是GUID Partition Table，全局唯一标识磁盘分区表。它由UEFI启动硬盘，这样就有了UEFI取代传动BIOS，而GPT则取代传统的MBR，windows支持最多128个GPT分区。
```

```
MBR分区方案
分区表=64字节
1个分区=16字节
4x16=64 最多只能记录4个分区 主分区
4个分区不够用？比如5个以上？
新方案：
牺牲一个主分区，换为扩展分区
扩展分作用可以分多个逻辑分区
逻辑分区，可以格式化使用的

1.主分区最多 4个，可以格式化
2.扩展分区最多可以有1个，占用一个主分区，不能格式化使用的，它是装载逻辑分区用的
3.逻辑分区-由扩展分区的空间划分而来的，约可以分15个左右。格式化使用，逻辑分区必定从5号开始
3个主分区，1扩展，2个逻辑
分区方案4P   3P+1E
```

|    0     | mbr  |     dpt     |      |
| :------: | :--: | :---------: | :--: |
| 512 Byte | 446  |     64      |  2   |
|          |      | Primary<=4  |      |
|          |      |  Extend<=1  |      |
|          |      | Logical<=14 |      |

|  ID  |              | Count | Size |           |      |
| :--: | ------------ | ----- | ---- | --------- | ---- |
|  1   | mbr \| msdos | 15    | 2TB  | 3P+1E(nL) | 4P   |
|  2   | gpt          | 128   | 8ZB  | P         |      |

|  ID  |        |       Windows       |                            Linux                             |    MacOS     |
| :--: | ------ | :-----------------: | :----------------------------------------------------------: | :----------: |
|  1   | local  | ntfs, fat32,  exfat | xfs, ext4 \| swap [exfat](https://centos.pkgs.org/8/rpmfusion-free-updates-x86_64/) | apfs,  exfat |
|  2   | remote |      cifs, nfs      |                                                              |              |

## 2 fdisk

```bash
使用新磁盘流程规划：
1.分区（可选）
2.格式化
3.挂载
4.使用

fdisk是一个分区工具，既可以查看磁盘状况，也可以对磁盘进行分区
语法：
fdisk  选项  设备名
选项：
-l 查看所有磁盘状态
例：
fdisk  -l  #查所有磁盘信息
fdisk  -l /dev/vdb   #查某一个磁盘信息
```

### 练习：

```bash
1个分区 1个扩展 1个逻辑
10G磁盘，每个分区1G

[root@clear /]# fdisk -l
[root@clear /]# fdisk -l /dev/vdb
[root@clear /]# fdisk /dev/vdb
n   #创建分区
p   #选择p主  或  e扩展
1	#分区编号
回车，不通过扇区范围分配         
+1G  设置一个1G大小分区
p  查看分区状态

d  删除
w  保存退出

#partprobe    磁盘分区正常结束后，此命令可以正常执行，不返回任何信息，主要做刷新分表信息通知内核
[root@clear /]# fdisk -l /dev/vdb
```

## 3 parted

### 3.1 MBR分区方案

```bash
1.mbr方式
定义分区方案
分区
分3个区 主、扩展 、逻辑。再用非交互式创建第二个逻辑
[root@servera /]# parted /dev/vdc     #直接指定设备，而不是分区
(parted) mklabel        #按回车键  定义分区方案                                                    
New disk label type? msdos     #两一下tab键，填写                                             
Number  Start  End  Size  Type  File system  Flags
(parted) mkpart #分区                                                          
Partition type?  primary/extended? p  #主/扩展/逻辑                                    
File system type?  [ext2]? ext4   #无用，不生效
Start? 2048s#第一个分区，一定从1M或2048s开始                                                          
End? 1000MB #分1G分区，1000M、1G、（10G磁盘，可以写10%，完全使用就是100%）                                                              
(parted) p          #查看                                                      

Number  Start   End     Size   Type     File system  Flags
 1      1049kB  1000MB  999MB  primary  ext4         lba
(parted) quit        #退出                                                    
Information: You may need to update /etc/fstab.
[root@servera ~]# udevadm  settle (更新通知内核，建议敲上，不是必要)

非交互式方式
命令：
[root@servera /]# parted /dev/vdc mkpart p ext4 1000MB 2000MB
```

### 3.2 GPT方案：

```bash
[root@clear /]# parted  /dev/vdc  #使用了上一个实验的同样的分区，重复使用了vdc
(parted) mklabel                                                          
New disk label type? gpt  #再更改分区方案时会抹掉之前的分区数据
Warning: The existing disk label on /dev/vdc will be destroyed and all data on this disk will be lost. Do
you want to continue?
Yes/No? yes    #yes                                                            
(parted) p                                                                 B
Partition Table: gpt  #此处显示gpt分区方案
(parted) mkpart                                                           
Partition name?  []? part1   #分区名字                                               
File system type?  [ext2]?     #直接回车                                           
Start? 1M                                                                 
End? 10%                                                                  
(parted) p                                                                
Number  Start   End     Size    File system  Name   Flags
 1      1049kB  1074MB  1073MB  ext2         part1        #注意Number和Name
(parted) mkpart
Partition name?  []? part2                                                
File system type?  [ext2]?                                                
Start? 10%                                                                
End? 20%
(parted) p
Number  Start   End     Size    File system  Name   Flags
 1      1049kB  1074MB  1073MB  ext2         part1
 2      1074MB  2147MB  1074MB  ext2         part2   #第二个分区完成
(parted) rm                                                               
Partition number? 2               #选择第二个分区的Number                                      
(parted) p                                                                
Number  Start   End     Size    File system  Name   Flags
 1      1049kB  1074MB  1073MB  ext2         part1
(parted) q                                                                
#非交互式方式重新分第二个分区
[root@clear /]# parted /dev/vdc mkpart  part2 ext2 10% 20%                
[root@clear /]# parted /dev/vdc p
Number  Start   End     Size    File system  Name   Flags
 1      1049kB  1074MB  1073MB               part1
 2      1074MB  2147MB  1074MB               part2   #成功分配
```

## 4 文件系统

```
1.分区后，会给分区定义文件系统类型，window有fat32 ntfs ,linux exfat 有ext2 ext3 ext4 xfs vfat exfat，Mac OS 有exfat。
2.为什么定义文件系统？给磁盘定义一种存储数据的方法，这样块存储设备才可以记录文件数据。
3.每个分区都可以定义一个独立的文件系统，定义的方法就是格式化。设备有了文件系统后才可以存储数据。
4.操作系统里分区很多，有不同的文件系统
5.VFS  虚拟文件系统：作用，将用户发送的指令给任何文件系统做翻译，对于用户来说，我不必学习不同文件系统的操作方法，而是使用常用shell管理指令，就可以通过VFS传递
给不同的文件系统了。
```

## 5 格式化：

```bash
语法：
mkfs  选项  文件系统
选项：
-t： 指定文件系统
例：
[root@servera /]# mkfs -t ext4 /dev/vdc1 	
例2：使用.点代替-t
[root@servera /]# mkfs.xfs /dev/vdc2
```

## 6 lsblk

```bash
[root@servera /]# lsblk --fs /dev/vdc
NAME   FSTYPE LABEL UUID                                 MOUNTPOINT
vdc                                                      
├─vdc1 ext4         af656cc6-80e3-4b05-abcf-a162907c2f0a 
└─vdc2 xfs          64237913-4937-48ff-8afa-28c6fc05124d 
[root@servera /]# parted /dev/vdc p
Model: Virtio Block Device (virtblk)
Disk /dev/vdc: 5369MB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End     Size   Type     File system  Flags
 1      1049kB  1000MB  999MB  primary  ext4
 2      1000MB  2000MB  999MB  primary  xfs
 
查看文件系统
lsblk  --fs /dev/vdc
blkid



```

## 7 挂载与永久挂载

### 7.1 mount

```bash
mount挂载也称为手动挂载，或临时挂载，重启失效
语法：
mount   源设备  挂载点
例1：
mount  /dev/vdc1    /mnt/disk1
选项：
-t 指定文件系统类型（默认自动识别） mount  -t ext4 /dev/vdc1    /mnt/disk1 
-o 指定挂载权限卸载--》再指定权限  mount  -o ro /dev/vdc1    /mnt/disk1 
例2：
remount 重新挂载 （不卸载的基础上重新挂载）
mount -o remount,ro /dev/vdc2

卸载：
umount 源设备/挂载点
例：
umount /dev/vdc1  #或者 umount /mnt/disk1  #卸载时要退出/mnt/disk1目录
```

```bash
1.临时挂载 
[root@clear dev]# mkdir /mnt/disk1   #创建挂载点
[root@clear dev]# mount /dev/vdc1 /mnt/disk1   #挂载
[root@clear dev]# df -Th
Filesystem     Type      Size  Used Avail Use% Mounted on
/dev/vdc1      ext4      991M  2.6M  922M   1% /mnt/disk1
[root@clear dev]# cd /mnt/disk1  #进入目录  
[root@clear disk1]# touch haha   #使用
[root@clear disk1]# ls
haha  lost+found
[root@clear disk1]# cd /
卸载
[root@clear /]# umount /dev/vdc1
[root@clear /]# df -Th  #查看发现已经没有/dev/vdc1的挂载信息，就算成功了 。

2.使用UUID方式挂载
[root@clear /]# blkid
[root@clear /]# blkid /dev/vdc1
/dev/vdc1: UUID="9bdeba87-5ad0-4c52-b577-0234115df2e1" TYPE="ext4" PARTLABEL="part1" PARTUUID="28f6e868-cd04-434c-9fd3-618f17382797"
[root@clear /]# mount UUID="9bdeba87-5ad0-4c52-b577-0234115df2e1" /mnt/disk1 #鼠标左键选定后按滑轮中间。
[root@clear /]# df -Th
/dev/vdc1      ext4      991M  2.6M  922M   1% /mnt/disk1
```

### 7.2 /etc/fstab

```bash
2.开机自动挂载   永久
[root@clear /]# df -h
/dev/vdc1       991M  2.6M  922M   1% /mnt/disk1
[root@clear /]# umount /dev/vdc1
[root@clear /]# df -h
[root@clear /]# vim /etc/fstab 
/dev/vdc1       /mnt/disk1      ext4    defaults    0     0
设备ID或设备名称	 挂载点	文件系统类型   选项（权限，认证设定，其他）   内核日志检测机制0不检测，1、2检测，1比2优先级高  磁盘检测机制0不检测

[root@clear /]# mount -a #挂载/etc/fstab中所有未挂载的设备
[root@clear /]# df -Th
/dev/vdc1      ext4      991M  2.6M  922M   1% /mnt/disk1

#reboot   #模拟考试环境，没做完selinux安全端口别重启，会起不来

`注意`
如果/etc/fstab中配置错误导致不能启动系统，重启时会自动进入紧急模式，此时输入管理员root密码，vi /etc/fstab更改正内容确后reboot即可
```

## 8 管理交换分区

```bash
创建swap 
流程： 
1.分区
[root@clear /]# parted  /dev/vdc mkpart part3 ext2 20% 30% 
Information: You may need to update /etc/fstab.
[root@clear /]# parted  /dev/vdc p
Number  Start   End     Size    File system  Name   Flags
 1      1049kB  1074MB  1073MB  ext4         part1
 2      1074MB  2147MB  1074MB  xfs          part2
 3      2147MB  3221MB  1074MB               part3
2.格式化
[root@clear /]# mkswap /dev/vdc3
Setting up swapspace version 1, size = 1024 MiB (1073737728 bytes)
no label, UUID=d66e7c4a-152a-4900-9801-bef1e23a021b
3.挂载
[root@clear /]# lsblk -f
└─vdc3 swap         d66e7c4a-152a-4900-9801-bef1e23a021b                                  [root@clear /]# free -m  
              total        used        free      shared  buff/cache   available
Mem:           1826         239        1059          16         528        1415
Swap:             0           0           0       #<-----提前检查以下系统默认swap空间，发现都是0,未添加
[root@clear /]# swapon /dev/vdc3    #临时加载
[root@clear /]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1826         240        1058          16         528        1414
Swap:          1023           0        1023   #有数值了，添加成功
[root@clear /]# swapoff /dev/vdc3    #卸载
[root@clear /]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1826         239        1058          16         528        1415
Swap:             0           0           0

写入fstab开机自启
[root@clear /]# echo "/dev/vdc3 swap swap defaults 0 0" >> /etc/fstab 
[root@clear /]# cat /etc/fstab
/dev/vdc3 swap swap defaults 0 0

[root@clear /]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1826         239        1059          16         528        1415
Swap:             0           0           0
[root@clear /]# swapon -a   #swap空间用swapon -a挂载
[root@clear /]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1826         240        1058          16         528        1414
Swap:          1023           0        1023

#reboot重启验证   #模拟考试环境没做selinux题，先别重启，起不来



使用本地存储创建swap（了解）
swap-file
# df -h
# dd if=/dev/zero of=/pagefile.sys bs=512M count=1
# mkswap /pagefile.sys 
# chmod 0600 /pagefile.sys 
# vim /etc/fstab 
...
/pagefile.sys swap swap defaults 0 0 
# swapon -a
# free -h
```



# 第七章 逻辑卷管理

## 1 名词解释

```
逻辑卷（Logical Volume Manager）是基于内核的一种逻辑卷管理器，LVM适合于管理大存储设备，并允许用户动态调整文件系统的大小。
```

```
物理卷（Physical Volume，PV）：物理卷是LVM的最底层概念，是LVM的逻辑存储块，物理卷与磁盘分区是逻辑的对应关系。
卷组（Volume Group，VG）：卷组是LVM逻辑概念上的磁盘设备，通过将单个或多个物理卷组合后生成卷组。卷组的大小取决于物理卷的容量以及个数。
物理长度（Physical Extent，PE）：物理长度是将物理卷组合为卷组后，所划分的最小存储单位，即逻辑意义上磁盘的最小存储单元。LVM默认PE大小为4MB.
逻辑卷（Logical Volume，LV）:逻辑卷就是LVM逻辑意义上的分区，我们可以指定从卷组中提取多少容量来创建逻辑卷，最后对逻辑卷格式化并挂载使用。
```

## 2 逻辑卷管理（考点）

1.创建逻辑卷的流程

```bash
1.分区或者添加物理硬盘
2.pv让物理磁盘或分区变成lvm可用的卷
3.创建vg同时指定pe块大小
4.在vg中划分lv空间
5.格式化lv空间
6.挂载或者永久挂载。

PV语法：
pvcreate  /dev/vdb1  /dev/vdb   #分区名称，或磁盘名
VG语法：
vgcreate -s 16M vgname pvname   #-s不写默认4M，扩大的话可以是2的次方，比如4、8、16、32...，vgname是vg名称自定义，pvname 就是创建pv时的物理分区名，就是pv名称
LV语法：
lvcreate -L 容量 -n vlname vgname #指定容量可以使用-L 容量 或 -l 块数
```

```bash
1.分区
[root@clear ~]# fdisk -l /dev/vdb
Device     Boot   Start      End  Sectors Size Id Type
/dev/vdb1          2048  2099199  2097152   1G 83 Linux
/dev/vdb2       2099200  4196351  2097152   1G 83 Linux
/dev/vdb3       4196352  6293503  2097152   1G 83 Linux
/dev/vdb4       6293504 20971519 14678016   7G  5 Extended
/dev/vdb5       6295552  8392703  2097152   1G 83 Linux

2.PV阶段
[root@clear ~]# man pvcreate ,搜索/EXAMPLES
[root@clear ~]# pvcreate /dev/vdb{1,3,5}
[root@clear ~]# pvs 或者  pvscan   或者  pvdisplay 进行查询

3.VG阶段
[root@clear ~]# man vgcreate ,搜索/EXAMPLES
[root@clear ~]# vgcreate -s 16M vg100 /dev/vdb{1..3}    # -s指定物理扩展块16M一个
[root@clear ~]# vgs         #主要查看下vg的大小，拥有的pv和lv数量
[root@clear ~]# vgdisplay   #vg名，容量，块大小，块的使用量

4.LV阶段
[root@clear ~]# man lvcreate ,搜索/64m
[root@clear ~]# lvcreate -L 1G -n mylv myvg　　　　（-L　指定具体容量-L 1G 　，　-l　指定PE块数量  -l 32）
[root@clear ~]# lvs
[root@clear ~]# lvdisplay 
5.格式化
# mkfs.xfs /dev/myvg/mylv 
# lsblk --fs /dev/myvg/mylv

6.创建挂载点
# mkdir /mnt/lvm
# mount /dev/myvg/mylv /mnt/lvm
# df -h
# cd /mnt/lvm/

6.2
永久挂载
[root@clear ~]# cd /
[root@clear /]# umount /mnt/lvm1
[root@clear /]# echo "/dev/vg100/lv100 /mnt/lvm1 xfs defaults 0 0" >> /etc/fstab 
[root@clear /]# mount -a
[root@clear /]# df -Th
Filesystem              Type      Size  Used Avail Use% Mounted on
/dev/mapper/vg100-lv100 xfs       794M   38M  757M   5% /mnt/lvm1


reboot重启验证

删除逻辑卷思路：
创建顺序---分区--lv（pv-vg-lv）--格式化---挂载
卸载顺序---卸载--删lv--删vg--删pv--删分区
vgremove vg100
```

## 3 扩展逻辑卷（考点）

```bash
语法：
lvextend 【-L| -l】【size|PE】

选项：
-L：指定容量   直接指定最终大小 -L 1500M ，或者在原有基础上增加多少容量 -L +700M 
-l：指定块数   -l 60     ， -l +30

扩展流程：
1、扩展lv大小增加容量
2、将其生效：
	ext 文件系统 ”resize2fs 设备名/挂载点“   resize2fs /dev/vg100/lv100
	xfs 文件系统 “xfs_growfs 设备名/挂载点”  xfs_growfs /dev/vg100/lv100 或 xfs_growfs 挂载点
	
例：
如果是xfs文件系统使用：
[root@servera /]# xfs_growfs /mnt/lvm (挂载点)
[root@servera /]# df -h

如果是ext4文件系统使用：
[root@servera /]# resize2fs /dev/myvg/mylv （lv设备名）
创建的lv名称为myly，属于myvg卷组，lv需要30个pe，每个pe16M，需要开机自动挂载到/mnt/mylvdir. 并且使用xfs文件系统
```

### 课上练习

```bash
扩展lv
[root@servera /]# lvextend -L 1500M /dev/mapper/vg100-lv100
[root@servera /]# xfs_growfs /mnt/lvm1
```

## 4 缩小lv（了解）

```bash
ext文件系统可以缩小，xfs不支持
流程：
1、卸载
2、resize2fs 定义缩小后的大小
3、磁盘检测
4、lvresize -L 1G 逻辑卷名

# umount /dev/myvg/mylv
# resize2fs /dev/myvg/mylv 1G
# e2fsck -f /dev/myvg/mylv
# resize2fs /dev/myvg/mylv 1G
# lvdisplay 
# lvresize -L 1G /dev/myvg/mylv 
# lvdisplay
```



# 第八章 实施高级存储功能

## 1 stratis(了解)

### 1.1 安装

```bash
# yum install -y stratis-cli stratisd
# systemctl enable --now stratisd
```

### 1.2 部署存储池

```bash
man stratis，搜索examples
[root@servera ~]# fdisk -l /dev/vdb
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Device     Boot   Start     End Sectors Size Id Type
/dev/vdb1          2048 2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 4196351 2097152   1G 83 Linux              

[root@servera ~]# stratis pool create pool1 /dev/vdb1
[root@servera ~]# stratis pool list
[root@servera ~]# stratis blockdev list
[root@servera ~]# stratis pool add-data pool1 /dev/vdb2
[root@servera ~]# stratis pool list
Name     Total Physical Size  Total Physical Used
pool1                  2 GiB               56 MiB
[root@servera ~]# stratis blockdev list
Pool Name  Device Node    Physical Size   State  Tier
pool1      /dev/vdb1              1 GiB  In-use  Data
pool1      /dev/vdb2              1 GiB  In-use  Data
```

### 1.3 创建文件系统

```bash
[root@servera ~]# stratis filesystem create pool1 filesystem1
[root@servera ~]# 
[root@servera ~]# stratis filesystem list 
Pool Name  Name         Used     Created            Device                      UUID                         
pool1      filesystem1  546 MiB  Mar 16 2020 21:47  /stratis/pool1/filesystem1  6d1ed6e714a6428eb374549b4fdd8d2b  
[root@servera ~]# mkdir /mnt/stratisvol
如何查看uuid
[root@servera ~]# lsblk --output=UUID  /stratis/pool1/filesystem1
[root@servera ~]# mount /stratis/pool1/filesystem1 /mnt/stratisvol/
```

### 1.4 备份

```bash
创建测试文件
[root@servera /]# cd /mnt/stratisvol/
[root@servera stratisvol]# dd if=/dev/zero of=myfile bs=1M count=100  #该命令意义是在挂载点中创建一个文件，也可以使用touch来替代该功能
[root@servera stratisvol]# du -sh myfile 
备份
[root@servera /]# stratis filesystem snapshot pool1 filesystem1 filesystembak1
模拟故障
[root@servera /]# cd /mnt/stratisvol/
[root@servera stratisvol]# ls
file1  myfile
[root@servera stratisvol]# rm -f *
[root@servera stratisvol]# cd /
[root@servera /]# umount /mnt/stratisvol
恢复
[root@servera /]# mkdir /mnt/stratisvolbak
[root@servera /]# mount /stratis/pool1/filesystembak1 /mnt/stratisvolbak/
```

### 1.5 开机自动挂载

```bash
vim /etc/fstab
/stratis/pool1/filesystembak1 /mnt/stratisvolbak/ xfs _netdev 0 0 #_netdev 延迟挂载，先连接网络再挂载文件系统
mount -a

[root@clear ~]# systemctl start stratis
[root@clear ~]# stratis pool create mypool /dev/vdb1
[root@clear ~]# stratis pool add-cache mypool /dev/vdb2
[root@clear ~]# stratis blockdev list mypool 
Pool Name  Device Node  Physical Size   Tier
mypool     /dev/vdb1            1 GiB   Data
mypool     /dev/vdb2            1 GiB  Cache
```

## 2 VDO

### 1.1安装

```bash
该实验需要在普通环境上做，恢复init快照，默认是294，要切换至rh134课程
切换方法：
【foundation】
[kiosk@foundation0 ~]$ rht-clearcourse 0
[kiosk@foundation0 ~]$ rht-setcourse rh134
[kiosk@foundation0 ~]$ cat /etc/rht | grep RHT_COURSE   
RHT_COURSE=rh134		#必须保证课程是rh134才可以
[kiosk@foundation0 ~]$ for i in classroom bastion workstation servera;do rht-vmctl start $i;done  #开这4台虚拟机，打开时稍等3分钟左右，让其保证都开启，然后ping一下测试连通性
[kiosk@foundation0 ~]$ for i in classroom bastion workstation servera;do ping -c 4  $i;done  
结果都是以下结果即可，应出现icmp_seq=1 ttl=64 time=1.13 ms字样：
PING bastion.lab.example.com (172.25.250.254) 56(84) bytes of data.
64 bytes from bastion.lab.example.com (172.25.250.254): icmp_seq=1 ttl=64 time=1.13 ms
64 bytes from bastion.lab.example.com (172.25.250.254): icmp_seq=2 ttl=64 time=0.180 ms
64 bytes from bastion.lab.example.com (172.25.250.254): icmp_seq=3 ttl=64 time=0.234 ms
64 bytes from bastion.lab.example.com (172.25.250.254): icmp_seq=4 ttl=64 time=0.265 m

【foundation】
ssh student@workstation
【workstation】
lab advstorage-vdo start   #运行脚本，运行前，保证servera已打开
ssh student@servera
【servera】
[root@servera ~]# sudo -i
[root@servera ~]# yum search vdo
[root@servera ~]# yum install -y vdo.x86_64 kmod-kvdo.x86_64
[root@servera ~]# systemctl enable --now vdo
```

### 1.2 部署vdo

```bash
[root@servera ~]# man vdo   #/EXAMPLE
[root@servera ~]# vdo create --name=vdo1 --device=/dev/vdd --vdoLogicalSize=50G
[root@servera ~]# vdo list
[root@servera ~]# vdo status --name=vdo1
[root@servera ~]# vdo status --name=vdo1 | grep Dedu
[root@servera ~]# vdo status --name=vdo1 | grep Comp
```

### 1.3 格式化及临时挂载测试

```bash
格式化
[root@servera ~]#  mkfs.xfs -K /dev/mapper/vdo1      #-K让命令可以快速返回，效果类似快速格式化 ，如果已有文件系统 可以使用 -f强制执行 

挂载
[root@servera ~]# mkdir /mnt/vdo1
[root@servera ~]# mount /dev/mapper/vdo1 /mnt/vdo1
[root@servera ~]# df -Th
[root@servera ~]# vdostats --human-readable
[root@servera ~]# cp /root/install.img /mnt/vdo1/install.img.1
[root@servera ~]# vdostats --human-readable
[root@servera ~]# vdostats --human-readable
[root@servera ~]# cp /root/install.img /mnt/vdo1/install.img.2
[root@servera ~]# vdostats --human-readable vdostats --human-readable
ls /mnt/vdo1/
lab advstorage-vdo finish
```

### 1.4 开机自动挂载

```bash
开机自动挂载方法：教材推荐
[root@servera ~]# man vdo | grep x-systemd
/dev/mapper/vdo1 /mnt/vdo1 xfs defaults,x-systemd.requires=vdo.service 0 0

mount -a

方法二：
/dev/mapper/vdo1 /mnt/vdo1 xfs defaults,_netdev 0 0
```



# 第九章 访问网络存储

## 1 挂载和卸载NFS共享

| NAS  | NFS  |
| ---- | ---- |
|      | CIFS |

###  1.1 查看NFS共享

```bash
模拟考试环境
[root@clear ~]# showmount -e 172.25.254.254  #后面IP地址是NFS服务器的地址，环境默认已经部署好
Export list for 172.25.254.254:     #来自254的共享
/rhome/remoteuser1 *			    #服务器共享的目录
```

### 2 客户端挂载 mount

```bash
语法：
mount -t nfs  ip/域名:共享目录  本地挂载点
练习：
[root@clear ~]# mkdir /mnt/nfs1   
[root@clear ~]# mount -t nfs 172.25.254.254:/rhome/remoteuser1 /mnt/nfs1  #源设备写服务器的IP地址
 [root@clear ~]#  df -h | tail -1
172.25.254.254:/rhome/remoteuser1   50G  1.9G   49G   4% /mnt/nfs1
```

### 3 开机自动挂载 /etc/fstab

```bash
[root@servera ~]# umount /mnt/nfs1
[root@servera ~]# vim /etc/fstab
172.25.254.254:/rhome/remoteuser1  /mnt/nfs1   nfs     defaults      0   0
[root@servera ~]# mount -a
[root@servera ~]# df -h
[root@servera ~]# reboot  （重启后使用df -h查看挂载状态）模拟考试环境没做selinux题，先别重启，起不来
```

## 3 autofs（考点）

### 3.1 自动挂载 示例：

```bash
1.安装
yum install -y autofs
systemctl enable --now autofs       #开机自启必须

2.主配置文件
vim /etc/auto.master.d/nfs.autofs    #文件名自定义根据业务而定，且.autofs扩展名结尾
/shares   /etc/auto.demo 			 #shares间接自动挂载的基础目录，可随意命名。auto.demo挂载详细信息

3.创建映射文件
vim /etc/auto.demo   #文件名用auto.开头 结尾名称根据业务自定义
work -rw,sync  serverb:/shares/work  #挂载点 选项（文件系统，权限1，权限2...）    源位置（共享目录）。sync立即写入磁盘

4.重启服务
systemctl restart autofs
5.测试
cd /shares/work  #cd就是使用共享
df -h
然后会自动将serverb:/shares/work  挂载到本机的/shares/work
```

练习：

```bash
1. 安装
模拟考试环境自动安装autofs，我们需要开机自启，并启动服务。
2. 主配置文件
[root@clear /]# vim /etc/auto.master.d/nfs.autofs 
/rhome /etc/auto.nfs
3.映射文件
[root@clear /]# cp /etc/auto.misc /etc/auto.nfs
[root@clear /]# vim /etc/auto.nfs
remoteuser1     -rw  172.25.254.254:/rhome/remoteuser1
4.重启服务
[root@clear /]# systemctl restart autofs
5.测试使用
[root@clear /]# cd /rhome/remoteuser1
6.检测挂载
[root@clear /]# df -h
172.25.254.254:/rhome/remoteuser1   50G  1.9G   49G   4% /rhome/remoteuser1
```

### 3.2 autofs 直接映射

```bash
1.主配置文件
[root@clear /]# vim /etc/auto.master.d/nfs.autofs  #nfs.autofs 名称规则和上个实验一样
/- /etc/auto.nfs     #所有直接映射条目使用/-作为基础目录
2.映射文件
[root@clear /]# cp /etc/auto.misc /etc/auto.nfs
[root@clear /]# vim /etc/auto.nfs   #固定文件名
/rhome/remoteuser1 -rw materials.example.com:/rhome/remoteuser1
3.重启服务
[root@clear /]# systemctl restart autofs
4.测试
[root@clear /]# umount /rhome/remoteuser1
[root@clear /]# cd /rhome/remoteuser1
[root@clear remoteuser1]# df -h
Filesystem                         Size  Used Avail Use% Mounted on
172.25.254.254:/rhome/remoteuser1   50G  1.9G   49G   4% /rhome/remoteuser1
```

### 3.2 autofs 间接映射

```bash
1.主配置文件
[root@clear /]# vim /etc/auto.master.d/nfs.autofs 
/rhome /etc/auto.nfs
2.映射文件
[root@clear /]# vim /etc/auto.nfs 
*	-rw	172.25.254.254:/rhome/&   #如果共享导出了多个子目录可以用&代替子目录，而星*号会自动匹配共享的目录
3.重启服务
[root@clear /]# systemctl restart autofs
4.测试
[root@clear /]# df -h  #保证没有挂载状态，如果由umount卸载
[root@clear /]# umount /rhome/remoteuser1
[root@clear /]# cd /rhome/remoteuser1
[root@clear remoteuser1]# df -h
materials.example.com:/rhome/remoteuser1   50G  1.9G   49G   4% /rhome/remoteuser1
```

# 第十章 启动流程

## 一 Linux8启动过程

```bash
1、计算机接通电源。系统固件（现代UEFI或更旧的BIOS）运行开机自检（POST），并开始
初始化部分硬件。
    使用系统BIOS或UEFI配置屏幕（早期按F2可进入设置）
2、系统固件会搜索可启动设备，可能是在UEFI启动固件中配置的，也可能按照BIOS中配置的顺序搜索所有磁盘上的主引导记录（MBR）
   使用系统BIOS或UEFI配置屏幕（早期按F2可进入设置）
3、系统固件会从磁盘读取启动加载器，然后将系统控制权交给启动加载器。红帽企业版Linux8中，启动加载器为GRand Unified Bootloader version2（GRUB2）
   使用grub2-install命令进行配置，它将安装GRUB2作为磁盘上的启动加载器。
4、GRUB2将从/boot/grub2/grub.cfg文件加载配置并显示一个菜单，从中可以选择要启动的内核。
   使用/etc/grub.d/目录、/etc/default/grub文件和grub2-mkconfig命令进行配置，以生成/boot/grub2/grub.cfg文件。
5、选择内核超时到期后，启动加载器从磁盘中加载内核和initramfs，并将他们放入内存中。initramfs是一个存档，其中包含启动时所有必要硬件的内核模块、初始化脚本等等。在redhat8中，initramfs包含自身可用的整个系统。
       使用/etc/dracut.conf.d/目录、dracut命令和lsinitrd命令进行配置，以检查initramfs文件。
6、启动加载器将控制权交给内核，从而传递启动加载器的内核命令行中指定的任何选项，以及initramfs在内存中的位置
7、对于内核可在initramfs中找到驱动程序的所有硬件，内核会初始化这些硬件，然后作为PID1从initramfs执行/sbin/init。在redhat8中/sbin/init是一个指向systemd的链接。
8、initramfs中的systemd进程会执行initrd.target目标的所有单元。这包括将磁盘上的root文件系统挂载于/sysroot目录。
    使用/etc/fstab进行配置
9、内核将root文件系统从initramfs切换回/sysroot中的root文件系统。随后，systemd会使磁盘中安装的systemd副本来重新执行。
10、systemd会查找从内核命令行传递或系统中配置的默认目标，然后启动或停止单元，以符合该目标的配置，从而自动解决单元之间依赖关系。本质上，systemd进程是一组系统应激活以达到所需状态的单元。这些进程通常启动一个基于文本的登录或图形登录屏幕
     可使用/etc/systemd/system/default.target和/etc/systemd/system/进行配置。
```

## 二 重启和关闭

```bash
关机：
systemctl poweroff
init 0
重启：
reboot
systemctl reboot
init 6
```

## 三 选择SYSTEMD TERGET

下表列出了systemd启动达到的systemd单元

| 目标              | 用途                                           |
| ----------------- | ---------------------------------------------- |
| graphical.target  | 多用户、图形、文本登录                         |
| multi-user.target | 多用户、文本登录                               |
| rescue.target     | 救援                                           |
| emergency.target  | 紧急，进入initramfs环境，root只读形式挂载于/上 |

```bash
systemctl list-units --type=target --all
systemctl list-dependencies graphical.target | grep target
```

### 1  在运行时选择target

```bash
切换图形或字符
[root@workstation ~]# systemctl isolate multi-user.target  或   init 3 
[root@workstation ~]# systemctl isolate graphical.target   或   init 5  
[root@workstation ~]# grep AllowIsolate /usr/lib/systemd/system/multi-user.target
AllowIsolate=yes    单元文件中包含AllowIsolate=yes才可以进行切换
```

### 2 设置默认target

```bash
设置默认的启动目标
[root@servera ~]# systemctl get-default 
[root@servera ~]# syetemctl set-default  multi-user.target
[root@servera ~]# ll /etc/systemd/system/default.target
```

### 3 在启动时选择其他目标

```bash
【模拟考试环境】
正常登录172.25.250.10
systemctl disable httpd  #先进入系统，将http修改为开机不启动，因为培训环境selinux的问题，影响系统无法启动
send key--发送ctrl+alt+del
reboot
选择内核的位置按e
linux.....<按键end或者ctrl+e> systemd.unit=emergency.target   或multi-user.target 或graphical.target 
ctrl+x 
如果进入了紧急模式，需要输入root密码
exit 退出
```

## 四 重置root密码（考点）

```bash
修改登录密码
1.reboot（通过软件的Send key 选择ctrl+alt+del进行重启虚拟机）
#通过按上下箭头，光标放置正在使用的内核文件位置
2.e #进入内核启动编辑界面
3.linux.....<end> rd.break console=tty0  #找到Linux开头这一行，可以按end按键，或者ctrl+e都可以将光标移动到本行的最后 rd.break进入单用户模式
4.ctrl+x #看屏幕下面的帮助信息里提到，ctrl+x是执行当前设置的意思
5.mount -o remount,rw /sysroot/   #-o 是设置挂载权限，remount是不卸载的情况下重新挂载，rw是设置读写权限。
6.chroot /sysroot  #chroot是切换目录的意思  /sysroot是实际的根目录
7.echo 123456 | passwd --stdin root  #修改密码
8.touch /.autorelabel   #创建文件达到修改linux标签的作用，该命令需要背下来
9.exit  #第一次exit退出根目录
10.exit   #第二次exit退出虚拟文件系统后，自动重启
#重启后可以输入密码测试是否修改成功，如果不成功，按上面步骤重新执行一遍。
```

## 五  诊断和修复文件系统问题（考点）

```bash
当/etc/fstab中挂载信息写错可能会导致系统起不来，会自动进入紧急模式
下表为常见错误：
```

| 问题                             | 结果                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| 文件系统损坏                     | systemd尝试修复，无法修复进入紧急(emergency)模式             |
| /etc/fstab 引用的设备/UUID不存在 | systemd等待一定时间，等设备变得可用。如不可用，则进入紧急模式 |
| /etc/fstab 挂载点不存在          | 直接进入紧急模式                                             |
| /etc/fstab挂载点错误             | 直接进入紧急模式                                             |
| 文件系统、选项错误（权限）       | 直接进入紧急模式                                             |

```bash
版本建议：编辑/etc/fstab后使用systemd daemon-reload加载。否则systemd可能会继续使用用旧版本。
解决方法：
在该模式中，输入root密码即可进入操作系统，然后修改/etc/fstab中的错误，reboot即可
或者将之前编写的挂载项注释掉，让系统先正常启动，然后再修改调试。
```



#   第十一章 firewalld

## **一 防火墙架构概念**

```bash
1 现代的计算机环境不仅需要流畅的网络连通，更需要具备安全性的网络，所以我们除了及时更新系统补丁以外事件，可以针对自己的计算机环境设置接收哪些数据和不接收哪些数据。我们可以使用软件来实现这一目的，这种软件就叫做防火墙。防火墙这种软件会制定一些规则，我们也叫做策略，管理数据包的通过。
 
2 firewalld优点  iptables
在于可使用zone、service简化配置任务，易于管理。而且属于动态管理（修改规则后不必重启整个防火墙服务）。

3.zone区域
firewalld预先提供了多个区域，不同区域拥有不同设置好的规则，类似不同的管理方案。系统默认区域为public。
所有区域默认在系统中会同时开启但是 如何判断我们的数据包在哪个区域中实现了数据限制，通过以下三种方法来判断：
- source，源地址
- interface，接收请求的网卡（ 一个网卡，只能绑定一个区域。多个网卡，可以绑定同一区域）
- firewalld.conf中配置的默认zone
三个优先级按次序降低。匹配后不再向下匹配。
```

### 1 nftables增强了netfilter

```bash
nftables--->替代--->netfilter
```

### 2 firewalld简介

```bash
rhel7之前---iptables（静态）
rhel7之后---firewalld（动态）
```

### 3 预定义区域

```bash
[root@foundation0 ~]# firewall-cmd --get-zones
block dmz drop external home internal libvirt public trusted work
```

### 4 预定义服务

## 二 配置防火墙

| 管理方法                          | 解释                |
| --------------------------------- | ------------------- |
| /etc/firewalld                    | 直接修改配置文件    |
| Web控制台图形界面                 | 通过cockpit         |
| firewalld-cmd命令行工具（重点考） | shell命令行直接执行 |
| firewall-config                   | 图形                |

### 1 使用Web控制台配置防火墙服务

### 2 从命令行配置防火墙

```
通用指令（会用）
```

| 防火墙命令                         | 说明                                                        |
| ---------------------------------- | ----------------------------------------------------------- |
| --get-default-zone                 | 查看默认区域                                                |
| --set-default-zone=public          | 设置默认区域为public，永久设置                              |
| --get-zones                        | 列出所有可用区域                                            |
| --get-active-zones                 | 列出当前正在使用所有区域                                    |
| --add-source=CIDR [--zone=ZONE]    | 将IP或网络到指定区域，如果未提供--zone=选项，则使用默认区域 |
| --remove-source=CIDR [--zone=ZONE] | 删除IP或网络.....，如果未提供--zone=选项，...则删除默认区域 |
| --add-interface=                   | 在某个区域中添加端口                                        |
| --change-interface=                | 改变端口至某个区域                                          |
| --list-all-zones                   | 列出所有区域状态                                            |

```
必会指令（考点）
```

| 防火墙命令                       | 解释             |
| -------------------------------- | ---------------- |
| --list-all [--zone=ZONE]         | 查看区域所有策略 |
| --add-service=  [--zone=ZONE]    | 允许一个服务     |
| --add-port=  [--zone=ZONE]       | 允许一个端口     |
| --remove-service=  [--zone=ZONE] | 移除一个服务     |
| --remove-port=  [--zone=ZONE]    | 移除一个端口     |
| --permanent                      | 永久生效         |
| --reload                         | 立即加载         |

### 3 练习

```bash
1、管理防火墙服务状态
systemctl status firewalld 
systemctl start firewalld 
systemctl stop firewalld 
systemctl restart firewalld 
systemctl enable --now firewalld 
```

```bash
2、查看与设置默认区域
man firewall-cmd #/Ex
firewall-cmd --get-service
firewall-cmd --get-zones
firewall-cmd --get-default-zone 
firewall-cmd --set-default-zone=home     设置默认区域，了解就可以，不是必须要设置
firewall-cmd --list-all
man 5 firewalld.zones
```

```bash
3.配置防火墙（考）
允许服务
[root@servera ~]# firewall-cmd --list-all  #查看区域所有配置
[root@servera ~]# firewall-cmd --permanent --add-service=http #允许http服务永久生效，要结合reload
[root@servera ~]# firewall-cmd --reload
[root@servera ~]# firewall-cmd --list-all
移除服务
[root@servera ~]# firewall-cmd --permanent --remove-service=http
[root@servera ~]# firewall-cmd --reload
[root@servera ~]# firewall-cmd --list-all
允许端口
[root@servera ~]# firewall-cmd --permanent --add-port=8000/tcp
[root@servera ~]# firewall-cmd --reload
[root@servera ~]# firewall-cmd --list-all
移除端口
[root@servera ~]# firewall-cmd --permanent --remove-port=8000/tcp
[root@servera ~]# firewall-cmd --reload
[root@servera ~]# firewall-cmd --list-all
允许源地址到某个区域（了解）
firewall-cmd --add-source=172.25.250.100 --zone=trusted --permanent
firewall-cmd --reload
  
firewall-cmd --add-interface=enp2s0 --zone=trusted --permanent
firewall-cmd --reload
```

### 4 典型举例

  ```bash
允许apache服务
foundation-----访问-----servera的web服务
思路
1.开启servera的web服务，并关闭防火墙
2.foundation访问servera的web正常
3.servera打开防火墙
4.foundation访问servera的web失败
5.servera允许httpd服务
6.foundation访问servera的web正常

【servera】
systemctl stop firewalld
yum install -y httpd
systemctl enable --now httpd
setenforce 0
curl localhost     访问成功后，证明本地可以正常访问
【foundation】
curl http://servera  发现可以访问
打开浏览器 http://servera  同样可以访问
【servera】
systemctl enable --now firewalld
systemctl status firewalld
【foundation】
curl http://servera  发现不可以访问
打开浏览器 http://servera  同样不可以访问
【servera】
firewall-cmd --permanent --add-service=http    #--permanent 永久生效，必须添加
firewall-cmd --reload  #立即生效
firewall-cmd --list-all
【foundation】
curl http://servera  发现可以访问
打开浏览器 http://servera  同样可以访问
【servera】
firewall-cmd --permanent --remove-service=http  #移除策略时也要添加--permanent
firewall-cmd --reload
firewall-cmd --list-all
firewall-cmd --permanent --add-port=80/tcp
firewall-cmd --reload
firewall-cmd --list-all
【foundation】
curl http://servera  发现可以访问
打开浏览器 http://servera  同样可以访问  

  
练习：允许ftp服务
server端：
yum install -y vsftpd    #安装服务端
systemctl enable --now vsftpd
vim /etc/vsftpd/vsftpd.conf   #进入配置文件 
anonymou_enable=NO  改为YES    #开启匿名访问
systemctl restart vsftpd
yum install -y ftp     #安装ftp可客户端
[root@workstation ~]# ftp localhost     #访问本机ftp服务器
Trying ::1...
Connected to localhost (::1).
220 (vsFTPd 3.0.3)
Name (localhost:root): ftp          #ftp表示匿名用户登录
331 Please specify the password.
Password: 直接回车

client端：
yum install -y ftp
ftp localhost   发现不能登录，需要在server端允许ftp服务。
  ```

##  二  SElinux安全端口（考点）

```bash
【servera】
[root@servera ~]# setenforce 1
[root@servera ~]# vim /etc/httpd/conf/httpd.conf 
Listen 80 改成了Listen 82
[root@servera ~]# systemctl restart httpd   重启不了，因为selinux
```

```bash
[root@servera ~]# man semanage port    #/EX
[root@servera ~]# semanage port -a -t http_port_t -p tcp 82  #数据库没有标签内容则-a，有则-m
[root@servera ~]# semanage port -l | grep http
重启web服务
[root@servera ~]# systemctl restart httpd
[root@servera ~]# systemctl enable --now httpd
```

```bash
[root@servera ~]# firewall-cmd --permanent --add-port=82/tcp   #本地访问无须配置，远端主机访问需要配置
[root@servera ~]# firewall-cmd --reload
[root@servera ~]# firewall-cmd --list-all

测试
[serverb curl http://servea:82] 
```

  ```bash
富规则参考
[root@servera ~]# man 5 firewalld.richlanguage
  ```

# 第 十二 章 kickstart

**提示: 在workstation(172.25.250.9)上面做服务器端，servera做客户端**

| 安装方式  | 简介                           |
| --------- | ------------------------------ |
| DVD 光盘  | 物理系统光盘                   |
| ISO镜像   | 光盘制作成为的镜像.iso文件     |
| QCOW2镜像 | 云环境或虚拟环境中部署为虚拟机 |

## 一 手动安装系统

## 二 使用KICKSTART自动安装

一 dhcp设置

```bash
【root@workstation】
[root@workstation ~]# systemctl stop firewalld;setenforce 0

一、dhcp
1、安装
[root@workstation ~]# yum install -y dhcp-server
2、建立配置文件
[root@workstation ~]# cp /usr/share/doc/dhcp-server/dhcpd.conf.example /etc/dhcp/dhcpd.conf
cp: overwrite '/etc/dhcp/dhcpd.conf'? y
[root@workstation ~]# vim /etc/dhcp/dhcpd.conf   #man 5 dhcpd.conf   /next-server
3、配置服务
[root@workstation ~]# vim /etc/dhcp/dhcpd.conf
allow bootp;
allow booting;
subnet 172.25.250.0 netmask 255.255.255.0 {
  range 172.25.250.100 172.25.250.200;
  option routers 172.25.250.254;
  default-lease-time 600;
  max-lease-time 7200;
  filename "/pxelinux.0";
  next-server 172.25.250.9;
}
4、启动并测试
[root@workstation ~]# systemctl enable --now dhcpd
测试dhcp功能
设置servera开机启动为网卡启动，当做客户端，测试能够获取ip即可
```

二、tftp and syslinux

```bash
1、安装tftp服务
[root@workstation ~]# yum install -y tftp-server tftp
[root@workstation ~]# rpm -ql tftp-server

2、安装syslinux-tftpboot该软件后提供了/tftpboot目录其中包含了一些引导文件、内核文件及pxelinux.0文件等，建立pxelinux.cfg目录，准备存放default文件。
[root@workstation ~]# yum install -y syslinux-tftpboot.noarch
[root@workstation ~]# rpm -ql syslinux-tftpboot
[root@workstation ~]# cd /tftpboot/
[root@workstation ~]# mkdir /tftpboot/pxelinux.cfg/

3、将254.250上的光盘镜像相关文件挂载至本机
[root@workstation ~]# mkdir /content
[root@workstation ~]# mount 172.25.254.250:/content /content/
[root@workstation ~]# df -h
[root@workstation ~]# cd /content/rhel8.0/x86_64/dvd/
[root@workstation ~]# cp images/pxeboot/{initrd.img,vmlinuz} /tftpboot/
[root@workstation ~]# cp isolinux/boot.msg /tftpboot/
[root@workstation ~]# cp isolinux/isolinux.cfg /tftpboot/pxelinux.cfg/default
[root@workstation ~]# vim /tftpboot/pxelinux.cfg/default 
default vesamenu.c32 
timeout 600  可以改为60，就是6秒
display boot.msg

label linux
  menu label ^Install Red Hat Enterprise Linux 8.0.0
  menu default
  kernel vmlinuz
  append initrd=initrd.img inst.stage2=ftp://172.25.250.9/dvd inst.ks=ftp://172.25.250.9/ks.cfg quiet

4、修改tftp发布目录，并启动服务及测试
[root@workstation ~]# vim /usr/lib/systemd/system/tftp.service 
[Service]
ExecStart=/usr/sbin/in.tftpd -s /tftpboot  (将-s /var/lib/tftpboot，更成-s /tftpboot)

[root@workstation ~]# systemctl enable --now tftp
测试：
登录servera，yum install -y tftp ,tftp 172.25.250.9,get ls.c32 quit
```

三、ftp


```bash
1、安装
[root@workstation ~]# yum install -y vsftpd.x86_64 ftp
[root@workstation ~]# rpm -qc vsftpd

2、配置服务
[root@workstation ~]# vim /etc/vsftpd/vsftpd.conf 
anonymous_enable=YES
anon_root=/var/ftp
[root@workstation ~]# mkdir /var/ftp/dvd
[root@workstation ~]# mount /content/rhel8.0/x86_64/isos/rhel-8.0-x86_64-dvd.iso /var/ftp/dvd/

3、启动及测试
df -h
[root@workstation ~]# systemctl enable --now vsftpd

【servera】cleint
以网卡方式启动--安装1、指定ftp路径172.25.250.9/dvd 2 最小化 3 设置lvm分区
进度条走完-重启，添加硬盘启动 ， 从本地硬盘启动。
```

四 、创建ks文件。并至少给予只读权限

```bash
[root@workstation opt]# cp ~/anaconda-ks.cfg /var/ftp/ks.cfg   #不建议直接用，建议用网站生成的文件，或者调试后的文件。如果没有anaconda-ks.cfg文件可以直接vim /var/ftp/ks.cfg
[root@workstation opt]# chmod o+r /var/ftp/ks.cfg
[root@workstation opt]# ll /var/ftp/ks.cfg 
-rw----r--. 1 root root 775 Feb 11 09:19 /var/ftp/ks.cfg
[root@workstation opt]# vim /var/ftp/ks.cfg
#version=RHEL8
ignoredisk --only-use=vda
bootloader --append="console=ttyS0 console=ttyS0,115200n8 no_timer_check net.ifnames=0  crashkernel=auto" --location=mbr --timeout=1 --boot-drive=vda
zerombr
clearpart --all --initlabel
reboot
text
url --url="ftp://172.25.250.9/dvd"
keyboard --vckeymap=us --xlayouts=''
lang en_US.UTF-8
network  --bootproto=dhcp --device=link --activate
rootpw --iscrypted nope
auth --enableshadow --passalgo=sha512
selinux --enforcing
firstboot --disable
services --disabled="kdump,rhsmcertd" --enabled="sshd,NetworkManager,chronyd"
timezone America/New_York --isUtc
part / --fstype="xfs" --ondisk=vda --size=8000

%post --erroronfail
echo redhat | passwd --stdin root
useradd tom
%end

%packages
@core
@base
NetworkManager
dnf-utils
-plymouth
%end


[root@workstation dvd]# systemctl restart vsftpd
```



## 三 使用cockpit安装虚拟机

```
[root@servera ~]# yum install -y cockpit-machines
```

```
以服务的形式启动http，一旦启动就会长期运行，在内存中产生相应的进程systemct start httpd

容器以进程的方式运行http，一旦运行完毕容器就会自动关闭，自动退出，结束运行。当再想运行http的时候需要新开启一个容器

rhel8查看一个文件，
容器

容器：1个应用  -- 好管理    apache   php   mysql +linux= lamp -- 支持php网站
容器：多个应用 -- 不好管理   （apache   php   mysql）
```



# [13. Running Containers](http://foundation0.ilt.example.com/slides/RH134-RHEL8.2-en-1-20200928/#/105)

![podman](https://gitee.com/suzhen99/redhat/raw/master/images/podman.svg)

**总目标：在一个 RHEL 服务器上获取、运行和管理作为容器的简单轻量级服务**

**目标：**

- 解释容器是什么，及如何管理和部署具有软件库和依赖的应用程序
- 安装容器管理工具，并运行一个简单的无根容器
- 查找、检索、检查和管理容器映像，从远程容器仓库获得并存储在服务器中
- 使用选项来运行容器，列出在系统上运行的容器，启动、停止和强制关闭容器
- 通过在运行的容器中挂载目录，以使用容器永久存储
- 以 systemd 服务的方式启动、停止和检查容器



**章节：**

1. [容器介绍](#13.1)

2. [运行一个基本的容器](#13.2)

3. [查找并管理容器映像](#13.3)

4. [实施高级的容器管理](13.4)

5. [为容器附加永久存储](13.5)

6. [以服务方式管理容器](13.6)

7. [实验](#13.l)

8. [总结](#13.s)

   

#### <a name="13.1">第一节：容器介绍</a>

**目标：**

- 解释容器是什么，及如何管理和部署具有软件库和依赖的应用程序

**1.1 容器技术介绍：**

- 应用程序通常依赖于 runtime environment 提供的库、配置文件或服务。`传统上，应用程序的 runtime environment 安装在运行在物理主机或虚拟机上的操作系统中。应用程序依赖项与该操作系统一起安装在主机上`
- 在 RHEL 中，使用 RPM 帮助管理应用程序依赖关系。当安装httpd 包时，RPM 系统会确保安装了正确的库和依赖项
- 应用程序可能需要比操作系统安装的更老或更新的软件版本。或在同一系统上的两个应用程序可能需要同一软件的不同版本，而版本彼此不兼容

- 解决这些冲突的一种方法是将应用程序打包并部署为容器

- 容器是与系统的其他部分隔离的一个或多个进程的集合。容器的内容与其他容器的内容是隔离的，不会相互影响

- 容器是打包应用程序以简化部署和管理的一种方法

**1.2 容器和虚拟化的对比：**

- 容器提供了许多与虚拟机相同的优点，例如安全性、存储和网络隔离

- 这两种技术都将它们的应用程序库和 runtime 资源与主机操作系统或管理程序隔离开来
  ![VirtualMachines-Containers](https://gitee.com/suzhen99/redhat/raw/master/images/VirtualMachines-Containers.png)

  <br>![Virtualization-Containers](https://gitee.com/suzhen99/redhat/raw/master/images/Virtualization-Containers.png)

- 容器和虚拟机与`硬件和底层操作系统交互方式`不同

- **虚拟化：**

  - 可以在单一硬件平台运行多操作系统
  - 使用 hypervisor 将硬件拆分成多个虚拟硬件，允许多个操作系统并行运行
  - 需要完整的操作系统来支持应用运行

- **容器：**

  - 在操作系统上`直接运行，容器之间分享硬件和操作系统资源`，容器中应用`轻量化和快速`并行运行
  - `共享`操作系统`内核`，将容器化的应用程序进程与系统的其余部分`隔离`，并使用与该内核兼容的任何软件
  - 比虚拟化要求`更少的硬件资源`，可以`快速启动和停止`，减少存储需求

**1.3 探索容器的实现：**

- RHEL 实现容器使用核心技术：
  - 用于资源管理的 Control Groups (cgroups)
  - 用于进程隔离的 Namespaces
  - SELinux 和 Seccomp（Secure Computing mode）加强安全边界

**1.4 计划使用容器：**

- 容器可移植性好。可以容易的从一个环境转移到另一个环境，比如从开发环境转移到生产环境

- 可以保存容器的多个版本，根据需要快速访问每个版本
- 容器通常是`临时（ephemeral）`的。可将运行中的容器生成的数据永久保存在`持久存储（persistent storage）`中
- 容器通常在需要时运行，不需要时停止并删除。下一次需要时，将启动一个新的容器进程
  ![container-storage](https://gitee.com/suzhen99/redhat/raw/master/images/container-storage.png)

**1.5 从容器映像（Container Image）运行容器：**

- 容器从容器映像（container image）运行。容器映像是创建容器的蓝图

- 容器映像打包一个应用程序连同它所有的依赖：
  - 系统库函数
  - 编程语言运行时
  - 编程语言库函数
  - 配置
  - 静态数据文件

- image `不可更改`

- image 根据`规范（OCI）`构建，例如 Open Container Initiative(OCI) image 格式规范。这些规范定义了 image 的格式及元数据

**1.6 设计基于容器的结构：**

- 可在单个容器中安装由多个服务组成的复杂软件应用程序。例如，可能有一个需要使用数据库和消息队列的 web 服务器。但是将一个容器用于多个服务是很难管理的

- 更好的设计是在`单独的容器`中运行每个组件、web服务器、数据库和消息队列。对单个应用程序组件的更新和维护不会影响其他组件或应用程序堆栈

**1.7 用 Podman 管理容器：**

![Podman](https://gitee.com/suzhen99/redhat/raw/master/images/2074831-20201129203558088-125133373.png)

> 1、Podman 直接与镜像注册表、容器和镜像存储进行交互
>
> 2、Podman 中没有使用守护进程，而是直接使用 runC 容器运行时
>
> 3、适用于 Docker 的命令在 Podman 中也是同样可用的
>
> 4、Podman 和 Docker 的镜像具有兼容性

- RHEL 提供了一套容器工具，可以实现：
  - podman：它直接管理容器和容器 image
  - skopeo：可以使用它检查、复制、删除和签名 image
  - buildah：可以使用它创建新的容器 image

- 这些工具与开放容器倡议（OCI）是`兼容`的。它们可以用于管理任何由`兼容 oci `的容器引擎（如Docker）创建的 Linux 容器

- 这些工具专门为在 RHEL 下的`单节点容器主机`上运行容器而设计

- 在本章中，将学习 `podman 和 skopeo 命令`来运行和管理容器和image

- 注：buildah 内容可以参考 [Introduction to Containers, Kubernetes, and OpenShift (DO180)](https://www.redhat.com/zh/services/training/do180-introduction-containers-kubernetes-red-hat-openshift)

**1.8 运行无根的容器：**

- 在容器主机上，用户能以根用户或普通用户运行容器。`非特权用户运行的容器称为无根容器`

- 无根容器`更安全`，但有一些限制。例如，无根容器不能通过容器主机的特权端口（1024以下的端口）发布网络服务

- 可以直接作为根用户运行容器，但这在一定程度上削弱了系统的安全性

**1.9 管理大量容器：**

- 越来越多的新应用程序使用容器实现，并彼此依赖。管理越来越多的容器很快就会成为一项难以应付的任务

- 在生产中大规模部署容器需要适应以下挑战：
  - 平台必须为客户提供容器的`可用性`
  - 环境必须能增加或减少运行的容器，并负载平衡流量来响应应用程序负载变化
  - 平台应该检测到容器或主机的故障并做出相应的反应
  - 开发人员需要一个自动化的工作流程，以透明和安全地向客户交付新的应用程序版本
- `Kubernetes` 是一种编排服务，可以更容易地跨容器主机部署、管理和伸缩基于容器的应用程序。它在启动新容器时管理 DNS 更新。它使用负载均衡将流量重定向到容器，还允许管理员手动或自动地伸缩提供服务的容器数量。它还支持用户定义的运行状况检查，以监视容器，并在容器失败时重新启动它们

- Red Hat 提供名为 `Red Hat OpenShift` 的 Kubernetes 发行版。OpenShift 是一组构建在 Kubernetes 基础设施之上的模块化组件和服务。它添加了一些额外的特性，例如基于 web 的远程管理、多租户、监视和审计、应用程序生命周期管理以及为开发人员提供的自助服务实例等等

- 注：Red Hat OpenShift 超出了本课程的范围，可以在 https://www.openshift.com了解更多有关它的信息

#### <a name="13.2">第二节：运行一个基本的容器</a>

**目标：**

- 安装容器管理工具，并运行一个简单的无根容器

**2.1 安装容器管理工具：**

|  ID  |    HOST     |         COMMENT          |
| :--: | :---------: | :----------------------: |
|  1   |  classroom  |         yum repo         |
|  2   |   bastion   |          router          |
|  3   |   utility   |  container-server: Quay  |
|  4   | **servera** | container-client: podman |

**[kiosk@foundation]**

```bash
$ rht-clearcourse 0
$ rht-setcourse rh134
  
$ for i in classroom bastion utility servera;do rht-vmctl start $i;done
#建议大家拍个快照
```

- 要在系统上运行和管理容器，使用 yum 安装 `container-tools` 模块（module）

  **[student@servera]**

  ```bash
  $ yum module list container*
  ```

  ```bash
  $ sudo yum module -y install container-tools
  ```

- 容器工具模块包括安装多个工具的软件包。本章使用是 `podman 和 skopeo`

**2.2 选择容器 image 和 registry：**

- 容器 registry 是用于存储和检索容器 image 的存储库。开发人员将 image 上传或推送到 registry。用户可以从 registry 下载或拉取这些容器 image 到本地系统，以便运行容器
- 可以使用包含第三方 image 的 `public registry`，也可以使自建的 `private registry`。容器 image 的来源很重要，是否可以信任 images 中的代码。不同的 registry 对于是否以及如何提供、评估和测试提交给它们的 images 有不同的策略
- https://catalog.redhat.com/software/containers/explore
  - Red Hat 通过两个主要的 registry 分发经过认证的 images ，用户可以使用 Red Hat 账户访问这些 registry：
    - [registry.redhat.io](https://registry.redhat.io) 基于红帽官方产品的 images
    - [registry.connect.redhat.com](https://registry.connect.redhat.com) 用于基于第三方产品的 images
  - 红帽正在逐步淘汰一个较老的registry：[registry.access.redhat.com](https://registry.access.redhat.com)
- 红帽容器目录（https://access.redhat.com/containers）提供了一个基于 web 的界面，可以索这些 registry 以获得认证的 images
- **注：**本课程运行一个基于 [Red Hat Quay](https://www.redhat.com/zh/technologies/cloud-computing/quay) 的私有 registry，以提供容器 images  

**2.3 容器 image 的命名格式：**

- **registry_name/user_name/image_name:tag**
  - registry_name：是存储 image 的 registry 名称，一般是 registry 的域名
  - user_name：是 image 所属的用户或组织
  - image_name：必须在用户 userspace 中唯一
  - tag：用于区分 image 版本，如果 image 名称中不含有 tag，将默认使用 latest tag

**2.4 运行容器：**

- 要在本地系统上运行容器，必须首先`下载（pull）`容器 image。使用 Podman 从 registry 中下载 images

- 在 pull images 时，应始终使用完整的 image 名称。`podman pull` 命令从 registry 中提取指定的 image 并保存到本地：

  **[kiosk@foundation]**

  >  firefox https://registry.lab.example.com

  **[student@servera]**

  ```bash
  $ podman login --help
  $ podman login -u admin -p redhat321 \
  --tls-verify=false registry.lab.example.com
  
  $ podman search \
  --tls-verify=false registry.lab.example.com/
  参数说明：（man podman search）
  NAME: 镜像仓库源的名称
  DESCRIPTION: 镜像的描述
  OFFICIAL: 是否 docker 官方发布
  stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。
  AUTOMATED: 自动构建。（Dockerfile是构建Docker应用镜像的脚本代码）
  ```

  ```bash
  $ podman pull \
  --tls-verify=false registry.lab.example.com/ubi8/ubi
  ```

  ```bash
  $ podman pull \
  --tls-verify=false registry.lab.example.com/ubi7/ubi
  ```

- 下载后，Podman 在本地存储 image，可以使用 `podman images` 命令列出：

  ```bash
  $ podman images
  REPOSITORY                          TAG      IMAGE ID       CREATED        SIZE
  registry.lab.example.com/ubi7/ubi   latest   87dd8ec61bbc   5 months ago   215 MB
  （ImageID:唯一标志一个镜像，其数值根据该镜像的元数据配置文件采用sha256算法的计算获得。）
  ```

  - 显示 image tag 是 `latest`，image id 是 `87dd8ec61bbc`

- 要从这个 image 运行一个容器，使用 `podman run` 命令，将从容器 image 创建并启动一个新的容器。如果需要，使用 `-it` 选项与容器交互。it 选项将终端分配给容器，并允许向其发送键盘指令

  ```bash
  $ podman run -it \
  registry.lab.example.com/ubi8/ubi:latest
  [root@99901bb00fc1 /]# <Ctrl-D>
  ```

  ```bash
  $ podman ps --all
  $ podman ps
  ```

- 如果运行一个容器使用完整 image name，但 image 还没有本地存储，则 podman run命令将先从 registry 中下载 image，再运行

- 注：-t = -tty ；-i = --interactive ；-d = --detach（background running）

- 当访问一个容器时，Podman 可使用容器 name 或生成的 ID。当使用 podman run 运行容器时，使用 `--name` 选项设置容器名，`容器名称必须是唯一的`。如果 podman run 命令不包含容器名称，那么podman将生成一个`随机名称`

  ```bash
  $ podman run -it --name=rhel8 registry.lab.example.com/ubi8/ubi  （可以添加-d将容器在后台运行，使用podman ps -a查看，podman rm 容器名称/ID -f 强制删除）
  [root@acd94b972f65 /]# exit
  ```

  ```bash
  $ podman ps --all
  $ podman ps
  ```

- `podman run --rm` 可以在不与容器交互的情况下在容器中运行快速命令，然后在命令完成后删除容器

  ```bash
  $ podman run --rm registry.lab.example.com/ubi8/ubi \
  cat /etc/os-release
  ```

  ```bash
  $ podman ps --all
  $ podman ps
  ```

**2.5 分析容器的隔离：**

- 容器提供了资源的 runtime 隔离。容器利用 Linux namespace 为资源（如进程、网络通信和卷）提供独立的、隔离的环境

- 在容器中运行的进程与主机上的所有其他进程是隔离的

- 查看容器内运行的进程：

  ```bash
  $ podman run -it registry.lab.example.com/ubi7/ubi /bin/bash
  [root@10855645141e /]# ps aux
  USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
  root           1  2.4  0.1  11840  2764 pts/0    Ss   20:30   0:00 /bin/bash
  root          14  0.0  0.1  51768  3212 pts/0    R+   20:31   0:00 ps aux
  ```

- 注意，容器内的用户名和 ID 与主机上的用户名和 ID 不同：

  ```bash
  [root@10855645141e /]# id
  uid=0(root) gid=0(root) groups=0(root)
  [root@10855645141e /]# exit
  $ id
  uid=1000(student) gid=1000(student) groups=1000(student),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
  ```

#### <a name="13.3">第三节：查找并管理容器映像</a>

**目标：**

- 查找、检索、检查和管理容器映像，从远程容器仓库下载并存储在服务器中

**3.1 配置容器 registries**

```bash
让servera联网方法：
1、found宿主机上ens192选择nat模式并获取IP，保证可以上网
2、在found宿主机上执行ssh root@172.25.254.254 rht-config-nat
3、servera上ping www.baidu.com测试
```



- podman 在主机上使用 registry.conf 来配置容器 registry 信息

  ```bash
  $ grep -A 1 ^\\[regis.*search /etc/containers/registries.conf
  [registries.search]
  registries = ['registry.access.redhat.com', 'registry.redhat.io', 'docker.io']
  
  ```

- podman 可以访问的 registry 列表在 `[registry.search] `中配置。如果没有在命令行中指定 image 完整域名，那么 podman 将按照顺序搜索此段内容，帮助补全域名路径

  - 方法一

  ```bash
  $ sudo vim /etc/containers/registries.conf
  ```

  ```toml
  # The initial configuration format
  #[registries.search]
  #registries = ['registry.lab.example.com']
  #[registries.insecure]
  #registries = ['registry.lab.example.com']
  #[registries.block]
  #registries = []
  ...
  :%s/^re/#re/g
  :%s/^\[re/#re/g
  
  # The second version of the configuration format
  unqualified-search-registries = ["registry.lab.example.com"]
  [[registry]]
  insecure = true
  blocked = false
  location = "registry.lab.example.com"
  ...
  ```

  - 方法二

  ```bash
  # wget -P /etc/yum.repos.d/ http://materials/updates.repo
  # yum update -y
  # mkdir -p .config/containers
  # wget http://materials/registries.conf -P .config/containers
  ```

  

- `podman info` 命令显示 Podman 的配置信息：

  ```bash
  $ podman info | grep -A 5 ^registries
  registries:
    blocked: null
    insecure:
    - registry.lab.example.com
    search:
    - registry.lab.example.com
  ```

**3.2 registry 安全：**

- 不安全的 registry 列在 registries.conf 的 [registry.inscure]中。到该 registry 的连接不受 TLS 加密保护

- 如果一个 registry 既可搜索又不安全，那么它可以在[registries.search] 和 [registries.insecure] 中同时写入

- registries 也可以配置为需要身份验证。使用 `podman login` 登录

  ```bash
  $ podman logout registry.lab.example.com
  $ podman login --get-login registry.lab.example.com #(了解)
  ```

**3.3 搜索容器 image：**

- `podman search` 命令搜索特定容器 image 的 registry：

  ```bash
  $ podman search ubi
  ```

  ```bash
  $ podman search registry.lab.example.com/
  ERRO[0000] error searching registry "registry.lab.example.com": couldn\'t search registry "registry.lab.example.com": unable to retrieve auth token: invalid username/password: unauthorized: access to the requested resource is not authorized
  
  $ podman login -u admin -p redhat321 registry.lab.example.com
  Login Succeeded!
  ```

  ```bash
  $ podman search registry.lab.example.com/
  INDEX         NAME              DESCRIPTION   STARS   OFFICIAL   AUTOMATED
  example.com   registry.lab.example.com/rhel8/mariadb-103                 0
  example.com   registry.lab.example.com/rhel8/httpd-24                    0   
  example.com   registry.lab.example.com/library/nginx                     0
  example.com   registry.lab.example.com/ubi7/ubi                          0
  example.com   registry.lab.example.com/ubi8/ubi                          0
  ```

- 添加 `--no-trunc` 选项，可以查看更多的 image 描述：
  **[kiosk@foundation]**

  > VMware `连接网络适配器 2`

  ```bash
  第二种联网方法：
  $ nmcli con up ens192
  $ ping -c 4 www.redhat.com
  $ su -
  Asimov
  # scp root@servera:/etc/yum.repos.d/*.repo /etc/yum.repos.d
  # sed -i -e '/nameserver.*172/d' -e '/nameserver/inameserver 172.25.254.250' /etc/resolv.conf
  i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)
  d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚
  -e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。
  #yum module -y install container-tools
  #<Ctrl-D>
  ```
  
  **[kiosk@foundation]**

```bash
  $ podman login -u `红帽帐号` registry.redhat.io
  Password: `红帽密码`
```

  ```bash
  $ podman search registry.redhat.io/rhel8
  INDEX       NAME                                                DESCRIPTION                                       STARS   OFFICIAL   AUTOMATED
redhat.io   registry.redhat.io/openjdk/openjdk-8-rhel8          OpenJDK 1.8 Image for Java Applications base...   0
  ...
  ```

  ```bash
  $ podman search --no-trunc registry.redhat.io/rhel8
  INDEX       NAME                                                DESCRIPTION                                       STARS   OFFICIAL   AUTOMATED
redhat.io   registry.redhat.io/openjdk/openjdk-8-rhel8         OpenJDK 1.8 Image for Java Applications based on UBI8   0
  ...
  ```

- 下表为一些其他 podman search 命令选项：

  | Option                         | Description                                                  |
  | ------------------------------ | ------------------------------------------------------------ |
  | **--limit \<number>**          | Limits the number of listed images per registry              |
  | **--filter <filter=value>**    | Filters output based on conditions provided. Supported filters include:<br>- **stars=\<number>**: Show only images with at least this number of stars<br>- **is-automated=<true\|false>**: Show only images automatically built<br>- **is-official=<true\|false>**: Show only images flagged as official |
  | **--tls-verify <true\|false>** | Enable or disables HTTPS certificate validation for all used registries. Default=**true** |

```bash
限制搜索输出个数（了解）
docker search redis --limit 5
过滤--filter的使用
stars  收藏星数

docker search --filter stars=3 busybox
IS-AUTOMATED  是否自动构建 

docker search --filter is-automated=true busybox
IS-OFFICIAL  是否官方镜像

docker search --filter is-official=true --filter stars=3 busybox
```

**3.4 使用红帽容器目录（Red Hat Container Catalog）：**

- 红帽维护包含`经过认证的`容器映像的 registry：
  https://access.redhat.com/containers

- 使用这个 registry 可以防范可能由未经测试的映像造成的`已知`漏洞

**3.5 查看容器的 images：**

- 可在将 image 下载到系统之前查看 image 信息。skopeo inspect 命令可以检查 registry 中的远程容器 image 并显示有关它的信息

  ```bash
  $ skopeo inspect docker://registry.redhat.io/rhel8/python-36
  {
      "Name": "registry.redhat.io/rhel8/python-36",
      "Digest": "sha256:ffe84f452974d21370c22008c872730171b0d3f11f89f00aba5c42409d26c6a7",
      "RepoTags": [
      ...
  ```

- 还可使用 podman inspect 检索本地保存的 image 信息，会比 `skopeo inspect` 提供更多信息

  ```bash
  $ podman inspect registry.lab.example.com/ubi7/ubi
  ```

**3.6 删除本地容器图像：**

- 容器映像是只读的。容器的更新意味着 image 的更新

- 当更新后的 image 可用时，发布者更改 latest tag 以将其与新 image 关联。管理员可以删除较旧的 image，pull 最新的 image，并且只使用最新的 image 来运行容器

- 由红帽提供的 image 受益于红帽在管理 RHEL 和其他产品的安全漏洞和缺陷方面的长期经验。红帽安全团队加固这些 images。当发现新的漏洞时，它们将被重新构建，并通过质保流程

- `podman rmi` 移除本地存储的 image

  ```bash
  $ podman images
  
  $ podman ps --all
  $ podman rm d8e3578d277f
  ```

  ```bash
  $ podman rmi registry.lab.example.com/ubi7/ubi
  Untagged: registry.lab.example.com/ubi7/ubi:latest
  Deleted: 87dd8ec61bbc977ed1b2bd29ba089489a8a0281e2e0f62bf43c3fb9c20414194
  ```

  ```bash
  $ podman images
  ```

#### <a name="13.4">第四节：实施高级的容器管理</a>

**目标：**

- 使用选项来运行容器，列出在系统上运行的容器，启动、停止和强制关闭容器

**4.1 用 Podman 管理容器：**

- 可以使用 Podman 运行容器，并管理正在运行或已停止的容器。在本节中，将学习如何使用 Podman 管理容器的整个生命周期
  ![Podman](https://gitee.com/suzhen99/redhat/raw/master/images/Podman.jpg)

  ```bash
  $ podman ps --all
  ```

  ```bash
  $ podman start ce079e808857
  ```

  ```bash
  $ podman ps
  ```

  ```bash
  $ podman stop ce079e808857
  ```

  ```bash
  $ podman ps --all
  ```

**4.2 配置容器：**

- `podman run` 命令从容器 image 启动容器。当运行一个容器时，它将在容器内启动一个进程，可以是一个应用程序，比如web 或数据库服务器
- 要访问容器的网络，`客户端必须连接到容器主机上的端口`，这些端口将网络流量传递到容器中的端口
- 可以向容器传递一些`环境变量`，而不需要修改容器 image

**4.3 将主机端口映射到容器：**

- 当`将容器主机上的网络端口映射到容器中的端口`时，容器将收发到主机端口的网络流量

- 例如，可以将容器主机上的端口 8000 映射到容器上的端口 8080

- podman run -p hostport:containerport 可以映射主机端口到容器

  ```bash
  $ podman run -d -p 8000:8080 registry.lab.example.com/rhel8/httpd-24
  40e4b0d0dce24a853fb7b67e7eb96ee7d8d968925ec04c00e9a9e6532b0c2c9f
  ```

  ```bash
  $ podman ps
  ```

- 可使用 `podman port containerID|name` 来列出端口映射，或使用 `-a` 选项列出所有正在使用的端口映射

  ```bash
  $ podman port -a
  40e4b0d0dce2	8080/tcp -> 0.0.0.0:8000
  -l 查看最后一次出现的
  ```

- 必须确保主机上的`防火墙允许外部客户端连接到它的映射端口`。上例中，可能要在主机上的防火墙规则中添加端口 8000/tcp：

  ```bash
  $ sudo firewall-cmd --permanent --add-port=8000/tcp
  $ sudo firewall-cmd --reload
  ```

**4.4 传递环境变量以配置容器：**

- 可以将环境变量传递给容器，环境变量的值用以配置其应用程序

- `podman inspect` 命令可详细显示容器 image 信息

  ```bash
  $ podman inspect registry.lab.example.com/rhel8/mariadb-103 | egrep '"url|"usage'
                  "url": "https://access.redhat.com/containers/#/registry.access.redhat.com/rhel8/mariadb-103/images/1-102",
                  "usage": "podman run -d -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -p 3306:3306 rhel8/mariadb-103",
  ...
  ```

> - **url** 标签指向 [Red Hat Container Catalog](https://access.redhat.com/containers/#/registry.access.redhat.com/rhel8/mariadb-103/images/1-102) 中的一个 web 页面，该页面记录了环境变量和关于如何使用容器 image 的信息
> - **usage** 标签是运行 image 的典型 podman 命令用例
> - 该 image 的 url 标签文档中提供的页面显示容器使用端口 3306，并可以使用以下环境变量来配置数据库服务：
>   - `MYSQL_USER`：MySQL 帐户的用户名
>   - `MYSQL_PASSWORD`：用户帐户的密码
>   - `MYSQL_DATABASE`：数据库名称
>   - `MYSQL_ROOT_PASSWORD`：root 用户的密码（可选）

- `podman run -e` 可以将环境变量传递到容器中

  ```bash
  $ podman run -d --name mydb \
  -e MYSQL_USER=tom \
  -e MYSQL_PASSWORD=mima \
  -e MYSQL_DATABASE=mydb \
  -e MYSQL_ROOT_PASSWORD=redhat \
  -p 3306:3306 registry.lab.example.com/rhel8/mariadb-103
  ```

  > `--name` 选项可为容器分配名称，如果没有设置，podman 将分配一个`随机名称`

**4.5 管理容器：**

- 启动容器只是容器生命周期的第一步。生命周期还包括停止、重启或删除容器。用户还可以检查容器状态和元数据，以便进行调试

- `podman ps` 可以列出运行中的容器

  ```bash
  $ podman ps
  ```

  > 1. 容器 id，16进制，随机生成
  >
  > 2. 容器 image
  >
  > 3. 容器启动时执行的命令
  >
  > 4. 容器创建的时间
  >
  > 5. 容器运行时间
  >
  > 6. 容器暴露的端口或端口映射的信息
  >
  > 7. 容器名称

- `podman ps -a` 命令列出所有容器，包括停止的。podman 并不会删除停止的容器，将保留容器在本地的文件和状态

  ```bash
  $ podman ps -a
  ```

- `podman stop` 命令停止容器运行

  ```bash
  $ podman stop my-httpd-container
  ```

- `podman rm` 在主机上删除容器（需要先停止运行容器）

- `podman rm -f` 可删除正在运行的容器

- `podman rm -a` 删除主机中所有停止运行的容器

  ```bash
  $ podman rm my-database
  ```

- `podman restart` 重新启动一个停止的容器。该命令将创建一个与已停止容器具有相同 ID的新容器，并重用其状态和文件系统

  ```bash
  $ podman restart my-httpd-container
  ```

- `podman kill` 命令发出 Unix SIGKILL 信号，终止容器运行

  ```bash
  $ sudo podman kill my-httpd-container
  ```

**4.6 在容器中运行命令：**

- 容器启动时执行 image 的 entry point 命令。但是，可能需要执行其他命令来管理运行中的容器

- `podman exec` 命令在一个已经运行的容器中启动一个额外的进程：

  ```bash
  #podman run -di --name rhel7 registry.lab.example.com/ubi7/ubi 自己创建一个红帽7系统容器
  $ podman exec 95cbef42ce31 cat /etc/redhat-release
  ```

- 如果希望附加交互式 shell，必须指定 `-it` 选项来打开交互式会话并为 shell 分配一个伪终端

  ```bash
  $ podman exec -it my_webserver /bin/bash
  bash-4.4$ hostname
  bash-4.4$ exit
  ```

- Podman 记得使用的`最后一个容器`。可使用 `-l` 选项在最新的 Podman 命令中替换以前的容器 ID 或名称

  ```bash
  $ podman exec -l cat /etc/redhat-release
  ```



#### <a name="13.5">第五节：为容器附加永久存储</a>

**目标：**

- 通过在运行的容器中挂载目录，以使用容器永久存储（persistent storage）

**5.1 准备永久储存地点：**

- 容器中的存储是短暂的，意味着它的内容在删除容器后会丢失

- 如想在重新启动容器时保留容器使用的数据，临时存储是不够的

- 例如，容器可能是一个数据库服务器，当容器重新启动时，必须保存数据库本身

- 必须为容器提供永久存储

**5.2 从主机提供持久存储：**

- 提供永久存储的一种简单方法是使用`容器主机上的目录`。容器化应用将这些主机目录视为容器存储的一部分。

- 当删除容器时，系统不会回收主机目录中的内容。新容器可以挂载它来访问数据

- 永久存储可以驻留在任何地方，从本地硬盘分区到远程网络文件系统

**5.3 准备主机目录：**

- 在准备主机目录时，必须对其进行配置，`以便容器内的进程能够访问它`。配置包括:
  - `配置目录的所有权和权限`
  - `设置适当的 SELinux context`

- 容器内的`应用程序必须能够访问主机目录`

- 还必须使用适当的SELinux context 配置主机目录（`container_file_t`）。额外的保护将防止在容器内运行的应用程序访问共享目录外的主机文件

- 如果没有来自 SELinux 的额外保护，这些应用程序可能拥有对主机系统上所有文件的根访问权，并且能够危及主机和其他容器

**5.4 卷挂载：**

- 创建并配置主机目录之后，下一步是将该目录挂载到容器中。
  `podman run --volume|-v host_dir:container_dir`

  ```bash
  --volume host_dir:container_dir:z
  ```

- 通过 `Z` 选项，Podman 自动将 SELinux `container_file_t context` 应用到主机目录

  ```bash
  方法一：（mysql相关）：
  [student@servera /]$ mkdir /home/student/dbdir/   #dbdir目录名称自定义
  [student@servera /]$ chmod a+w /home/student/dbdir/  #一定要给写权限
  [student@servera /]$ 
  （如果不知道mysql数据库位置，可以临时启动一个mysql容器后，通过podman exec -ti containerID /bin/bash方式进入容器查看数据库目录后，作为参考使用。最后删除临时容器。）
  
  [student@servera /]$ 
  podman run -d --name mydb -v /home/student/dbdir:/var/lib/mysql/data:Z  -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -p 3306:3306 rhel8/mariadb-103
  
  [student@servera /]$ cd /home/student/dbdir/
  [student@servera my_date]$ ls
  data  mysql.sock
  [student@servera my_date]$ ll -Z /home/student/dbdir/ -d
  drwxrwxrwx. 2 student student system_u:object_r:container_file_t:s0:c697,c990 6 Dec 11 05:04 /home/student/dbfiles/   #其中包含了selinux上下文类型container_file_t
  
  
  方法二：
  1、希望启动apache的容器，但是容器内没有网页，所以真机的目录绑定至容器内的网页发布目录，给容器使用
  $ mkdir ~/www/html/
  $ echo hello > ~/www/html/index.html
  $ chmod -R o+w ~/www/
  $ podman run -d -p 8080:8080 -v /home/student/www/:/var/www/:Z registry.lab.example.com/rhel8/httpd-24
  
  ```



#### <a name="13.6">第六节：以服务方式管理容器</a>

**目标：**

- 以 systemd 服务的方式启动、停止和检查容器

**6.1 服务器启动时自动启动容器**

- 当将数据库或 web 服务器等服务部署为容器时，通常希望这些`容器与服务器一起自动启动`

- 通过为无根（rootless）容器创建 `systemd user unit` 文件，可使用 systemctl 命令来管理它们，类似常规服务

- `通过 enable 这些服务，可以确保容器在主机启动时启动`

- 如果容器以“无根”模式运行，可以非特权用户帐户管理这些服务，以提高安全性

- 要对许多基于容器的应用程序和服务进行更复杂的伸缩和编排，可使用基于 Kubernetes 的企业编排平台，如Red Hat OpenShift Container Platform

**6.2 常规用户运行 Systemd 服务**

- systemd 可以管理 user service，`普通用户可以为自己的服务创建 unit 文件`，并使用systemctl 命令管理这些服务

- 当用户服务类型为非根用户时，通过文本或图形控制台或使用 SSH 打开第一个会话时，该服务将自动启动。当关闭最后一次会话时，服务将停止

- `这种行为与系统服务不同`，系统服务在系统启动时启动，在系统关闭时停止

- 但也可以更改此默认行为，通过运行 `loginctl enable-linger` 命令`强制 service 在服务器启动时启动并在关闭时停止`。逆向操作，请使用 `loginctl disable-linger` 命令

- 查看当前状态，使用 loginctl show-user username 命令

  ```bash
  $ loginctl enable-linger
  $ loginctl show-user user | grep Linger
  Linger=yes
  
  $ loginctl disable-linger
  $ loginctl show-user user | grep Linger
  Linger=no
  ```

**6.3 创建和管理 Systemd User Services：**

- 要定义 systemd user service，创建 `~/.config/systemd/user/` 目录来存储 unit 文件，语法与 system unit file 相同

- 要了解更多细节，请查看 systemd.unit(5) 和 systemd.service(5)

- 要控制新 user service，使用 `systemctl --user` 选项

- 下面的示例列出 ~/.config/systemd/user/ 中的 unit 文件，强制 systemd 重新加载其配置，然后 enable 和 start myapp user service

  ```bash
  $ ls ~/.config/systemd/user/myapp.service
  $ systemctl --user daemon-reload
  $ systemctl --user enable myapp.service
  $ systemctl --user start myapp.service
  ```

  > 更新 podman 版本

  ```bash
  $ podman --version
  podman version 1.6.4
  
  $ sudo wget -P /etc/yum.repos.d/ http://materials/updates.repo
  [sudo] password for student: `student`
  
  $ sudo yum -y update
  
  $ podman --version	# --new支持；开机自启fix
  podman version 1.9.3
  ```

- **注**：要使用 systemctl --user 命令，`必须在控制台登录或直接通过 SSH 登录，不能使用 sudo 或 su 命令`。systemctl 命令与每个用户的 systemd --user 进程交互。只有当用户第一次从控制台或 SSH 登录时，系统才会启动该进程

- 下表总结了 systemd 系统和 user services 之间的区别:

  |                                                |                 System Services                 |                        User services                         |
  | :--------------------------------------------: | :---------------------------------------------: | :----------------------------------------------------------: |
  |         Storing <br>custom unit files          |        /etc/systemd/system/unit.service         |           **~/.config/systemd/user/unit.service**            |
  |              Reloading unit files              |            # systemctl daemon-reload            |            \$ **systemctl --user daemon-reload**             |
  |      Starting and <br>stopping a service       | # systemctl start UNIT<br># systemctl stop UNIT | \$ **systemctl --user start UNIT**<br>\$ **systemctl --user stop UNIT** |
  | Starting a service <br>when the machine starts |             # systemctl enable UNIT             | \$ **loginctl enable-linger**<br>\$ **systemctl --user enable UNIT** |

  

**6.4 使用 Systemd 服务管理容器：**

- 如果容器主机运行少量的容器，可以设置基于用户的 systemd unit 文件，并配置它们以通过自动启动容器

- 这是一种简单的方法，`适用于不需要扩展的小型部署`

- 对于更实际的生产，可以考虑使用 OpenShift

**6.5 创建用于运行容器的专用用户帐户：**

- 为简化无根容器的管理，可以创建一个`专用的用户帐户`，用于管理所有容器

- **注**：为对所有容器进行分组而创建的帐户必须是常规用户帐户。当使用 useradd 创建帐户时，该命令在 /etc/subuid 文件中为用户的容器保留一系列用户 id。但当使用 useradd --system(或 -r)选项创建系统帐户时，该命令不会保留一个范围。因此，不能使用系统帐户启动无根容器

**6.6 创建 Systemd unit 文件**

- 从现有的容器中，`podman 命令可以帮助生成 systemd unit 文件`

- 下面的例子使用 podman generate systemd 命令为现有的 web 容器创建 unit 文件：

  ```bash
  $ cd ~/.config/systemd/user/
  
  $ podman generate systemd --help
  $ podman generate systemd --name web --files --new
  （生成文件前关闭容器，生成文件后删除容器，再开机自启动并启动，否则无法启动容器）
  ```

- `podman generate systemd` 命令使用一个容器作为模型来创建配置文件。在创建文件之后，须删除容器

- podman generate systemd 的`选项`：

  - --name container_name：name 选项指定容器的名称，用作模板来生成 unit 文件。Podman 还使用该名称来生成 `unit 文件`的名称：`containers-container_name.service`

  - --files：files 选项指示 Podman 在`当前目录中`生成 unit 文件。如没有这个选项，Podman将在标准输出中显示该文件

  - --new：new 选项指示 Podman 配置 systemd 服务，以便在服务启动时创建容器，并在服务停止时删除。在这种模式下，容器是临时的，通常需要持久存储来保存数据。`没有 --new 选项，Podman 配置服务启动和停止现有的容器，而不删除`

- 下例在运行 podman generate systemd `--new` 时，unit 文件中的开始和停止指令：

  ```bash
  $ podman run -d --name web -p 8080:8080 \
  registry.lab.example.com/rhel8/httpd-24:1-105
  $ podman generate systemd --name web --new
  ```

  1. 启动时，systemd 执行 podman run 命令创建并启动一个新容器

  2. 停止时，systemd 执行 podman stop 命令来停止容器

  3. 当 systemd 关闭了容器，systemd 使用 `podman rm 命令删除容器`

- 相反，下例显示在运行 podman generate systemd 命令时`不带 --new` 选项时的开始和停止指令：

  ```bash
  $ podman run -d --name www -p 8888:8080 \
  registry.lab.example.com/rhel8/httpd-24:1-105
  $ podman generate systemd --name www
  ```

1. 启动时，systemd 执行 podman start 命令来启动已存在的容器
2. 停止时，systemd 执行 podman stop 命令来停止容器。
   `注：systemd 不会删除容器`

**6.7 使用 Systemd 启动和停止容器**

- 使用 systemctl 命令控制容器

  ```bash
  $ systemctl --user start container-web
  $ systemctl --user stop container-web
  $ systemctl --user status container-web
  ```

- 重要：使用 systemctl 命令管理的容器由 systemd 控制。`systemd 监视容器状态，并在它们失败时重新启动它们。不要使用 podman 命令来启动或停止这些容器。`这样做可能会干扰 systemd 监视

**6.8 配置在主机启动时启动的容器**

- 默认情况下，已启用的 systemd user service 在用户打开第一个会话时启动，在用户关闭最后一个会话时停止。
  要让 user service 随服务器自动启动，请运行` loginctl enable-linger` 命令：

  ```bash
  $ loginctl enable-linger
  ```

- 要使容器在主机启动时启动：

  ```bash
  $ systemctl --user enable container-web
  ```

- 要在主机启动时禁用容器启动：

  ```bash
  $ systemctl --user disable container-web
  ```

**6.9 使用 Systemd 管理以 root 运行的容器：**

- 还可以配置希望作为 root 用户运行的容器，以便使用 Systemd unit 文件管理它们

- 优点是可以将这些 unit 文件配置为与普通 unit 单元文件完全相同的工作方式，而不需要一个特定的用户

- 设置这些容器的过程与前面介绍的无根容器类似，不同之处在于:
  - 不需要设置专用用户
  - `当使用 podman generate systemd 创建 unit 文件时，请在 /etc/systemd/system 中运行`，而不是在 ~/.config/systemd/user 中
  - 当用 systemctl 配置容器的服务时，将不会使用 --user 选项
  - 不需要以 root 用户身份运行：loginctl enable-linger

**6.10 规模化编排容器：**

- 在本章学习了如何在单个主机上通过命令行手动配置和管理容器，以及如何配置Systemd 以便容器与服务器一起自动启动。这在很小的范围内非常有用，有助于了解许多关于容器的知识
- 然而，大多数企业需要部署更多容器。Kubernetes 通常用于管理由多个协作容器组成的复杂应用程序
- Red Hat OpenShift 是一个 Kubernetes 平台，它添加了基于 web 的用户界面、监控、在集群中的任何位置运行容器的能力、自动缩放、日志记录和审计等
- 讨论这些工具超出了本课程的范围。如果想了解更多信息，Red Hat 培训还提供了其他课程，从免费的技术概览课程：
  [Deploying Containerized Applications（DO080）](https://www.redhat.com/zh/services/training/do080-deploying-containerized-applications-technical-overview)开始，到 [Introduction to Containers, Kubernetes, and OpenShift（DO180）](https://www.redhat.com/zh/services/training/do180-introduction-containers-kubernetes-red-hat-openshift)。更多信息，请访问 https://www.redhat.com/training 
- 也可以从 https://www.openshift.com了解更多关于 Kubernetes 和 Red Hat OpenShift 的信息



#### <a name="13.l">LAB. containers-review</a>

- 环境准备

**[kiosk@foundation]**

```bash
$ grep -q RHT_COURSE.*rh134 /etc/rht \
  || rht-clearcourse 0 \
  && rht-setcourse rh134
$ for i in classroom bastion utility workstation serverb; do \
  rht-vmctl start $i; sleep 20
  done

$ ping workstaiton
<Ctrl-C>
$ ping serverb
<Ctrl-C>
$ ssh workstation 'lab containers-review start'

Starting lab.

Preparing serverb for lab exercise work:

 · Checking the status of the container registry...............  SUCCESS
 · Creating required user podsvc in serverb ...................  SUCCESS
 · Configuring Yum repository on serverb.......................  SUCCESS
 · Configuring podsvc access to registry on serverb............  SUCCESS
 · Checking that mariadb client is installed on serverb........  SUCCESS
 · Deploying the help files on serverb.........................  SUCCESS
 
 $ ssh podsvc@serverb
```

- Initialize and set some variables

  |  ID  |      ITEM      |                  CONTENT                   |
  | :--: | :------------: | :----------------------------------------: |
  |  1   |     target     |                  serverb                   |
  |  2   |  system_user   |                   podsvc                   |
  |  3   | persistent_dir |            /home/podsvc/db_data            |
  |  4   |     image      | registry.lab.example.com/rhel8/mariadb-103 |
  |  5   |      tag       |                    1-86                    |
  |  6   | container_name |                inventorydb                 |

  |  ID  |        ITEM         |       CONTENT       |
  | :--: | :-----------------: | :-----------------: |
  |  7   |     local_port      |        13306        |
  |  8   |     MYSQL_USER      |      operator1      |
  |  9   |   MYSQL_PASSWORD    |       redhat        |
  |  10  |   MYSQL_DATABASE    |      inventory      |
  |  11  | MYSQL_ROOT_PASSWORD |       redhat        |
  |  12  |       storage       | /var/lib/mysql/data |

- 实验步骤

  **[podsvc@serverb]**

  ```bash
  $ su -
  密码: `redhat`
  # yum module list container*
  # yum module -y install container-tools
  # <Ctrl-D>
  
  $ podman login -u admin -p redhat321
  WARNING! Using --password via the cli is insecure. Please consider using --password-stdin
  Login Succeeded!
  $ podman search registry.lab.example.com/
  INDEX         NAME                                         DESCRIPTION   STARS   OFFICIAL   AUTOMATED
  example.com   `registry.lab.example.com/rhel8/mariadb-103`                 0                  
  example.com   registry.lab.example.com/rhel8/httpd-24                    0                  
  example.com   registry.lab.example.com/library/nginx                     0                  
  example.com   registry.lab.example.com/ubi7/ubi                          0                  
  example.com   registry.lab.example.com/ubi8/ubi                          0
  $ podman pull registry.lab.example.com/rhel·8/mariadb-103
  Trying to pull registry.lab.example.com/rhel8/mariadb-103...
  Getting image source signatures
  Copying blob 77c58f19bd6e done  
  Copying blob 67b9f0b530d9 done  
  Copying blob 47db82df7f3f done  
  Copying blob 71391dc11a78 done  
  Copying config 11a47e0fbe done  
  Writing manifest to image destination
  Storing signatures
  11a47e0fbed05a1f423929778645063f6a9dd6b24251e7e14da9c4b0788fe1e1
  $ podman images
  REPOSITORY                                   TAG      IMAGE ID       CREATED        SIZE
  registry.lab.example.com/rhel8/mariadb-103   latest   11a47e0fbed0   4 months ago   572 MB
  
  $ podman tag 11a47e0fbed0 registry.lab.example.com/rhel8/mariadb-103:1-86
  $ podman images
  REPOSITORY                                   TAG      IMAGE ID       CREATED        SIZE
  registry.lab.example.com/rhel8/mariadb-103   latest   11a47e0fbed0   4 months ago   572 MB
  registry.lab.example.com/rhel8/mariadb-103   1-86     11a47e0fbed0   4 months ago   572 MB
  
  $ mkdir /home/podsvc/db_data
  $ chmod a+rwx db_data
  $ podman run -d \
  --name inventorydb \
  -v /home/podsvc/db_data:/var/lib/mysql/data:z \
  -e MYSQL_USER=operator1 -e MYSQL_PASSWORD=redhat \
  -e MYSQL_DATABASE=inventory -e MYSQL_ROOT_PASSWORD=redhat \
  -p 13306:3306 \
  registry.lab.example.com/rhel8/mariadb-103:1-86
  fb92a1a6b64c13fc882636149e9007e98fb5cb56956e7b1af7b4d973c129ac66
  $ podman ps
  CONTAINER ID  IMAGE                                              COMMAND     CREATED         STATUS             PORTS                    NAMES
  fb92a1a6b64c  registry.lab.example.com/rhel8/mariadb-103:latest  run-mysqld  20 seconds ago  `Up` 18 seconds ago  0.0.0.0:13306->3306/tcp  inventorydb
  $ ss -antup | grep 13306
  tcp    LISTEN  0       128          *:13306        *:*       users:(("exe",pid=28441,fd=12))
  $ mysql -u operator1 -predhat -h serverb -P 13306 -e 'show databases;'
  Database
  information_schema
  inventory
  test
  
  $ mkdir -p .config/systemd/user
  $ cd ~/.config/systemd/user/
  $ podman generate systemd --name inventorydb --files --new
  /home/podsvc/.config/systemd/user/container-inventorydb.service
  
  $ loginctl enable-linger
  $ loginctl show-user podsvc | grep ^L
  Linger=yes
  $ systemctl --user enable container-inventorydb.service
  Created symlink /home/podsvc/.config/systemd/user/multi-user.target.wants/container-inventorydb.service → /home/podsvc/.config/systemd/user/container-inventorydb.service.
  Created symlink /home/podsvc/.config/systemd/user/default.target.wants/container-inventorydb.service → /home/podsvc/.config/systemd/user/container-inventorydb.service.
  ```

- 验证结果

  **[student@workstation]**

  ```bash
  $ lab containers-review grade 
  
  Grading the student\'s work on serverb:
  
   · Required container packages exist...........................  PASS
   · The inventorydb container exists............................  PASS
   · The container is using the correct image....................  PASS
   · The container is using the correct image tag................  PASS
   · The container host port is 13306............................  PASS
   · The database user is operator1..............................  PASS
   · The database password is redhat.............................  PASS
   · The database name is inventory..............................  PASS
   · The database root password is redhat........................  PASS
   · The database uses db_data for storage.......................  PASS
   · The storage is mounted in /var/lib/mysql/data...............  PASS
   · SELinux context is set for db_data..........................  PASS
   · The systemd unit file exists for the container..............  PASS
   · The systemd service for the container is enabled............  PASS
   · The services for podsvc start at boot.......................  PASS
  
  Overall lab grade..............................................  PASS
  ```



#### <a name="13.s">Summary</a>

> - 容器提供了一种轻量级的方式来分发和运行应用程序及其依赖关系，而这些依赖关系可能与主机上安装的软件发生冲突
> - 容器从容器映像运行，您可以从容器注册表下载或自己创建
> - 由 Red Hat Enterprise Linux 提供的 Podman 可在单个主机上直接运行和管理容器以及容器映像
> - 容器可以作为 root 用户运行，也可以作为非特权的无根容器运行，以提高安全性
> - 你可以映射容器主机上的网络端口，以将流量传递到在其容器中运行的服务。
>   您还可以使用环境变量在容器中配置软件
> - 容器存储是临时的，但是你可以使用例如容器主机上目录的内容将持久性存储附加到容器
> - 你可以将 Systemd 配置为在系统启动时自动运行容器



# 第十四章 总复习

## [docker](https://www.docker.com)

![Docker_logo](https://gitee.com/suzhen99/redhat/raw/master/images/Docker_logo.png)



#### d.1 Docker 是什么

> Docker 是一个容器化平台，在这个平台中，我们可以将我们的应用程序与容器中的库和环境绑定在一起

#### d.2 Docker 流程

![Docker Flow](https://gitee.com/suzhen99/redhat/raw/master/images/2074831-20201129203506049-178243366.png)

> 1. Docker 运行在单个进程上，这可能会导致单点故障
> 2. 所有子进程都归属于此进程
> 3. 无论何时，如果 Docker 守护进程失败，所有子进程都会失去跟踪并进入孤立状态
> 4. 安全漏洞
> 5. 对于 Docker 的操作，所有步骤都需要由 root 执行

**[root@foundation]**

1. 卸载 container-tools

```bash
# yum -y module remove container-tools
```

2. 设置 yum 仓库

```bash
wget -P /etc/yum.repos.d https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
sed -i s_download.docker.com_mirrors.aliyun.com/docker-ce_ /etc/yum.repos.d/docker-ce.repo
wget -P /etc/yum.repos.d https://mirrors.aliyun.com/repo/Centos-8.repo
```

3. 安装

```bash
# yum -y install docker-ce docker-ce-cli containerd.io
```

4. 启动

```bash
# systemctl enable --now docker
```

5. 确认

```bash
# docker version
```

6. 设置 docker 仓库

```bash
# cat > /etc/docker/daemon.json <<EOF
{
  "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn","https://hub-mirror.c.163.com"]
}
EOF
# systemctl daemon-reload 
# systemctl restart docker
```

7. 搜索 镜像

```bash
# docker search httpd
```

8. 拉取镜像

```bash
# docker pull httpd
```

9. 查看镜像

```bash
# docker images
```

10. 你准备建立容器

```bash
# mkdir -p /srv/web/
# echo Hello world > /srv/web/index.html
# docker images
```

11. 创立容器，设置端口、持久存储、传参、开机自启

```bash
# docker run -d --name web \
-p 8888:80 \
-v /srv/web:/usr/local/apache2/htdocs:Z \
-e HTTPD_MPM=event \
--restart=always httpd
```

12. 查看建立的容器

```bash
# docker inspect web
```

13. 测试确认

```bash
# docker ps
# curl http://localhost:8888
Hello world

# sync && reboot
```

14. 确认开机自启

```bash
# curl http://localhost:8888
Hello world
```

15. 停止容器

```bash
# docker stop web
```

16. 确认停止

```bash
# docker ps
```

17. 删除容器

```bash
# docker rm web
```

18. 确认删除

```bash
# docker ps --all
```

setcourse

```
【foundation】
rht-clearcourse 0
rht-setcourse rh124
rht-setcourse rh134
rht-setcourse rh294

virt-manager 
```

# RHCSA模拟练习环境布置方法

```bash
考试模拟环境布置方法：
1、恢复init初始环境，启动系统
2、加载ex200软件包，使虚拟机加载软件包镜像
3、以root身份将软件包拷贝到/opt/下 su - root 
4、su - kisok 后 ssh root@localhost 'yum install -y /opt/包名'   （注意不要用其他方式否则报错）
5、安装后，使用exam-setup部署模拟考试环境
6、使用
```

