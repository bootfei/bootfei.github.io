---
title: 高并发下保证接口的幂等性
date: 2021-04-28 12:12:34
tags:
---

## **保证幂等的手段**

保证幂等需要理清楚两件事情：幂等条件和期望结果。

- 保证幂等的手段有[token令牌]()、[分布式锁]()、[去重表]()、[数据库唯一索引]()等，这些所谓的幂等手段实际上防重手段。防重本质是防止一个相同的请求被当成多个不同的请求来处理。

- 幂等的条件是知道这是一个相同的请求。防重和幂等本质上是两个不同的阶段。



## 使用幂等的场景

### 前端重复提交

用户注册，用户创建商品等操作，前端都会提交一些数据给后台服务，后台需要根据用户提交的数据在数据库中创建记录。如果用户不小心多点了几次，后端收到了好几次提交，这时就会在数据库中重复创建了多条记录。这就是接口没有幂等性带来的 bug。

### 接口超时重试

对于给第三方调用的接口，有可能会因为网络原因而调用失败，这时，一般在设计的时候会对接口调用加上失败重试的机制。如果第一次调用已经执行了一半时，发生了网络异常。这时再次调用时就会因为脏数据的存在而出现调用异常。

### 消息重复消费

在使用消息中间件来处理消息队列，且手动 ack 确认消息被正常消费时。如果消费者突然断开连接，那么已经执行了一半的消息会重新放回队列。

当消息被其他消费者重新消费时，如果没有幂等性，就会导致消息重复消费时结果异常，如数据库重复数据，数据库数据冲突，资源重复等。



## 防重手段实现幂等

### 借助数据库

#### 先select再update/insert使用悲观锁

使用悲观锁实现幂等性，一般是配合事务一起来实现，在没有使用悲观锁时，我们通常的执行过程是这样的，首先来判断数据的状态，执行 SQL 如下：

```mysql
第一步：select status from table_name where id='xxx';

第二步：insert into table_name (id) values ('xxx');
		或者update table_name set status='xxx';
```

[但这种情况因为是非原子操作，所以在高并发环境下可能会造成一个业务被执行两次的问题]()，当一个程序在执行中时，而另一个程序也开始状态判断的操作。因为第一个程序还未来得及更改状态，所以第二个程序也能执行成功，这就导致一个业务被执行了两次。

- 使用事务实现悲观锁，从而保证原子性  <!--这种方法感觉有问题，select操作在RR事务隔离级别下，可能读到的是过期版本的数据-->


```sql
begin;  # 1.开始事务
select * from table_name where id='xxx' for update; # 2.查询状态

# 3. insert或者update
insert into table_name (id) values ('xxx'); 
或者 update table_name set status='xxx';

commit; # 4.提交事务
```

- 使用select … for update ,这种和 synchronized 锁住先查再insert or update一样,但要避免死锁,效率也较差。针对单体 请求并发不大 可以推荐使用

> 在实现的过程中需要注意以下两个问题：
>
> - 如果使用的是 MySQL 数据库，必须选用 innodb 存储引擎，因为 innodb 支持事务；
> - id 字段一定要是主键或者是唯一索引，不然会锁表，影响其他业务执行。
>

#### update使用多版本控制（乐观锁）

需要在表中增加一个`timestamp`或者`version`字段，这里以`version`字段为例。

```
 update user set amount=amount+100,version=version+1where id=123 and version=1;
```



#### insert使用唯一索引

我们可以创建一个唯一索引的表来实现幂等性，在每次执行业务之前，先执行插入操作，因为唯一字段就是业务的 ID，因此如果重复插入的话会触发唯一约束而导致插入失败。在这种情况下（插入失败）我们就可以判定它为重复提交的请求。

虽说抛异常对数据来说没有影响，不会造成错误数据。但是为了保证接口幂等性，我们需要对该异常进行捕获，然后返回成功。

如果是`java`程序需要捕获：`DuplicateKeyException`异常，如果使用了`spring`框架还需要捕获：`MySQLIntegrityConstraintViolationException`异常。



### 借助web api入口

#### 使用Redis实现分布式锁

由于`数据库分布式锁`的性能不太好，我们可以改用：`redis`或`zookeeper`。

鉴于现在很多公司分布式配置中心改用`apollo`或`nacos`，已经很少用`zookeeper`了，我们以`redis`为例介绍分布式锁。

目前主要有三种方式实现redis的分布式锁：

1. setNx命令
2. set命令
3. Redission框架

> 需要特别注意的是：分布式锁一定要设置一个合理的过期时间，如果设置过短，无法有效的防止重复请求。如果设置过长，可能会浪费`redis`的存储空间，需要根据实际业务情况而定。



#### 获取token

通过token 机制实现接口的幂等性,这是一种比较通用性的实现方法。

示意图如下：

<img src="https://filescdn.proginn.com/863953bbd02d158b7d726d78b269339e/47e6218040f85184d170ef253514ca59.webp" alt="img" style="zoom:67%;" />

具体流程步骤：

1. 客户端会先发送一个请求去获取 token，服务端会生成一个全局唯一的 ID 作为 token 保存在 redis 中，同时把这个 ID 返回给客户端
2. 客户端第二次调用业务请求的时候必须携带这个 token
3. 服务端会校验这个 token，如果校验成功，则执行业务，并删除 redis 中的 token
4. 如果校验失败，说明 redis 中已经没有对应的 token，则表示重复操作，直接返回指定的结果给客户端

> 注意：
>
> 1. 对 redis 中是否存在 token 以及删除的代码逻辑建议用 Lua 脚本实现，保证原子性
> 2. 全局唯一 ID 可以用百度的 uid-generator、美团的 Leaf 去生成



这种思路存在漏洞，如下图所示：
[![幂等检查和接口重试之间的冲突](https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/%E5%B9%82%E7%AD%89%E6%A3%80%E6%9F%A5%E5%92%8C%E6%8E%A5%E5%8F%A3%E9%87%8D%E8%AF%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.png)](https://tallate.top/imgs/服务治理——幂等/幂等检查和接口重试之间的冲突.png)

[幂等检查和接口重试之间的冲突](https://tallate.top/imgs/服务治理——幂等/幂等检查和接口重试之间的冲突.png)

token 是只有在幂等检查结束后才会被保存下来的，如果下游服务还没执行完毕，触发上游 RPC 的超时重试机制，就会重新再发一次请求，这时如果上一次请求，仍然没有执行完毕，就会导致请求被执行了两次。
这里的漏洞是：进入下游 API 入口处的幂等检查逻辑，会经过查 `token -> 保存 token -> 设置超时时间`这个过程，可能会因为网络抖动而花费特别长的时间。如果超时是因此而导致的，幂等性检查就起不到作用了。
解决的办法是保证幂等检查的**原子性**，并且还需要注意存储的**隔离性**，这在一般的存储设计中是必须要考虑的。

> 在这里吐槽一下我公司的实现，采用的是`setnx + expire`的方式，如果`setnx`后、`expire`前出错了，之后对该接口的重试也会直接被拦截了，也就是说幂等检查组件影响了正常的业务执行流程。

